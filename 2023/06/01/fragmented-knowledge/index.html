<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="pragma" content="no-cache">
  <meta http-equiv="cache-control" content="no-cache">
  <meta http-equiv="expires" content="0">
  
  <title>fragmented-knowledge | wd-z711&#39;s B10g</title>
  <meta name="author" content="wd-z711">
  
  <meta name="description" content="Common student in China. Interested in web &amp; re.">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="fragmented-knowledge"/>
  <meta property="og:site_name" content="wd-z711&#39;s B10g"/>

  
    <meta property="og:image" content=""/>
  

  
  
    <link href="/favicon.png" rel="icon">
  
  
  <link rel="stylesheet" href="/css/bootstrap.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/font-awesome.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/responsive.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/google-fonts.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

  <script src="/js/jquery-2.0.3.min.js"></script>

  <!-- analytics -->
  
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'G-YHJSKZDC3Y', 'auto');
  ga('send', 'pageview');
</script>




<meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="wd-z711's B10g" type="application/atom+xml">
</head>

 <body>  
  <nav id="main-nav" class="navbar navbar-inverse navbar-fixed-top" role="navigation">
    <div class="container">
      <button type="button" class="navbar-header navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
		<span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
	  <a class="navbar-brand" href="/">wd-z711&#39;s B10g</a>
      <div class="collapse navbar-collapse nav-menu">
		<ul class="nav navbar-nav">
		  
		  <li>
			<a href="/archives" title="All the articles.">
			  <i class="fa fa-archive"></i>Archives
			</a>
		  </li>
		  
		  <li>
			<a href="/categories" title="All the categories.">
			  <i class="fa fa-folder"></i>Categories
			</a>
		  </li>
		  
		  <li>
			<a href="/about" title="About me.">
			  <i class="fa fa-user"></i>About
			</a>
		  </li>
		  
		</ul>
      </div>
    </div> <!-- container -->
</nav>
<div class="clearfix"></div>

  <div class="container">
  	<div class="content">
    	 


	
		<div class="page-header">
			<h1> fragmented-knowledge</h1>
		</div>
	



<div class="row post">

	<!-- cols -->
	
	<div id="top_meta"></div>
	<div class="col-md-9">
	

	<!-- content -->
	<div class="mypage">		
	  		

	  <h1 id="一些小知识"><a href="#一些小知识" class="headerlink" title="一些小知识"></a>一些小知识</h1><h4 id="Ring"><a href="#Ring" class="headerlink" title="Ring"></a>Ring</h4><p>&emsp;Intel的 CPU 将特权级别分为 4 个级别: RING0、RING1、RING2、RING3。Windows 只使用其中的两个级别 RING0 和 RING3，<br>RING0 只给操作系统用，RING3 谁都能用。如果普通应用程序企图执行RING0 指令，则 Windows 会显示”非法指令”错误信息。图示如下，可以看到RING2与RING1都是驱动文件使用的：</p>
<span id="more"></span>
<p><img src="/images/fragmented-knowledge/image-20230601132542209.png" alt="image-20230601132542209" style="zoom:67%;" /></p>
<h4 id="Powershell-amp-CMD"><a href="#Powershell-amp-CMD" class="headerlink" title="Powershell&amp;CMD"></a>Powershell&amp;CMD</h4><p>&emsp;Powershell 是<strong>新的</strong>命令行和脚本环境，它基于 .NET Framework。cmd 是 Windows 中<strong>传统的</strong>命令行工具，它继承了 DOS 的命令和语法，主要用于执行一些简单的系统操作。Powershell有更强大的脚本能力。</p>
<h4 id="MFC程序与GUI程序有什么区别？"><a href="#MFC程序与GUI程序有什么区别？" class="headerlink" title="MFC程序与GUI程序有什么区别？"></a>MFC程序与GUI程序有什么区别？</h4><p>&emsp;MFC程序是使用 Microsoft Foundation Class (MFC) 库开发的 Windows 应用程序。MFC 是一组针对大部分 Win32 和 COM API 提供面向对象的包装器的类。MFC 程序通常使用 MFC 应用程序向导来创建，并且可以创建标准 Windows 应用程序、对话框、基于窗体的应用程序、资源管理器样式的应用程序和 Web 浏览器样式的应用程序。</p>
<p>&emsp;GUI程序是使用图形用户界面 (GUI) 来与用户交互的应用程序。GUI 程序可以使用不同的框架或库来创建，例如 MFC、WPF、Qt、GTK+ 等。GUI 程序通常包含窗口、菜单、按钮、文本框等控件，以及响应用户输入的事件处理逻辑。</p>
<p>&emsp;<strong>MFC程序是 GUI程序 的一种，但不是唯一的一种。MFC 是一个较旧的框架，已经不再更新，而且只能用于 Windows 平台。</strong>新入门的人可以根据自己的需求和兴趣选择合适的 GUI 框架来学习，例如 WPF、Qt、Flutter 等。</p>
<h4 id="STM32中hex文件-amp-bin文件-amp-axf文件"><a href="#STM32中hex文件-amp-bin文件-amp-axf文件" class="headerlink" title="STM32中hex文件&amp;bin文件&amp;axf文件"></a>STM32中hex文件&amp;bin文件&amp;axf文件</h4><p>&emsp;与C语言类似，STM32程序也是用C写的，其编译过程与C差不多。两者编译过程图如下：</p>
<p><img src="/images/fragmented-knowledge/image-20230621182445636.png" alt="image-20230621182445636" style="zoom:67%;" /></p>
<p><img src="/images/fragmented-knowledge/image-20230621182459144.png" alt="image-20230621182459144" style="zoom:67%;" /></p>
<p>&emsp;例如，LED灯程序的编译过程如下：</p>
<p><img src="/images/fragmented-knowledge/image-20230621182735616.png" alt="image-20230621182735616" style="zoom:67%;" /></p>
<p>&emsp;<strong>axf文件、hex文件与bin文件都是可以运行在stm32上，它们都存储了编译器根据源代码生成的机器码。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">axf文件：包含调试信息。</span><br><span class="line">hex文件：包含地址信息。</span><br><span class="line">bin文件：最直接的代码映像。</span><br></pre></td></tr></table></figure>
<p>&emsp;axf文件是编译默认生成的文件，不仅包含代码数据，而且还包含着调试信息，在MDK里进行debug调试用的就是这个文件。bin文件是根据axf文件生成的。</p>
<p>&emsp;hex 文件是一种使用十六进制符号表示的代码记录， 记录了代码应该存储到FLASH 的哪个地址，下载器可以根据这些信息辅助下载。</p>
<h4 id="unicorn"><a href="#unicorn" class="headerlink" title="unicorn"></a>unicorn</h4><p>&emsp;开源的CPU模拟器框架，用于模拟多种不同的处理器架构。</p>
<h4 id="OP-TEE"><a href="#OP-TEE" class="headerlink" title="OP-TEE"></a>OP-TEE</h4><p>&emsp;<strong>OP-TEE</strong> 是一个开源可信执行环境，应用在Arm上的Linux内核中。 主要包括 Secure world OS（optee_os）、normal world client（optee_client）、test suite（optee_test/xtest）以及 Linux 驱动部分。OP-TEE，open source project Trusted Execution Environment (TEE)。TEE与Rich Execution Environment (REE)相对应。<strong>REE中运行的是non-secure OS，安卓，Linux系统等都运行在REE。TEE中运行的是secure OS，他需要Arm TrustZone技术的支持，依赖硬件设计，REE中的系统和应用是无法直接访问TEE中的资源的，只能通过TEE提供的接口获取一个结果，其间的运算和存储等操作对REE中的系统和应用都是不可见的，从而来保证安全性。</strong>比如我们手机录入的指纹信息就会通过这项技术保存在TEE中，应用无法获得指纹数据，只能得到一个是否验证通过的结果。</p>
<p>&emsp;TrustZone可以认为是操作系统间实现相互独立（例如硬件平台上同时运行了两个OS）。在同一个CPU上运行两个OS，其中一个OS只负责一些安全存储或者计算的操作，比如存储我们的指纹数据等。另一个OS就是平时用的OS，比如安卓系统，对于这个OS来说，安全OS是不可见的，所以根本没有权限获取到安全OS中的隐私数据。 <strong>两个OS之间需要交互，因此我们需要一种机制来访问安全OS的服务，也就是CA/TA这种调用机制</strong>。</p>
<p>&emsp;OP-TEE的执行流程如下：</p>
<p><img src="/images/fragmented-knowledge/image-20230712232638590.png" alt="image-20230712232638590" style="zoom:67%;" /></p>
<p>（1）CA调用函数部分，发起一次调用请求，是整个流程的开端。</p>
<p>（2）TEE_client（libteec）做某些事。OP-TEE提供给用户在linux 用户层面调用的接口实现。</p>
<p>（3）tee-supplicant做某些事。OP-TEE能够通过tee_supplicant来访问REE端文件系统中的资源，例如加载存放在文件系统中的TA镜像到TEE中，对REE端数据库的操作。</p>
<p>（4）OP-TEE在linux端的驱动部分做某些事。REE与TEE端进行数据交互的桥梁作用。</p>
<p>（5）Monitor mode 接收中断请求。</p>
<p>（6）OPTEE OS处理请求。</p>
<p>（7）TA（可信应用）部分实现功能并返回结果。</p>
<h4 id="交叉编译工具"><a href="#交叉编译工具" class="headerlink" title="交叉编译工具"></a>交叉编译工具</h4><p>&emsp;在传统的编译过程中，开发人员需要在目标平台上进行编译，这意味着他们需要在目标平台上安装编译器、链接器、调试器等开发工具，这可能会带来很多问题。</p>
<p>&emsp;交叉编译工具的出现解决了以上这些问题，它们可以<strong>在开发人员的主机上构建目标平台的软件，并将生成的二进制文件移植到目标平台上运行，从而提高了开发效率和软件质量</strong>。</p>
<h4 id="SMC调用"><a href="#SMC调用" class="headerlink" title="SMC调用"></a>SMC调用</h4><p>&emsp;SMC（Secure Monitor Call）调用是一种在ARM处理器上进行安全监控的机制，它允许运行在非安全模式下的软件向运行在安全模式下的软件发起请求。</p>
<p>&emsp;SMC调用的实现不同于普通的函数调用。SMC调用需要使用特殊的指令（SMC指令），来触发运行在安全模式下的软件响应请求。SMC指令包含一个参数，该参数包含请求的服务号和请求的参数。运行在安全模式下的软件根据服务号和参数来执行请求，并返回处理结果。</p>
<h4 id="ubuntu-apt"><a href="#ubuntu-apt" class="headerlink" title="ubuntu apt"></a>ubuntu apt</h4><p>&emsp;<code>apt</code> 命令会自动处理软件包的依赖关系，可以自动安装/卸载/更新软件包所需要的依赖项。而 <code>apt-get</code> 命令需要手动处理依赖关系。<code>apt</code> 命令是 <code>apt-get</code> 命令的改进版本。</p>
<p>&emsp;<code>apt install update</code> 和 <code>apt install upgrade</code>：<code>update</code>是更新本地的软件包索引数据库，<code>upgrade</code>用于升级系统中已安装的软件包。</p>
<h4 id="zigbee与Z-ware"><a href="#zigbee与Z-ware" class="headerlink" title="zigbee与Z-ware"></a>zigbee与Z-ware</h4><p>&emsp;Zigbee 是一种低功耗、短距离无线通信技术，用于连接智能家居和物联网设备。它基于 IEEE 802.15.4 标准，支持多种网络拓扑结构（如星型、树型、网状等），并提供安全、可靠的数据传输和设备管理功能。Zigbee 设备通常运行在 2.4GHz、915MHz 或 868MHz 频段，可以连接数百个设备，覆盖数千平方米的区域。</p>
<p>&emsp;Z-Wave 也是一种低功耗、短距离无线通信技术，用于连接智能家居和物联网设备。它采用专有的无线协议，支持星型网络拓扑结构，提供安全、可靠的数据传输和设备管理功能。Z-Wave 设备通常运行在 900MHz 频段，可以连接数百个设备，覆盖数千平方米的区域。</p>
<p>&emsp;他俩差不多，Z-ware欧洲用的多一点。</p>
<h4 id="Telnet"><a href="#Telnet" class="headerlink" title="Telnet"></a>Telnet</h4><p>&emsp;Telnet 是一种远程登录协议，用于在计算机网络上通过一个终端或控制台连接到远程计算机。默认23端口。</p>
<h4 id="Android四大组件"><a href="#Android四大组件" class="headerlink" title="Android四大组件"></a>Android四大组件</h4><p>&emsp;Activity, Service, Content Provider, Broadcast Receiver。</p>
<p>&emsp;Activity 和 Service：<strong>Activity 是用户界面的展示，Service 是后台运行的组件，它们之间可以通过 Intent 进行通信。</strong>例如，Activity 可以启动 Service 来执行耗时的任务，Service 可以将执行结果通过 Intent 返回给 Activity。</p>
<p>&emsp;Activity 和 Content Provider：Activity 可以通过 Content Provider 访问和共享数据，例如访问系统的联系人、短信、音乐等数据。Content Provider 会暴露一些 API 接口，供 Activity 调用，并返回相应的数据。</p>
<p>&emsp;Service 和 Content Provider：Service 可以通过 Content Provider 访问和共享数据，例如在后台下载文件、缓存数据等。Content Provider 会暴露一些 API 接口，供 Service 调用，并返回相应的数据。</p>
<p>&emsp;Broadcast Receiver 和其他组件：Broadcast Receiver 可以接收系统广播和应用程序广播，并根据广播内容进行相应的操作。例如，Broadcast Receiver 可以接收系统发出的电池电量变化广播，并通知 Service 或 Activity 进行相应的操作。</p>
<h4 id="Android的其他组件"><a href="#Android的其他组件" class="headerlink" title="Android的其他组件"></a>Android的其他组件</h4><p>&emsp;Bundle 是一种用于在<strong>不同组件（如 Activity、Service、BroadcastReceiver）之间传递数据的数据结构</strong>。Bundle 对象中可以包含不同类型的数据，例如基本数据类型、数组、字符串、Parcelable 对象等。<strong>使用 Bundle 可以方便地将多个数据类型打包成一个对象，并通过 <code>Intent</code> 在不同组件之间传递数据。同时，由于 Bundle 对象是可序列化的，因此可以将其保存到文件或内存中，以便在需要时重新恢复数据。</strong></p>
<p>&emsp;Parcelable 是一种用于在不同组件之间传递复杂对象的机制。当需要在不同的组件之间传递自定义的数据对象时，可以使用<code>Parcelable</code>接口来实现。它允许将一个对象序列化为一个二进制数据流，然后在不同的进程中进行传输和反序列化。<strong>Parcelable 接口的实现需要将对象的状态保存在一个 Parcel 对象中，以便在不同进程之间进行传输。</strong></p>
<p>&emsp;Binder 是一种用于实现<strong>跨进程</strong>通信（IPC）的机制。</p>
<p>&emsp;system_server 是 Android 系统中的一个重要进程，主要功能是<strong>启动和管理 Android 系统中的各种服务和组件</strong>，包括 Activity Manager、Window Manager、Package Manager、Notification Manager 等。</p>
<p>&emsp;<code>Settings</code>系统应用是用于管理设备系统设置的应用程序。它包含了多个设置选项，例如网络、声音、显示、应用程序管理、安全性和账户等选项。</p>
<h4 id="gcc-amp-clang"><a href="#gcc-amp-clang" class="headerlink" title="gcc&amp;clang"></a>gcc&amp;clang</h4><p>&emsp;gcc：跨平台的C/C++编译器，可在linux、windows、mac上运行。</p>
<p>&emsp;clang也是跨平台的C/C++编译器。</p>
<h4 id="白盒AES"><a href="#白盒AES" class="headerlink" title="白盒AES"></a>白盒AES</h4><p>&emsp;白盒AES是一种加密算法实现技术，旨在在不泄漏密钥的情况下保护AES加密算法的安全性。在传统的AES加密中，密钥是加密过程中的核心组成部分，因此如果密钥被泄露，整个加密系统的安全性将被破坏。而白盒AES通过将密钥分散在算法的多个子函数中，并使用混淆和掩码等技术，使得攻击者无法直接访问到密钥，从而提高了加密算法的安全性和抵抗暴力攻击的能力。</p>
<h4 id="STM32中的寄存器库与HAL库"><a href="#STM32中的寄存器库与HAL库" class="headerlink" title="STM32中的寄存器库与HAL库"></a>STM32中的寄存器库与HAL库</h4><p>&emsp;寄存器级库提供了对STM32内部寄存器的直接访问，开发者可以直接操作寄存器来控制STM32的外设。这种库的使用需要对STM32的底层硬件有深入的了解，因此使用起来需要较高的技术水平。但是，寄存器级库具有较小的代码量和较快的执行速度，对于对代码大小和性能要求较高的项目非常适用。</p>
<p>&emsp;HAL库是STMicroelectronics提供的一种抽象层，它提供了一套高级API，使得开发者可以通过更高层次的抽象来操作STM32的外设。HAL库中的函数会将开发者的请求转换为对底层硬件寄存器的相应操作。HAL库的使用相对较为简单，但它会增加代码的大小和执行速度，因为HAL库需要在底层操作之上提供额外的抽象层。</p>
<h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><p>&emsp;闭包实际上就是把几个值和函数绑定在一起。</p>
<h4 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h4><p>&emsp;将一个函数作为参数传递到另一个函数中，并在需要的时候调用它。</p>
<h4 id="JIT编译与AOT编译"><a href="#JIT编译与AOT编译" class="headerlink" title="JIT编译与AOT编译"></a>JIT编译与AOT编译</h4><p>&emsp;<strong>AOT编译（Ahead-Of-Time compilation）在运行程序之前将源代码编译成机器代码。JIT编译在程序运行时将字节码编译成机器代码。</strong></p>
<p>&emsp;AOT编译器将源代码编译成机器代码，并将其打包到可执行文件中。当程序运行时，不需要再进行编译，而是直接执行机器代码。</p>
<p>&emsp;AOT编译通常用于编译静态语言（如C++、Java和C#）的程序，而JIT编译通常用于解释性语言（如Python和JavaScript）的程序。</p>
<h4 id="ueb128编码"><a href="#ueb128编码" class="headerlink" title="ueb128编码"></a>ueb128编码</h4><p>&emsp;uleb128是一种常见的压缩形式的数据存储方式，经常应用到Android DEX文件格式中。它最长采用5个字节表示数据的大小，最少采用1个字节表示数据的大小。具体采用的位数，可以通过判断每字节的最高位是否为1，为1则使用下一字节的数据。</p>
<h4 id="AI的Prompt"><a href="#AI的Prompt" class="headerlink" title="AI的Prompt"></a>AI的Prompt</h4><p>&emsp;Prompt是给模型的一条指令，告诉它要做什么。Prompt可以是简单的句子，也可以是更复杂的指令。例如，如果您想让模型生成一首诗，您可以给它一个Prompt，如“写一首关于爱情的诗”，模型将使用其训练数据生成一首诗，符合Prompt的要求。</p>
<h4 id="gdbus"><a href="#gdbus" class="headerlink" title="gdbus"></a>gdbus</h4><p>&emsp;GLib dbus（GDBus）是 GLib 库中提供 D-Bus 功能的一部分。D-Bus 用于在运行在 Linux 或具有 D-Bus 实现的其他操作系统上的应用程序之间进行通讯。</p>
<h4 id="svc"><a href="#svc" class="headerlink" title="svc"></a>svc</h4><p>&emsp;SVC 用于向内核发送请求。SVC 调用由一个特殊的异常处理程序处理，该处理程序将请求转发到内核。SVC 调用通常用于执行系统调用。例如，svc 调用可以用于打开文件、读取文件或写入文件。SVC 调用也可以用于执行其他操作，例如创建线程或设置定时器。</p>
<h4 id="LLVM-pass"><a href="#LLVM-pass" class="headerlink" title="LLVM pass"></a>LLVM pass</h4><p>&emsp;LLVM Pass 是 LLVM 编译器框架中的一组可重用的函数，用于<strong>对中间语言 (IR) 进行操作。</strong>LLVM Pass 可以用于执行各种任务，例如优化、分析和转换 IR。LLVM Pass 是编写为 C++ 代码的模块。它们可以独立运行，也可以组合在一起以创建更复杂的 Pass。</p>
<h4 id="ctx中的cipher指针"><a href="#ctx中的cipher指针" class="headerlink" title="ctx中的cipher指针"></a>ctx中的cipher指针</h4><p>&emsp;ctx 结构体中的 cipher 指针指向一个加密器对象。加密器对象包含加密算法的所有必要信息，例如密钥、块大小和工作模式。cipher 指针在 AES 中很重要，因为它允许加密器对象在加密和解密数据时使用。</p>
<h4 id="C-的虚函数"><a href="#C-的虚函数" class="headerlink" title="C++的虚函数"></a>C++的虚函数</h4><p>&emsp;C++中的虚函数可以被派生类重写。虚函数在基类中使用virtual关键字声明。当基类的指针或引用指向派生类对象时，调用虚函数时，会根据实际对象的类型来调用派生类中的函数定义。虚函数的主要作用是实现多态性。</p>
<p>&emsp;以下是虚函数的使用示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Base::func()&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Derived::func()&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Base* base = <span class="keyword">new</span> Derived;</span><br><span class="line">  base-&gt;<span class="built_in">func</span>(); <span class="comment">// 输出：Derived::func()</span></span><br><span class="line">  <span class="keyword">delete</span> base;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="RTTI"><a href="#RTTI" class="headerlink" title="RTTI"></a>RTTI</h4><p>&emsp;RTTI 是 Run-Time Type Identification 的缩写，它指的是运行时类型识别。在 C++ 中，RTTI 允许程序在运行时获取对象的类型信息。RTTI 在 C++ 中使用 typeid 运算符来获取对象的类型信息。typeid 运算符返回一个 type_info 对象，该对象包含了对象的类型信息。</p>
<h4 id="程序以独占方式运行"><a href="#程序以独占方式运行" class="headerlink" title="程序以独占方式运行"></a>程序以独占方式运行</h4><p>&emsp;程序以独占方式运行，是指程序在运行时，其他程序无法访问该程序所使用的资源。例如，一个程序正在使用一个文件，如果该程序以独占方式运行，则其他程序无法访问该文件。</p>
<p>&emsp;程序以独占方式运行通常是为了确保程序的安全性和稳定性。例如，一个程序正在写入一个文件，如果该程序以独占方式运行，则其他程序无法访问该文件，从而避免了文件被意外修改或损坏。</p>
<p>&emsp;程序以独占方式运行通常是通过操作系统的进程管理机制来实现的。操作系统会为每个程序分配一个唯一的进程 ID，并将该进程 ID 与该程序所使用的资源相关联。当一个程序以独占方式运行时，操作系统将阻止其他程序访问该程序所使用的资源。</p>
<h4 id="VIR文件"><a href="#VIR文件" class="headerlink" title="VIR文件"></a>VIR文件</h4><p>&emsp;VIR文件是Avira Antivirus Pro 2016创建的病毒感染文件。</p>
<h4 id="srv-sys"><a href="#srv-sys" class="headerlink" title="srv.sys"></a>srv.sys</h4><p>&emsp;srv.sys 是 Windows 操作系统的核心组件，负责文件系统的读取和写入。srv.sys 驱动程序负责以下任务：</p>
<ul>
<li>读取和写入文件</li>
<li>管理文件句柄</li>
<li>管理文件属性</li>
<li>管理文件权限</li>
</ul>
<h4 id="SSE指令"><a href="#SSE指令" class="headerlink" title="SSE指令"></a>SSE指令</h4><div class="table-container">
<table>
<thead>
<tr>
<th>指令名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>pmovmskb eax, xmm2</td>
<td>取xmm2（8字节）中的每个字节的符号位，并赋给eax（低8位）</td>
</tr>
<tr>
<td>packsswb xmm2, xmm2</td>
<td>将xmm2寄存器中的单精度浮点数转换为有符号整数</td>
</tr>
</tbody>
</table>
</div>
<h4 id="syscall-sysenter"><a href="#syscall-sysenter" class="headerlink" title="syscall/sysenter"></a>syscall/sysenter</h4><p>&emsp;syscall（系统调用）是Linux内核中提供给用户空间程序使用的接口，也称为系统调用函数。它可以让用户空间程序向内核发出请求，并获取内核返回的结果。syscall是操作系统与应用程序之间进行通信的桥梁，是Linux系统中最基本、最底层的API之一。sysenter是Intel 64和IA-32处理器中的一个特殊指令，用于快速进入系统模式。它是一种在ring 0级别上的入口点，用于启动特权模式代码。通过sysenter指令，可以跳转到由IA32_SYSENTER_CS（段选择子）和IA32_SYSENTER_EIP指定的特权模式代码，从而进入内核模式。</p>
<p>&emsp;syscall主要用于实现用户空间程序与内核的通信，而sysenter则用于快速进入系统模式。</p>
<h4 id="kernel-bypass-frameworks"><a href="#kernel-bypass-frameworks" class="headerlink" title="kernel-bypass frameworks"></a>kernel-bypass frameworks</h4><p>&emsp;能够绕过操作系统的内核级检查和授权，直接访问硬件资源的应用程序编程接口（API）和库集合，应用于高性能计算、大数据处理、虚拟化和安全领域。</p>
<h4 id="Syscall-User-Dispatch-SUD"><a href="#Syscall-User-Dispatch-SUD" class="headerlink" title="Syscall User Dispatch (SUD)"></a>Syscall User Dispatch (SUD)</h4><p>&emsp;用于在Linux上运行Windows游戏时提高性能和兼容性，SUD允许通过系统调用（syscall）在用户空间中调度和执行部分Ring3权限的函数，从而使得在Linux上运行Windows游戏时，不需要进行内核级别的修改或使用虚拟化技术。</p>
<h4 id="BSD-Packet-Filter-BPF-eBPF"><a href="#BSD-Packet-Filter-BPF-eBPF" class="headerlink" title="BSD Packet Filter (BPF)/eBPF"></a>BSD Packet Filter (BPF)/eBPF</h4><p>&emsp;BSD Packet Filter (BPF)是一种抓取并过滤网络数据包的内核结构，主要目的是允许用户空间程序对网络流量进行监控和分析，以便实现网络管理和安全审计等功能。</p>
<p>&emsp;BPF包含两个重要的组成部分：网络分流器（network tap）和包过滤器（packet filter）。网络分流器负责从网络驱动拷贝数据包，而包过滤器则根据用户空间程序提交的过滤规则，过滤掉不符合条件的数据包，只把符合需求的数据包上报给应用程序。</p>
<p>&emsp;BPF的过滤规则使用一种类似于汇编语言的伪汇编码语言来编写，这种语言可以被编译成可以在BPF虚拟机上运行的指令。BPF虚拟机运行在内核空间中，它可以从网络分流器获取数据包，并根据过滤规则对数据包进行过滤操作。</p>
<p>&emsp;eBPF（extended Berkeley Packet Filter）是一个能够在内核运行沙箱程序的技术，它允许用户态程序将C语言编写的一小段“内核代码”注入到内核中运行，使得非内核开发人员也可以对内核进行控制。</p>
<p>&emsp;eBPF的核心特性包括：</p>
<ol>
<li>在内核事件发生时安全地注入代码：用户态程序可以编写一段C语言代码，并将其注入到内核中运行。这使得非内核开发人员也可以对内核进行控制。</li>
<li>提供了强大的工具集：eBPF提供了一组强大的工具，包括用于跟踪和调试的bpftrace和bpftool等工具。</li>
<li>提供了安全检查：为了防止注入的代码导致内核崩溃或其他安全问题，eBPF会对注入的代码进行严格检查，拒绝不合格的代码的注入。</li>
<li>提供了与用户程序的通信机制：用户态程序和注入到内核中的程序可以通过共享内存实现通信，从而实现了更高效的交互。</li>
</ol>
<h4 id="callq-call"><a href="#callq-call" class="headerlink" title="callq/call"></a>callq/call</h4><p>&emsp;<code>callq</code>指令是64位模式下使用的，它直接跳转到目标地址去执行，同时将<strong>目标地址（即函数入口）压入栈（但是论文zopline中写的是caller address）</strong>中。这个指令相当于将控制权完全转移给被调用的函数。</p>
<p>&emsp;而<code>call</code>指令可以在16位、32位和64位模式下使用。在32位模式下，<code>call</code>指令会将<strong>下一条指令的地址压入栈</strong>中，并跳转到目标地址去执行。</p>
<h4 id="Trampoline-code"><a href="#Trampoline-code" class="headerlink" title="Trampoline code"></a>Trampoline code</h4><p>&emsp;Trampoline code是一种用于控制程序跳转的代码结构，它可以让程序从一个函数或任务跳转到另一个函数或任务，并可以按照特定的流程顺序执行这些函数或任务。</p>
<h4 id="dlmopen"><a href="#dlmopen" class="headerlink" title="dlmopen"></a>dlmopen</h4><p>&emsp;dlmopen是Linux中的一个函数，它用于打开动态链接库。dlmopen函数允许应用程序在运行时动态地加载和链接共享对象，以便使用其中的函数和数据。<strong>dlmopen函数支持对象加载隔离，即在新的命名空间中加载共享对象符号，这些符号不会暴露给应用程序的其他部分。</strong></p>
<h4 id="Bitmap"><a href="#Bitmap" class="headerlink" title="Bitmap"></a>Bitmap</h4><p>&emsp;bitmap通过使用每一bit位代表一个数，位号就是数值，1标识有，0标识无。如下所示：</p>
<p><img src="/images/fragmented-knowledge/image-20230907113634047.png" alt="image-20230907113634047" style="zoom:67%;" /></p>
<h4 id="vDSO-virtual-dynamic-shared-object"><a href="#vDSO-virtual-dynamic-shared-object" class="headerlink" title="vDSO (virtual dynamic shared object)"></a>vDSO (virtual dynamic shared object)</h4><p>&emsp;vDSO（virtual Dynamic Shared Object，虚拟动态共享对象）是一个比较小的共享库，内核动态地将它映射到所有应用程序的地址空间中。vDSO包含了一组用于优化系统调用的函数，<strong>它通过将频繁使用的系统调用改写为库函数，并将该库函数以用户空间的形式实现，从而加速系统调用的速度</strong>。vDSO主要被用户态的程序频繁调用，例如数据库或Web服务器等。</p>
<h4 id="IOCP套接字模型"><a href="#IOCP套接字模型" class="headerlink" title="IOCP套接字模型"></a>IOCP套接字模型</h4><p>&emsp;IOCP（I/O Completion Port），常称I/O完成端口。就是用于高效处理很多很多的客户端进行数据交换的一个模型。IOCP有一个队列，当你要发数据时，收数据和连接时，都交由IOCP队列处理，不会与操作系统底层交互。发送数据时，先将缓冲区和长度封好，这个请求会发送到IOCP队列，IOCP内部会帮你把请求发出去。收数据时，收数据的请求丢掉IOCP队列，IOCP会将收到的数据填入指定的缓冲区里边，当数据收好后会通知你来收数据。建立连接时，IOCP帮你把连接建立好，告诉你新的连接已经来了。</p>
<h4 id="Rundll32"><a href="#Rundll32" class="headerlink" title="Rundll32"></a>Rundll32</h4><p>&emsp;Rundll32（Run a DLL as an App）是Windows操作系统中的一个可执行文件，用于加载和执行DLL（Dynamic Link Library）文件中的函数。它允许将DLL文件中的函数作为独立的应用程序来执行。</p>
<h4 id="lwIP"><a href="#lwIP" class="headerlink" title="lwIP"></a>lwIP</h4><p>&emsp;lwIP (lightweight IP) 是一个轻量级的开源 TCP/IP 协议栈，专门设计用于嵌入式系统和资源受限设备。它提供了实现基本的网络通信所需的核心协议，如 IP、TCP、UDP 和 ICMP，以及一些常见的网络应用协议，如 DHCP、DNS 和 HTTP。</p>
<h4 id="Underminer-Exploit-Kit"><a href="#Underminer-Exploit-Kit" class="headerlink" title="Underminer Exploit Kit"></a>Underminer Exploit Kit</h4><p>&emsp;Underminer Exploit Kit（Underminer 攻击工具包）是一个恶意软件工具包，用于进行大规模的网络攻击和利用漏洞。它被用于分发恶意软件、实施网络钓鱼、进行勒索软件攻击和窃取敏感信息等恶意活动。</p>
<h4 id="MS-Detours"><a href="#MS-Detours" class="headerlink" title="MS Detours"></a>MS Detours</h4><p>&emsp;MS Detours（Microsoft Detours）是一种软件开发库，用于在 Windows 操作系统上进行函数挂钩（Function Hooking）。函数挂钩是一种技术，允许开发者在运行时修改或替换目标函数的行为，以实现定制化的功能扩展或拦截。MS Detours 包括软件调试、反病毒软件、代码注入、API 监视、性能分析等。</p>
<h4 id="LibPEConv"><a href="#LibPEConv" class="headerlink" title="LibPEConv"></a>LibPEConv</h4><p>&emsp;LibPEConv（Library PE Conv）是一个开源的C++库，用于在Windows平台上进行可执行文件（PE文件）的加载、解析和修改。它提供了一组功能强大的API，使开发者能够处理和操作PE文件的各个部分，包括头部信息、节表、导入表、导出表、重定位表等等。</p>
<p>LibPEConv的主要特点和功能包括：</p>
<ol>
<li>加载和解析PE文件：LibPEConv可以加载和解析PE文件，提取出各个组成部分的信息。</li>
<li>导入表和导出表操作：开发者可以使用LibPEConv来读取和修改PE文件的导入表和导出表，包括添加、删除、修改导入导出函数等。</li>
<li>重定位表处理：LibPEConv支持处理PE文件的重定位表，即使在修改PE文件后也能正确处理重定位。</li>
<li>节表操作：开发者可以使用LibPEConv来读取和修改PE文件的节表，包括添加、删除、重命名节等。</li>
<li>异常处理：LibPEConv支持处理PE文件中的异常处理表，包括添加、删除、修改异常处理信息。</li>
<li>兼容性：LibPEConv具有较好的兼容性，能够处理不同类型的PE文件，包括32位和64位的可执行文件和动态链接库（DLL）。</li>
</ol>
<h4 id="TSO-WMM"><a href="#TSO-WMM" class="headerlink" title="TSO/WMM"></a>TSO/WMM</h4><p>&emsp;TSO 是一种内存一致性模型，每个处理器核心的存储操作（Store）都会按照程序中的顺序进行排序和提交到主内存。在每个处理器核心看来，存储操作是按照其在程序中出现的顺序执行的，即<strong>每个处理器看到的存储操作顺序是一致的</strong>。然而，不同处理器核心之间的存储操作的顺序可能是不确定的，可能会发生重排序，因此程序员需要使用同步原语（如锁、原子操作等）来确保正确的顺序和同步。</p>
<p>&emsp;WMM 是一种较弱的内存一致性模型，它允许更多的存储操作重排序和乱序执行。在 WMM 下，处理器核心之间的内存操作的顺序可能会被重排，这包括存储操作和加载操作（Load）。这意味着在多核系统中，不同核心看到的存储和加载操作的顺序可能是不确定的，可能会产生一些奇怪的行为和错误。在 WMM 下编写正确的并发程序更加困难，因为程序员需要显式地使用同步原语（如内存屏障、原子操作等）来保证正确的顺序和同步。</p>
<h4 id="Shell脚本中-0"><a href="#Shell脚本中-0" class="headerlink" title="Shell脚本中$0 | $? | $! | $$ | $* | $# | $@"></a>Shell脚本中<code>$0 | $? | $! | $$ | $* | $# | $@</code></h4><div class="table-container">
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>$$$$</td>
<td>shell本身的pid</td>
</tr>
<tr>
<td><code>$?</code></td>
<td>返回值</td>
</tr>
<tr>
<td><code>$!</code></td>
<td>shell最后运行的后台进程的pid</td>
</tr>
<tr>
<td><code>$0</code></td>
<td>shell文件本身的文件名</td>
</tr>
<tr>
<td><code>$*</code></td>
<td>所有参数列表，以<code>&quot;$1 $2 ... $n&quot;</code>的形式输出</td>
</tr>
<tr>
<td><code>$#</code></td>
<td>参数个数</td>
</tr>
<tr>
<td><code>$@</code></td>
<td>所有参数列表，以<code>&quot;$1&quot; &quot;$2&quot; ... &quot;$n&quot;</code>的形式输出</td>
</tr>
</tbody>
</table>
</div>
<h4 id="Shell脚本中"><a href="#Shell脚本中" class="headerlink" title="Shell脚本中$() | `` | ${} | $[] | $(()) | [] | (()) | [[]]"></a>Shell脚本中<code>$() | `` | $&#123;&#125; | $[] | $(()) | [] | (()) | [[]]</code></h4><h5 id=""><a href="#" class="headerlink" title="$() | `` "></a><code>$() | `` </code></h5><p>&emsp;两者都可以当作<strong>命令替换</strong>来用，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">version = $(uname -r)</span><br><span class="line">version = `uname -r`</span><br></pre></td></tr></table></figure>
<p>&emsp;但是，<code>`` </code> 基本上可用在全部的 unix shell 中使用，而<code>$()</code>并不是所有shell都支持。</p>
<h5 id="-1"><a href="#-1" class="headerlink" title="${}"></a><code>$&#123;&#125;</code></h5><p>&emsp;<code>$&#123;&#125;</code>用于变量替换。一般情况下，<code>$var</code>与<code>$&#123;var&#125;</code>并没有啥不一样。但是用<code>$&#123;&#125;</code>会比较精确的界定变量名称的范围。</p>
<h5 id="与"><a href="#与" class="headerlink" title="$[]与$(())"></a><code>$[]</code>与<code>$(())</code></h5><p>&emsp;都是进行数学运算的，但是注意，bash只能作整数运算，对于浮点数是当作字符串处理的。而<code>(()) | [[]]</code>是数学表达式的加强版。</p>
<h4 id="反汇编器"><a href="#反汇编器" class="headerlink" title="反汇编器"></a>反汇编器</h4><p>&emsp;机器指令到汇编语言。</p>
<h4 id="vsyscall-vdso"><a href="#vsyscall-vdso" class="headerlink" title="vsyscall/vdso"></a>vsyscall/vdso</h4><p>&emsp;<code>vsyscall</code> 是一种特殊的内核映射区域，用于提供对一些常用系统调用的快速访问。在早期的 Linux 内核版本中，系统调用是通过软中断（software interrupt）的方式实现的，这需要从用户空间切换到内核空间，并执行相应的系统调用处理例程。这种切换的开销相对较高，对于频繁调用的系统调用来说，会导致性能下降。</p>
<p>&emsp;为了解决这个问题，Linux 内核引入了 <code>vsyscall</code> 机制。<code>vsyscall</code> 是一个位于用户空间的内存映射区域，它包含了一些常见的系统调用的实现代码，如获取当前时间、获取系统信息等。这些系统调用的实现在 <code>vsyscall</code> 区域中直接运行，而不需要进行用户空间到内核空间的切换。</p>
<p>&emsp;需要注意的是，<code>vsyscall</code> 机制在较新的 Linux 内核版本中已经被废弃，并被 <code>vdso</code>（Virtual Dynamic Shared Object）机制所取代。<code>vdso</code> 是一个用户空间的共享库，其中包含了一些常用系统调用的实现代码。它通过动态链接器的机制自动加载到每个用户空间进程的虚拟内存空间中，从而提供快速的系统调用访问。</p>
<h4 id="WebDAV-UNC"><a href="#WebDAV-UNC" class="headerlink" title="WebDAV/UNC"></a>WebDAV/UNC</h4><p>&emsp;WebDAV（Web-based Distributed Authoring and Versioning）用于在远程服务器上进行文件管理和协作。它允许用户通过 Web 进行文件的读取、写入、复制、移动和删除操作，类似于本地文件系统的访问方式。</p>
<p>&emsp;UNC（Universal Naming Convention）用于在网络上访问共享资源，如文件和打印机。UNC 路径使用特定的格式来标识网络上的共享资源，通常以双斜杠开头，后面跟着服务器名称或 IP 地址，然后是共享资源的名称或路径。</p>
<h4 id="js中的异步函数与同步函数"><a href="#js中的异步函数与同步函数" class="headerlink" title="js中的异步函数与同步函数"></a>js中的异步函数与同步函数</h4><p>&emsp;同步函数按照代码的顺序逐行执行，每一行代码都会等待上一行代码执行完成后再执行下一行。而异步函数执行时，虽然此函数还没运行完，但是就直接运行下一行代码。</p>
<h4 id="io-uring"><a href="#io-uring" class="headerlink" title="io_uring"></a>io_uring</h4><p>&emsp;传统的 I/O 操作（如读取文件、网络通信等）通常需要使用系统调用（如 read、write、recv、send 等），这些调用会导致进程阻塞等待 I/O 完成。在阻塞期间，进程无法执行其他任务，效率较低。</p>
<p>&emsp;io_uring 引入了一种新的异步 I/O 模型，它通过使用 I/O 事件环（I/O event ring）来实现高效的非阻塞 I/O 操作。它的设计目标是减少系统调用的开销和提高 I/O 操作的吞吐量。</p>
<h4 id="bootloader锁"><a href="#bootloader锁" class="headerlink" title="bootloader锁"></a>bootloader锁</h4><p>&emsp;bootloader 锁是一种安全机制，用于限制用户对设备的操作和修改。Bootloader 是手机启动时加载的程序，负责引导操作系统的启动。Bootloader 锁限制了用户在手机上安装非官方固件、自定义操作系统或进行其他修改的能力。</p>
<p>&emsp;当手机的 bootloader 被锁定时，只能安装由手机制造商或官方渠道提供的经过验证的固件和操作系统。这意味着用户无法自行安装第三方 ROM（如刷入自定义的 Android ROM）或进行其他需要访问 bootloader 功能的操作。</p>
<h4 id="TWRP"><a href="#TWRP" class="headerlink" title="TWRP"></a>TWRP</h4><p>&emsp;Team win recovery project是一个开放源码软件的定制Recovery映像，允许用户向第三方安装固件和备份当前的系统，Recovery指的是一种可以对安卓机内部的数据或系统进行修改的模式，类似于Windows PE。</p>
<h4 id="android-studio的DDMS"><a href="#android-studio的DDMS" class="headerlink" title="android studio的DDMS"></a>android studio的DDMS</h4><p>&emsp;早期的android studio中，DDMS（Dalvik Debug Monitor Server）是用于调试和监视 Android 设备和模拟器的工具。</p>
<h4 id="一代整体加固（Whole-Program-Obfuscation）与二代抽取加固（Code-and-Resource-Extraction-Protection）"><a href="#一代整体加固（Whole-Program-Obfuscation）与二代抽取加固（Code-and-Resource-Extraction-Protection）" class="headerlink" title="一代整体加固（Whole-Program Obfuscation）与二代抽取加固（Code and Resource Extraction Protection）"></a>一代整体加固（Whole-Program Obfuscation）与二代抽取加固（Code and Resource Extraction Protection）</h4><p>&emsp;一代整体加固是指将整个应用程序的代码进行混淆和加密，使得逆向工程师难以理解和还原源代码，通常包括代码混淆、字符串加密、控制流混淆、反调试。</p>
<p>&emsp;二代抽取加固是指将应用程序的<strong>关键逻辑和资源从原始的可执行文件中提取出来，以加密和保护</strong>，而将剩余的代码保留在原始的可执行文件中，包括代码与资源提取、加密保护、运行时解密。</p>
<h4 id="ART虚拟机与Dalvik虚拟机"><a href="#ART虚拟机与Dalvik虚拟机" class="headerlink" title="ART虚拟机与Dalvik虚拟机"></a>ART虚拟机与Dalvik虚拟机</h4><p>&emsp;ART（Android Runtime）是 Android 系统中的一种虚拟机，用于执行和管理 Android 应用程序的运行时环境。它是在 Android 5.0中引入的，之前是 Dalvik 虚拟机。</p>
<h4 id="安卓中的zygote与Libart-so"><a href="#安卓中的zygote与Libart-so" class="headerlink" title="安卓中的zygote与Libart.so"></a>安卓中的zygote与Libart.so</h4><p>&emsp;zygote 是安卓的关键进程，作为应用程序的孵化器。它在系统启动时被初始化，负责创建和管理应用程序的进程（作用1）。当启动新的应用程序时，复制自身并生成新的进程，作为新应用程序的基础。预加载并共享一些常用的系统类和资源，以减少应用程序启动时间和系统资源的消耗（作用2）。执行应用程序进程的安全隔离，确保不同应用程序之间的互相隔离和保护（作用3）。</p>
<p>&emsp;libart.so（或ART Runtime）是安卓的运行时库，用于执行应用程序的代码。其实现了安卓应用程序的AOT（Ahead-of-Time）编译，将应用程序的字节码转换为本地机器代码，以提高应用程序的执行效率。还提供了一些优化功能，如垃圾回收、内存管理和即时编译等。</p>
<h4 id="vmware桥接模式与仅主机模式"><a href="#vmware桥接模式与仅主机模式" class="headerlink" title="vmware桥接模式与仅主机模式"></a>vmware桥接模式与仅主机模式</h4><p>&emsp;桥接模式（Bridged Mode）：宿主机的副本。桥接模式允许虚拟机与物理网络中的其他设备直接连接，就像虚拟机是网络中的一个独立计算机一样。在桥接模式下，<strong>虚拟机会获得与主机所连接的物理网络相同的网络信息（ip地址在同一c段下）</strong>。</p>
<p>&emsp;仅主机模式：在仅主机模式下，虚拟机之间可以相互通信，但无法与物理网络中的其他设备进行通信。仅主机模式提供了一种安全的网络环境，<strong>适用于需要虚拟机之间进行通信，但不需要与外部网络进行交互的场景</strong>。</p>
<h4 id="http与socks5"><a href="#http与socks5" class="headerlink" title="http与socks5"></a>http与socks5</h4><p>&emsp;http工作在应用层，socks5工作在传输层，socks5可以观察到更多的协议信息。</p>
<h4 id="frida-f与-F"><a href="#frida-f与-F" class="headerlink" title="frida -f与-F"></a>frida -f与-F</h4><p>&emsp;<code>-f</code>参数后面跟着应用程序的标识符，可以是应用程序的包名、进程名或应用程序的可执行文件路径。<code>-F</code> 又可以写为<code>--attach-frontmost</code>，会<code>自动搜索</code>正在运行的进程，此时确保要调试的app，处在前台=正在运行=当前界面。</p>
<h4 id="SSL-Pinning"><a href="#SSL-Pinning" class="headerlink" title="SSL Pinning"></a>SSL Pinning</h4><p>&emsp;SSL Pinning（SSL 锐化）是一种用于增强应用程序与服务器之间的安全通信的技术。它可以<code>防止中间人攻击和窃听</code>。</p>
<p>&emsp;通常情况下，应用程序与服务器之间的通信通过 SSL/TLS 加密协议进行保护，SSL Pinning 引入了一个额外的验证步骤，以确保<code>应用程序只信任特定的服务器证书或公钥</code>。</p>
<p>&emsp;其工作原理如下：</p>
<p>（1）预先固定证书或公钥：开发者在应用程序中嵌入了服务器的证书或公钥信息。这些信息是预先固定的。</p>
<p>（2）运行时验证：当应用程序与服务器建立 SSL/TLS 连接时，它会<code>验证服务器的证书或公钥是否与预先固定的信息匹配</code>。如果匹配成功，连接被认为是受信任的，通信继续进行。</p>
<p><img src="/images/fragmented-knowledge/image-20231010175359561.png" alt="image-20231010175359561" style="zoom:67%;" /></p>
<p>&emsp;SSL Pinning实际上是<code>客户端锁定服务器端的证书</code>，在要与服务器进行交互的时候，<code>服务器端会将CA证书发送给客户端，客户端会调用函数对服务器端的证书进行校验，与本地的服务器端证书(存放在.asset目录或resraw下)进行比对</code>。</p>
<h4 id="尾指令与非尾指令"><a href="#尾指令与非尾指令" class="headerlink" title="尾指令与非尾指令"></a>尾指令与非尾指令</h4><p>&emsp;尾指令：直接跳转到其他指令，而不是继续执行当前指令后面的指令，通常是无条件跳转或条件跳转。</p>
<p>&emsp;非尾指令：接着执行后面的指令。</p>
<h4 id="子资源完整性（Subresource-Integrity，SRI）"><a href="#子资源完整性（Subresource-Integrity，SRI）" class="headerlink" title="子资源完整性（Subresource Integrity，SRI）"></a>子资源完整性（Subresource Integrity，SRI）</h4><p>&emsp;验证和确保在网页中引用的外部资源（如脚本文件、样式表文件等）的完整性的安全技术。<code>SRI 使用哈希算法来生成资源的完整性校验值，并将其与引用资源的网页中的对应值进行比对</code>。如果校验值匹配，表示资源未被篡改，可以安全加载和使用。</p>
<h4 id="内容安全策略-Content-Security-Policy-CSP"><a href="#内容安全策略-Content-Security-Policy-CSP" class="headerlink" title="内容安全策略 (Content Security Policy, CSP)"></a>内容安全策略 (Content Security Policy, CSP)</h4><p>&emsp;一种安全机制，用于保护网站免受恶意脚本注入、跨站脚本攻击（XSS）、数据泄露和点击劫持等。CSP 允许网站所有者通过<code>定义一组策略规则，明确指定允许加载的资源来源和允许执行的操作</code>，从而限制网页中可执行的内容和行为。</p>
<h4 id="goroot-vs-gopath"><a href="#goroot-vs-gopath" class="headerlink" title="goroot vs gopath"></a>goroot vs gopath</h4><ul>
<li>GOROOT：GOROOT就是Go的安装目录，（类似于java的JDK）</li>
<li>GOPATH：GOPATH是工作空间，保存go项目代码和第三方依赖包。设置了GOPATH，则无法使用go mod（依赖文件）。</li>
</ul>
<h4 id="ps的Invoke-Expression与Invoke"><a href="#ps的Invoke-Expression与Invoke" class="headerlink" title="ps的Invoke-Expression与Invoke"></a>ps的Invoke-Expression与Invoke</h4><p>&emsp;<code>Invoke-Expression</code> 命令用于执行以<code>字符串</code>形式提供的 PowerShell 表达式或命令。</p>
<p>&emsp;<code>Invoke</code>（也称为 <code>Invoke-Command</code>）是<code>通用的 PowerShell 命令</code>，用于执行命令、脚本块或脚本文件。</p>
<h4 id="CIDR表示法"><a href="#CIDR表示法" class="headerlink" title="CIDR表示法"></a>CIDR表示法</h4><p>&emsp;Classless Inter-Domain Routing，一种用于表示 IP 网络和子网的简洁表示方法，例如<code>192.0.2.0/24</code>。</p>
<h4 id="波束成形"><a href="#波束成形" class="headerlink" title="波束成形"></a>波束成形</h4><p>&emsp;波束成形（Beamforming）通过对传输或接收的信号进行加权和相位调整，实现对特定方向的信号增强或抑制。传统的无线通信系统中，信号以均匀扩散的方式传输和接收，导致信号的能量在空间中的分布较为平均。而波束成形技术通过调整信号的相位和幅度分布，<code>使得信号在某个特定的方向上形成一个集中的波束，从而将信号的能量聚焦在目标方向上</code>。</p>
<h4 id="Constant-False-Alarm-Rate-CFAR-算法"><a href="#Constant-False-Alarm-Rate-CFAR-算法" class="headerlink" title="Constant False Alarm Rate (CFAR) 算法"></a>Constant False Alarm Rate (CFAR) 算法</h4><p>&emsp;首先对输入的噪声进行处理后确定一个门限，将此门限与输入端信号相比，如输入端信号超过了此门限，则判为有目标，否则，判为无目标。</p>
<h4 id="Gradient-Reversal-Layer-GRL-梯度反转层"><a href="#Gradient-Reversal-Layer-GRL-梯度反转层" class="headerlink" title="Gradient Reversal Layer (GRL) 梯度反转层"></a>Gradient Reversal Layer (GRL) 梯度反转层</h4><p>&emsp;在反向传播过程中，GRL层将输入的梯度乘以一个负的标量权重（通常为-1），从而实现梯度反转。</p>
<p>&emsp;作用：</p>
<ul>
<li>域自适应：GRL层主要用于域自适应任务，其中训练数据包含来自不同领域的样本，但目标是在目标领域中获得良好的性能。</li>
<li>域不变表示学习：GRL层通过反转梯度的方向，鼓励模型在域自适应任务中学习到与输入域无关的特征表示。</li>
<li>特征混淆：通过反转梯度的方向，GRL层试图最大化源域和目标域之间的特征差异，从而迫使模型学习到与域相关的特征，并减小域之间的分布差异。</li>
<li>提升模型泛化性能：通过减小域之间的分布差异，GRL层有助于提高模型在目标域中的泛化性能。</li>
</ul>
<h4 id="dilated-conv（扩张卷积）"><a href="#dilated-conv（扩张卷积）" class="headerlink" title="dilated conv（扩张卷积）"></a>dilated conv（扩张卷积）</h4><p>&emsp;传统的卷积操作是在输入数据上滑动一个固定大小的卷积核，进行局部感知和特征提取。Dilated Convolution引入了一个称为膨胀率的概念。膨胀率定义了卷积核中采样点之间的间隔，卷积核的每个采样点之间通过添加固定的间隔来形成一个网格。这样，卷积核在输入数据上的感受野变得更大，从而能够捕捉更广泛的上下文信息。</p>
<h4 id="t-SNE（t-Distributed-Stochastic-Neighbor-Embedding）"><a href="#t-SNE（t-Distributed-Stochastic-Neighbor-Embedding）" class="headerlink" title="t-SNE（t-Distributed Stochastic Neighbor Embedding）"></a>t-SNE（t-Distributed Stochastic Neighbor Embedding）</h4><p>&emsp;非线性降维和可视化技术，用于将高维数据映射到低维空间，并保持数据点之间的相似性关系。</p>
<h4 id="java反射"><a href="#java反射" class="headerlink" title="java反射"></a>java反射</h4><p>&emsp;在Java中，反射（Reflection）是指在<code>运行时动态地获取和操作类的信息</code>，包括类的结构、字段、方法和构造函数等。</p>
<h4 id="hypervisor"><a href="#hypervisor" class="headerlink" title="hypervisor"></a>hypervisor</h4><p>&emsp;      Hypervisor（虚拟机监控程序）允许在物理计算机上同时运行多个虚拟机（Virtual Machine），每个虚拟机都可以执行独立的操作系统和应用程序。Hypervisor负责管理和分配物理资源给虚拟机，并提供虚拟化环境，使得每个虚拟机都能够运行和管理自己的操作系统和应用程序。</p>
<h4 id="selinux-policies"><a href="#selinux-policies" class="headerlink" title="selinux policies"></a>selinux policies</h4><p>&emsp;SELinux (Security-Enhanced Linux) 是一种在 Linux 操作系统上实施强制访问控制（MAC）的安全机制。SELinux Policies 文件是用于定义和配置 SELinux 策略的文件。SELinux Policies 文件包含了一组规则和规范，用于控制系统上进程、文件、网络通信等资源的访问权限。这些策略规则定义了哪些进程可以访问哪些文件、网络端口、设备等，并规定了访问权限的具体规则和限制。</p>
<h4 id="proc-self-attr-prev-文件"><a href="#proc-self-attr-prev-文件" class="headerlink" title="/proc/self/attr/prev 文件"></a><code>/proc/self/attr/prev</code> 文件</h4><p>&emsp;是与 SELinux 相关的特殊文件之一，用于存储进程的安全上下文（Security Context）的先前值。</p>
<h4 id="True-Positive-TP-：将正类预测为正类"><a href="#True-Positive-TP-：将正类预测为正类" class="headerlink" title="True Positive(TP)：将正类预测为正类"></a>True Positive(TP)：将正类预测为正类</h4><h4 id="True-Negative-TN-：将负类预测为负类"><a href="#True-Negative-TN-：将负类预测为负类" class="headerlink" title="True Negative(TN)：将负类预测为负类"></a>True Negative(TN)：将负类预测为负类</h4><h4 id="False-Positive-FP-：将负类预测为正类数（误报）"><a href="#False-Positive-FP-：将负类预测为正类数（误报）" class="headerlink" title="False Positive(FP)：将负类预测为正类数（误报）"></a>False Positive(FP)：将负类预测为正类数（误报）</h4><h4 id="False-Negative-FN-：将正类预测为负类数（漏报）"><a href="#False-Negative-FN-：将正类预测为负类数（漏报）" class="headerlink" title="False Negative(FN)：将正类预测为负类数（漏报）"></a>False Negative(FN)：将正类预测为负类数（漏报）</h4><h4 id="Gradle"><a href="#Gradle" class="headerlink" title="Gradle"></a>Gradle</h4><p>&emsp;Gradle 是强大的构建工具和构建自动化系统，用于构建和管理软件项目。它采用了基于 Groovy 或 Kotlin 的领域特定语言（DSL）来定义项目的构建脚本。它可以用于构建Java项目。</p>
<h4 id="DSL"><a href="#DSL" class="headerlink" title="DSL"></a>DSL</h4><p>&emsp;领域特定语言（Domain-Specific Language，DSL）是一种针对特定领域或问题域的编程语言。DSL 的设计目标是为了解决特定领域中的问题，并提供更高级、更专注的表达能力。分为内部DSL与外部DSL。内部 DSL 是嵌入在通用编程语言中的领域特定语言，例如，Java 中的流式 API（Stream API）就是一种内部 DSL。外部 DSL 是一种独立的编程语言，用于解决特定领域的问题，例如，正则表达式是一种外部 DSL。</p>
<h4 id="java的泛型"><a href="#java的泛型" class="headerlink" title="java的泛型"></a>java的泛型</h4><p>&emsp;泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。java 中泛型标记符：</p>
<ul>
<li><strong>E</strong> - Element (在集合中使用，因为集合中存放的是元素)</li>
<li><strong>T</strong> - Type（Java 类）</li>
<li><strong>K</strong> - Key（键）</li>
<li><strong>V</strong> - Value（值）</li>
<li><strong>N</strong> - Number（数值类型）</li>
<li><strong>？</strong> - 表示不确定的 java 类型</li>
</ul>
<p><img src="/images/fragmented-knowledge/image-20231117200539593.png" alt="image-20231117200539593" style="zoom:67%;" /></p>
<p><img src="/images/fragmented-knowledge/image-20231117200733591.png" alt="image-20231117200733591" style="zoom:67%;" /></p>
<h4 id="fld与fstp"><a href="#fld与fstp" class="headerlink" title="fld与fstp"></a>fld与fstp</h4><p>fld：将浮点数值加载到浮点寄存器中。</p>
<p>fstp：用于将浮点寄存器中的值存储到指定的目标位置。</p>
<h4 id="CIP-与长连服务器"><a href="#CIP-与长连服务器" class="headerlink" title="CIP 与长连服务器"></a>CIP 与长连服务器</h4><p>&emsp;CIP（Common Industrial Protocol）通道是一种用于工业自动化领域的通信协议，其允许在工业网络中以一种标准化的方式来管理和控制不同厂商的设备，使它们能够相互通信并协同工作。</p>
<p>&emsp;长连接服务器（Long-polling Server）是一种服务器端技术，可以实现实时的双向通信。与传统的短连接不同，长连接服务器允许客户端与服务器之间建立持久的连接，以便在任何时间点上进行双向的数据传输。长连接服务器通过保持连接的持久性来解决这个问题，长连接服务器可以用于实现各种实时通信应用，如实时聊天、实时数据推送、多人协作、在线游戏等，长连接服务器技术包括 WebSocket、Server-Sent Events（SSE）等。</p>
<h4 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h4><p>&emsp;Socket 本身并不是协议，它是对传输层协议（如 TCP 或 UDP）的抽象和封装。通过 Socket 编程接口，开发人员可以使用底层的传输层协议进行网络通信。</p>
<h4 id="网络字节序与主机字节序"><a href="#网络字节序与主机字节序" class="headerlink" title="网络字节序与主机字节序"></a>网络字节序与主机字节序</h4><p>&emsp;网络字节序是一种固定的大端字节序，用于在计算机网络中进行数据交换；而主机字节序是指主机使用的字节序，可能是大端字节序或小端字节序。常用的字节序转换函数包括 <code>ntohl</code>（网络字节序转主机字节序）和 <code>htonl</code>（主机字节序转网络字节序）。</p>
<h4 id="java’s-visitor-mode"><a href="#java’s-visitor-mode" class="headerlink" title="java’s visitor mode"></a>java’s visitor mode</h4><p>Define new operation in object structure’s element without modifing object structure.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Visitor</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(ElementA elementA)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(ElementB elementB)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Element</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Visitor visitor)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ElementA</span> <span class="keyword">implements</span> <span class="title class_">Element</span> &#123;</span><br><span class="line">    <span class="comment">// implements Element interface</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Visitor visitor)</span> &#123;</span><br><span class="line">        <span class="comment">// implements Visitor interface</span></span><br><span class="line">        visitor.visit(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ElementA&#x27;s feature</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ElementB</span> <span class="keyword">implements</span> <span class="title class_">Element</span> &#123;</span><br><span class="line">    <span class="comment">// implements Element interface</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Visitor visitor)</span> &#123;</span><br><span class="line">        <span class="comment">// implements Visitor interface</span></span><br><span class="line">        visitor.visit(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ElementB&#x27;s feature</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// implement concrete class of visitor</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteVisitor</span> <span class="keyword">implements</span> <span class="title class_">Visitor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(ElementA elementA)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;访问者对 ElementA 进行操作&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(ElementB elementB)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;访问者对 ElementB 进行操作&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Element</span> <span class="variable">elementA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ElementA</span>();</span><br><span class="line">        <span class="type">Element</span> <span class="variable">elementB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ElementB</span>();</span><br><span class="line">        <span class="comment">// define a visitor</span></span><br><span class="line">        <span class="type">Visitor</span> <span class="variable">visitor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteVisitor</span>();   </span><br><span class="line">        <span class="comment">// for different element, do different thing</span></span><br><span class="line">        elementA.accept(visitor);</span><br><span class="line">        elementB.accept(visitor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="call-ret"><a href="#call-ret" class="headerlink" title="call/ret"></a>call/ret</h4><p>call = push IP, jmp near ptr 标号</p>
<p>ret = pop ip</p>
<h4 id="Cpp-的一些特性"><a href="#Cpp-的一些特性" class="headerlink" title="Cpp 的一些特性"></a>Cpp 的一些特性</h4><h5 id="explicit"><a href="#explicit" class="headerlink" title="explicit"></a>explicit</h5><p>&emsp;防止编译器进行隐式的类型转换。如下所示，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MyClass</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 构造函数的实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(MyClass obj)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 函数的实现</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyClass <span class="title">obj1</span><span class="params">(<span class="number">10</span>)</span></span>;  <span class="comment">// 直接调用构造函数，显式创建对象</span></span><br><span class="line">    MyClass obj2 = <span class="number">20</span>;  <span class="comment">// 错误！禁止隐式类型转换</span></span><br><span class="line">    MyClass obj3 = <span class="built_in">MyClass</span>(<span class="number">30</span>);  <span class="comment">// 正确，显式调用构造函数进行类型转换</span></span><br><span class="line">    <span class="built_in">func</span>(<span class="number">40</span>);  <span class="comment">// 错误！禁止隐式类型转换</span></span><br><span class="line">    <span class="built_in">func</span>(<span class="built_in">MyClass</span>(<span class="number">50</span>));  <span class="comment">// 正确，显式调用构造函数进行类型转换</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="inline"><a href="#inline" class="headerlink" title="inline"></a>inline</h5><p>&emsp;向编译器提供函数内联展开的建议。如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">add</span>(<span class="number">3</span>, <span class="number">4</span>);  <span class="comment">// 函数调用被内联展开，即不使用 call</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>cpp 中函数参数定义为 const 有什么好处？</code>使用 const 修饰参数可以向函数的调用者传达一种约束，即函数内部不会修改参数的值。</p>
<p><code>cpp 中函数定义为 const 有什么好处？</code>这意味着该函数在执行过程中不会修改对象的成员变量。常量成员函数可以在常量对象上调用，这样可以提供对常量对象的操作。如果没有将成员函数定义为 const，则无法在常量对象上调用该函数。<code>将函数定义为 const 的前提是该函数是类的成员函数。对于非成员函数，不能将其定义为 const</code>。</p>
<h5 id="virtual"><a href="#virtual" class="headerlink" title="virtual"></a>virtual</h5><p>&emsp;用于声明类的成员函数为虚函数。虚函数允许在派生类中进行函数的覆盖，实现运行时的多态性。</p>
<h5 id="protected"><a href="#protected" class="headerlink" title="protected"></a>protected</h5><p>&emsp;private<code>成员在类内部可见，外部无法直接访问。</code>protected` 成员在类内部和派生类中可见，外部无法直接访问。</p>
<h5 id="类的公有继承与私有继承"><a href="#类的公有继承与私有继承" class="headerlink" title="类的公有继承与私有继承"></a>类的公有继承与私有继承</h5><p>&emsp;公有继承特点为：<code>基类的公有成员和保护成员作为派生类的成员时，它们都保持原有的状态，而基类的私有成员仍然是私有的，不能被这个派生类的子类所访问</code>。私有继承的特点是：<code>基类的公有成员和保护成员都作为派生类的私有成员，并且不能被这个派生类的子类所访问</code>。</p>
<h5 id="friend"><a href="#friend" class="headerlink" title="friend"></a>friend</h5><p>&emsp;一个类可以授权其他类或函数访问其私有成员。如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> privateData;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">friendFunction</span><span class="params">()</span></span>;  <span class="comment">// 声明友元函数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">publicFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        privateData = <span class="number">10</span>;          <span class="comment">// 友元函数可以访问私有成员</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">friendFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass obj;</span><br><span class="line">    obj.privateData = <span class="number">20</span>;           <span class="comment">// 可以访问 MyClass 的私有成员</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="constexpr-与-const"><a href="#constexpr-与-const" class="headerlink" title="constexpr 与 const"></a>constexpr 与 const</h5><p>&emsp;<code>const</code> 关键字用于声明一个常量，表示它的值不能在程序运行时被修改。<code>constexpr</code> 关键字用于声明一个常量表达式，表示它在编译时就能被计算出来。</p>
<h5 id="using"><a href="#using" class="headerlink" title="using"></a>using</h5><p>&emsp;<code>using</code> 用于引入类型别名、类型别名模板以及模板别名。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> MyInt = <span class="type">int</span>;</span><br><span class="line"><span class="keyword">using</span> MyFunction = std::function&lt;<span class="built_in">void</span>(<span class="type">int</span>)&gt;;</span><br></pre></td></tr></table></figure>
<h5 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h5><p>&emsp;显著简化内存管理，并避免手动释放内存的工作。<code>std::unique_ptr</code>：独占所有权的智能指针，它提供了对单个对象的独占所有权，并确保在其生命周期结束时自动释放内存。</p>
<h5 id="右值引用-amp-amp"><a href="#右值引用-amp-amp" class="headerlink" title="右值引用&amp;&amp;"></a>右值引用&amp;&amp;</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">A</span>() &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Default constructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">A</span>(<span class="type">const</span> A&amp; other) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Copy constructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">A</span>(A&amp;&amp; other) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Move constructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(A&amp;&amp; a)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用 a 进行操作，可能会进行移动操作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A obj;  <span class="comment">// 创建一个对象</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">foo</span>(std::<span class="built_in">move</span>(obj));  <span class="comment">// 将 obj 转为右值引用传递给 foo 函数。注意：在实际应用中，将 obj 转为右值引用时需要谨慎，确保 obj 不再被使用。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="cmake-与-make-指令"><a href="#cmake-与-make-指令" class="headerlink" title="cmake 与 make 指令"></a>cmake 与 make 指令</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CMake：生成 Makefile 的工具，侧重于跨平台构建配置。</span><br><span class="line">Make：根据 Makefile 执行实际的构建命令，侧重于执行编译任务并管理依赖关系。</span><br></pre></td></tr></table></figure>
<h4 id="python-的-co-lnotab"><a href="#python-的-co-lnotab" class="headerlink" title="python 的 co_lnotab"></a>python 的 co_lnotab</h4><p><code>co_lnotab</code> 的名称来自 line number table，即行号表。每条记录通常包含两个部分：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">字节码偏移的增量。</span><br><span class="line">从上一个记录到当前记录的行号增量。</span><br></pre></td></tr></table></figure>
<p>&emsp;如下图所示：</p>
<p><img src="/images/fragmented-knowledge/image-20240325215644570.png" alt="image-20240325215644570" style="zoom:67%;" /></p>
<h4 id="mmap-与-vdso-页面"><a href="#mmap-与-vdso-页面" class="headerlink" title="mmap 与 vdso 页面"></a>mmap 与 vdso 页面</h4><p>mmap 内存映射：</p>
<p><img src="/images/fragmented-knowledge/image-20240507204927809.png" alt="image-20240507204927809" style="zoom:67%;" /></p>
<p>&emsp;系统调用涉及到从用户态切换到内核态，这是一个耗时的操作。<code>vDSO</code> 提供了一种机制，允许用户程序直接在用户态执行某些系统调用，无需切换到内核态。这通过将一小块代码（即 <code>vDSO</code> 代码）映射到每个进程的地址空间来实现。</p>
<h4 id="gcc-编译选项"><a href="#gcc-编译选项" class="headerlink" title="gcc 编译选项"></a>gcc 编译选项</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-no-pie。不生成位置无关的可执行文件。</span><br><span class="line">-fno-pie。不生成位置无关的代码。</span><br><span class="line">-ldl。告诉 GCC 链接时需要包括动态链接库 libdl。这个库提供了动态加载和链接功能，如 dlopen, dlclose, dlsym, dlerror 等函数。</span><br><span class="line">-fpic。为共享库生成位置无关代码。</span><br><span class="line">-pie。生成动态链接的位置无关可执行文件，通常需要同时指定 -fpie。</span><br><span class="line">-fpie。类似于-fpic，但生成的位置无关代码只能用于可执行文件，通常同时指定 -pie。</span><br><span class="line">-m32。32 位编译。</span><br><span class="line">-fno-stack-protector。关闭 canary。</span><br><span class="line">-z noexecstack。开启 NX。</span><br></pre></td></tr></table></figure>
<h4 id="got-与-got-plt-的区别"><a href="#got-与-got-plt-的区别" class="headerlink" title=".got 与 .got.plt 的区别"></a>.got 与 .got.plt 的区别</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.got (Global Offset Table)。.got 用于动态链接的程序中，它存储了全局数据的地址，如全局变量和静态变量的动态地址。这些地址在程序启动时由动态链接器填充，并在程序执行期间被直接访问。</span><br><span class="line"></span><br><span class="line">.got.plt (Procedure Linkage Table&#x27;s Global Offset Table)。主要用于解决动态链接的函数地址。它是 .plt（Procedure Linkage Table）的一个扩展，.plt 用于管理动态链接的函数调用。</span><br><span class="line"></span><br><span class="line">区别：.got 用于全局变量的地址解析；.got.plt 专门用于动态链接的函数地址解析。</span><br></pre></td></tr></table></figure>
<h4 id="plt-got-与-got-plt-有什么区别"><a href="#plt-got-与-got-plt-有什么区别" class="headerlink" title=".plt.got 与 .got.plt 有什么区别"></a>.plt.got 与 .got.plt 有什么区别</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.got.plt。Global Offset Table 的一个部分，专门用于处理动态链接的函数地址。它与 Procedure Linkage Table (.plt) 直接关联，主要涉及延迟绑定的函数调用。</span><br><span class="line"></span><br><span class="line">.plt.got。通常在使用静态链接的 PIE (Position Independent Executables) 下使用，用于处理全局偏移表的条目。.plt.got 是一个小的 .plt 表，用于实现对全局变量的动态解析，尤其是那些需要通过 GOT 进行访问的全局变量。</span><br></pre></td></tr></table></figure>
<h4 id="寄存器与参数传递"><a href="#寄存器与参数传递" class="headerlink" title="寄存器与参数传递"></a>寄存器与参数传递</h4><p>&emsp;在 Linux 上，前六个参数分别通过 RDI、RSI、RDX、RCX、R8 和 R9 进行传递。在 Windows 中，前四个参数通过 RCX、RDX、R8 和 R9 来传递。</p>
<h4 id="幂等操作与非幂等操作"><a href="#幂等操作与非幂等操作" class="headerlink" title="幂等操作与非幂等操作"></a>幂等操作与非幂等操作</h4><p>&emsp;<strong>幂等授权 (idempotent authorization)</strong>：幂等性是指某个操作可以重复执行多次，但只会产生与执行一次相同的结果。例如，在授权操作中，无论你执行多少次授权操作，结果都是相同的，不会因为多次执行而产生不同的影响。这意味着即使重复执行相同的授权操作，也不会改变系统的状态或引起错误。</p>
<p>&emsp;<strong>非幂等操作 (non-idempotent)</strong>：与幂等操作相对，非幂等操作是指每次执行都会改变系统的状态，并且每次执行的结果都可能不同。例如，账户余额的增减操作属于非幂等操作，因为每次执行都会改变账户的余额，重复执行会产生不同的结果。因此，非幂等操作需要全局排序来确保正确性和一致性。</p>
<h4 id="gossip-协议"><a href="#gossip-协议" class="headerlink" title="gossip 协议"></a>gossip 协议</h4><p>&emsp;Gossip 协议是一种分布式通信协议，用于在网络节点之间传播信息。它模仿了人类传播谣言的方式，节点间随机地与其他节点交换信息，逐渐使整个网络所有节点都获得相同的信息。具体步骤如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1 初始传递：控制器向一小部分见证人发送新事件和收据。</span><br><span class="line">2 信息传播：</span><br><span class="line">   - 接收到信息的见证人会随机选择其他几个见证人，向他们传播新事件和收据。</span><br><span class="line">   - 这些见证人接收信息后，再随机选择其他见证人，继续传播。</span><br><span class="line">3 逐步传播：</span><br><span class="line">   - 随着时间推移，信息逐渐在整个网络中传播，每个见证人都通过与其他见证人交换信息获得新事件和收据。</span><br><span class="line">   - 由于每个见证人都不断向其他见证人传播信息，信息传播速度呈指数级增长。</span><br><span class="line">4 效率：</span><br><span class="line">   - Gossip 协议的通信负载通常为 N·log(N)，其中 N 是见证人的数量。这比轮询协议的 2·N 更高效，特别是在大规模网络中。虽然看起来 Gossip 协议的通信次数更多，但其效率体现在实际传播速度和可靠性上。轮询协议需要逐个节点确认，传播速度线性增长，可能在大规模网络中造成延迟。而 Gossip 协议通过并行传播，可以快速覆盖整个网络，提高了整体传播效率。</span><br></pre></td></tr></table></figure>
<h4 id="ret-与-leave-指令"><a href="#ret-与-leave-指令" class="headerlink" title="ret 与 leave 指令"></a>ret 与 leave 指令</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ret 相当于 pop eip; jmp esip</span><br><span class="line">leave 相当于 mov esp, ebp; pop ebp</span><br></pre></td></tr></table></figure>

  
	</div>

	<div>
  	<center>
	<div class="pagination">

    
    
    <a href="/2023/06/02/camera-experiment/" type="button" class="btn btn-default"><i
                class="fa fa-arrow-circle-o-left"></i> 上一页</a>
    

    <a href="/" type="button" class="btn btn-default"><i class="fa fa-home"></i>Home</a>
    
    <a href="/2023/05/31/frida-study/" type="button" class="btn btn-default ">下一页<i
                class="fa fa-arrow-circle-o-right"></i></a>
    

    
</div>

    </center>
	</div>


	<!-- comment -->
	
<section id="comment">
    <h2 class="title">留言</h2>

    <!-- 
    <div id="disqus_thread" class="ds-thread">
        <script type="text/javascript">
            /**
             * RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
             * LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
             */
                /*
                 var disqus_config = function () {
                 this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable
                 this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
                 };
                 */
            (function() { // DON'T EDIT BELOW THIS LINE
                var d = document, s = d.createElement('script');

                s.src = 'https://https-wd-2711-tech.disqus.com/embed.js';

                s.setAttribute('data-timestamp', +new Date());
                (d.head || d.body).appendChild(s);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="//disqus.com/?ref_noscript">comments powered by
                Disqus.</a></noscript>
    </div> -->
    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
    <div id="vcomments"></div>
    <script>
        new Valine({
            el: '#vcomments',
            appId: 'wLIJ70s3fPvW8WJPgVVAuWVR-gzGzoHsz',
            appKey: 'NVGqxhUkqtFv2CbwmXXWjCdR'
        })
    </script>

    
</section>


	</div> <!-- col-md-9/col-md-12 -->
		
	
	<div id="side_meta">
		<div class="col-md-3" id="post_meta"> 

	<!-- date -->
	
	<div class="meta-widget">
	<i class="fa fa-clock-o"></i>
	2023-06-01 
	</div>
	

	<!-- categories -->
    
	<div class="meta-widget">
	<a data-toggle="collapse" data-target="#categorys"><i class="fa fa-folder"></i></a>	
    <ul id="categorys" class="tag_box list-unstyled collapse in">
          
  <li>
    <li><a href="/categories/杂记/">杂记<span>16</span></a></li>
  </li>

    </ul>
	</div>
	

	<!-- tags -->
		

	<!-- toc -->
	<div class="meta-widget">
	
	</div>
	
    <hr>
	
</div><!-- col-md-3 -->

	</div>

	<!-- copyright -->
	<div>
    <ul class="post-copyright">
      <li class="post-copyright-author">
      <strong>作者:  </strong>wd-z711</a>
      </li>
      <li class="post-copyright-link">
      <strong>文章链接:  </strong>
      <a href="/" target="_blank" title="">https://wd-2711.tech/</a>
      </li>
      <li class="post-copyright-license">
        <strong>版权声明:   </strong>
        本博客所有文章除特别声明外，均采用 <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)">CC BY-NC-ND 4.0</a>
        许可协议。转载请注明出处!
      </li>
    </ul>
  <div>
 	

		


</div><!-- row -->




	</div>
  </div>
  <div class="container-narrow">
  <footer> <p>
  &copy; 2024 wd-z711
  
      <!-- with help from <a href="http://hexo.io/" target="_blank">Hexo</a>,<a target="_blank" rel="noopener" href="http://github.com/wzpan/hexo-theme-freemind/">Freemind</a>,<a href="http://getbootstrap.com/" target="_blank">Twitter Bootstrap</a> and <a href="http://getbootstrap.com/" target="_blank">BOOTSTRA.386</a>. 
     <br> Theme by <a target="_blank" rel="noopener" href="http://github.com/wzpan/hexo-theme-freemind/">Freemind.386</a>.     -->

     <!-- <script type="text/javascript">
      (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
      (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
      e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
      })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');
      
      _st('install','aB-vgeB8gEDrnRJuhceL','2.0.0');
    </script> -->
    </p>
 </footer>
</div> <!-- container-narrow -->
  


  
<a id="gotop" href="#">   
  <span>⬆︎TOP</span>
</a>

<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/bootstrap.min.js"></script>
<script src="/js/main.js"></script>
<script src="/js/search.js"></script> 


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>



   <script type="text/javascript">      
     var search_path = "search.xml";
	 if (search_path.length == 0) {
	 	search_path = "search.xml";
	 }
	 var path = "/" + search_path;
     searchFunc(path, 'local-search-input', 'local-search-result');
   </script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
   </html>
