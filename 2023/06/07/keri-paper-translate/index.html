<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="pragma" content="no-cache">
  <meta http-equiv="cache-control" content="no-cache">
  <meta http-equiv="expires" content="0">
  
  <title>keri-paper-translate | wd-z711&#39;s B10g</title>
  <meta name="author" content="wd-z711">
  
  <meta name="description" content="Drummond Reed-Self-Sovereign Identity-Decentralized digital identity and verifiable credentials-Manning-2021 translate about keri.">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="keri-paper-translate"/>
  <meta property="og:site_name" content="wd-z711&#39;s B10g"/>

  
    <meta property="og:image" content=""/>
  

  
  
    <link href="/favicon.png" rel="icon">
  
  
  <link rel="stylesheet" href="/css/bootstrap.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/font-awesome.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/responsive.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/google-fonts.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

  <script src="/js/jquery-2.0.3.min.js"></script>

  <!-- analytics -->
  
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'G-YHJSKZDC3Y', 'auto');
  ga('send', 'pageview');
</script>




<meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="wd-z711's B10g" type="application/atom+xml">
</head>

 <body>  
  <nav id="main-nav" class="navbar navbar-inverse navbar-fixed-top" role="navigation">
    <div class="container">
      <button type="button" class="navbar-header navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
		<span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
	  <a class="navbar-brand" href="/">wd-z711&#39;s B10g</a>
      <div class="collapse navbar-collapse nav-menu">
		<ul class="nav navbar-nav">
		  
		  <li>
			<a href="/archives" title="All the articles.">
			  <i class="fa fa-archive"></i>Archives
			</a>
		  </li>
		  
		  <li>
			<a href="/categories" title="All the categories.">
			  <i class="fa fa-folder"></i>Categories
			</a>
		  </li>
		  
		  <li>
			<a href="/about" title="About me.">
			  <i class="fa fa-user"></i>About
			</a>
		  </li>
		  
		</ul>
      </div>
    </div> <!-- container -->
</nav>
<div class="clearfix"></div>

  <div class="container">
  	<div class="content">
    	 


	
		<div class="page-header">
			<h1> keri-paper-translate</h1>
		</div>
	



<div class="row post">

	<!-- cols -->
	
	<div id="top_meta"></div>
	<div class="col-md-9">
	

	<!-- content -->
	<div class="mypage">		
	  
		 <div class="alert alert-success description">
			<i class="fa fa-info-circle"></i> Drummond Reed-Self-Sovereign Identity-Decentralized digital identity and verifiable credentials-Manning-2021 translate about keri.
		 </div> <!-- alert -->
	  		

	  <h1 id="KERI文献翻译-1"><a href="#KERI文献翻译-1" class="headerlink" title="KERI文献翻译-1"></a>KERI文献翻译-1</h1><h2 id="Reed-book-section-10"><a href="#Reed-book-section-10" class="headerlink" title="Reed book section 10"></a>Reed book section 10</h2><p>&emsp;第 9 章涵盖了 SSI 数字钱包和代理的整体主题。然而，数字钱包非常核心的功能——密钥管理，需要详细讲一讲。尽管关于密钥管理的主题已经写了数千篇论文和数十本书，但在本章关于分散密钥管理的这一章中，我们请来了Sam Smith博士，他不仅是SSI中最多产的思想家和作者之一，而且是密钥事件接收基础结构（Key Event Receipt Infrastructure，KERI）的发明者，本章的最后一节说明了这一点。Sam于1991年在Brigham Young大学获得电气和计算机工程博士学位；在Florida Atlantic大学工作了10年，达到正式教授身份；然后退休，成为一名全职企业家和战略顾问。他在机器学习、人工智能、自动车辆系统、自动推理、区块链和去中心化系统等领域发表了100多篇被引用的出版物。</p>
<span id="more"></span>
<p>&emsp;第 9 章从数字钱包的总体定义开始：</p>
<p>&emsp;数字钱包由软件（和可选的硬件）组成，该软件使钱包的控制器能够生成、存储、管理和保护加密密钥、秘密和其他敏感私有数据。</p>
<p>&emsp;我们说数字钱包是 SSI 中每个参与者的控制关系（如何理解？）。控制的本质是密钥管理：涉及加密密钥的生成、交换、存储、使用、终止/销毁和旋转/替换的所有内容。它包括加密协议、密钥服务器和安全存储模块的设计。密钥管理还包括人类过程，如组织政策、用户培训、认证和审计。</p>
<p>&emsp;在本章中，我们将涵盖以下内容:</p>
<ul>
<li>为什么任何形式的数字密钥管理都很困难</li>
<li>传统密钥管理的标准和最佳实践</li>
<li>密钥管理体系结构的起点：信任根</li>
<li>去中心化密钥管理的特殊挑战</li>
<li>可验证凭证(VCs)、去中心化标识符(DIDs)和自我主权身份(SSI)的新工具如何构建去中心化密钥管理</li>
<li>基于账本的DID密钥管理</li>
<li>基于peer-DID的密钥管理</li>
<li>具有密钥事件接收基础设施(KERI)的完全自主分散密钥管理</li>
</ul>
<p>&emsp;KERI 的最后一节是本书的一个特殊特征，因为它总结了 KERI 的技术架构，KERI是分散加密密钥管理最全面的解决方案之一。</p>
<h3 id="10-1为什么任何形式的数字密钥管理都很困难"><a href="#10-1为什么任何形式的数字密钥管理都很困难" class="headerlink" title="10.1为什么任何形式的数字密钥管理都很困难"></a>10.1为什么任何形式的数字密钥管理都很困难</h3><p>&emsp;密码学和公共/私钥基础设施的新人经常会想，为什么密钥管理这么麻烦？管理数字密钥不是类似于管理物理密钥吗？在物理密钥管理中，我们通常将密钥放到钥匙环上。</p>
<p>&emsp;虽然物理密钥和数字密钥之间看似相似，但实际上差异是显着的：</p>
<ul>
<li><p>数字密钥可以远程窃取。处理物理密钥需要物理访问存储密钥的位置。没有适当保护的数字密钥可以在网络上远程窃取。即使它们被很好地保护，数字密钥仍然可以使用侧通道攻击窃取。</p>
</li>
<li><p>人们可能无法判断数字密钥是否被盗。被盗的物理密钥很容易发现（除非小偷可以快速复制并替换它）。但是，如果攻击者可以获得数字密钥的访问，他们可以以毫秒复制它，而无需拥有者知道。</p>
</li>
<li>数字锁更难打破。窃取物理密钥的另一种方法是打破锁。对于许多现实世界的资产，如汽车或家，是完全可行的，而打破受强加密保护的数字锁几乎是不可能的。</li>
<li>数字密钥可以解锁的值可能远大于物理世界中的值。大多数受物理密钥保护的资产——汽车、房屋——其价值与为资产提供的物理安全强度成正比。但是使用数字资产，单一密钥可能会以加密货币、数字货币或其他一些数字资产形式解锁数十亿美元的价值。</li>
</ul>
<p>&emsp;NOTE：任何保护高价值数字资产的人都应该使用多签名，因为它很安全。例如，尽管钱包对应的资产很多，但没有报告说Gnosis多签名钱包有漏洞（<a target="_blank" rel="noopener" href="https://gprecision-safe.io）。">https://gprecision-safe.io）。</a></p>
<ul>
<li>如果丢失或被盗，数字密钥是不可替代的。几乎不可能保护具有足够物理安全性的物理资产，即在给定足够的时间和金钱的情况下无法被破坏。但数字资产可以通过非常强大的加密(甚至是量子验证)来保护，理论上，它可以在接下来的时间里(或至少在接下来的几千年)承受住宇宙中所有的计算能力。因此，数字密钥可能比物理密钥更有价值。2019年，华尔街日报估计所有比特币的五分之一丢失了，因为私钥已经不可挽回地丢失[1]。在撰写本文时，丢失的比特币价值远远超过了 100 亿美元。</li>
<li>使用SSI，您的数字密钥将成为数字生活的密钥。物理密钥很重要，它们解锁了你的汽车、房子、邮箱、办公室和安全存款箱。但是如果你失去了物理密钥，只花几天或几周的时间来替换所有这些。如果您在成熟的 SSI 数字钱包中丢失所有数字密钥（并且没有恢复方法），它可能会让你的数字生活暂停几个月。</li>
</ul>
<p>&emsp;底线：控制您的数字密钥——以及您的数字钱包的其余部分——可能是 SSI 架构中最关键的元素。</p>
<h3 id="10-2-传统的关键管理的标准和最佳实践"><a href="#10-2-传统的关键管理的标准和最佳实践" class="headerlink" title="10.2 传统的关键管理的标准和最佳实践"></a>10.2 传统的关键管理的标准和最佳实践</h3><p>&emsp;幸运的是，数字密钥管理并不是什么新鲜事——我们有数十年使用传统PKI，以及使用加密密钥和钱包部署数字密钥管理的经验。此外，由于密钥管理是网络安全基础设施的基础，因此美国等研究机构NIST对该主题提出了广泛的提议。NIST 中已知的几个如下：</p>
<ul>
<li>NIST 特殊出版 800-130：设计密码学密钥管理系统 (CKMS) 的框架，它为密钥管理中的每个主题提供全面的指导 (<a target="_blank" rel="noopener" href="https://nvlpubs.nist.gov/nistpubs/specialPublications/NIST.SP.800-130.pdf">https://nvlpubs.nist.gov/nistpubs/specialPublications/NIST.SP.800-130.pdf</a>)</li>
<li>NIST 特殊出版物 800-57：密钥管理推荐——NIST 不断更新的三部分系列（<a target="_blank" rel="noopener" href="https://csrc.nist.gov/projects/key）：">https://csrc.nist.gov/projects/key）：</a><ul>
<li>第 1 部分 - 通用</li>
<li>第 2 部分 - 密钥管理组织最佳实践</li>
<li>第 3 部分 - 应用特定密钥管理指导</li>
</ul>
</li>
</ul>
<p>&emsp;以下是第 2 部分 (<a target="_blank" rel="noopener" href="https://nvlpubs.nist.gov/nistpubs/specialPublications/NIST.SP.800-57pt2r1.pdf">https://nvlpubs.nist.gov/nistpubs/specialPublications/NIST.SP.800-57pt2r1.pdf</a>) 的一些指南示例：</p>
<p>&emsp;由于加密密钥的泄露会损害所有受该密钥保护的信息和过程，因此重要的是客户端节点能够信任密钥/密钥组件来自可信来源，并且它们的机密性和完整性在存储和传输中都受到保护。</p>
<p>&emsp;通信组的任何成员或该组中的任何对之间的任何链接暴露密钥都会危及使用该密钥的组共享的所有信息。因此，重要的是要避免使用来自未经验证的来源的密钥，以此保护所有密钥和传输中的密钥组件。</p>
<p>&emsp;NIST第 2 部分的第 2.3.9 节包括对集中和分散密钥管理的指导：</p>
<p>&emsp;CKMS 本质上可以集中或分散。对于 PKI，公共密钥不需要保护，因此分散的密钥管理对于大规模和小规模的情况都可以有效地工作。对于对称密钥，特别是对于大规模操作，通常采用集中结构。</p>
<p>&emsp;正如我们所料，已经为密钥管理的不同方面开发了许多标准和协议。例如，例如，NIST第2部分的第2.3.10节包括来自互联网工程任务组的14个密钥管理请求(RFC)的列表。 NIST特别出版物包含对符合美国联邦政府标准的CKMS的设计、应用的要求。</p>
<p>&emsp;另一个例子是自 2010 年以来结构化信息标准组织 (OASIS) 开发的密钥管理互操作性协议 (KMIP)。它已成为集中式密钥管理服务器互操作性的行业标准，集中式密钥管理服务器通常由企业部署，以标准化和自动化跨大量应用程序和服务的密钥管理。</p>
<h3 id="10-3密钥管理体系结构的起点-信任根"><a href="#10-3密钥管理体系结构的起点-信任根" class="headerlink" title="10.3密钥管理体系结构的起点:信任根"></a>10.3密钥管理体系结构的起点:信任根</h3><p>&emsp;无论密钥管理体系结构是集中式、联合式还是分散式，都是从信任根(也称为信任根或信任锚)开始的。信任根是信任链的起点，因为它是信任链中不需要被派生信任的唯一点(意思是通过某种方式进行验证)。信任被假定为信任根，即验证者只是从公理上接受信任根是可以信任的。</p>
<p>&emsp;在X.509标准等传统PKI体系结构中，信任根由称为根证书的特殊数字证书来表示。依赖方(也称为信任方)必须拥有根证书的副本，然后才能对信任链进行验证。这就是为什么大多数计算机和移动操作系统都提供了根证书内置列表的原因，例如Firefox 和 Chrome 等浏览器。<strong>这意味着用户隐含地信任浏览器制造商以及发布根证书的认证机构 (CA)。</strong></p>
<p>&emsp;SSI代表密钥管理的巨大变化的原因是，它从一组关于信任根的不同假设开始，如图10.1所示：</p>
<p><img src="/images/keri-paper-translate/image-20230607113346243.png" alt="image-20230607113346243" style="zoom:67%;" /></p>
<ul>
<li>传统的PKI采用信任管理根：由人类组成的证书颁发机构(CAs)，按照严格程序(认证实施声明)，以确保他们发行的数字证书的质量和完整性。此时信任管理根的信任是基于服务提供商的声誉，如行业认证。</li>
<li>信任的算法根(也称为交易信任根)是基于计算机算法设计的，旨在创建安全的系统，在这种系统中，没有单一的一方控制，但所有各方都可以就共享的真理来源达成一致。区块链、分布式账本和分布式文件系统，如IPFS都是信任算法根的例子。（有关不同 SSI 架构如何使用各种信任算法根的完整描述，请参见第 5 章。）尽管信任的所有算法根都基于密码学，但假设的信任需要的不仅仅是这些——它基于整个系统的声誉，例如，参与者的数量和规模、项目的历史、分类账运行了多长时间、是否存在任何安全问题以及分叉的历史。然而，正如我们在第15章中解释的那样，对于这些方法中的哪一种最值得信赖，存在着大量的分歧。</li>
<li>自我证明的信任根(也称为自主信任根)完全基于安全的随机数生成和加密。在SSI的情况下，这意味着只使用数字钱包就可以生成DID。最安全的自我认证信任根使用特殊硬件，如可信处理模块(TPM)来生成密钥对并存储私钥。对自我认证信任根源的假定信任基于硬件和软件的规格、测试、认证和声誉。</li>
</ul>
<p>&emsp;这些区别如此重要的原因总结在表 10.1 中。</p>
<p><img src="/images/keri-paper-translate/image-20230607113459606.png" alt="image-20230607113459606" style="zoom:67%;" /></p>
<p>&emsp;简而言之，向SSI和分散密钥管理的范式转变是从信任管理根——本质上是集中的，容易受到人为失误的影响，转变为算法和自我认证的信任根，这可以部分或完全自动化，且分散。<strong>算法和自我证明的信任根之间的唯一区别是任何第三方的角色(在本章后面讨论)。</strong></p>
<h3 id="10-4分散密钥管理的特殊挑战"><a href="#10-4分散密钥管理的特殊挑战" class="headerlink" title="10.4分散密钥管理的特殊挑战"></a>10.4分散密钥管理的特殊挑战</h3><p>&emsp;集中式密钥管理已经使用了几十年，去中心化密钥管理是一个较新的主题。直到最近，DID的第一个版本(见第8章)才被发布为2016年12月的社区规范。由于DID既是去中心化的，又是可加密验证的，因此他们需要一个去中心化的解决方案来管理相关的公/私钥。人们对DID的兴趣与日俱增，导致美国国土安全部(DHS)于2017年将分散密钥管理的研究合同授予SSI供应商Evernym[2]。正如如下公告总结的那样：</p>
<p>&emsp;通过一个名为”区块链技术对隐私保护身份管理的适用性”的项目，Evernym正在开发一种DKMS——一种与区块链和其他分布式账本技术一起使用的加密密钥管理方法——以促进在线身份认证和验证。在 DKMS 中，所有参与者的初始信任根是一个分布式账本，支持去中心化标识符——一种新的根身份记录形式。</p>
<p>&emsp;DKMS 代表去中心化密钥管理系统（与 CKMS 相比）。在两年研究项目中，Evernym 召集了一组密码工程师和密钥管理专家，以生成一个名为《DKMS 设计和架构》的文档，该文档作为 Linux 基金会的 Hyperledger Indy 项目的一部分发布。文档中说：</p>
<p>&emsp;DKMS（去中心化密钥管理系统）是一种加密密钥管理的新方法，旨在与区块链和分布式账本技术（DLT）一起使用，其中没有中央授权机构。DKMS颠覆了传统PKI(公钥基础设施)体系结构的核心假设，即公钥证书由集中或联合的证书颁发机构(CA)颁发。</p>
<p>&emsp;如第 1.3 节所述，DKMS 旨在提供以下主要好处：</p>
<ul>
<li>没有单点故障——由于 DKMS 使用算法或自我认证信任根，因此不依赖中央CA或其他注册机构，这些机构的故障可能会危及大量用户。</li>
<li>互操作性——DKMS 支持任意两个身份所有者及其应用程序来执行密钥交换并创建加密的点对点 (P2P) 连接，而不依赖于专有软件、服务提供商。</li>
<li>可移植性——使用 DKMS，用户可以避免被锁定到 DKMS 兼容的钱包、代理的任何特定实现中。在适当的安全保障措施下，用户能够使用 DKMS 协议在兼容的DKMS之间来移动钱包的内容（尽管不一定是实际的加密密钥）。</li>
<li>弹性信任基础设施<strong>（弹性体现在哪儿？）</strong>——DKMS融合了分布式分类帐技术的所有优势，可分散访问可加密验证的数据。然后，DKMS在分布式分类帐之上添加了一个分布式的信任网络，其中任何对等体都可以交换密钥、形成连接以及颁发/接受来自任何其他对等体的可验证凭证。(《DKMS设计与架构》是在KERI发明之前出版的。但是，它与KERI的完全去中心化的密钥管理体系结构兼容。请参阅本章的最后几节。)</li>
<li>密钥恢复——与特定于应用程序的或特定领域的密钥恢复解决方案相比，使用DKMS，可直接构建健壮的密钥恢复，包括代理自动化加密备份、DKMS密钥托管服务和密钥的社交恢复——例如，通过跨受信任的DKMS连接的代理备份。（有关SSI 数字钱包和代理在密钥恢复中的作用，请参见第 9 章。）</li>
</ul>
<p>&emsp;然而，为了提供这些好处，DKMS 需要解决以下挑战：</p>
<ul>
<li>不能有任何“更高权威”可以依靠。如果您知道您最终可以依靠一个集中的权威机构，那么您可以使系统变得如此简单。但在DKMS中，没有“密码重置”选项。如果有一个外部机构，你可以求助于他来更换你的密钥，那么这个机构总是可以拿走你的密钥，或者他们的系统可能会被攻破，从而泄露你的密钥。因此，DKMS系统的设计必须从一开始就为密钥持有者提供故障保护。</li>
<li>DKMS 不能来自一家公司——甚至是一个单一的联盟。它必须完全基于任何开源项目或商业供应商都可以实施的开放标准——很像 W3C 以及已经成为 SSI 基础的分散标识符标准。这消除了当今一些流行的安全聊天产品的专有方法，例如 Apple iMessage 和 Facebook Messenger。</li>
<li>DKMS 不能规定每个人都必须使用的单一加密算法或密码套件。许多问题都可以通过每个人都同意使用相同的密码算法或套件来解决。但对于DKMS来说，有太多的选择，而且这个领域发展太快，无法锁定到单一类型的加密。<strong>DKMS必须能够适应密码算法和协议的不断进步。</strong></li>
<li>DKMS 密钥和钱包数据必须能够跨不同供应商的不同技术实现移植。正如SSI圈子中经常说的那样，“如果它不是可移植的，它就不是自主性的。”此外，必须通过正式的互操作性测试来证明可移植性，而不仅仅是营销口号。</li>
<li>DKMS 假设用户不具备任何专业的知识或技能。启用 DKMS 的数字钱包和代理必须像现代浏览器和电子邮件客户端一样易于使用。最重要的是，它们不需要最终用户了解有关密码学、区块链、SSI 甚至公钥/私钥的概念的任何信息，它只需要正常工作，并且是安全的。</li>
</ul>
<p>&emsp;一些阅读这些需求的开发人员可能会举手表示这是不可能做到的。然而，越来越多的架构师、密码学家和可用性专家不仅致力于这样做，而且打算将解决方案深入到互联网的基础设施中，以便每个人都可以使用它，就像今天的电子邮件和网络一样。</p>
<h3 id="10-5-分散密钥管理的新工具：VC、DID、SSI"><a href="#10-5-分散密钥管理的新工具：VC、DID、SSI" class="headerlink" title="10.5 分散密钥管理的新工具：VC、DID、SSI"></a>10.5 分散密钥管理的新工具：VC、DID、SSI</h3><p>&emsp;SSI依赖于分散的密钥管理，但SSI也为实现分散密钥管理带来了新的工具。在这一部分中，我们列出了来自VC(第7章)、DID(第8章)以及数字钱包和代理(第9章)的具体贡献。</p>
<h4 id="10-5-1将身份验证与公钥验证分开（DID支持了这一点）"><a href="#10-5-1将身份验证与公钥验证分开（DID支持了这一点）" class="headerlink" title="10.5.1将身份验证与公钥验证分开（DID支持了这一点）"></a>10.5.1将身份验证与公钥验证分开（DID支持了这一点）</h4><p>&emsp;除了去中心化信任根之外，DKMS 的主要创新是 DID 将 DID 控制器<strong>（控制器是什么？）</strong>公钥的验证与其他身份属性（例如控制器的合法名称、URL、地址、政府 ID 编号等）的验证分开。对于传统的PKI，公钥与其他身份属性在由证书颁发机构(CA)颁发X.509数字证书时捆绑在一起。如图 10.2 所示（取自第 8 章中 DID 如何工作的深入解释）。</p>
<p><img src="/images/keri-paper-translate/image-20230607113919398.png" alt="image-20230607113919398" style="zoom:67%;" /></p>
<p>&emsp;通过 SSI，DID 是使用算法信任根或自证明信任根从公/私钥对生成的。这意味着 DID 控制器总是可以通过使用自己的私钥对自己的 DID 文档进行数字签名来提供对其 DID 的控制证明，如图 10.3 所示（也取自第 8 章）。</p>
<p><img src="/images/keri-paper-translate/image-20230607113940745.png" alt="image-20230607113940745" style="zoom:67%;" /></p>
<p>&emsp;如果 DID 方法使用<strong>自证明信任根，则密钥生成和轮换操作可以完全在DID控制器的保护下进行，例如在它们的数字钱包或它们控制的一些其他密钥生成和签名系统中。</strong>如果 DID 方法使用算法信任根，则需要第二步：与区块链等外部可验证数据注册中心(VDR)进行交易。然而，在这两种情况下，这些步骤可以由 DID 控制器的代理自动执行，无需人工干预。消除人工干预提供了另外两个主要好处：这些步骤的成本可以下降到几乎零，并且生成和使用 DID 的规模急剧增加。这样的话DID控制器就可以拥有任意数量的DID。</p>
<p>&emsp;NOTE：有关随机数生成和加密算法如何在没有共谋的情况下创建无限数量的公钥/私钥对和DID的更多信息，请参见第8章。这就是使去中心化的本质。</p>
<h4 id="10-5-2-使用-VC-来证明身份"><a href="#10-5-2-使用-VC-来证明身份" class="headerlink" title="10.5.2 使用 VC 来证明身份"></a>10.5.2 使用 VC 来证明身份</h4><p>&emsp;如果 DID 和 DID 文档可以进行密钥验证，那么就可以使用 VC ：传递 DID 控制器在现实世界身份属性的第三方证明。这就是验证者建立现实世界中的信任所需要的。</p>
<p>&emsp;此外，通过将身份验证与公共密钥验证分开，Issuer的数量和多样性应该会增加很多。这为DID控制器和验证器提供了更广泛的选择，并降低了每个人的成本。</p>
<h4 id="10-5-3-自动密钥旋转"><a href="#10-5-3-自动密钥旋转" class="headerlink" title="10.5.3 自动密钥旋转"></a>10.5.3 自动密钥旋转</h4><p>&emsp;DID 帮助解决的另一个核心密钥管理问题——在第 8 章中也深入解释——是自动密钥旋转。由于 DID 是一个不可变的标识符，<strong>所有 DID 方法（除了称为静态的特殊类别）通过将更新发布到相关的 DID 文档来定义 DID 控制器如何更改与 DID 相关的公/私钥对。</strong>如何做到这一点的细节因不同的DID方法而异，但它们都遵循相同的原则：DID控制器可以在不依赖任何外部管理员的情况下完成密钥旋转。</p>
<h4 id="10-5-4具有离线和社交恢复方式的自动加密备份"><a href="#10-5-4具有离线和社交恢复方式的自动加密备份" class="headerlink" title="10.5.4具有离线和社交恢复方式的自动加密备份"></a>10.5.4具有离线和社交恢复方式的自动加密备份</h4><p>&emsp;SSI数字钱包不能要求更高权威机构重置密码或更换密钥，这意味着备份和恢复必须直接内置到基础设施中。可以在数字钱包和代理中实现备份和恢复功能，如第9章所述，或者通过使用设计到特定DID方法中的特殊密钥恢复功能来实现。有关构建在KERI中的复杂的分散式密钥恢复体系结构的更多信息，请参见第10.8节。</p>
<h4 id="10-5-5-数字监管"><a href="#10-5-5-数字监管" class="headerlink" title="10.5.5 数字监管"></a>10.5.5 数字监管</h4><p>&emsp;通过集中的密钥管理系统，由公司或政府运营的密钥服务器可以为具有不同功能级别的广泛用户群提供服务。<strong>通过分散密钥管理，解决方案需要覆盖那些缺乏操作自己的设备和管理自己的密钥的体力、智力或经济能力的个人。</strong>SSI 基础设施的这一关键方面称为数字监管，在第 11 章中有更详细的介绍。</p>
<p>&emsp;具有讽刺意味的是，从高层次上讲，数字监管人看起来非常像集中式密钥管理系统。然而，它们非常不同。监管人通常为每个依赖他们的人托管个人云钱包，称为受抚养人。监管人通常由官方当局颁发监护证书，以授权他们的监管角色；他们又向工作人员或承包商颁发授权证书，以授权他们的行动。最后，监管人通常在一个治理框架下运作，该框架对他们作为信息受托人的角色提出了严格的法律要求。由于任何个人或组织都可以作为数字监管人运行，并且数字监护人使用与SSI其余部分相同的开放标准和基础设施，因此它将控制和管理数字密钥的能力扩展到那些无法独立完成的人。</p>
<h3 id="10-6-基于协议的-DID-方法的密钥管理（算法信任根）"><a href="#10-6-基于协议的-DID-方法的密钥管理（算法信任根）" class="headerlink" title="10.6 基于协议的 DID 方法的密钥管理（算法信任根）"></a>10.6 基于协议的 DID 方法的密钥管理（算法信任根）</h3><p>&emsp;所有 DID 方法都依赖于信任根，如图 10.1 所示——这是证明基于公钥/私钥对的信任链的起点。尽管密钥对通常使用长随机数在安全硬件中生成（有关如何安全做到这一点，请参见 <a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc4086），但大多数">https://tools.ietf.org/html/rfc4086），但大多数</a> DID 方法不仅仅只依赖于此信任根（即，它们不是自我实现的）。他们需要第二步：使用私钥在分布式分类账或区块链中对交易进行数字签名，以记录DID和初始关联的公钥。一旦创建了该记录，分类账就成为DID的算法信任根。</p>
<p>&emsp;这意味着验证者必须向分类帐查询，以验证当前公钥和与DID相关联的DID文档的任何其他内容。换句话说，验证者必须信任</p>
<ul>
<li>共识算法和特定分类帐的操作：即它能够承受51%的攻击或任何其他形式的攻击。</li>
<li>用于访问分类帐记录的resolver的安全性。</li>
<li>resolver(或验证者)用来验证查询结果的正确性。</li>
</ul>
<p>&emsp;鉴于比特币和以太坊等大型、完善的公共区块链的成功，以及众所周知的从这些分类账中验证查找的机制，这些机制被广泛认为是信任的强算法根。此外，对于许多 DID，它们希望是可公开解析和可验证的。因此，毫不奇怪，截至 2021 年年初，在W3C DID规范注册中心中注册的 80 种 DID 方法的 95% 使用基于信任算法根的 DID 方法。</p>
<p>&emsp;<strong>但是基于分类帐的DID方法也有几个缺点：</strong></p>
<ul>
<li>对分类账的依赖——尽管信任的最终根仍然是用于生成 DID 并更新有关分类账的 DID 文件的密钥对，但基于分类账的DID方法要求DID控制器依赖于分布式分类账及其相关的治理机制才能可信。在某种程度上，DID控制器可以指望分类账是不可破坏的，并且总是可用的，这种风险可能很小，但它仍然是非零的。例如，所有分布式账本都会受到51%的攻击、分叉以及其治理或监管状态的变化。</li>
<li>不可移植性（”ledger lock”）。基于分类帐的DID被”锁定”到特定的分类帐，如果分类帐或其治理出现问题，或者如果DID控制器希望使用其他DID方法，则无法移动。</li>
<li>与 GDPR被遗忘的权利的潜在冲突——虽然用于组织使用的DID不是问题，但用于个人使用的DID和公钥在欧盟通用数据保护条例(GDPR)下被视为个人数据，因此受到删除权的约束，通常称为被遗忘权。对于不可变的公共分类账来说，这可能是一个严重的问题。由于这些分类账混合了来自所有用户的交易，因此给定DID的交易可能无法在不破坏所有其他用户的分类账完整性的情况下被删除。</li>
</ul>
<p>&emsp;关于这个问题的深入讨论，请参见Sovrin基金会白皮书《创新满足合规性:数据隐私监管和分布式账本技术》：<a target="_blank" rel="noopener" href="https://sovrin.org/data-保护。">https://sovrin.org/data-保护。</a></p>
<h3 id="10-7-基于peer的-DID-方法（信任的自我认证根）的密钥管理"><a href="#10-7-基于peer的-DID-方法（信任的自我认证根）的密钥管理" class="headerlink" title="10.7 基于peer的 DID 方法（信任的自我认证根）的密钥管理"></a>10.7 基于peer的 DID 方法（信任的自我认证根）的密钥管理</h3><p>&emsp;一旦 DID 和 DKMS 开始流行，不久之后，一些安全架构师就意识到，尽管基于分类账的DID有许多优点，但从技术上讲，并不需要使用分类账来获得DID的好处。<strong>考虑到信任的最终根是公共/私钥对基于的长随机数，并且这种信任根仅存在于 DID 控制器的数字钱包中，这些架构师看到，在许多情况下，可以完全在数字钱包中生成自我认证的DID和DID文档，并直接点对点交换。(自认证标识符[scid]将在下一节中进一步解释。)</strong></p>
<p>&emsp;这导致了由peer did方法规范(<a target="_blank" rel="noopener" href="https://identity.foundation/peer-did-method-spec)定义的did:peer:方法的发展，该规范由Daniel">https://identity.foundation/peer-did-method-spec)定义的did:peer:方法的发展，该规范由Daniel</a> Hardman于2018年首次发布。截至2020年8月，该规范有15位贡献作者，并已转移到分散身份基金会的标识符和发现工作组进行进一步标准化(<a target="_blank" rel="noopener" href="https://identity.Foundation/Working-groups/identifiers-discovery.html)。引自概述：">https://identity.Foundation/Working-groups/identifiers-discovery.html)。引自概述：</a></p>
<p>&emsp;大多数关于去中心化标识符 (DID) 的文档将它们描述为以公共事实来源为根的标识符，例如区块链、数据库、分布式文件系统等。这种公开让任意方将 DID 解析为端点和密钥。对于许多用例来说，这是一个重要的特性。然而，绝大多数人、组织和事物之间的关系都有更简单的需求。当 Alice (Corp|Device) 和 Bob 想要交互时，世界上只有两方需要关心：Alice和Bob。对等did在这些情况下是完美的。</p>
<p>&emsp;在许多方面，<strong>peer DID之于公开的、基于区块链的DID，就像以太坊等状态通道之于链上智能合约，或者比特币闪电网络之于链上加密货币交易。</strong>Peer DID方法规范继续列出了Peer DID的这些好处：</p>
<ul>
<li>Peer DID没有交易成本，这使得它们基本上可以自由地创建、存储和维护。</li>
<li>Peer DID完全作为参与者的功能来扩展和执行，而不是基于任何中央系统的能力。</li>
<li>因为Peer DID没有保存在任何中央系统中，所以没有trove需要保护。</li>
<li>由于只有特定关系的当事人知道它们，因此对第三方数据控制者或处理者造成的个人数据和隐私法规的担忧大大减少。</li>
<li>因为Peer DID不依赖于任何特定的区块链，所以他们的政治或技术包袱最小。</li>
<li>Peer DID可以映射到其他DID生态系统的名称空间中，从而允许peer DID在一个或多个其他区块链中具有可预测的含义。这创建了一个互操作性桥梁，并解决了区块链分叉争夺DID所有权的问题<strong>（如何理解？）</strong>。</li>
<li>因为它们避免了对中心真理来源<strong>（如何理解？）</strong>的依赖，peer DID将自己从通常在线的需求中解放出来，这是大多数其他DID方法的典型，因此非常适合需要分散的面向对等的体系结构的用例。peer DID可以在整个生命周期内创建和维护，而不依赖于互联网，不会降低信任。</li>
</ul>
<p>&emsp;使用peer DID 进行密钥旋转和密钥恢复是每个对等方的问题，就像它们自己的peer DID的控制器所做的那样，更新它们的peer DID文档，并传递给另一个对等体。这是 Peer DID 方法规范的第 4 节中定义的对等 DID 协议的目的。它定义了DID CRUD(创建、读取、更新和停用)操作的标准：</p>
<ul>
<li>相互创建/注册peer DID和DID文档。</li>
<li>阅读/解析peer DID。</li>
<li>更新peer DID 文档以进行密钥轮换、服务端点迁移或其他更改。</li>
<li>停用peer DID以中止peer联系。</li>
</ul>
<p>&emsp;Peer DID不需要算法信任根，因为它们直接基于用于生成初始密钥对的自我证明信任根，而不必依赖网络。由于任何精心设计的 SSI 数字钱包都可以提供此功能，并保护生成的私钥，Peer DID 消除了对任何外部依赖的需要。它们是完全可移植的，可以像互联网本身一样分散和可扩展。这种设计也有利于抵制审查，这是分散技术社区中许多人高度重视的属性。</p>
<p>&emsp;请注意，互联网的 TCP/IP 仍然依赖于联合标识符 (IP 地址) 和路由表，这些表最终具有由 ICANN 管理的集中根。Peer DID 没有中央根。</p>
<p>&emsp;唯一的缺点是peer DID 不会公开发现和可解析。如果有一种 DID 方法仅依赖于自我认证信任根，但提供了两个好处：<strong>可公开发现/可解析的 DID 和对等 DID（KERI要实现的点）</strong>？</p>
<h3 id="10-8具有密钥事件接收基础设施-KERI-的完全自主分散密钥管理"><a href="#10-8具有密钥事件接收基础设施-KERI-的完全自主分散密钥管理" class="headerlink" title="10.8具有密钥事件接收基础设施(KERI)的完全自主分散密钥管理"></a>10.8具有密钥事件接收基础设施(KERI)的完全自主分散密钥管理</h3><p>&emsp;如图10.1所示，从安全的角度来看，信任的理想根，是不需要依赖区块链网络的信任的自认证根。如果实施得当，它既是最分散的，也是最能抵抗攻击的。每个DID控制器的钱包都可以作为他们自己的自我认证信任根，这些钱包可以位于网络上的任何地方，理想情况下是在边缘设备上，在那里它们最难受到远程攻击。</p>
<p>&emsp;peer DID 方法（在上一节中讨论）通过使用一种简单的自我认证标识符 (SCID) 应用这种架构。SCID 源自公共/私钥对，使用加密单向函数的一个或多个应用（参见第 6 章）。SCID现在绑定到该密钥对，只有私钥的持有者可以证明SCID的控制。</p>
<p>&emsp;许多其他区块链使用基于公钥的标识符的相同概念——例如，这就是比特币用户证明对比特币地址的控制的方式。<strong>不同之处在于，SCID不需要区块链或任何其他基础设施来验证与公钥的绑定。任何拥有SCID和公钥的人都可以仅使用密码学来验证绑定。这就是自我证明的意思。</strong></p>
<p>&emsp;下一步是使整个DID方法自我认证，即不仅是初始SCID，而且是之后的所有密钥旋转。这是密钥事件接收基础设施 (KERI) 的灵感。<strong>在KERI中，可以查找到对公钥/私钥对的所有使用或更改的历史，以实现对SCID和相关联的公/私钥对之间的绑定的通用自我认证证明。使用KERI体系结构，SCID不知道它在哪里注册或发现，即它是完全可移植的，并且可以形成同一控制器中其他SCID的命名空间的根。</strong></p>
<p>&emsp;就作者而言，KERI 是标识符和密钥管理系统，它是完全自主的、可移植，并有加密可验证标识符，这些标识符可以是公共的或私有的。<strong>虽然这听起来可能类似于PGP(Pretty Good Privacy)的原始愿景，但PGP的密钥共享基础设施需要由人类通过密钥签名方手动设置和维护。</strong>密钥旋转也是一个手动、费力（容易出错）的过程。使用 KERI，我们终于可以通过使用分布式计算基础设施和区块链启发的密码工程来实现Phil Zimmermann的愿景。<strong>KERI的目标是成为第一个分散的密钥管理体系结构，可以适用于任何底层的数字钱包或密钥管理服务器，并可以在所有这些基础上进行互操作。基于KERI的DID方法继承了所有这些特性。因此，从SSI的角度来看，KERI能够在所有DID和DKMS选项中提供最大程度的自我主权，包括任何植根于共享分类账的选项。</strong></p>
<p>&emsp;在本节中，我们将通过总结其<strong>七个主要优点</strong>来解释 KERI 架构的基础。KERI 是在 140 页的技术白论文中定义的，该论文由分散身份基金会的标识符和发现工作组标准化，对于完整的技术信息，请参阅 <a target="_blank" rel="noopener" href="https://keri.one。">https://keri.one。</a></p>
<h4 id="10-8-1-自认证标识符作为信任根"><a href="#10-8-1-自认证标识符作为信任根" class="headerlink" title="10.8.1 自认证标识符作为信任根"></a>10.8.1 自认证标识符作为信任根</h4><p>&emsp;如前所述，KERI 架构的起点是自认证标识符 (SCID)。<strong>SCID 在第 8 章中介绍（后面看一看）</strong>，因为它们是 DID 的子类，完全依赖于自我认证的信任根，它们不需要算法信任根。基本概念如图 10.4 所示（从第 8 章重复）。</p>
<p><img src="/images/keri-paper-translate/image-20230607115215242.png" alt="image-20230607115215242" style="zoom:67%;" /></p>
<p>&emsp;标识符是自认证的，因为在给定相关公钥的情况下，任何人都可以使用诸如散列函数的单向函数来立即验证该标识符是从公钥/私钥对中生成的。图 10.5 左侧的图表显示了控制器如何指导数字钱包生成大随机数（使用 IETF RFC 4086 中描述的熵安全源；请参阅 <a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc4086）。然后数字钱包生成加密密钥对。最后，数字钱包从密钥对中导出标识符">https://tools.ietf.org/html/rfc4086）。然后数字钱包生成加密密钥对。最后，数字钱包从密钥对中导出标识符</a> (SCID)。结果是一个 SCID，其与公共密钥的结合可以单独使用密码学立即验证——不需要分类账、管理员或任何其他外部真相来源。</p>
<p><img src="/images/keri-paper-translate/image-20230607115234810.png" alt="image-20230607115234810" style="zoom:67%;" /></p>
<p>&emsp;SCID 是 100% 的可移植标识符，因为控制器可以把它们带到任何地方，无需验证者信任任何东西，而只需信任控制器的数字钱包的加密和安全。(对等DID是SCID的子类，共享完全可移植性这一相同的好处。)</p>
<p>&emsp;因为 KERI 中的所有其他功能都依赖于 SCID 的完整性和强度，KERI 技术论文定义了 SCID 的几个特定子类型（基本、自寻址、多签名自寻址、委托自寻址和自签名），以及它们的语法结构、派生代码、初始语句和自认证信任根中的生成算法。</p>
<h4 id="10-8-2-自我认证密钥事件日志"><a href="#10-8-2-自我认证密钥事件日志" class="headerlink" title="10.8.2 自我认证密钥事件日志"></a>10.8.2 自我认证密钥事件日志</h4><p>&emsp;KERI的名字不是来自体系结构核心的SCID，而是来自它如何处理去中心化密钥管理中最困难的问题之一：密钥轮换和恢复。此方法在KERI技术白皮书的第29页中进行了总结：</p>
<p>&emsp;KERI利用这样一个事实，即只有私钥的控制器才能创建和排序事件，这些事件对密钥执行可验证的操作。只要保留了事件历史的完整可验证副本，就可以确定控制权限的来源。</p>
<p>&emsp;使用 KERI，与 SCID 相关的密钥对的每个旋转都会生成新的关键事件。KERI 协议规定了密钥事件消息的确切结构。每个密钥事件消息都包含一个序列号。除了第一个（初始事件）之外，每个密钥事件消息还包括前一个密钥事件消息的hash。然后，控制器用新的私钥标记新的密钥事件消息，生成密钥事件收据。</p>
<p>&emsp;结果是一个称为密钥事件日志的密钥事件记录的有序序列（链），任何人都可以以与验证区块链上交易序列相同的方式来验证此序列——但不需要算法信任根。图 10.6 说明了密钥事件日志中的一系列密钥事件消息：</p>
<p><img src="/images/keri-paper-translate/image-20230607115356766.png" alt="image-20230607115356766" style="zoom:67%;" /></p>
<h4 id="10-8-3-密钥事件日志的见证人"><a href="#10-8-3-密钥事件日志的见证人" class="headerlink" title="10.8.3 密钥事件日志的见证人"></a>10.8.3 密钥事件日志的见证人</h4><p>&emsp;KERI的主要创新之一是，控制器以外的各方也可以对密钥事件消息进行数字签名。这些方被称为见证人，因为它们是在密钥事件消息上“见证”控制器的数字签名，就像他们见证一个人在纸质文件上的实际签名一样(这通常是遗嘱和抵押等高价值文件的法律要求)。</p>
<p>&emsp;如图 10.7 所示，KERI 协议标准化见证人如何从控制器接收关键事件消息。<strong>如果见证人可以验证关键事件消息，则见证人可以添加自己的签名来创建他们自己的密钥事件日志独立副本。</strong></p>
<p><img src="/images/keri-paper-translate/image-20230607115428776.png" alt="image-20230607115428776" style="zoom:67%;" /></p>
<p>&emsp;每个见证人成为控制器主要自我证明信任根的次要信任根。在验证者信任证人充当有关密钥事件消息的独立真实性来源的程度上，每个额外的证人都增加了密钥事件日志的可信性。同样，它的工作原理就像人类见证物理文档的“湿墨水”签名一样。如果您有一个证人的签名，证明他们在何时何地看到签名者签署了文档，这是很好的。如果您有四个证人的签名，说明他们在何时何地看到签名者签署了文档，那就更好了。</p>
<h4 id="10-8-4-预旋转是针对密钥泄露的简单、安全、可扩展的保护"><a href="#10-8-4-预旋转是针对密钥泄露的简单、安全、可扩展的保护" class="headerlink" title="10.8.4 预旋转是针对密钥泄露的简单、安全、可扩展的保护"></a>10.8.4 预旋转是针对密钥泄露的简单、安全、可扩展的保护</h4><p>&emsp;所有密钥管理系统必须回答的挑战不仅仅是如何旋转密钥，而且是在任意情况下，如何防止私钥的泄露，这些情况例如：</p>
<ul>
<li>丢失或窃取的设备</li>
<li>信任根的安全漏洞（数字钱包）</li>
<li>对自证明信任根的侧通道攻击</li>
<li>对控制器进行社会工程学攻击</li>
<li>对控制器进行勒索攻击（ruber-hose 密码分析）</li>
</ul>
<p>&emsp;私钥泄露在分散密钥管理中更加危险，因为没有比密钥控制器更高的权限。因此，失去对私钥的控制等同于交出对依赖于该私钥的所有DID或SCID的控制。</p>
<p>&emsp;因此，KERI 使用一种称为预旋转的技术在体系结构的核心构建了针对泄露的私钥的保护。简而言之，从初始事件开始并继续在每个密钥旋转事件中，控制器不仅发布新的公钥，还发布对下一个公钥的加密承诺(称为预旋转公钥)。该承诺以预旋转公钥的摘要的形式。该摘要包含在建立新当前公钥的密钥事件消息中，如图 10.8 所示。</p>
<p><img src="/images/keri-paper-translate/image-20230607115645297.png" alt="image-20230607115645297" style="zoom:67%;" /></p>
<p>&emsp;预旋转使控制器能够为下一个密钥旋转事件预先建立一个全新的、不同的公/私钥对。这意味着泄露当前私钥的攻击者将不能通过轮换到新的公钥来接管SCID，因为下一个公钥已经被承诺。</p>
<p>&emsp;攻击者接管SCID的唯一方法是窃取预先轮换的私钥。但有几个因素使这一点变得极其困难：</p>
<ul>
<li>攻击者不知道预旋转的公钥是什么，因为所有已经发布的都是它的摘要。</li>
<li>在下一个密钥旋转事件之前，预旋转密钥对不需要任何签名操作中暴露。</li>
<li>预先轮换的密钥对可以在非常高的安全性下安全地离线存储，因为在下一次密钥轮换事件之后，此密钥是不需要的。</li>
<li>每个预旋转的密钥对都可以在进入活动服务之前安全地生成下一个对。</li>
<li>只要摘要函数使用量子安全的密码散列函数，预旋转甚至可以是量子安全的。</li>
</ul>
<p>&emsp;KERI 技术论文的第 9.3.1 节总结了为什么这种预旋转架构如此安全：</p>
<p>&emsp;对于许多攻击来说，成功的可能性是接触持续监控或探测的函数。在时间、地点和方法上限制曝光机会，特别是如果时间和地点只发生一次，这使得攻击非常困难。攻击者要么预测那次曝光的一个时间和地点，要么对所有曝光进行连续的普遍监测。通过在初始事件中宣布第一个预旋转，其攻击的窗口很窄。</p>
<p>&emsp;<strong>但是，如果攻击者得到了现有的私钥，难道他们不能立即发布自己的冲突密钥事件消息，声明攻击者控制私钥的新的预旋转密钥对吗？如果控制器已有控制器先前的密钥轮换事件消息的一个或多个见证，则不会。这些证人将识别重复的序列号，并拒绝攻击者稍后的密钥轮换事件消息(理想情况下，还会通知控制器潜在的私钥泄露)。（改进版KERI没有这个问题）</strong></p>
<p>&emsp;<strong>如果控制器是恶意的呢？控制器不能发布两个冲突的密钥轮换事件消息，每个消息具有相同的序列号和时间戳，但具有两个不同的预循环密钥对摘要吗？同样，证人(或验证者)可以看到这些不可靠的事件，并将SCID标记为不再值得信任（改进版KERI没有这个问题）。</strong></p>
<p>&emsp;<strong>在将预旋转与分层派生密钥进行对比之后，可以更好地理解预旋转的威力。许多加密货币钱包都是从生成随机种子开始的。然后，此种子用于派生由钱包控制的所有公钥/私钥对，并且种子的值随着从中派生更多密钥而增长。种子必须安全地存储，因为种子的泄露也会导致每个派生密钥对的危害。KERI通过预旋转颠倒了这一过程。预循环创建下一个密钥对，而不是存储根种子并需要永远保护它，只有在使用它的时候才必须安全地存储它。（改进版KERI有这个问题）</strong></p>
<p>&emsp;预旋转是一种强大的密钥管理安全技术。有关更深入的解释，请参阅 KIRI 技术论文的第 9 节。</p>
<h4 id="10-8-5-与系统无关的验证（环境可验证性）"><a href="#10-8-5-与系统无关的验证（环境可验证性）" class="headerlink" title="10.8.5 与系统无关的验证（环境可验证性）"></a>10.8.5 与系统无关的验证（环境可验证性）</h4><p>&emsp;依赖于算法信任根的DID方法，如分布式账本，生成只能通过引用该信任根进行验证的DID。KERI 技术论文将此依赖项称为分类帐锁。这种DID<strong>不能移植</strong>到另一个验证源，即不同的分布式账本、分布式文件系统、集中式注册表、点对点协议或任何其他潜在的真实性来源。</p>
<p>&emsp;相比之下，KERI 完全依赖于一个自我认证的信任根——控制器的数字钱包。因此，KERI SCID 和密钥事件日志是自我验证的。所需要的只是来自任何潜在源的完整密钥事件日志的副本，副本来自控制器或者验证者可以访问的任何见证。如 KERI 技术论文的第 12 页所述：</p>
<p>&emsp;[密钥事件日志] 是端到端可验证的。这意味着收到副本的任何终端用户都可以验证日志。不需要信任中间基础设施来验证日志，从而建立当前的控制权限。</p>
<p>&emsp;这导致了一个非常健壮、灵活、分散的基础设施，其中每个控制器都可以选择见证人，以便在任何特定情况下提供验证者所需的保证级别。<strong>它不仅将基于KERI SCID和密钥事件日志的DID方法从分类账锁定中解放出来，还使Issuer和Verifier不必就区块链或分布式分类账等可验证数据注册中心(VDR)的治理达成一致。</strong>KERI技术报告在第81页总结了这种“控制分离”：</p>
<p>&emsp;…<strong>控制器和验证器之间控制中心分离的设计原则消除了全有序分布式一致性算法的主要缺陷之一，即共享对提供一致性算法的节点池的治理。消除强制共享治理的限制，允许各方、控制器和验证方根据其需求选择特定的安全、可用性和性能级别（意思就是不同方可以选择不同的证人等）。</strong></p>
<p>&emsp;<strong>从第2章中介绍的基于IP的信任(TOIP)四层架构的角度来看，这意味着第1层公用事业的治理和技术都可以更简单、更快、更便宜、更通用。（这个没看懂）</strong></p>
<p>&emsp;KERI技术文章对KERI环境可验证性基础设施的协议、配置和操作进行了深入探讨。参见关于协议操作模式的第10节，关于控制建立的KERI协议算法的第11节，以及关于事件语义和语法的第12节。</p>
<h4 id="10-8-6-用于企业级密钥管理的委托自我认证标识符（简略看）"><a href="#10-8-6-用于企业级密钥管理的委托自我认证标识符（简略看）" class="headerlink" title="10.8.6 用于企业级密钥管理的委托自我认证标识符（简略看）"></a>10.8.6 用于企业级密钥管理的委托自我认证标识符（简略看）</h4><p>&emsp;对于个人使用，个人应该能够在他们的数字钱包中生成和管理所需的任意数量的SCID。但当我们逐渐转向企业使用时，密钥管理的规模和复杂性急剧增加。正如本书中所讨论的，企业需要能够轻松而安全地将DID、VC和随之而来的密钥管理的使用委托给董事、高级管理人员、员工、承包商和代表组织采取行动的任何其他人。</p>
<p>&emsp;这种委托密钥管理使组织能够从自己的自我认证根中分叉成树，为委托建立子根，每个子根都有自己的自我认证信任根。引用 KERI 技术论文的第 48 页：</p>
<p>&emsp;一个常见的用例是将签名权限委托给一个新的标识符。可以通过与用于根标识符的密钥不同的一系列可撤销签名密钥来行使签名权限。这实现了签名操作的水平可伸缩性。委派操作还可以授权委派的标识符来进行其自己的委派。这实现了可为分散式密钥管理基础设施(DKMI)提供通用体系结构的委托标识符架构。</p>
<p>&emsp;在KERI协议中，可以使用密钥交互事件来执行委派，该事件之所以得名，是因为它不涉及主SCID的开始或轮换，而是用于执行不影响主SCID的控制权限的操作。在这种情况下，密钥交互事件用于授权开始或轮换委托的SCID。图10.9描述了包含新委托的SCID的委托印章的密钥交互事件消息。<strong>（密钥交互事件的作用是为了进行委派）</strong></p>
<p><img src="/images/keri-paper-translate/image-20230607120159631.png" alt="image-20230607120159631" style="zoom:67%;" /></p>
<p>&emsp;除了委托之外，密钥交互事件（及其日志）还可以用于跟踪和验证具有密钥对的其他操作，例如为电子文档生成数字签名。图 10.10 显示了从一个委托控制器（委托器 C）到另一个委托控制器（Delegate D）的一系列密钥交互事件。</p>
<p><img src="/images/keri-paper-translate/image-20230607120242447.png" alt="image-20230607120242447" style="zoom:67%;" /></p>
<p>&emsp;委托SCID可以使用任何委托的自我认证信任根提供适当的安全水平。有些可能需要委托给硬件安全模块(HSM)或可信平台模块(TPM)，其他模块可以在本地或云上托管，还有一些在使用安全飞地的边缘设备。</p>
<p>&emsp;委托 SCID 也可以有证人——证人在整个企业之间共享，或针对特殊类型的密钥或功能的专用证人。KERI 技术论文的第 9.5 节涵盖了不同的委托模式和部署架构，可以为大型跨国企业提供服务。</p>
<h4 id="10-8-7-与-GDPR“被遗忘的权利”的兼容性"><a href="#10-8-7-与-GDPR“被遗忘的权利”的兼容性" class="headerlink" title="10.8.7 与 GDPR“被遗忘的权利”的兼容性"></a>10.8.7 与 GDPR“被遗忘的权利”的兼容性</h4><p>&emsp;KIRI 还为 SSI 中长期存在的两极分化提供了一种解决方案：数据永远存在的一成不变的公共区块链和个人被遗忘的权利——根据欧盟GDPR和其他数据保护法规授予个人从任何法律上不再需要存储个人数据的系统中删除其个人数据的权利。</p>
<p>&emsp;由于识别个人身份的DID及其关联的公钥都被视为GDPR下的个人数据，即使DID是假名的。因此将该DID及其DID文档写入不可更改的公共分类账，在该公共分类账中不能删除，似乎会造成不可调和的冲突。Sovrin治理框架工作组在2019年的大部分时间里都在与Sovrin管家(运行Sovrin公共许可区块链节点的组织)、法律顾问和GDPR专家合作，试图解决这个问题。结果是一篇35页的论文，提出了个人维护自我主权身份的权利为什么不应该与同一个人使用公共区块链来确保自我主权身份的权利相冲突(《创新与合规：数据保护法规和分布式分类帐技术》；Sovrin基金会，2019年，<a target="_blank" rel="noopener" href="https://sovrin.org/data-protection)。">https://sovrin.org/data-protection)。</a></p>
<p>&emsp;然而，由于欧盟委员会和其他数据保护监管机构尚未直接就此事做出裁决，这仍然是一个监管不确定性领域（以及 SSI 采用的潜在障碍）。因此，非常欢迎明确的替代方案。</p>
<p>&emsp;KERI 提供了该替代方案。正如我们在前几节中强调的那样，KERI SCID 的主要信任根不是区块链或分布式分类账。相反，这是一个自我证明信任根——仅数字钱包。<strong>如果像区块链这样的算法信任根被用作KERI见证，它只用作可选的次要信任根。（KERI可以用区块链当见证）</strong></p>
<p>&emsp;如果密钥事件日志是针对没有 GDPR 问题的公共组织（GDPR 仅适用于个人的个人数据），那么这种次要信任根就很好。然而，如果控制器是个人，因此SCID和密钥事件日志被认为是个人数据——那么一个明显的解决方案是，不要使用不变的公共分类帐作为见证。</p>
<p>&emsp;<strong>取而代之的是为证人使用无数其他选项中的任何一种：分布式数据库、复制的目录系统、具有自动故障转移功能的云存储服务。这些系统允许删除存储的数据。由于KERI允许删除一个SCID的密钥事件日志，而不影响任何其他SCID，因此证人很容易遵守被遗忘的权利。并且该过程可以完全自动化，因为控制器可以发出单个KERI协议命令，指示所有证人执行删除。简而言之，KERI可以消除GDPR和SSI之间的紧张关系，使两者都能实现预期目标。</strong></p>
<h4 id="10-8-8-KERI标准化和KERI-DID方法"><a href="#10-8-8-KERI标准化和KERI-DID方法" class="headerlink" title="10.8.8 KERI标准化和KERI DID方法"></a>10.8.8 KERI标准化和KERI DID方法</h4><p>&emsp;<strong>KERI 比 DID 更广泛。KERI 可以与任何类型的 SCID 一起使用。</strong>KERI协议规定了支持KERI的去中心化密钥管理体系结构所需的所有密钥事件消息类型。这就是为什么分散身份基金会(DIF，<a target="_blank" rel="noopener" href="https://identity.foundation/working-groups)的一个工作组正在进行KERI标准化的原因。">https://identity.foundation/working-groups)的一个工作组正在进行KERI标准化的原因。</a></p>
<p>&emsp;然而，KERI 从根本上与 DID 架构兼容，因此也可以实现为自己的 DID 方法或作为其他DID方法的选项来实现。定义 KERI DID 方法是 DIF IDWG 的动作项之一。当前计划是使用以下 DID 方法名称：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">did:keri:</span><br></pre></td></tr></table></figure>
<p>&emsp;KERI 支持包含在基于 Hyperledger Indy 的公共许可链的 DID 方法中。在这种情况下，基于 KERI 的 SCID 将是一个子名称空间，可以使用以下语法在任何 Indy 链上支持：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">did:indy:[network]:[method-specific-id] </span><br><span class="line">did:indy:[network]:keri:[scid]</span><br></pre></td></tr></table></figure>
<p>&emsp;其中 [network] 基于Indy的特定Hyperledger分类帐的标识符，[method-specific-id] 是非 KERI DID 的标识符，[scid] 是基于 KERI 的自我认证标识符。</p>
<p>&emsp;这种前向兼容方法允许任何Indy网络合并KERI SCID，返回包含KERI密钥事件收据的DID文档。其他DID方法还可以通过采用相同的方法来包括与KERI 的向前兼容性，即只为KERI SCID预留一个子名称空间。<strong>（没理解）</strong></p>
<h4 id="10-8-9互联网的信任跨越层"><a href="#10-8-9互联网的信任跨越层" class="headerlink" title="10.8.9互联网的信任跨越层"></a>10.8.9互联网的信任跨越层</h4><p>&emsp;以下引述自KERI技术论文，总结了其信任体系结构：</p>
<p>&emsp;<strong>因为在发布时，自证明标识符在该标识符和密钥对之间建立了密码强绑定，所以除了创建密钥对并由此持有私钥的控制器之外，可能没有其他可验证的真值来源。</strong></p>
<p>&emsp;这就是为什么 KERI 对分散密钥管理有重大贡献的原因：它使每个控制器使用的每个数字钱包都能够作为自己的信任根。由于 KERI 不对任何设备、系统、数据库、网络或合同施加任何特殊要求，因此所有这些都可能是信任的次要根。</p>
<p>&emsp;KERI提供可移植性、可互操作性、可验证的SCID和密钥事件日志的能力意味着，<strong>KERI协议可以像网际协议(IP)创建用于互联网的数据跨越层一样，为互联网启用信任跨越层。（如何理解？）</strong>这是一个深刻的概念。它在 KERI 技术论文的第 5 节。然而，这个想法的本质可以在几个图中传达。图10.11显示了互联网协议套件中各种协议之间的依赖关系如何形成沙漏形状。图10.12简化了图10.11，使沙漏形状更加明显。</p>
<p><img src="/images/keri-paper-translate/image-20230607121001014.png" alt="image-20230607121001014" style="zoom:67%;" /></p>
<p><img src="/images/keri-paper-translate/image-20230607121010945.png" alt="image-20230607121010945" style="zoom:67%;" /></p>
<p>&emsp;协议栈设计的“沙漏定理”在 Micah Beck 于 2019 年 ACM 论文中非常明确。他以这种方式总结了定理：</p>
<p>&emsp;沙漏模型建议的形状表达了跨越层应该支持各种应用程序并使用许多可能的支持层来实现的目标。将沙漏作为一种设计工具也表达了一种直觉，即限制跨越层的功能有助于实现这些目标。模型的元素在视觉上以沙漏形状的形式组合在一起，沙漏的“细腰”代表受限的跨越层，其上其下分别代表应用和支持层的多样性。</p>
<p>&emsp;图 10.13 说明了应该如何设计跨越层尽可能薄、弱或受限制，并且仍然支持上面的应用程序。</p>
<p><img src="/images/keri-paper-translate/image-20230607121052623.png" alt="image-20230607121052623" style="zoom:67%;" /></p>
<p>&emsp;beck的论文继续定义一个正式的模型来解释为什么沙漏定理有效。该论文还提供了几个示例，其中沙漏定理已应用于多播、互联网地址转换和 Unix 操作系统。</p>
<p>&emsp;KERI 技术论文的第 5 节建立在此基础上，提出将沙漏定理应用到不同类型的跨度层——信任跨度层。我们无法直接修复 IP 中缺失的安全，因为IP使用了好多年。但是，我们现在可以通过添加第二个更高级别的跨度层来修复它。论文中写道：</p>
<p>&emsp;因为[信任跨越层]必须使用IP层之上的协议，所以它不能在IP层跨越互联网，但必须跨越IP层之上的某个地方。这就产生了“双腰”或“腰和脖子”形状，其中[信任跨越层]是脖子。</p>
<p>&emsp;图 10.14 是这种双沙漏形状的图表，显示了 IP 跨越层和信任跨越层。</p>
<p><img src="/images/keri-paper-translate/image-20230607121144195.png" alt="image-20230607121144195" style="zoom:67%;" /></p>
<p>&emsp;这一前景非常令人兴奋——一个可互操作的跨层信任层，可以在互联网上的任何地方工作，允许任何两个对等点连接并建立相互的、可加密验证的信任。它与TOIP堆栈的目标完全一致，如图10.15所示，其中第1层和第2层的重点是KERI可以在第2层的数字钱包中实现，而公用事业公司则可以在第1层作为KERI的见证人。<strong>（使用了我们的方案则不需要见证人）</strong></p>
<p><img src="/images/keri-paper-translate/image-20230607121203998.png" alt="image-20230607121203998" style="zoom:67%;" /></p>
<p>&emsp;最重要的是，KERI 为我们提供了一种一致的方法来实现分散密钥管理，可以跨我们日常使用的所有设备、系统、网络和应用程序进行集成。为了确保KERI基础设施的开发、测试、部署和集成将花费时间——就像互联网的采用时间一样。但是如果 KERI 可以为互联网提供信任跨越层，那么它的被采用将成为不可避免的，就像40年前互联网被采用一样。</p>
<h4 id="10-9-关键要点"><a href="#10-9-关键要点" class="headerlink" title="10.9 关键要点"></a>10.9 关键要点</h4><p>&emsp;本章深入涵盖了 SSI 中最深的主题：分散密钥管理。关键要点如下：</p>
<ul>
<li>所有形式的加密密钥管理都很困难，因为数字密钥只是必须非常小心地保护的位串。如果它们丢失、被盗或损坏，它们实际上是不可替代的。</li>
<li>传统密钥管理的标准和协议已经很好地建立起来，包括NIST的主要出版物和OASIS的密钥管理互操作性协议(KMIP)。</li>
<li>向去中心化密钥管理的范式转变是从信任的管理（administrator）根迁移到算法或自我认证的信任根。后两者都消除了对人类的信任或对新密钥或轮换密钥的组织断言的依赖。</li>
<li>这种新的权力带来了新的责任——现在直接落在自我主权个人肩上的密钥键管理责任，因为有了SSI，就没有更高的权力可以求助。</li>
<li>这需要一个分散式密钥管理系统(DKMS)，该系统最初由Evernym根据美国国土安全部的合同于2018-19年设计，是一个供应商中立的开放标准，使数字钱包能够跨供应商、设备、系统和网络进行移植</li>
<li>DID、VC 和 SSI 带来了新的工具来帮助实现去中心化密钥管理，包括将密钥验证与身份验证分离，使用 VC 证明身份、自动化密钥旋转、自动备份和恢复方法和数字保护。</li>
<li>DID方法绝大多数(95%)目前使用区块链或分布式账本作为信任的算法根，<strong>但这些DID是账本锁定的(不可移植的)，可能与GDPR冲突，以便被遗忘</strong>。</li>
<li>peer DID不使用分类账——它们使用一种简单形式的自我证明标识符(SCID)，完全依赖于自我证明的信任根(数字钱包)，并直接在对等网络中共享，每个对等设备都可以验证它们。它们还具有高度可伸缩性和隐私保护功能。唯一的缺点是它们不能被公开发现。</li>
<li>KERI (Key Event Receipt Infrastructure) 使用一种通用的 SCID 方法，为任何应用程序提供完整的分散密钥管理基础设施——该解决方案比 DID 更通用。本章的 KERI 部分涵盖了 KERI 的所有七个主要特征和好处。</li>
<li>KERI提供可移植性、可互操作和可验证的SCID和密钥事件日志的能力意味着，KERI协议可以像网际协议(IP)创建用于互联网的数据跨越层一样，为互联网启用信任跨越层。这非常适合TOIP堆栈的第1层和第2层。</li>
</ul>

  
	</div>

	<div>
  	<center>
	<div class="pagination">

    
    
    <a href="/2023/06/07/keri-translate-2/" type="button" class="btn btn-default"><i
                class="fa fa-arrow-circle-o-left"></i> 上一页</a>
    

    <a href="/" type="button" class="btn btn-default"><i class="fa fa-home"></i>Home</a>
    
    <a href="/2023/06/04/PIR-Blockchain/" type="button" class="btn btn-default ">下一页<i
                class="fa fa-arrow-circle-o-right"></i></a>
    

    
</div>

    </center>
	</div>


	<!-- comment -->
	
<section id="comment">
    <h2 class="title">留言</h2>

    <!-- 
    <div id="disqus_thread" class="ds-thread">
        <script type="text/javascript">
            /**
             * RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
             * LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
             */
                /*
                 var disqus_config = function () {
                 this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable
                 this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
                 };
                 */
            (function() { // DON'T EDIT BELOW THIS LINE
                var d = document, s = d.createElement('script');

                s.src = 'https://https-wd-2711-tech.disqus.com/embed.js';

                s.setAttribute('data-timestamp', +new Date());
                (d.head || d.body).appendChild(s);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="//disqus.com/?ref_noscript">comments powered by
                Disqus.</a></noscript>
    </div> -->
    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
    <div id="vcomments"></div>
    <script>
        new Valine({
            el: '#vcomments',
            appId: 'wLIJ70s3fPvW8WJPgVVAuWVR-gzGzoHsz',
            appKey: 'NVGqxhUkqtFv2CbwmXXWjCdR'
        })
    </script>

    
</section>


	</div> <!-- col-md-9/col-md-12 -->
		
	
	<div id="side_meta">
		<div class="col-md-3" id="post_meta"> 

	<!-- date -->
	
	<div class="meta-widget">
	<i class="fa fa-clock-o"></i>
	2023-06-07 
	</div>
	

	<!-- categories -->
    
	<div class="meta-widget">
	<a data-toggle="collapse" data-target="#categorys"><i class="fa fa-folder"></i></a>	
    <ul id="categorys" class="tag_box list-unstyled collapse in">
          
  <li>
    <li><a href="/categories/blockchain/">blockchain<span>6</span></a></li>
  </li>

    </ul>
	</div>
	

	<!-- tags -->
		

	<!-- toc -->
	<div class="meta-widget">
	
	</div>
	
    <hr>
	
</div><!-- col-md-3 -->

	</div>

	<!-- copyright -->
	<div>
    <ul class="post-copyright">
      <li class="post-copyright-author">
      <strong>作者:  </strong>wd-z711</a>
      </li>
      <li class="post-copyright-link">
      <strong>文章链接:  </strong>
      <a href="/" target="_blank" title="">https://wd-2711.tech/</a>
      </li>
      <li class="post-copyright-license">
        <strong>版权声明:   </strong>
        本博客所有文章除特别声明外，均采用 <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)">CC BY-NC-ND 4.0</a>
        许可协议。转载请注明出处!
      </li>
    </ul>
  <div>
 	

		


</div><!-- row -->




	</div>
  </div>
  <div class="container-narrow">
  <footer> <p>
  &copy; 2023 wd-z711
  
      <!-- with help from <a href="http://hexo.io/" target="_blank">Hexo</a>,<a target="_blank" rel="noopener" href="http://github.com/wzpan/hexo-theme-freemind/">Freemind</a>,<a href="http://getbootstrap.com/" target="_blank">Twitter Bootstrap</a> and <a href="http://getbootstrap.com/" target="_blank">BOOTSTRA.386</a>. 
     <br> Theme by <a target="_blank" rel="noopener" href="http://github.com/wzpan/hexo-theme-freemind/">Freemind.386</a>.     -->

     <!-- <script type="text/javascript">
      (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
      (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
      e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
      })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');
      
      _st('install','aB-vgeB8gEDrnRJuhceL','2.0.0');
    </script> -->
    </p>
 </footer>
</div> <!-- container-narrow -->
  


  
<a id="gotop" href="#">   
  <span>⬆︎TOP</span>
</a>

<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/bootstrap.min.js"></script>
<script src="/js/main.js"></script>
<script src="/js/search.js"></script> 


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>



   <script type="text/javascript">      
     var search_path = "search.xml";
	 if (search_path.length == 0) {
	 	search_path = "search.xml";
	 }
	 var path = "/" + search_path;
     searchFunc(path, 'local-search-input', 'local-search-result');
   </script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
   </html>
