<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="pragma" content="no-cache">
  <meta http-equiv="cache-control" content="no-cache">
  <meta http-equiv="expires" content="0">
  
  <title>frida-reverse-analysis-3 | wd-z711&#39;s B10g</title>
  <meta name="author" content="wd-z711">
  
  <meta name="description" content="Common student in China. Interested in web &amp; re.">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="frida-reverse-analysis-3"/>
  <meta property="og:site_name" content="wd-z711&#39;s B10g"/>

  
    <meta property="og:image" content=""/>
  

  
  
    <link href="/favicon.png" rel="icon">
  
  
  <link rel="stylesheet" href="/css/bootstrap.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/font-awesome.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/responsive.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/google-fonts.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

  <script src="/js/jquery-2.0.3.min.js"></script>

  <!-- analytics -->
  
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'G-YHJSKZDC3Y', 'auto');
  ga('send', 'pageview');
</script>




<meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="wd-z711's B10g" type="application/atom+xml">
</head>

 <body>  
  <nav id="main-nav" class="navbar navbar-inverse navbar-fixed-top" role="navigation">
    <div class="container">
      <button type="button" class="navbar-header navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
		<span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
	  <a class="navbar-brand" href="/">wd-z711&#39;s B10g</a>
      <div class="collapse navbar-collapse nav-menu">
		<ul class="nav navbar-nav">
		  
		  <li>
			<a href="/archives" title="All the articles.">
			  <i class="fa fa-archive"></i>Archives
			</a>
		  </li>
		  
		  <li>
			<a href="/categories" title="All the categories.">
			  <i class="fa fa-folder"></i>Categories
			</a>
		  </li>
		  
		  <li>
			<a href="/about" title="About me.">
			  <i class="fa fa-user"></i>About
			</a>
		  </li>
		  
		</ul>
      </div>
    </div> <!-- container -->
</nav>
<div class="clearfix"></div>

  <div class="container">
  	<div class="content">
    	 


	
		<div class="page-header">
			<h1> frida-reverse-analysis-3</h1>
		</div>
	



<div class="row post">

	<!-- cols -->
	
	<div id="top_meta"></div>
	<div class="col-md-9">
	

	<!-- content -->
	<div class="mypage">		
	  		

	  <h1 id="Frida逆向与协议分析-3"><a href="#Frida逆向与协议分析-3" class="headerlink" title="Frida逆向与协议分析-3"></a>Frida逆向与协议分析-3</h1><p>&emsp;frida逆向与协议分析第三部分，主要就是Android源码编译、沙箱等。</p>
<span id="more"></span>
<h2 id="0x05-Android源码编译与Xposed魔改"><a href="#0x05-Android源码编译与Xposed魔改" class="headerlink" title="0x05 Android源码编译与Xposed魔改"></a>0x05 Android源码编译与Xposed魔改</h2><p>&emsp;市面上绝大多数app都会对xposed框架进行特征检测，绕过的思路就是找到检测点（java层或者native层），然后hook修改返回结果，或者以硬编码、置零等方式来绕过检测逻辑。但是检测点很难找到（代码太多，或者以ollvm、vmp加固）。</p>
<p>&emsp;一个绝杀点就是：在源头消灭xposed特征，让你检测不到。本章就介绍如何魔改编译魔改xposed，从而绕过开源xposed检测工具Xposed Checker。</p>
<h3 id="Android源码环境搭建"><a href="#Android源码环境搭建" class="headerlink" title="Android源码环境搭建"></a>Android源码环境搭建</h3><p>&emsp;为什么要编译Android源码？Xposed源码不就得了。这是因为Xposed的编译过程很依赖android的源码，因此，我们先对android源码进行编译。（需要12G运存+450G硬盘，电脑办不了，只能组装了）</p>
<hr>
<p>&emsp;由于安卓源码引用了外部开源工具，例如OpenSSL，每一个子项目都是Git仓库，为了方便的管理这个Git仓库，安卓官方推出了相关的管理工具，名为repo。Repo封装了一系列的Git指令，可以方便的对多个Git仓库进行管理。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir aosp712_r8 &amp;&amp; cd aosp712_r8</span><br><span class="line">repo init -u git://mirrors.ustc.edu.cn/aosp/platform/manifest -b android-7.1.2_r8</span><br><span class="line">repo sync</span><br></pre></td></tr></table></figure>
<p>&emsp;<code>repo sync</code>只是下载了系统运行必须的代码，只能编译出运行Android Emulator（模拟器）的虚拟机系统，要是想让此系统安装到设备中，还需要下载设备对应的驱动（作用是在物理机系统上起到协调上层系统与底层硬件的通信）。</p>
<p>&emsp;编译完成后，编译出来的镜像是不全的，还需要下载BootLoader等关键的系统镜像，之后即可刷上自编译系统。</p>
<h3 id="Xposed定制"><a href="#Xposed定制" class="headerlink" title="Xposed定制"></a>Xposed定制</h3><div class="table-container">
<table>
<thead>
<tr>
<th>模块</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>XposedInstaller</td>
<td>用于下载和安装Xposed.zip刷机包。</td>
</tr>
<tr>
<td>XposedBridge</td>
<td>java层的API提供者，调用Xposed相关的API时，首先调用XposedBridge中的函数，之后转发到Native方法。</td>
</tr>
<tr>
<td>Xposed</td>
<td>位于Native层的Xposed实际实现，是对Zygote的二次开发。</td>
</tr>
<tr>
<td>android_art</td>
<td>对art的二次开发，以提供对Xposed的支持。</td>
</tr>
<tr>
<td>XposedTools</td>
<td>负责编译和打包刷机的ZIP包。</td>
</tr>
</tbody>
</table>
</div>
<p>&emsp;就是，将XposedInstaller安装到设备之后，XposedInstaller会下载由XposedTools打包的含有XposedBridge，Xposed，android_art的ZIP包，并将此ZIP包刷入到系统（放置与替换系统文件）。</p>
<p>&emsp;Xposed包的编译过程见书P137。</p>
<p>&emsp;之后，使用XposedChecker检测Xposed模块。其中有很多不同的检测项，例如：</p>
<p>（1）<code>载入Xposed工具类</code>检测项，是通过使用系统类加载器加载XposedHelper类，如果可以加载那么说明此系统中是有Xposed模块的。</p>
<p>（2）<code>寻找特征动态链接库</code>检测项，是通过查看<code>/proc/self/maps</code>文件，其中如果有XposedBridge字符串，那么说明此系统中有Xposed模块。</p>
<p>（3）<code>检测Xposed安装情况</code>检测项，是查看系统中已安装的App列表是否包含Xposed相关的App。</p>
<p>（4）<code>环境变量特征字判断</code>检测项，通过获得环境变量，查看环境变量中是否有XposedBridge。</p>
<p>&emsp;可以发现，大多数Xposed的特征都是字符串特征，所以可将Xposed检测字符串的点修改为其它字符串。步骤如下：</p>
<p>&emsp;(1) 修改XposedInstaller App的Xposed字符串特征，即修改整体包名以及prop配置文件相关字符串。根据书P144，可以修改所有<code>xposed</code>字符串变为<code>xppsed</code>，之后，修改配置文件与字符串硬编码的字符，例如<code>AndroidManifest.xml</code>，这里不再赘述，详见书P145左右。</p>
<p>&emsp;(2) 根据 (1) 的步骤修改XposedBridge，最终制作出XppsedBridge.jar。</p>
<p>&emsp;(3) 修改Xposed项目源代码，详见书P147。</p>
<p>&emsp;(4) 修改XposedTools工具的源码，保证编译过程中不报错。</p>
<p>&emsp;但是跟书修改完之后，始终无法检测到新编译的 xposed-v89-sdk25-arm64.zip，但是试了原代码编译的 xposed-v89-sdk25-arm64.zip，发现是可以检测到的。通过查看 xposedInstaller 源代码并调试，也未发现原因。为了不耽误时间，所以直接跳过此处的实验。耽误了两三周。</p>
<p>&emsp;本章最后还说明了基于自定义修改的 Xposed 框架编写 Xposed 模块的方式，见书 P150。本章大部分是 Xposed 魔改过检测，主要是针对字符串的检测，但是被 Xposed Hook 的函数，其 access_flags 属性变成了 native。</p>
<h3 id="相关知识补充"><a href="#相关知识补充" class="headerlink" title="相关知识补充"></a>相关知识补充</h3><p>&emsp;见<a target="_blank" rel="noopener" href="https://bbs.kanxue.com/thread-269627.htm#msg_header_h2_1">link</a>。</p>
<p>&emsp;<code>Android 的平台架构如下所示：</code></p>
<p><img src="/images/frida-reverse-analysis-3/image-20240115194321408.png" alt="image-20240115194321408" style="zoom:67%;" /></p>
<p>（1）Linux 内核。Android 平台的基础是 linux 内核，Android Runtime（ART）依靠 Linux 内核来执行底层功能，基于linux 内核让 Android 更安全并且可以拥有很多设备驱动。</p>
<p>（2）硬件抽象层（HAL）。HAL 向更高级别 Java API 框架显示设备硬件功能，其中每个模块都为特定类型的硬件组件实现一个界面，例如相机和蓝牙模块，当框架 API 要访问设备硬件时，Android 系统为该硬件组件加载库模块。</p>
<p>（3）Android Runtime。Android 5.0 之前 Android Runtime 为 Dalvik，之后为 ART。Dalvik 是 JIT （运行前转为机器码），ART 是 AOT （运行时转为机器码）。 </p>
<p>（4）原生 C/C++ 库。许多核心 Android 系统组件和服务（例如 ART 和 HAL）需要以 C 和 C++ 编写的原生库。Android 平台提供 Java 框架 API 以向应用显示其中部分原生库的功能，我们可以通过 NDK 开发 Android 中的 C/C++ 库。</p>
<p>（5）Java API 框架。这些 API 形成创建 Android 应用所需的构建块。</p>
<p>&emsp;<code>一些文件类型：</code></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>文件类型</th>
<th>类型含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>dex</td>
<td>Android 将所有的 class 文件打包形成一个 dex 文件，是 Dalvik 运行的程序。</td>
</tr>
<tr>
<td>odex</td>
<td>优化过的 dex 文件，apk 在安装时会进行验证和优化，通过 dexopt 生成 odex 文件，加快 apk 的响应时间。</td>
</tr>
<tr>
<td>oat</td>
<td>android 私有 ELF 文件格式，有 dex2oat 处理生成，包含（原 dex 文件<code>+</code>dex 翻译的本地机器指令），是 ART 虚拟机使用的文件，可以直接加载。</td>
</tr>
<tr>
<td>vdex</td>
<td>包含 APK 的未压缩 DEX 代码，以及一些旨在加快验证速度的元数据</td>
</tr>
</tbody>
</table>
</div>
<p>&emsp;<code>一些广泛的安卓版本：</code></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>版本号</th>
<th>特性</th>
</tr>
</thead>
<tbody>
<tr>
<td>Android 2.2</td>
<td>支持已转换成 dex 格式的 android 应用，基于寄存器，指令执行更快，加载的是 odex 文件，采用 JIT 运行时编译。但是由于是 JIT，每次启动应用都需要重新编译。</td>
</tr>
<tr>
<td>Android 4.4</td>
<td>ART 和 AOT。ART 和 Dalvik 是共存的，用户可以在两者之间选择。</td>
</tr>
<tr>
<td>Android 5.0</td>
<td>ART 取代 Dalvik。AOT是一种运行前编译的策略，缺点：（1）应用安装和系统升级之后的应用优化比较耗时；（2）优化后的文件会占用额外的存储空间。</td>
</tr>
<tr>
<td>Android 7.0</td>
<td>考虑上面 AOT 的缺点，dex2oat 过程比较耗时且会占用额外的存储空间，Android 7.0 再次加入 JIT 形成AOT+JIT+解释器模式。混合编译模式综合了 AOT 和 JIT 的各种优点，使得应用在安装速度加快的同时，运行速度、存储空间和耗电量等指标都得到了优化。应用在安装的时候 dex 不会被编译，应用在运行时 dex 文件先通过解析器（Interpreter）后会被直接执行，与此同时，热点函数（Hot Code）会被识别并被 JIT 编译后存储在 jit code cache 中并生成 profile 文件以记录热点函数的信息，手机进入 IDLE（空闲） 的时候，系统会扫描 App 目录下的 profile 文件并执行 AOT 过程进行编译。</td>
</tr>
</tbody>
</table>
</div>
<p>&emsp;Android 2.2 的 APP 运行图如下所示：</p>
<p><img src="/images/frida-reverse-analysis-3/image-20240115204417368.png" alt="image-20240115204417368" style="zoom:67%;" /></p>
<p>&emsp;Android 5.0 的 APP 运行图如下所示：</p>
<p><img src="/images/frida-reverse-analysis-3/image-20240115204957856.png" alt="image-20240115204957856" style="zoom:67%;" /></p>
<p>&emsp;<code>JIT 与 AOT 的区别：</code></p>
<p>&emsp;JIT 在每次运行程序的时候都需要对 odex 重新进行编译。AOT 是静态编译，应用在安装的时候会启动 dex2oat 过程把 dex 预编译成 ELF 文件，每次运行程序的时候不用重新编译。</p>
<p>&emsp;<code>JVM、Dalvik 和 ART 区别</code>：</p>
<p>&emsp;JVM：传统的 Java 虚拟机、基于栈、运行 class 文件。Dalvik，支持已转换成 dex 格式的 android 应用，基于寄存器，指令执行更快，加载的是 odex。ART，第一次安装时，将 dex 进行 Aot (预编译)，字节码预先编译成机器码，生成可执行 oat 文件（ELF文件）。</p>
<p>&emsp;<code>Android 各版本 ClassLoader 加载 dex 时的 dexopt 过程：</code></p>
<p><img src="/images/frida-reverse-analysis-3/image-20240115205940127.png" alt="image-20240115205940127" style="zoom:67%;" /></p>
<h2 id="0x06-Android沙箱之加解密库“自吐”"><a href="#0x06-Android沙箱之加解密库“自吐”" class="headerlink" title="0x06 Android沙箱之加解密库“自吐”"></a>0x06 Android沙箱之加解密库“自吐”</h2><p>&emsp;每个安卓应用都运行在独立的沙箱中，而本章介绍的沙箱指的是系统级的沙箱，即通过自定义系统源码编译特定系统，是得运行在自定义系统上的 App 行为都暴露在系统的监控下。</p>
<h3 id="自吐沙箱的建立"><a href="#自吐沙箱的建立" class="headerlink" title="自吐沙箱的建立"></a>自吐沙箱的建立</h3><p>&emsp;对于系统而言，App 的行为是没有隐私的。基于这种系统级沙箱从而监控 App 行为的思路，DexHunter、FART 等脱壳机从 ART 虚拟机层面对 App 进行内存数据的 dump，从而提出第一代、第二代（整体加固与函数加固）的解决方案。TinyTool 从内核中调用 JProbe（动态跟踪 Java 方法执行的工具，它是 Linux 内核提供的功能）来监控 syscall 系统调用，这样即使 App 应用使用静态编译的二进制文件，或者通过 svc 汇编指令在用户态直接进行系统调用，还可以打印出一份日志，来分析 App 的行为。</p>
<p>&emsp;除了基于系统源码的沙箱外，还有其它类型的沙箱，例如基于 Hook 类型的沙箱 r0capture，其虽然没有修改系统源码，但是基于 Hook 对系统收发包函数进行插桩，从而可以对应用层进行抓包。</p>
<p>&emsp;App 由于要依赖系统的 API，从而导致本身行为暴露在系统监控中。那么 App 如何抵抗沙箱分析？（1）App 尽可能少的减少系统 API 的调用；（2）关键函数的算法尽量不直接使用系统的加密库。</p>
<p>&emsp;本章基于 Hook 类型的沙箱，即 appmon，从而提出针对加密库进行分析的脚本，结合 Frida 开发自己的加密库沙箱。安卓提供了便利的加密封装库，我们可以直接通过 Hook 关键加密函数来进行逆向分析。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hookEvent.js</span></span><br><span class="line"><span class="keyword">var</span> jclazz = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">var</span> jobj = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getObjClassName</span>(<span class="params">obj</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!jclazz)&#123;</span><br><span class="line">        jclazz = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.lang.Class&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!jobj)&#123;</span><br><span class="line">        jobj = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.lang.Object&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> jclazz.<span class="property">getName</span>.<span class="title function_">call</span>(jobj.<span class="property">getClass</span>.<span class="title function_">call</span>(obj));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">watch</span>(<span class="params">obj, mtdName</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> listener_name = <span class="title function_">getObjClassName</span>(obj);</span><br><span class="line">    <span class="keyword">var</span> target = <span class="title class_">Java</span>.<span class="title function_">use</span>(listener_name);</span><br><span class="line">    <span class="keyword">if</span>(!target || !mtdName <span class="keyword">in</span> target)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// overload onClick function</span></span><br><span class="line">    target[mtdName].<span class="property">overloads</span>.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">overload</span>)&#123;</span><br><span class="line">        overload.<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[WatchEvent] &quot;</span> + mtdName + <span class="string">&quot;: &quot;</span> + <span class="title function_">getObjClassName</span>(<span class="variable language_">this</span>));</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">this</span>[mtdName].<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// hook View all onClick listener</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">OnClickListener</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="comment">// spawn 模式</span></span><br><span class="line">    	<span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;android.view.View&quot;</span>).<span class="property">setOnClickListener</span>.<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params">listener</span>)&#123;</span><br><span class="line">        	<span class="keyword">if</span>(listener != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="title function_">watch</span>(listener, <span class="string">&quot;onClick&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">setOnClickListener</span>(listener);</span><br><span class="line">    	&#125;;</span><br><span class="line">        <span class="comment">// attach 模式</span></span><br><span class="line">        <span class="title class_">Java</span>.<span class="title function_">choose</span>(<span class="string">&quot;android.view.View$ListenerInfo&quot;</span>, &#123;</span><br><span class="line">            <span class="attr">onMatch</span>: <span class="keyword">function</span>(<span class="params">instance</span>)&#123;</span><br><span class="line">                instance = instance.<span class="property">mOnClickListener</span>.<span class="property">value</span>;</span><br><span class="line">                <span class="keyword">if</span>(instance)&#123;</span><br><span class="line">                    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;mOnClickListener name is :&quot;</span> + <span class="title function_">getObjClassName</span>(instance));</span><br><span class="line">                    <span class="title function_">watch</span>(instance, <span class="string">&quot;onClick&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">onComplete</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">setImmediate</span>(<span class="title class_">OnClickListener</span>);</span><br></pre></td></tr></table></figure>
<p>&emsp;使用 frida，将 hookEvent.js 注入到 com.xiaojianbang.app，发现 JAVAMD5 按钮响应函数位于 com.xiaojianbang.app.MainActivity，之后使用 JADX 定位到 JAVAMD5 按钮的响应函数。JAVAMD5 使用了 java.security.MessageDigest 类中的函数，用于进行密码计算。主要包括 MessageDigest.getInstance()/update()/digest() 函数，由于每个函数可能存在多个重载，所以编写通用的可以 hook 任意函数所有重载的脚本（这里针对 MessageDigest.getInstance()），代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hook.js</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">hookMD5</span>(<span class="params">targetClassMethod</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> delim = targetClassMethod.<span class="title function_">lastIndexOf</span>(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(delim === -<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">var</span> targetClass = targetClassMethod.<span class="title function_">slice</span>(<span class="number">0</span>, delim);</span><br><span class="line">    <span class="keyword">var</span> targetMethod = targetClassMethod.<span class="title function_">slice</span>(delim + <span class="number">1</span>, targetClassMethod.<span class="property">length</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> hook = <span class="title class_">Java</span>.<span class="title function_">use</span>(targetClass);</span><br><span class="line">    <span class="keyword">var</span> overloadCount = hook[targetMethod].<span class="property">overloads</span>.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; overloadCount; i++)&#123;</span><br><span class="line">    	hook[targetMethod].<span class="property">overloads</span>[i].<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="comment">// this and arguments</span></span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">warn</span>(<span class="string">&quot;\n*** entered &quot;</span> + targetClassMethod);</span><br><span class="line">            <span class="keyword">if</span>(<span class="variable language_">arguments</span>.<span class="property">length</span> &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; <span class="variable language_">arguments</span>.<span class="property">length</span>; j++)&#123;</span><br><span class="line">                    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;arg[&quot;</span> + j + <span class="string">&quot;]: &quot;</span> + <span class="variable language_">arguments</span>[j],<span class="string">&#x27;=&gt;&#x27;</span>, <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(<span class="variable language_">arguments</span>[j]));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">var</span> retval = <span class="variable language_">this</span>[targetMethod].<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>);</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;\nretval: &quot;</span> + retval,<span class="string">&#x27;=&gt;&#x27;</span>, <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(retval));</span><br><span class="line">            <span class="comment">// 打印调用栈</span></span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;android.util.Log&quot;</span>).<span class="title function_">getStackTraceString</span>(<span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.lang.Throwable&quot;</span>).$new()));</span><br><span class="line">            <span class="keyword">return</span> retval;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> targetClassMethod = <span class="string">&quot;java.security.MessageDigest.getInstance&quot;</span>;</span><br><span class="line">    <span class="title function_">hookMD5</span>(targetClassMethod);</span><br><span class="line">    targetClassMethod = <span class="string">&quot;java.security.MessageDigest.update&quot;</span>;</span><br><span class="line">    <span class="title function_">hookMD5</span>(targetClassMethod);</span><br><span class="line">    targetClassMethod = <span class="string">&quot;java.security.MessageDigest.digest&quot;</span>;</span><br><span class="line">    <span class="title function_">hookMD5</span>(targetClassMethod);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">setImmediate</span>(main);</span><br></pre></td></tr></table></figure>
<p>&emsp;结果如下：</p>
<p><img src="/images/frida-reverse-analysis-3/image-20240116204627467.png" alt="image-20240116204627467" style="zoom:67%;" /></p>
<p>&emsp;<a target="_blank" rel="noopener" href="https://github.com/dpnishant/appmon">Appmon 沙箱</a>是怎么做的呢？我们只关注功能本身，看针对 Hash 函数进行 trace 的脚本（appmon/scripts/Android/Crypto/Hash.js），注入后发现：</p>
<p><img src="/images/frida-reverse-analysis-3/image-20240116205248420.png" alt="image-20240116205248420" style="zoom:67%;" /></p>
<p>&emsp;其识别算法时，并未通过勾取 getInstance() 来获取算法信息，而是在勾取 digest 函数时通过 getAlgorithm 获得算法的种类，且 data 总为空。下面分析一下它的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Hash.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 严格模式，对代码的解析和执行施加更严格的限制和规则</span></span><br><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改 byteArraytoHexString，将 map 方法修改为如下</span></span><br><span class="line"><span class="keyword">var</span> byteArraytoHexString = <span class="keyword">function</span>(<span class="params">byteArray</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span>(!byteArray)&#123;<span class="keyword">return</span> <span class="string">&#x27;11&#x27;</span>;&#125;</span><br><span class="line">  <span class="keyword">var</span> result = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; byteArray.<span class="property">length</span>; i++)&#123;</span><br><span class="line">    result += (<span class="string">&#x27;0&#x27;</span> + (byteArray[i] &amp; <span class="number">0xFF</span>).<span class="title function_">toString</span>(<span class="number">16</span>)).<span class="title function_">slice</span>(-<span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> updateInput = <span class="keyword">function</span>(<span class="params">input</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (input.<span class="property">length</span> &amp;&amp; input.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> normalized = <span class="title function_">byteArraytoHexString</span>(input);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (input.<span class="property">array</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> normalized = <span class="title function_">byteArraytoHexString</span>(input.<span class="title function_">array</span>());</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> normalized = input.<span class="title function_">toString</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> normalized;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> <span class="title class_">MessageDigest</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.security.MessageDigest&quot;</span>);</span><br><span class="line">  <span class="comment">// 如果有 digest 函数</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="title class_">MessageDigest</span>.<span class="property">digest</span>)&#123;</span><br><span class="line">    <span class="title class_">MessageDigest</span>.<span class="property">digest</span>.<span class="property">overloads</span>[<span class="number">0</span>].<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> digest = <span class="variable language_">this</span>.<span class="property">digest</span>.<span class="property">overloads</span>[<span class="number">0</span>].<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>);</span><br><span class="line">       </span><br><span class="line">      <span class="comment">// 获取密码算法</span></span><br><span class="line">      <span class="keyword">var</span> algorithm = <span class="variable language_">this</span>.<span class="title function_">getAlgorithm</span>().<span class="title function_">toString</span>();</span><br><span class="line">        </span><br><span class="line">      <span class="comment">// Payload 头</span></span><br><span class="line">      <span class="keyword">var</span> send_data = &#123;&#125;;</span><br><span class="line">      send_data.<span class="property">time</span> = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">      send_data.<span class="property">txnType</span> = <span class="string">&#x27;Crypto&#x27;</span>;</span><br><span class="line">      send_data.<span class="property">lib</span> = <span class="string">&#x27;java.security.MessageDigest&#x27;</span>;</span><br><span class="line">      send_data.<span class="property">method</span> = <span class="string">&#x27;digest&#x27;</span>;</span><br><span class="line">      send_data.<span class="property">artifact</span> = [];</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Payload 体</span></span><br><span class="line">      <span class="keyword">var</span> data = &#123;&#125;;</span><br><span class="line">      data.<span class="property">name</span> = <span class="string">&quot;Algorithm&quot;</span>;</span><br><span class="line">      data.<span class="property">value</span> = algorithm;</span><br><span class="line">      data.<span class="property">argSeq</span> = <span class="number">0</span>;</span><br><span class="line">      send_data.<span class="property">artifact</span>.<span class="title function_">push</span>(data);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Payload 体</span></span><br><span class="line">      <span class="keyword">var</span> data = &#123;&#125;;</span><br><span class="line">      data.<span class="property">name</span> = <span class="string">&quot;Digest&quot;</span>;</span><br><span class="line">      data.<span class="property">value</span> = <span class="title function_">byteArraytoHexString</span>(digest);</span><br><span class="line">      data.<span class="property">argSeq</span> = <span class="number">0</span>;</span><br><span class="line">      send_data.<span class="property">artifact</span>.<span class="title function_">push</span>(data);</span><br><span class="line"></span><br><span class="line">      <span class="title function_">send</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(send_data));</span><br><span class="line">      <span class="keyword">return</span> digest;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title class_">MessageDigest</span>.<span class="property">digest</span>.<span class="property">overloads</span>[<span class="number">1</span>].<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params">input</span>) &#123;</span><br><span class="line">      <span class="comment">// same as above</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="title class_">MessageDigest</span>.<span class="property">update</span>) &#123;</span><br><span class="line">    <span class="title class_">MessageDigest</span>.<span class="property">update</span>.<span class="property">overloads</span>[<span class="number">0</span>].<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params">input</span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> send_data = &#123;&#125;;</span><br><span class="line">      send_data.<span class="property">time</span> = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">      send_data.<span class="property">txnType</span> = <span class="string">&#x27;Crypto&#x27;</span>;</span><br><span class="line">      send_data.<span class="property">lib</span> = <span class="string">&#x27;java.security.MessageDigest&#x27;</span>;</span><br><span class="line">      send_data.<span class="property">method</span> = <span class="string">&#x27;update&#x27;</span>;</span><br><span class="line">      send_data.<span class="property">artifact</span> = [];</span><br><span class="line">      <span class="keyword">var</span> data = &#123;&#125;;</span><br><span class="line">      data.<span class="property">name</span> = <span class="string">&quot;Raw Data&quot;</span>;</span><br><span class="line">      data.<span class="property">value</span> = <span class="title function_">updateInput</span>(input);</span><br><span class="line">      data.<span class="property">argSeq</span> = <span class="number">0</span>;</span><br><span class="line">      send_data.<span class="property">artifact</span>.<span class="title function_">push</span>(data);</span><br><span class="line">      <span class="title function_">send</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(send_data));</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">update</span>.<span class="property">overloads</span>[<span class="number">0</span>].<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title class_">MessageDigest</span>.<span class="property">update</span>.<span class="property">overloads</span>[<span class="number">1</span>].<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params">input, offset, len</span>) &#123;</span><br><span class="line">      <span class="comment">// same as above</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title class_">MessageDigest</span>.<span class="property">update</span>.<span class="property">overloads</span>[<span class="number">2</span>].<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params">input</span>) &#123;</span><br><span class="line">      <span class="comment">// same as above</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title class_">MessageDigest</span>.<span class="property">update</span>.<span class="property">overloads</span>[<span class="number">3</span>].<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params">input</span>) &#123;</span><br><span class="line">      <span class="comment">// same as above</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>&emsp;考虑到 hook 主要依赖于 Frida，Xposed 等工具，这类工具可能会由 app 检测出来，因此，我们打算直接从系统源码层面修改代码。虽然 hook 沙箱与源码沙箱实现方式不同，但是两者都是采取对源码插桩的方式实现的，只是 hook 是针对二进制的动态代码插桩，源码沙箱是针对源码的插桩。我们要实现源码沙箱，只需要针对目标函数内容进行修改即可。</p>
<p>&emsp;以 Android 7.1.2_r8 为例，生成对应的 idegen.jar，android.iml（包含源码导入 Android studio 时会被导入和派出的子目录），android.ipr（源码工程的具体配置、代码以及依赖的 lib）文件，之后直接用 android studio 打开 ipr 文件即可。</p>
<p>&emsp;我们直接修改 MessageDigest 的源码，但要解决 2 个问题：（1）用什么方式进行自吐，解决方法 a：<code>日志打印，即调用 android.util.Log，但是无法通过 import 导入，因为会出现 cannot find symbol 的问题，可使用反射方式（运行时动态获取类的信息并操作对象）调用 Log 中的函数，但要处理反射可能带来的异常</code>；（2）确定哪一个是重载函数，是否存在相互调用的情况，解决方法 b：<code>首先用 Objection 确定 MessageDigest 类中存在的目标函数，找到所有重载后，直接源码分析每一个重载函数，如果某函数内没有再次调用其他重载函数，那么就要进行源码插桩；解决方法 c：方法 b 无法处理添加新的函数的问题，因此，运行 make update-api。具体见 P163。</code></p>
<p>&emsp;解决方法 a：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// update</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">logClass</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// load class</span></span><br><span class="line">    logClass = <span class="built_in">this</span>.getClass().getClassLoader().loadClass(<span class="string">&quot;android.util.Log&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Method</span> <span class="variable">loge</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// get corresponding method</span></span><br><span class="line">    loge = logClass.getMethod(<span class="string">&quot;e&quot;</span>, String.class, String.class);</span><br><span class="line">&#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// call method</span></span><br><span class="line">    loge.invoke(<span class="literal">null</span>, <span class="string">&quot;wd2711&quot;</span>, <span class="string">&quot;input =&gt; &quot;</span> + inputString);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;ps：自己编译的镜像一般都有 root 权限（具有 su 指令），要想不要 root 权限，那么直接 lunch 选择 user 类型（直接打字 user，而不是选择标号）即可。</p>
<p>&emsp;最后，就可以建立一个 Hash 自吐的沙箱。由于我已经详细知晓步骤，所以，为了加快时间，就不进行实验了，对下面的章节也是这样，除非我认为这是很有必要做的实验。</p>
<h3 id="crypto-filter-aosp-项目移植"><a href="#crypto-filter-aosp-项目移植" class="headerlink" title="crypto_filter_aosp 项目移植"></a>crypto_filter_aosp 项目移植</h3><p>&emsp;下面针对 com.xiaojianbang.app 关于 AES/DES/RSA 算法进行分析，使用 jadx 可以得到它们的源码（在此只列出 AES 的源码）：</p>
<p><img src="/images/frida-reverse-analysis-3/image-20240119210512045.png" alt="image-20240119210512045" style="zoom:67%;" /></p>
<p>&emsp;可以发现，控制加解密的类是 <code>javax.crypto.Cipher</code>，init 用于传递密钥和向量，update 用于更新加解密输入，doFinal 用于进行真正的加解密过程。本小节不进行相关的沙箱开发，而是使用一个项目 <a target="_blank" rel="noopener" href="https://github.com/icew4y/crypto_filter_aosp">crypro_filter_aosp</a>，它是一个监控 java 层加密算法的 ROM（只读存储），它的输出就是向目录中写文件，且只能监控一个 app。</p>
<p>&emsp;此项目是针对 nexux 6p android 6.0.1 的，如果想要复用就要做修改。此项目包含 6 个文件，修改后直接覆盖掉 android 8.1.0 的源码即可。要进行修改，就要对比 android 6.0.1 源码与项目代码，比较改了什么。其次，此项目在输出时将一次加解密过程输出一条日志（前面的沙箱在一次加解密过程中输出多条日志），这是因为，此项目增加了成员变量 jsoninfo，在 init 与 update 函数中，更新 jsoninfo 信息，在最终的 doFinal 运行时，把此变量输出到文件，并清空 jsoninfo。</p>
<p>&emsp;由于此项目添加了原来 android 源码中没有的文件，所以需要在 libcore 目录的 obenjdk_java_files.mk 中增加相应文件的全路径，添加完成后还需要执行 make update-api 更新系统 api。</p>
<p>ps：check_oom 一般是检测内存是否溢出的函数，在微软的区块链钱包中也有此函数。</p>
<h2 id="0x07-Android沙箱开发之网络库与系统库“自吐”"><a href="#0x07-Android沙箱开发之网络库与系统库“自吐”" class="headerlink" title="0x07 Android沙箱开发之网络库与系统库“自吐”"></a>0x07 Android沙箱开发之网络库与系统库“自吐”</h2><p>&emsp;很多 App 都对抓包进行了相应的防御，例如反 wifi 代理、反 VPN 代理、服务器校验客户端/客户端校验服务器（CA 证书层面）。虽然工具 r0capture 从代码层面抓取数据包，绕过了以上这些应对中间人抓包的对抗方式，但是由于其依赖于 frida，因此很容易被检测到。</p>
<h3 id="基于-r0capture-的源码沙箱网络库“自吐”"><a href="#基于-r0capture-的源码沙箱网络库“自吐”" class="headerlink" title="基于 r0capture 的源码沙箱网络库“自吐”"></a>基于 r0capture 的源码沙箱网络库“自吐”</h3><p>&emsp;要构建沙箱，首先要找到源码中关键代码的位置。在 TCP/IP 模型中，由于 App 是属于应用层，因此只能修改所使用的应用层协议类型、数据格式、传输端口、或者用 TCP/UDP 直接通信。基本没有 App 可以修改网络层内容，即使是 VPN app，也只是创建出新的网络接口，IP 还是 VPN server 分配的。目前，有很多网络通信框架通信，例如 Okhttp（访问网站）、Exoplayer（播放视频）、Glide（异步平滑图片滚动加载框架），这些框架底层还是使用系统 API 处理。基于此，app 采取多种手段防止应用层的抓包，例如，app 使用特定 API（<code>Proxy.NO_PROXY</code>、<code>System.getProperty(&quot;http.proxyHost&quot;)</code> 等）检测来防止 wifi 代理，即使使用 VPN app 从网络层将数据流转发到抓包软件，也可以使用 <code>getNetWorkCapbilities()</code> 来检测网络接口，从而检测 VPN app。我们可以使用 objection 对 <code>android.net.ConnectivityManager.getNetWorkCapbilities()</code> 进行勾取，从而发现一些 VPN 使用的痕迹。</p>
<p>&emsp;App 还可以通过证书层面来检测抓包，例如<code>客户端校验服务器的方式，即在客户端和服务器进行握手时，验证 CA 的 hash 值，来达到只与持有相同 CA 的服务器进行通信，而服务器只与持有特定 CA 的客户端进行交互</code>。</p>
<p>&emsp;由于协议通用性问题，即使在应用层做了很多防护手段，攻击者也可以绕过。因此开发者可能会使用小众协议甚至自研应用层协议（腾讯的 JceStruct 协议），即使数据流量被窃取，也无法得到有效信息。自研的协议可以很大发挥传输层功能，例如，（1）某厂商使用自建代理长连的网络方案，app 请求通过 CIP (Common industrial protocol，用于工业自动化领域的通信协议，提供了标准化的方式来相互通信）通道中的 TCP 子通道与长连服务器通信，长连服务器与业务服务器进行通信；（2）某厂商自研内核、算法、传输层网络库与服务端，此时使用沙箱也无法对 app 进行抓包。</p>
<p>&emsp;但是大多数 app 都是直接调用系统 API，我们只需要在应用层下层，对 socket 接口相关函数进行 hook，就可以抓到封装成 http 的应用数据，之后，这些数据使用 SSL 进行加密，并通过 socket 与服务器进行通信。下面是一个 app 的网络函数调用图（会话层 (SSL) -&gt; 表示层 (HTTP) -&gt; 应用层 (自定义视频流解密) -&gt; 应用层 (播放解密后的流媒体)）：</p>
<p><img src="/images/frida-reverse-analysis-3/image-20240120105331069.png" alt="image-20240120105331069" style="zoom:67%;" /></p>
<p>&emsp;通过 hook socket 函数，所监听的上层数据可以分为加密/未加密两种类型，并针对多个应用层协议进行验证与测试。我们可以得出以下结论，如果数据未加密，那么如果是发送数据，那么一定会经过 <code>java.net.SocketOutputStream</code> 的 <code>socketWrite0()</code> 函数，如果是接收数据，那么一定会经过<code>java.net.SocketInputStream</code> 的 <code>socketRead0()</code> 函数。通过分析以下 r0capture 代码，从而了解关于<code>未加密数据</code>的 hook 脚本（并不是修改源码）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// overload socketWrite0</span></span><br><span class="line"><span class="comment">// 有参数函数的 overload</span></span><br><span class="line"><span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.net.SocketOutputStream&quot;</span>).<span class="property">socketWrite0</span>.<span class="title function_">overload</span>(<span class="string">&#x27;java.io.FileDescriptor&#x27;</span>, <span class="string">&#x27;[B&#x27;</span>, <span class="string">&#x27;int&#x27;</span>, <span class="string">&#x27;int&#x27;</span>).<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params">fd, bytearry, offset, byteCount</span>) &#123;</span><br><span class="line">    <span class="comment">// 调用原函数</span></span><br><span class="line">    <span class="keyword">var</span> result = <span class="variable language_">this</span>.<span class="title function_">socketWrite0</span>(fd, bytearry, offset, byteCount);</span><br><span class="line">    <span class="comment">// 进行信息记录</span></span><br><span class="line">    <span class="keyword">var</span> message = &#123;&#125;;</span><br><span class="line">    message[<span class="string">&quot;function&quot;</span>] = <span class="string">&quot;HTTP_send&quot;</span>;</span><br><span class="line">    message[<span class="string">&quot;ssl_session_id&quot;</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    message[<span class="string">&quot;src_addr&quot;</span>] = <span class="title function_">ntohl</span>(<span class="title function_">ipToNumber</span>((<span class="variable language_">this</span>.<span class="property">socket</span>.<span class="property">value</span>.<span class="title function_">getLocalAddress</span>().<span class="title function_">toString</span>().<span class="title function_">split</span>(<span class="string">&quot;:&quot;</span>)[<span class="number">0</span>]).<span class="title function_">split</span>(<span class="string">&quot;/&quot;</span>).<span class="title function_">pop</span>()));</span><br><span class="line">    message[<span class="string">&quot;src_port&quot;</span>] = <span class="built_in">parseInt</span>(<span class="variable language_">this</span>.<span class="property">socket</span>.<span class="property">value</span>.<span class="title function_">getLocalPort</span>().<span class="title function_">toString</span>());</span><br><span class="line">    <span class="comment">// 需要注意的是，这里完全可以用 this.socket.toString 而不是 this.socket.value.getRemoteSocketAddress 来实现目的地址的获取，因为 Socket 对应的内容就是目的地址信息，这是通过 Objection 的插件 wallbreaker 查看 java.net.SocketOutputStream 对象的成员结构发现的</span></span><br><span class="line">    message[<span class="string">&quot;dst_addr&quot;</span>] = <span class="title function_">ntohl</span>(<span class="title function_">ipToNumber</span>((<span class="variable language_">this</span>.<span class="property">socket</span>.<span class="property">value</span>.<span class="title function_">getRemoteSocketAddress</span>().<span class="title function_">toString</span>().<span class="title function_">split</span>(<span class="string">&quot;:&quot;</span>)[<span class="number">0</span>]).<span class="title function_">split</span>(<span class="string">&quot;/&quot;</span>).<span class="title function_">pop</span>()));</span><br><span class="line">    message[<span class="string">&quot;dst_port&quot;</span>] = <span class="built_in">parseInt</span>(<span class="variable language_">this</span>.<span class="property">socket</span>.<span class="property">value</span>.<span class="title function_">getRemoteSocketAddress</span>().<span class="title function_">toString</span>().<span class="title function_">split</span>(<span class="string">&quot;:&quot;</span>).<span class="title function_">pop</span>());</span><br><span class="line">    <span class="comment">// 打印调用栈</span></span><br><span class="line">    message[<span class="string">&quot;stack&quot;</span>] = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;android.util.Log&quot;</span>).<span class="title function_">getStackTraceString</span>(<span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.lang.Throwable&quot;</span>).$new()).<span class="title function_">toString</span>();</span><br><span class="line">    <span class="keyword">var</span> ptr = <span class="title class_">Memory</span>.<span class="title function_">alloc</span>(byteCount);</span><br><span class="line">    <span class="comment">// 将 bytearray 写入到 ptr，并将 ptr 与记录的信息一块发出去</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; byteCount; ++i) &#123;</span><br><span class="line">        <span class="title class_">Memory</span>.<span class="title function_">writeS8</span>(ptr.<span class="title function_">add</span>(i), bytearry[offset + i]);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="title function_">send</span>(message, <span class="title class_">Memory</span>.<span class="title function_">readByteArray</span>(ptr, byteCount));</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.net.SocketInputStream&quot;</span>).<span class="property">socketRead0</span>.<span class="title function_">overload</span>(<span class="string">&#x27;java.io.FileDescriptor&#x27;</span>, <span class="string">&#x27;[B&#x27;</span>, <span class="string">&#x27;int&#x27;</span>, <span class="string">&#x27;int&#x27;</span>, <span class="string">&#x27;int&#x27;</span>).<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params">fd, bytearry, offset, byteCount, timeout</span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> result = <span class="variable language_">this</span>.<span class="title function_">socketRead0</span>(fd, bytearry, offset, byteCount, timeout);</span><br><span class="line">      <span class="keyword">var</span> message = &#123;&#125;;</span><br><span class="line">      message[<span class="string">&quot;function&quot;</span>] = <span class="string">&quot;HTTP_recv&quot;</span>;</span><br><span class="line">      message[<span class="string">&quot;ssl_session_id&quot;</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">      message[<span class="string">&quot;src_addr&quot;</span>] = <span class="title function_">ntohl</span>(<span class="title function_">ipToNumber</span>((<span class="variable language_">this</span>.<span class="property">socket</span>.<span class="property">value</span>.<span class="title function_">getRemoteSocketAddress</span>().<span class="title function_">toString</span>().<span class="title function_">split</span>(<span class="string">&quot;:&quot;</span>)[<span class="number">0</span>]).<span class="title function_">split</span>(<span class="string">&quot;/&quot;</span>).<span class="title function_">pop</span>()));</span><br><span class="line">      message[<span class="string">&quot;src_port&quot;</span>] = <span class="built_in">parseInt</span>(<span class="variable language_">this</span>.<span class="property">socket</span>.<span class="property">value</span>.<span class="title function_">getRemoteSocketAddress</span>().<span class="title function_">toString</span>().<span class="title function_">split</span>(<span class="string">&quot;:&quot;</span>).<span class="title function_">pop</span>());</span><br><span class="line">      message[<span class="string">&quot;dst_addr&quot;</span>] = <span class="title function_">ntohl</span>(<span class="title function_">ipToNumber</span>((<span class="variable language_">this</span>.<span class="property">socket</span>.<span class="property">value</span>.<span class="title function_">getLocalAddress</span>().<span class="title function_">toString</span>().<span class="title function_">split</span>(<span class="string">&quot;:&quot;</span>)[<span class="number">0</span>]).<span class="title function_">split</span>(<span class="string">&quot;/&quot;</span>).<span class="title function_">pop</span>()));</span><br><span class="line">      message[<span class="string">&quot;dst_port&quot;</span>] = <span class="built_in">parseInt</span>(<span class="variable language_">this</span>.<span class="property">socket</span>.<span class="property">value</span>.<span class="title function_">getLocalPort</span>());</span><br><span class="line">      message[<span class="string">&quot;stack&quot;</span>] = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;android.util.Log&quot;</span>).<span class="title function_">getStackTraceString</span>(<span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.lang.Throwable&quot;</span>).$new()).<span class="title function_">toString</span>();</span><br><span class="line">      <span class="keyword">if</span> (result &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="comment">// bytearry 的数据长度并不是 byteCount，而是 scoketRead0 执行完后的返回值 result</span></span><br><span class="line">          <span class="keyword">var</span> ptr = <span class="title class_">Memory</span>.<span class="title function_">alloc</span>(result);</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; result; ++i) &#123;</span><br><span class="line">              <span class="title class_">Memory</span>.<span class="title function_">writeS8</span>(ptr.<span class="title function_">add</span>(i), bytearry[offset + i]);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="title function_">send</span>(message, <span class="title class_">Memory</span>.<span class="title function_">readByteArray</span>(ptr, result))</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;可以发现，输出的信息包括：地址，数据信息，函数调用栈（便于解密数据）。</p>
<p>&emsp;上面是 r0capture 使用 frida 的勾取，对于修改安卓源码的沙箱而言，（1）完全可以用 this.socket.toString 而不是 this.socket.value.getRemoteSocketAddress（r0capture 的做法） 来实现目的地址的获取，因为 Socket 对应的内容就是目的地址信息；（2）由于 <code>socketWrite0</code> 与 <code>socketRead0</code> 都是 native 函数，其具体实现都是 native 层，为了避免对 native 层的代码（so 文件中）进行修改，所以对其上层函数（调用链为： <code>socketRead -&gt; socketRead0</code>），也就是 <code>socketRead</code> 进行修改；（3）调用栈打印时，可以使用 <code>Exception e = new Exception(&quot;wd2711SOCKETresponse&quot;); e.printStackTrace();</code> 修改 <code>Log.getStackTraceString(Throwable)</code>（r0capture 的做法）。最后修改后的安卓源码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// socketInputStream.java</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">socketRead</span><span class="params">(FileDescriptor fd, <span class="type">byte</span> b[], <span class="type">int</span> off, <span class="type">int</span> len, <span class="type">int</span> timeout)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> socketRead0(fd, b, off, len, timeout);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// b -&gt; input</span></span><br><span class="line">        <span class="type">byte</span>[] input = <span class="keyword">new</span> <span class="title class_">byte</span>[result];</span><br><span class="line">        System.arraycopy(b, off, input, <span class="number">0</span>, result);</span><br><span class="line">        <span class="type">String</span> <span class="variable">inputString</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(input);</span><br><span class="line">        <span class="comment">// 获得 Log.e 函数</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">logClass</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            logClass = <span class="built_in">this</span>.getClass().getClassLoader().loadClass(<span class="string">&quot;android.util.Log&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Method</span> <span class="variable">loge</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            loge = logClass.getMethod(<span class="string">&quot;e&quot;</span>, String.class, String.class);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 打印目的地址</span></span><br><span class="line">            loge.invoke(<span class="literal">null</span>,<span class="string">&quot;r0ysueSOCKETresponse&quot;</span>,<span class="string">&quot;Socket is =&gt; &quot;</span> + <span class="built_in">this</span>.socket.toString());</span><br><span class="line">            <span class="comment">// 打印接收到的信息</span></span><br><span class="line">            loge.invoke(<span class="literal">null</span>,<span class="string">&quot;r0ysueSOCKETresponse&quot;</span>,<span class="string">&quot;buffer is =&gt; &quot;</span> + inputString);</span><br><span class="line">            <span class="comment">// 打印函数调用栈</span></span><br><span class="line">            <span class="type">Exception</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;wd2711SOCKETresponse&quot;</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;以上是<code>未加密数据</code>的沙箱“自吐”，下面关注一波<code>加密</code>数据的沙箱“自吐”。要是加密的话，加密机制拉满了的话就是先 app 数据加密，之后再 SSL 加密。r0capture（基于 frida）的工具针对 SSL 加密的话（代码如下）主要是参考 frida_ssl_logger 在 native 层的 hook，要是我们想通过修改源码的话，这部分行不通。因此我们找找其他办法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// r0capture 对 SSL data 的自吐，这里没有打印调用栈信息，这是因为 frida 打印的 native 层（SSL_read 与 SSL_write）的调用栈信息可能不准确，所以在 java 层处理调用栈信息，并保存到全局变量中</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">SSLstackwrite</span> = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">var</span> <span class="title class_">SSLstackread</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SSL_read 的 args[0] -&gt; SSL 连接的上下文指针</span></span><br><span class="line"><span class="comment">//             args[1] -&gt; SSL_read 执行完后存放到 args[1]，是 SSL 解密后的数据</span></span><br><span class="line"><span class="title class_">Interceptor</span>.<span class="title function_">attach</span>(addresses[<span class="string">&quot;SSL_read&quot;</span>], &#123;</span><br><span class="line">    <span class="attr">onEnter</span>: <span class="keyword">function</span>(<span class="params">args</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> ms = <span class="title function_">getPortAndAddresses</span>(<span class="title function_">SSL_get_fd</span>(args[<span class="number">0</span>]), <span class="literal">true</span>);</span><br><span class="line">        ms[<span class="string">&quot;ssl_session_id&quot;</span>] = <span class="title function_">getSslSessionId</span>(args[<span class="number">0</span>]);</span><br><span class="line">        ms[<span class="string">&quot;function&quot;</span>] = <span class="string">&quot;SSL_read&quot;</span>;</span><br><span class="line">        ms[<span class="string">&quot;stack&quot;</span>] = <span class="title class_">SSLstackread</span>;</span><br><span class="line">        <span class="comment">// 构造 this.message 与 this.buf 结构</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">message</span> = ms;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">buf</span> = args[<span class="number">1</span>];</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">onLeave</span>: <span class="keyword">function</span>(<span class="params">ret</span>) &#123;</span><br><span class="line">        <span class="comment">// 将 ret 转为 32bit 数字</span></span><br><span class="line">        ret |= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (ret &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 展示 ssl_session_id + function name + SSL_read 后的结果 + SSL_read 返回的值</span></span><br><span class="line">        <span class="title function_">send</span>(<span class="variable language_">this</span>.<span class="property">message</span>, <span class="title class_">Memory</span>.<span class="title function_">readByteArray</span>(<span class="variable language_">this</span>.<span class="property">buf</span>, ret));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// SSL_read 的 args[0] -&gt; SSL 连接的上下文指针</span></span><br><span class="line"><span class="comment">//             args[1] -&gt; 将要经过 SSL 加密的数据放到 args[1] 中</span></span><br><span class="line"><span class="title class_">Interceptor</span>.<span class="title function_">attach</span>(addresses[<span class="string">&quot;SSL_write&quot;</span>], &#123;</span><br><span class="line">    <span class="attr">onEnter</span>: <span class="keyword">function</span>(<span class="params">args</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> ms = <span class="title function_">getPortAndAddresses</span>(<span class="title function_">SSL_get_fd</span>(args[<span class="number">0</span>]), <span class="literal">false</span>);</span><br><span class="line">        ms[<span class="string">&quot;ssl_session_id&quot;</span>] = <span class="title function_">getSslSessionId</span>(args[<span class="number">0</span>]);</span><br><span class="line">        ms[<span class="string">&quot;function&quot;</span>] = <span class="string">&quot;SSL_write&quot;</span>;</span><br><span class="line">        ms[<span class="string">&quot;stack&quot;</span>] = <span class="title class_">SSLstackwrite</span>;</span><br><span class="line">        <span class="title function_">send</span>(message, <span class="title class_">Memory</span>.<span class="title function_">readByteArray</span>(args[<span class="number">1</span>], <span class="built_in">parseInt</span>(args[<span class="number">2</span>])));</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">onLeave</span>: <span class="keyword">function</span>(<span class="params">ret</span>) &#123;&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.android.org.conscrypt.ConscryptFileDescriptorSocket$SSLInputStream&quot;</span>).<span class="property">read</span>.<span class="title function_">overload</span>(<span class="string">&#x27;[B&#x27;</span>, <span class="string">&#x27;int&#x27;</span>, <span class="string">&#x27;int&#x27;</span>).<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params">bytearry, int1, int2</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="variable language_">this</span>.<span class="title function_">write</span>(bytearry, int1, int2);</span><br><span class="line">    <span class="title class_">SSLstackwrite</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;android.util.Log&quot;</span>).<span class="title function_">getStackTraceString</span>(<span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.lang.Throwable&quot;</span>).$new()).<span class="title function_">toString</span>();</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.android.org.conscrypt.ConscryptFileDescriptorSocket$SSLOutputStream&quot;</span>).<span class="property">write</span>.<span class="title function_">overload</span>(<span class="string">&#x27;[B&#x27;</span>, <span class="string">&#x27;int&#x27;</span>, <span class="string">&#x27;int&#x27;</span>).<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params">bytearry, int1, int2</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="variable language_">this</span>.<span class="title function_">write</span>(bytearry, int1, int2);</span><br><span class="line">    <span class="title class_">SSLstackwrite</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;android.util.Log&quot;</span>).<span class="title function_">getStackTraceString</span>(<span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.lang.Throwable&quot;</span>).$new()).<span class="title function_">toString</span>();</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;那我们咋找其他办法呢？首先，我们先快速定位 SSL 相关的函数，通过使用 Objection 搜索所有与 socket 相关的类（<code>objection -g packagename explore; android class search socket</code>），并利用 objection 在执行注入时 <code>-c hook.txt</code>，hook.txt 包含要执行的命令，从而 trace 这些类，从而快速定位到这些类在代码中的位置。最后定位到两个关键函数：<code>com.android.org.conscrypt.ConscryptFileDescriptorSocket$SSLInputStream.read()</code> （数据接收）与 <code>com.android.org.conscrypt.ConscryptFileDescriptorSocket$SSLOutputStream.write()</code>（数据发送）的自吐函数。</p>
<p>&emsp;之后，我们就要寻思如何输出（1）数据内容；（2）地址信息；（3）函数调用栈。</p>
<p>&emsp;针对数据内容，进一步调研后发现，<code>com.android.org.conscrypt.ConscryptFileDescriptorSocket$SSLInputStream.read()</code> （数据接收）与 <code>com.android.org.conscrypt.ConscryptFileDescriptorSocket$SSLOutputStream.write()</code>（数据发送）会调用 SSL 成员所在类的函数，即 <code>ssl.read</code> 与 <code>ssl.write</code>，跟踪之后发现 <code>ssl</code> 实际上是 <code>sslWrapper</code> 类型的的对象，因此，我们最终在 <code>sslWrapper</code> 中实现源码修改，从而完成沙箱的自吐。</p>
<p>&emsp;针对地址信息，使用 objection 的 WallBreaker 插件查看 sslWrapper 类的实例信息，发现其多个成员（例如 <code>handshakeCallbacks</code> 成员）的值与 socket 成员起到的作用一致（上文中使用 <code>this.socket.value.getRemoteSocketAddress()</code> 获取地址信息），因此此问题解决。</p>
<p>&emsp;针对打印调用栈的问题，与 <code>未加密</code> 数据的处理方法相同。最终，修改的源代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SslWrapper.java</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">write</span><span class="params">(FileDescriptor fd, <span class="type">byte</span>[] buf, <span class="type">int</span> offset, <span class="type">int</span> len, <span class="type">int</span> timeoutMillis)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">if</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">byte</span>[] input = <span class="keyword">new</span> <span class="title class_">byte</span>[len];</span><br><span class="line">        System.arraycopy(buf, offset, input, <span class="number">0</span>, len);</span><br><span class="line">        <span class="type">String</span> <span class="variable">inputString</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(input);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取 Log.e 函数</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">logClass</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            logClass = <span class="built_in">this</span>.getClass().getClassLoader().loadClass(<span class="string">&quot;android.util.Log&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Method</span> <span class="variable">loge</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            loge = logClass.getMethod(<span class="string">&quot;e&quot;</span>, String.class, String.class);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 打印目的地址信息</span></span><br><span class="line">            loge.invoke(<span class="literal">null</span>, <span class="string">&quot;wd2711SSLrequest&quot;</span>, <span class="string">&quot;SSL is =&gt; &quot;</span> + <span class="built_in">this</span>.handshakeCallbacks.toString());</span><br><span class="line">            <span class="comment">// 打印 SSL 要加密的信息</span></span><br><span class="line">            loge.invoke(<span class="literal">null</span>, <span class="string">&quot;wd2711SSLrequest&quot;</span>, <span class="string">&quot;buffer is =&gt; &quot;</span> + inputString);</span><br><span class="line">            <span class="comment">// 打印函数调用栈</span></span><br><span class="line">            <span class="type">Exception</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;wd2711SSLrequest&quot;</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 原始函数，调用 SSL_write native 层的代码</span></span><br><span class="line">    NativeCrypto.SSL_write(ssl, fd, handshakeCallbacks, buf, offset, len, timeoutMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;<code>最终编译出不带 root 的系统，运行后 Log 会存放到某个 txt 中</code>。这是因为，我们可以使用 crypto_filter_aosp，注入到 ROM，并监控我们想要的 app，之后，将 android 的 SslWrapper.java 修改为上述代码，之后，输出的 log 就可以存放到某个 txt 中。</p>
<h3 id="使用沙箱辅助中间人抓包"><a href="#使用沙箱辅助中间人抓包" class="headerlink" title="使用沙箱辅助中间人抓包"></a>使用沙箱辅助中间人抓包</h3><p>&emsp;前面所提出的技术，例如 r0capture 使用 frida 进行 SSL 层的抓包，修改系统源码实现 SSL 层的抓包（沙箱），但是对于采用自定义 SSL 框架进行通信的方式来说就行不通了。这类自定义的 SSL 框架（webview，小程序，flutter）不是依赖系统进行收发数据的，而是通过 App 自己进行收发数据的。此时，就需要进行中间人抓包。</p>
<p>&emsp;但是有很多对抗中间人抓包的方式，例如安卓自己的 API （Proxy.NO_PROXY 对抗 Wifi 代理抓包，getNetWorkCapabilities 检测 VPN 代理），服务器校验客户端，客户端校验服务器的方式。</p>
<p>&emsp;如何对上述手段进行反制呢？我们可以通过修改系统源码，生成沙箱来进行反制。</p>
<h4 id="HTTPS-抓包"><a href="#HTTPS-抓包" class="headerlink" title="HTTPS 抓包"></a>HTTPS 抓包</h4><p>&emsp;中间人抓包（只说对于 HTTPS）：对于需要 CA 认证成功才能通信的协议，例如 HTTPS，如果我们使用简单的 wifi 代理与 vpn 代理 （系统设置）来设置中间人，那么在访问网页的时候就会显示<code>您的链接不是私密链接</code>警告。为了解决这个问题，我们可以使用其他代理软件，例如 charles，并将其相应的证书文件放到<code>用户信任的凭据空间</code>与<code>安卓系统信任的凭据空间</code>中。这需要使用 mount 指令将系统分区设置为可写后，才能进行放置，也就是说，需要 root 权限。</p>
<p>&emsp;那么对于非 root 环境如何做呢？答案是：<code>将 charles 证书文件转换为安卓系统能识别的形式，并放置到系统证书在源码中的对应目录下即可。</code></p>
<p>（1）将证书转为安卓系统能识别的形式。安装 charles 证书，这样的话证书会被放置在用户信任的凭据空间中，这样就变成了安卓系统能识别的形式，即<code>xxx.0</code>。</p>
<p>（2）将证书放置到系统证书在源码下的对应目录。对应目录为<code>/system/ca-certificates/google/files/</code>，移动后确认证书所属用户/用户组/对应权限都与其他证书一致（<code>ls -alit</code>）即可。</p>
<p>&emsp;放到系统信任的凭据空间之后，即使是抓取 HTTPs 数据，也不会报警告。</p>
<h4 id="对抗服务器校验客户端和-SSL-pinning-的问题"><a href="#对抗服务器校验客户端和-SSL-pinning-的问题" class="headerlink" title="对抗服务器校验客户端和 SSL pinning 的问题"></a>对抗服务器校验客户端和 SSL pinning 的问题</h4><p>&emsp;服务器校验客户端，指的是服务器在与客户端进行通信时，会在握手阶段验证客户端使用证书的公钥。但是当使用中间人进行抓包时，与服务器进行通信的是 charles 抓包软件，其使用的证书就不是服务端认证的证书文件。<code>具体来说，手机安装 app 后，会一并安装 app 自带的证书，服务器就要验证这个证书。代理软件一般是没有这个 app 自带的证书的，所以服务器验证客户端就会失败</code>。</p>
<p>&emsp;绕过思路也比较简单：<code>在 app 中找到相应的证书文件与对应密码（打开证书的密码），转为 P12 格式的证书，最终导入到代理软件中，以欺骗服务器</code>。</p>
<p>&emsp;客户端（手机、代理软件）想要与特定证书与服务器通信，就要用密码打开证书。开发者通常使用 KeyStore(InputStream, char[]) 函数使用密码打开证书，我们可以 hook 该函数，从而 dump 证书文件与相应密码。具体 hook 脚本如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// saveClientCer.js</span></span><br><span class="line"><span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="title class_">StringClass</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.lang.String&quot;</span>);</span><br><span class="line">    <span class="keyword">var</span> <span class="title class_">KeyStore</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.security.KeyStore&quot;</span>);</span><br><span class="line">    <span class="comment">// KeyStore.load(InputStream, char[])</span></span><br><span class="line">    <span class="title class_">KeyStore</span>.<span class="property">load</span>.<span class="title function_">overload</span>(<span class="string">&quot;java.io.InputStream&quot;</span>, <span class="string">&quot;[C&quot;</span>).<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params">arg0, arg1</span>)&#123;</span><br><span class="line">        <span class="comment">// 打印堆栈</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;android.util.Log&quot;</span>).<span class="title function_">getStackTraceString</span>(<span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.lang.Throwable&quot;</span>).$new()));</span><br><span class="line">        <span class="comment">// arg1 为证书密钥</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;KeyStore.load2:&quot;</span>, arg0, arg1 ? <span class="title class_">StringClass</span>.$new(arg1) : <span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (arg0) &#123;</span><br><span class="line">            <span class="comment">// 将证书（加密的证书）保存到 /sdcard/Download/ 目录下</span></span><br><span class="line">            <span class="keyword">var</span> file = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.io.File&quot;</span>).$new(<span class="string">&quot;/sdcard/Download/&quot;</span> + <span class="title class_">String</span>(arg0) + <span class="string">&quot;.p12&quot;</span>);</span><br><span class="line">            <span class="keyword">var</span> out = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.io.FileOutputStream&quot;</span>).$new(file);</span><br><span class="line">            <span class="keyword">var</span> r;</span><br><span class="line">            <span class="keyword">while</span> ((r = arg0.<span class="title function_">read</span>(buffer)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                out.<span class="title function_">write</span>(buffer, <span class="number">0</span>, r);</span><br><span class="line">            &#125;</span><br><span class="line">            out.<span class="title function_">close</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">load</span>(arg0, arg1);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>&emsp;因此，我们可以使用 frida hook 到证书文件与密码，使用 keyStore Explorer 查看证书文件，并用密码进行解密，就可以查看证书的各种信息（书中说可以查看到证书私钥，我存疑）。之后，将证书文件导入到代理软件（例如 charles）（我理解应该也导入密码），就可以进行上网。我们也可以通过修改系统源码 hook 到证书文件与密码，具体而言是 hook java/security/KeyStore.java 中的 load 函数，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">load</span><span class="params">(InputStream stream, <span class="type">char</span>[] password)</span> <span class="keyword">throws</span> IOException, NoSuchAlgorithmException, CertificateException &#123;</span><br><span class="line">    <span class="keyword">if</span> (password != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">inputPASSWORD</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(password);</span><br><span class="line">        <span class="comment">// import Log class</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">logClass</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            logClass = <span class="built_in">this</span>.getClass().getClassLoader().loadClass(<span class="string">&quot;android.util.Log&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// import Log.e function</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">loge</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            loge = logClass.getMethod(<span class="string">&quot;e&quot;</span>, String.class, String.class);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// log password and call stack</span></span><br><span class="line">            loge.invoke(<span class="literal">null</span>, <span class="string">&quot;KeyStoreLoad&quot;</span>, <span class="string">&quot;KeyStore load PASSWORD is =&gt; &quot;</span> + inputPASSWORD);</span><br><span class="line">            <span class="type">Exception</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;KeyStoreLoad&quot;</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">	    <span class="comment">// write stream into file</span></span><br><span class="line">        <span class="type">Date</span> <span class="variable">now</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        <span class="type">String</span> <span class="variable">currentTime</span> <span class="operator">=</span> String.valueOf(now.getTime());</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;/sdcard/Download/&quot;</span> + inputPASSWORD + currentTime);</span><br><span class="line">        <span class="type">byte</span>[] b = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> length;</span><br><span class="line">        <span class="keyword">while</span> ((length = stream.read(b)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            fos.write(b, <span class="number">0</span>, length);</span><br><span class="line">        &#125;</span><br><span class="line">        fos.flush();</span><br><span class="line">        fos.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    keyStoreSpi.engineLoad(stream, password);</span><br><span class="line">    initialized = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;但是对证书的 dump 会报错，因此使用 Objection trace 与 keystore 相关的类（打开样本 apk 时调用 keystore 的哪些函数），从而找到其他更通用的函数。之后，使用 wallbreaker 查看函数中对象的数据结构，发现 java.security.KeyStore$PrivateKeyEntry 对象中存在证书信息。</p>
<p>&emsp;我们还了解到，如果知道证书链信息与 privatekey 之后，就可以将证书保存在文件中，具体是用 <code>storeP12(PrivateKey sk, String p7, String p12Path, String p12Password)</code>。其中，sk 指的是 privatekey，p7 指的是证书链，p12Path 是将证书导出到哪里，p12Password 指的是证书密码（用户指定）。此函数的在源码中的代码路径我并未找到。</p>
<p>&emsp;使用 Objection 对类 KeyStore$PrivateKeyEntry 中的函数进行 trace，来查看哪些函数在<code>服务端验证客户端</code>的流程中被调用，发现会调用 getPrivateKey() 与 getCertificateChain() 函数。之后，使用 frida 进行简单测试，具体而言，就是使用 js 重写了 <code>KeyStore$PrivateKeyEntry.getPrivateKey</code>与<code>KeyStore$PrivateKeyEntry.getCertificateChain</code>，然后注入到了样本中。</p>
<p>&emsp;与之前 hook KeyStore.load 相比，这种方法是 dump 成功的。<code>KeyStore.load 中 dump 失败的原因不详。</code>在 getPrivateKey 与 getCertificateChain 中进行 dump 时，我们可以自定义证书的密码，而在 KeyStore.load 中是不行的。</p>
<p>&emsp;最后，我们在源码中修改 getPrivateKey 与 getCertificateChain：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// KeyStore-PrivateEntry.java</span></span><br><span class="line"><span class="keyword">public</span> PrivateKey <span class="title function_">getPrivateKey</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">p12Password</span> <span class="operator">=</span> <span class="string">&quot;wd2711&quot;</span>;</span><br><span class="line">    <span class="type">Date</span> <span class="variable">now</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">    <span class="type">String</span> <span class="variable">currentTime</span> <span class="operator">=</span> String.valueOf(now.getTime());</span><br><span class="line">    <span class="type">String</span> <span class="variable">p12Path</span> <span class="operator">=</span> <span class="string">&quot;/sdcard/Download/tmp&quot;</span>  + currentTime + <span class="string">&quot;.p12&quot;</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 初始化证书链</span></span><br><span class="line">    <span class="type">X509Certificate</span> <span class="variable">p7X509</span> <span class="operator">=</span> (X509Certificate) chain[<span class="number">0</span>];</span><br><span class="line">    Certificate[] mychain = <span class="keyword">new</span> <span class="title class_">Certificate</span>[]&#123;p7X509&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 生成一个空的 p12 证书</span></span><br><span class="line">    <span class="type">KeyStore</span> <span class="variable">myks</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        myks = KeyStore.getInstance(<span class="string">&quot;PKCS12&quot;</span>, <span class="string">&quot;BC&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (KeyStoreException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchProviderException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        myks.load(<span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CertificateException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置此证书的 privatekey 以及相应的自定义的 password，原来的密码可能不是这个，这里更改了</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        myks.setKeyEntry(<span class="string">&quot;client&quot;</span>, privKey, p12Password.toCharArray(), mychain);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (KeyStoreException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用自定义的密码加密保存 p12 证书，证书已经保存在 p12Path 中</span></span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">fOut</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        fOut = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(p12Path);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        myks.store(fOut, p12Password.toCharArray());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (KeyStoreException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> privKey;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;以上解决<code>服务端验证客户端</code>时出现的问题，但是如果证书内容被硬编码到代码中，就可能绕过上述说的相关函数，例如 keyStore.load。</p>
<p>&emsp;<code>客户端校验服务器</code>的过程与 SSL Pinning 有关。SSL pinning 意思就是<code>客户端校验当前使用的证书是不是特定证书，其实是在 app 层面对证书进行校验</code>。相关的 SSL pinning 绕过工具为：Objection的 SSL pinning bypass、FridaContainer、DroidSSLUnpinning，这些工具的原理就是对 app 中的证书校验代码部分进行 patch。</p>
<p>&emsp;对于系统源码来说，我们无法直接干预这个过程，但是由于 SSL pinning 的校验流程都会有<code>打开证书、进行哈希</code>这两个步骤，因此我们可以监控文件打开的操作，从而绕过 SSL pinning 校验。通过 objection hook Java.io.File 类的构造函数 <code>$init</code>，最后发现证书校验函数所在的类总是调用<code>java.io.File.$init(File, String)</code>这样一个函数重载，第二个参数是<code>.0</code>格式的证书名。因此，我们对<code>java.io.File.$init(File, String)</code>函数使用 frida 进行 hook，通过打印调用栈后发现，<code>并不是所有证书都会进行校验</code>。而对于进行校验的证书来说，其调用栈中都会存在<code>X509TrustManagerExtensions.checkServerTrusted</code>函数。</p>
<p>&emsp;因此，我们可以在源码的 file 类中打印调用栈中有<code>X509TrustManagerExtensions.checkServerTrusted</code>函数的调用栈信息，因此，我们就<code>可以得到 apk 中进行 SSL pinning 校验的相关函数名，从而进行下一步操作</code>。总的来说，绕过 SSL pinning 的基础是假定 app 会通过打开证书文件以及调用栈中会包含<code>X509TrustManagerExtensions.checkServerTrusted</code>函数，这其实是可以反绕过的。</p>
<h3 id="风控对抗-设备信息篡改"><a href="#风控对抗-设备信息篡改" class="headerlink" title="风控对抗-设备信息篡改"></a>风控对抗-设备信息篡改</h3><p>&emsp;风险控制，即在电子支付或其他场景下保护甲方产品免受利益损失，其与黑产相对立。风控判断用户的真实性往往是通过用户是否使用真实的设备来进行，本节主要是使用沙箱的方式，不切换真实设备，通过修改源码来让 app 认为是两台设备。</p>
<p>&emsp;设备的相关信息（设备指纹/设备名称/设备型号）都是通过 android.os.Build 类中的成员值得到的。在安卓开发中，要获取此类中的值，直接访问该类即可。通过查看 android.os.Build 的构造源码，可以发现好多信息，例如 ID/DEVICE/BOARD 都是通过 getString(“ro.build.xxx”) 来得到的。</p>
<p>&emsp;通过跟踪 getString 函数，最终可以发现实际上 getString 调用了 native 层的 <code>__system_property_get()</code>函数，此函数位于 <code>bionic/libc/bionic/system_properties.cpp</code>中，属于 libc 基础库的内容。<code>__system_property_get()</code>已经是最底层的了，该函数通过与 property_service_socket 设备进行 socket 通信来获取具体的属性值。某些黑产通过修改 ROM（即修改<code>__system_property_get()</code>代码），来修改返回值。</p>
<p>&emsp;本节则是修改 getString 函数，修改方式很简单，就是修改源码即可，其是 android.os.Build 类中的函数。Build 类中大部分信息无法表示设备的唯一性，用来表示唯一性的有：<code>IMEI（国际移动设备识别码）、IMSI（国际移动用户识别码）、Android_id、SN</code>。</p>
<p>&emsp;IMEI 是设备的唯一标识，由 15 位数字组成。开发者需要用 <code>TelephonyManager.getDeviceID/getImei</code>来获得，当然需要在 androidManifest.xml 中声明一些权限，我们可以在 <code>frameworks/base/telephony/java/android/teltephony/TelephonyManager.java</code>中修改这两个函数的返回值，从而让开发者分不清两个设备。</p>
<p>&emsp;IMSI 是移动网络中区分不同用户的识别码，其存储在 SIM 卡中，由 15 位数字组成。IMSI 由<code>移动国家号码（MCC）、移动网络号码（MNC）、移动用户识别号码（MSIN）链接</code>而成。中国的 MCC 为 460，中国移动的 MNC 是 00。开发者需要用 <code>TelephonyManager.getSubscriberId</code>来获得，也需要在 androidManifest.xml 中声明一些权限。</p>
<p>&emsp;Android_id 是设备第一次启动时产生与存储的 64 bit 数，也叫做 SSAID（Settings.Secure.ANDROID_ID）。此值只有在设备被刷机或者恢复出厂设置时才会被修改。在 android 8 及以上版本，每一个 app 在第一次安装时都会根据 app 签名 + 设备信息生成针对于 app 的 android_id。因此，不同的 app 所拿到的 android_id 是不一样的。不同于 IMEI 与 IMSI，拿到 android_id 不需要任何权限。获取代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> android.provider.Settings;</span><br><span class="line"><span class="type">String</span> <span class="variable">android_id</span> <span class="operator">=</span> Settings.Secure.getString(getContentResolver(),</span><br><span class="line">                                             Settings.Secure.ANDROID_ID);</span><br></pre></td></tr></table></figure>
<p>&emsp;看一下 Settings.Secure.getString 的源码，并修改它，让它返回自定义的值。</p>
<p>&emsp;SN（serial number）就是 build 类中的 SERIAL 成员，它是手机生产厂商提供的设备序列号，是为了验证产品的合法而存在的，其格式由生产厂商自定义。也需要在 androidManifest.xml 中声明一些权限，通过 Build.getSerial（android 8-10）来获取 SN 号，还可以在 adb shell 中以 <code>getprop ro.serialno</code>获取。</p>
<p>&emsp;<code>真实黑产不可能这么简单</code>。</p>
<p>&emsp;总结一下，如果 app 想实现不被系统底层窥探，则要尽量将所有关键功能交由自身应用实现，减少对系统的依赖，例如<code>自实现虚拟机，不依赖于 art 虚拟机解析指令；自定义 openssl 库</code>，而不是简单的使用系统 api。</p>

  
	</div>

	<div>
  	<center>
	<div class="pagination">

    
    
    <a href="/2023/10/29/ACTF-2023/" type="button" class="btn btn-default"><i
                class="fa fa-arrow-circle-o-left"></i> 上一页</a>
    

    <a href="/" type="button" class="btn btn-default"><i class="fa fa-home"></i>Home</a>
    
    <a href="/2023/10/21/N1CTF-2023/" type="button" class="btn btn-default ">下一页<i
                class="fa fa-arrow-circle-o-right"></i></a>
    

    
</div>

    </center>
	</div>


	<!-- comment -->
	
<section id="comment">
    <h2 class="title">留言</h2>

    <!-- 
    <div id="disqus_thread" class="ds-thread">
        <script type="text/javascript">
            /**
             * RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
             * LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
             */
                /*
                 var disqus_config = function () {
                 this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable
                 this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
                 };
                 */
            (function() { // DON'T EDIT BELOW THIS LINE
                var d = document, s = d.createElement('script');

                s.src = 'https://https-wd-2711-tech.disqus.com/embed.js';

                s.setAttribute('data-timestamp', +new Date());
                (d.head || d.body).appendChild(s);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="//disqus.com/?ref_noscript">comments powered by
                Disqus.</a></noscript>
    </div> -->
    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
    <div id="vcomments"></div>
    <script>
        new Valine({
            el: '#vcomments',
            appId: 'wLIJ70s3fPvW8WJPgVVAuWVR-gzGzoHsz',
            appKey: 'NVGqxhUkqtFv2CbwmXXWjCdR'
        })
    </script>

    
</section>


	</div> <!-- col-md-9/col-md-12 -->
		
	
	<div id="side_meta">
		<div class="col-md-3" id="post_meta"> 

	<!-- date -->
	
	<div class="meta-widget">
	<i class="fa fa-clock-o"></i>
	2023-10-22 
	</div>
	

	<!-- categories -->
    
	<div class="meta-widget">
	<a data-toggle="collapse" data-target="#categorys"><i class="fa fa-folder"></i></a>	
    <ul id="categorys" class="tag_box list-unstyled collapse in">
          
  <li>
    <li><a href="/categories/re-book/">re-book<span>11</span></a></li>
  </li>

    </ul>
	</div>
	

	<!-- tags -->
		

	<!-- toc -->
	<div class="meta-widget">
	
	   <a data-toggle="collapse" data-target="#toc"><i class="fa fa-bars"></i></a>
	   <div id="toc" class="toc collapse in">
		   <span class="toc-title">Contents</span>
			<ol class="toc-article"><li class="toc-article-item toc-article-level-1"><a class="toc-article-link" href="#Frida%E9%80%86%E5%90%91%E4%B8%8E%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90-3"><span class="toc-article-text">Frida逆向与协议分析-3</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#0x05-Android%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91%E4%B8%8EXposed%E9%AD%94%E6%94%B9"><span class="toc-article-text">0x05 Android源码编译与Xposed魔改</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#Android%E6%BA%90%E7%A0%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA"><span class="toc-article-text">Android源码环境搭建</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#Xposed%E5%AE%9A%E5%88%B6"><span class="toc-article-text">Xposed定制</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85"><span class="toc-article-text">相关知识补充</span></a></li></ol></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#0x06-Android%E6%B2%99%E7%AE%B1%E4%B9%8B%E5%8A%A0%E8%A7%A3%E5%AF%86%E5%BA%93%E2%80%9C%E8%87%AA%E5%90%90%E2%80%9D"><span class="toc-article-text">0x06 Android沙箱之加解密库“自吐”</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E8%87%AA%E5%90%90%E6%B2%99%E7%AE%B1%E7%9A%84%E5%BB%BA%E7%AB%8B"><span class="toc-article-text">自吐沙箱的建立</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#crypto-filter-aosp-%E9%A1%B9%E7%9B%AE%E7%A7%BB%E6%A4%8D"><span class="toc-article-text">crypto_filter_aosp 项目移植</span></a></li></ol></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#0x07-Android%E6%B2%99%E7%AE%B1%E5%BC%80%E5%8F%91%E4%B9%8B%E7%BD%91%E7%BB%9C%E5%BA%93%E4%B8%8E%E7%B3%BB%E7%BB%9F%E5%BA%93%E2%80%9C%E8%87%AA%E5%90%90%E2%80%9D"><span class="toc-article-text">0x07 Android沙箱开发之网络库与系统库“自吐”</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E5%9F%BA%E4%BA%8E-r0capture-%E7%9A%84%E6%BA%90%E7%A0%81%E6%B2%99%E7%AE%B1%E7%BD%91%E7%BB%9C%E5%BA%93%E2%80%9C%E8%87%AA%E5%90%90%E2%80%9D"><span class="toc-article-text">基于 r0capture 的源码沙箱网络库“自吐”</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E4%BD%BF%E7%94%A8%E6%B2%99%E7%AE%B1%E8%BE%85%E5%8A%A9%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%8A%93%E5%8C%85"><span class="toc-article-text">使用沙箱辅助中间人抓包</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#HTTPS-%E6%8A%93%E5%8C%85"><span class="toc-article-text">HTTPS 抓包</span></a></li><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#%E5%AF%B9%E6%8A%97%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A0%A1%E9%AA%8C%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%92%8C-SSL-pinning-%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-article-text">对抗服务器校验客户端和 SSL pinning 的问题</span></a></li></ol></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E9%A3%8E%E6%8E%A7%E5%AF%B9%E6%8A%97-%E8%AE%BE%E5%A4%87%E4%BF%A1%E6%81%AF%E7%AF%A1%E6%94%B9"><span class="toc-article-text">风控对抗-设备信息篡改</span></a></li></ol></li></ol></li></ol>
		</div>
	
	</div>
	
    <hr>
	
</div><!-- col-md-3 -->

	</div>

	<!-- copyright -->
	<div>
    <ul class="post-copyright">
      <li class="post-copyright-author">
      <strong>作者:  </strong>wd-z711</a>
      </li>
      <li class="post-copyright-link">
      <strong>文章链接:  </strong>
      <a href="/" target="_blank" title="">https://wd-2711.tech/</a>
      </li>
      <li class="post-copyright-license">
        <strong>版权声明:   </strong>
        本博客所有文章除特别声明外，均采用 <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)">CC BY-NC-ND 4.0</a>
        许可协议。转载请注明出处!
      </li>
    </ul>
  <div>
 	

		


</div><!-- row -->




	</div>
  </div>
  <div class="container-narrow">
  <footer> <p>
  &copy; 2024 wd-z711
  
      <!-- with help from <a href="http://hexo.io/" target="_blank">Hexo</a>,<a target="_blank" rel="noopener" href="http://github.com/wzpan/hexo-theme-freemind/">Freemind</a>,<a href="http://getbootstrap.com/" target="_blank">Twitter Bootstrap</a> and <a href="http://getbootstrap.com/" target="_blank">BOOTSTRA.386</a>. 
     <br> Theme by <a target="_blank" rel="noopener" href="http://github.com/wzpan/hexo-theme-freemind/">Freemind.386</a>.     -->

     <!-- <script type="text/javascript">
      (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
      (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
      e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
      })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');
      
      _st('install','aB-vgeB8gEDrnRJuhceL','2.0.0');
    </script> -->
    </p>
 </footer>
</div> <!-- container-narrow -->
  


  
<a id="gotop" href="#">   
  <span>⬆︎TOP</span>
</a>

<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/bootstrap.min.js"></script>
<script src="/js/main.js"></script>
<script src="/js/search.js"></script> 


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>



   <script type="text/javascript">      
     var search_path = "search.xml";
	 if (search_path.length == 0) {
	 	search_path = "search.xml";
	 }
	 var path = "/" + search_path;
     searchFunc(path, 'local-search-input', 'local-search-result');
   </script>

</body>
   </html>
