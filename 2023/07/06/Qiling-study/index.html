<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="pragma" content="no-cache">
  <meta http-equiv="cache-control" content="no-cache">
  <meta http-equiv="expires" content="0">
  
  <title>Qiling-study | wd-z711&#39;s B10g</title>
  <meta name="author" content="wd-z711">
  
  <meta name="description" content="Qiling study note. It mainly talk about a program about some challenges. When you overcome it, you will master this skill.">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="Qiling-study"/>
  <meta property="og:site_name" content="wd-z711&#39;s B10g"/>

  
    <meta property="og:image" content=""/>
  

  
  
    <link href="/favicon.png" rel="icon">
  
  
  <link rel="stylesheet" href="/css/bootstrap.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/font-awesome.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/responsive.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/google-fonts.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

  <script src="/js/jquery-2.0.3.min.js"></script>

  <!-- analytics -->
  
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'G-YHJSKZDC3Y', 'auto');
  ga('send', 'pageview');
</script>




<meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="wd-z711's B10g" type="application/atom+xml">
</head>

 <body>  
  <nav id="main-nav" class="navbar navbar-inverse navbar-fixed-top" role="navigation">
    <div class="container">
      <button type="button" class="navbar-header navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
		<span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
	  <a class="navbar-brand" href="/">wd-z711&#39;s B10g</a>
      <div class="collapse navbar-collapse nav-menu">
		<ul class="nav navbar-nav">
		  
		  <li>
			<a href="/archives" title="All the articles.">
			  <i class="fa fa-archive"></i>Archives
			</a>
		  </li>
		  
		  <li>
			<a href="/categories" title="All the categories.">
			  <i class="fa fa-folder"></i>Categories
			</a>
		  </li>
		  
		  <li>
			<a href="/about" title="About me.">
			  <i class="fa fa-user"></i>About
			</a>
		  </li>
		  
		</ul>
      </div>
    </div> <!-- container -->
</nav>
<div class="clearfix"></div>

  <div class="container">
  	<div class="content">
    	 


	
		<div class="page-header">
			<h1> Qiling-study</h1>
		</div>
	



<div class="row post">

	<!-- cols -->
	
	<div id="top_meta"></div>
	<div class="col-md-9">
	

	<!-- content -->
	<div class="mypage">		
	  
		 <div class="alert alert-success description">
			<i class="fa fa-info-circle"></i> Qiling study note. It mainly talk about a program about some challenges. When you overcome it, you will master this skill.
		 </div> <!-- alert -->
	  		

	  <h1 id="Qiling框架学习"><a href="#Qiling框架学习" class="headerlink" title="Qiling框架学习"></a>Qiling框架学习</h1><p>&emsp;前几天在看雪公众号上看到这篇文章：<a target="_blank" rel="noopener" href="https://bbs.kanxue.com/thread-277412.htm">Qiling框架分析实战</a>，当时简单看了看开头，应该是<code>IOT</code>漏洞利用的一个执行框架，感觉和我之后想干的很契合，所以打算学习学习。</p>
<p>&emsp;<code>Qiling</code> 框架是基于 <code>unicorn</code> 的多架构平台模拟执行框架，能够在模拟执行的基础上提供统一的分析 API，可以进行插桩分析、快照、系统调用和API劫持等操作。Joansivion提供了能够针对<code>Qiling</code>框架进行学习的<a target="_blank" rel="noopener" href="https://joansivion.github.io/qilinglabs/">程序</a>，并提供了相应的writeup。他提供的 writeup 是 arm 架构的。<strong>本文也是对其提供的程序进行分析，但是提供的题解是x86_64的。</strong></p>
<span id="more"></span>
<p>&emsp;Joansivion提供的程序包括11个挑战，分为<a target="_blank" rel="noopener" href="https://www.shielder.com/attachments/qilinglab-x86_64">x86_64</a>版本与<a target="_blank" rel="noopener" href="https://www.shielder.com/attachments/qilinglab-aarch64">aarch64</a>版本。本文主要针对<code>x86_64</code>，其挑战如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Welcome to QilingLab.</span><br><span class="line">Here is the list of challenges:</span><br><span class="line">Challenge 1: Store 1337 at pointer 0x1337.</span><br><span class="line">Challenge 2: Make the &#x27;uname&#x27; syscall return the correct values.</span><br><span class="line">Challenge 3: Make &#x27;/dev/urandom&#x27; and &#x27;getrandom&#x27; &quot;collide&quot;.</span><br><span class="line">Challenge 4: Enter inside the &quot;forbidden&quot; loop.</span><br><span class="line">Challenge 5: Guess every call to rand().</span><br><span class="line">Challenge 6: Avoid the infinite loop.</span><br><span class="line">Challenge 7: Don&#x27;t waste time waiting for &#x27;sleep&#x27;.</span><br><span class="line">Challenge 8: Unpack the struct and write at the target address.</span><br><span class="line">Challenge 9: Fix some string operation to make the iMpOsSiBlE come true.</span><br><span class="line">Challenge 10: Fake the &#x27;cmdline&#x27; line file to return the right content.</span><br><span class="line">Challenge 11: Bypass CPUID/MIDR_EL1 checks.</span><br><span class="line"></span><br><span class="line">挑战1：将 1337 存储在指针 0x1337 处。</span><br><span class="line">挑战2：使&#x27;uname&#x27;系统调用返回正确的值。</span><br><span class="line">挑战3：使 &#x27;/dev/urandom&#x27; 和 &#x27;getrandom&#x27; &#x27;碰撞&#x27;。</span><br><span class="line">挑战4：进入&#x27;禁止&#x27;循环。</span><br><span class="line">挑战5：猜测对 rand() 的每次调用。</span><br><span class="line">挑战6：避免无限循环。</span><br><span class="line">挑战7：不要浪费时间等待&#x27;sleep&#x27;。</span><br><span class="line">挑战8：解压结构体并写入目标地址。</span><br><span class="line">挑战9：修复一些字符串操作以使iMpOsSiBlE成为现实。</span><br><span class="line">挑战10：伪造&#x27;cmdline&#x27;行文件以返回正确的内容。</span><br><span class="line">挑战11：绕过&#x27;CPUID/MIDR_EL1&#x27;检查。</span><br></pre></td></tr></table></figure>
<p>&emsp;使用<code>qiling</code>运行一下<code>x86_64</code>，显示错误：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> qiling <span class="keyword">import</span> *</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    path = [<span class="string">&quot;qilinglab-x86_64&quot;</span>]</span><br><span class="line">    rootfs = <span class="string">&quot;./qiling/examples/rootfs/x8664_linux&quot;</span></span><br><span class="line">    ql = Qiling(path, rootfs)</span><br><span class="line">    ql.run()</span><br><span class="line"><span class="comment"># [=] 	brk(inp = 0x0) = 0x55555575a000</span></span><br><span class="line"><span class="comment"># [=] 	uname(buf = 0x80000000d9b0) = 0x0</span></span><br><span class="line"><span class="comment"># [=] 	access(path = 0x7ffff7df6082, mode = 0x0) = -0x1 (EPERM)</span></span><br><span class="line"><span class="comment"># [=] 	access(path = 0x7ffff7df8dd0, mode = 0x4) = -0x1 (EPERM)</span></span><br><span class="line"><span class="comment"># [=] 	openat(fd = 0xffffff9c, path = 0x7ffff7df6428, flags = 0x80000, mode = 0x0) = -0x2 (ENOENT)</span></span><br><span class="line"><span class="comment"># [=] 	openat(fd = 0xffffff9c, path = 0x80000000d340, flags = 0x80000, mode = 0x0) = -0x2 (ENOENT)</span></span><br><span class="line"><span class="comment"># [=] 	stat(path = 0x80000000d340, buf_ptr = 0x80000000d400) = -0x2 (ENOENT)</span></span><br><span class="line"><span class="comment"># [=] 	openat(fd = 0xffffff9c, path = 0x80000000d340, flags = 0x80000, mode = 0x0) = -0x2 (ENOENT)</span></span><br><span class="line"><span class="comment"># [=] 	stat(path = 0x80000000d340, buf_ptr = 0x80000000d400) = -0x2 (ENOENT)</span></span><br><span class="line"><span class="comment"># [=] 	openat(fd = 0xffffff9c, path = 0x80000000d340, flags = 0x80000, mode = 0x0) = -0x2 (ENOENT)</span></span><br><span class="line"><span class="comment"># [=] 	stat(path = 0x80000000d340, buf_ptr = 0x80000000d400) = -0x2 (ENOENT)</span></span><br><span class="line"><span class="comment"># [=] 	openat(fd = 0xffffff9c, path = 0x80000000d340, flags = 0x80000, mode = 0x0) = -0x2 (ENOENT)</span></span><br><span class="line"><span class="comment"># [=] 	stat(path = 0x80000000d340, buf_ptr = 0x80000000d400) = -0x2 (ENOENT)</span></span><br><span class="line"><span class="comment"># [=] 	openat(fd = 0xffffff9c, path = 0x80000000d340, flags = 0x80000, mode = 0x0) = -0x2 (ENOENT)</span></span><br><span class="line"><span class="comment"># [=] 	stat(path = 0x80000000d340, buf_ptr = 0x80000000d400) = -0x2 (ENOENT)</span></span><br><span class="line"><span class="comment"># [=] 	openat(fd = 0xffffff9c, path = 0x80000000d340, flags = 0x80000, mode = 0x0) = -0x2 (ENOENT)</span></span><br><span class="line"><span class="comment"># [=] 	stat(path = 0x80000000d340, buf_ptr = 0x80000000d400) = -0x2 (ENOENT)</span></span><br><span class="line"><span class="comment"># [=] 	openat(fd = 0xffffff9c, path = 0x80000000d340, flags = 0x80000, mode = 0x0) = -0x2 (ENOENT)</span></span><br><span class="line"><span class="comment"># [=] 	stat(path = 0x80000000d340, buf_ptr = 0x80000000d400) = -0x2 (ENOENT)</span></span><br><span class="line"><span class="comment"># [=] 	openat(fd = 0xffffff9c, path = 0x80000000d340, flags = 0x80000, mode = 0x0) = -0x2 (ENOENT)</span></span><br><span class="line"><span class="comment"># [=] 	stat(path = 0x80000000d340, buf_ptr = 0x80000000d400) = -0x2 (ENOENT)</span></span><br><span class="line"><span class="comment"># [=] 	openat(fd = 0xffffff9c, path = 0x80000000d340, flags = 0x80000, mode = 0x0) = -0x2 (ENOENT)</span></span><br><span class="line"><span class="comment"># [=] 	stat(path = 0x80000000d340, buf_ptr = 0x80000000d400) = -0x2 (ENOENT)</span></span><br><span class="line"><span class="comment"># [=] 	openat(fd = 0xffffff9c, path = 0x80000000d340, flags = 0x80000, mode = 0x0) = -0x2 (ENOENT)</span></span><br><span class="line"><span class="comment"># [=] 	stat(path = 0x80000000d340, buf_ptr = 0x80000000d400) = -0x2 (ENOENT)</span></span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"><span class="comment"># [x] 	0000007ffff7ffc000 - 0000007ffff7ffd000   r--     ld-linux-x86-64.so.2   /home/wd/Desktop/qiling/qiling/examples/rootfs/x8664_linux/lib64/ld-linux-x86-64.so.2</span></span><br><span class="line"><span class="comment"># [x] 	0000007ffff7ffd000 - 0000007ffff7fff000   rw-     ld-linux-x86-64.so.2   /home/wd/Desktop/qiling/qiling/examples/rootfs/x8664_linux/lib64/ld-linux-x86-64.so.2</span></span><br><span class="line"><span class="comment"># [x] 	0000007ffffffde000 - 00000080000000e000   rwx     [stack]                </span></span><br><span class="line"><span class="comment"># [x] 	00ffffffffff600000 - 00ffffffffff601000   rwx     [vsyscall]  </span></span><br><span class="line"><span class="comment"># UcError: Invalid memory read (UC_ERR_READ_UNMAPPED)</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>brk(inp = 0x0) = 0x55555575a000</code>：通过<code>brk()</code>系统调用请求增加堆内存的结果，其中<code>inp</code>参数为0，表示请求增加0字节的堆内存，返回值<code>0x55555575a000</code>表示堆内存的起始地址。</p>
</li>
<li><p><code>uname(buf = 0x80000000d9b0) = 0x0</code>：通过<code>uname()</code>系统调用获取系统信息的结果，其中<code>buf</code>参数表示用于存储系统信息的缓冲区的地址，返回值<code>0x0</code>表示操作成功。</p>
</li>
<li><code>access(path = 0x7ffff7df6082, mode = 0x0) = -0x1 (EPERM)</code>：通过<code>access()</code>系统调用检查文件访问权限的结果，其中<code>path</code>参数表示要检查的文件路径，<code>mode</code>参数表示要检查的权限，返回值<code>-0x1</code>表示操作失败，错误码为<code>EPERM</code>，表示权限不允许。</li>
<li><code>openat(fd = 0xffffff9c, path = 0x7ffff7df6428, flags = 0x80000, mode = 0x0) = -0x2 (ENOENT)</code>：通过<code>openat()</code>系统调用打开文件的结果，其中<code>fd</code>参数表示文件描述符，<code>path</code>参数表示要打开的文件路径，<code>flags</code>参数表示打开文件的方式和行为，<code>mode</code>参数表示文件的权限，返回值<code>-0x2</code>表示操作失败，错误码为<code>ENOENT</code>，表示文件不存在。</li>
<li><code>stat(path = 0x80000000d340, buf_ptr = 0x80000000d400) = -0x2 (ENOENT)</code>：通过<code>stat()</code>系统调用获取文件状态的结果，其中<code>path</code>参数表示要获取状态的文件路径，<code>buf_ptr</code>参数表示用于存储状态信息的缓冲区的地址，返回值<code>-0x2</code>表示操作失败，错误码为<code>ENOENT</code>，表示文件不存在。该行出现了多次，表明程序尝试多次获取同一个文件的状态，但均返回了文件不存在的错误。</li>
</ul>
<p>&emsp;查看一下<code>qilinglab-x86_64</code>的头部信息（<code>-h</code>代表头部。）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">(base) wd@ubuntu:$ readelf -h qilinglab-x86_64 </span><br><span class="line">ELF Header:</span><br><span class="line">  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 </span><br><span class="line">  Class:                             ELF64</span><br><span class="line">  Data:                              2&#x27;s complement, little endian</span><br><span class="line">  Version:                           1 (current)</span><br><span class="line">  OS/ABI:                            UNIX - System V</span><br><span class="line">  ABI Version:                       0</span><br><span class="line">  Type:                              DYN (Shared object file)</span><br><span class="line">  Machine:                           Advanced Micro Devices X86-64</span><br><span class="line">  Version:                           0x1</span><br><span class="line">  Entry point address:               0xa80</span><br><span class="line">  Start of program headers:          64 (bytes into file)</span><br><span class="line">  Start of section headers:          15840 (bytes into file)</span><br><span class="line">  Flags:                             0x0             </span><br><span class="line">  Size of this header:               64 (bytes)</span><br><span class="line">  Size of program headers:           56 (bytes)</span><br><span class="line">  Number of program headers:         9</span><br><span class="line">  Size of section headers:           64 (bytes)</span><br><span class="line">  Number of section headers:         29</span><br><span class="line">  Section header string table index: 28</span><br></pre></td></tr></table></figure>
<p>&emsp;从<code>data</code>字段可以看出是小端序，从<code>flags</code>字段可以看出未裁剪符号表。</p>
<p>&emsp;查看一下文件类型，并显示符号链接的类型与其指向的文件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(base) wd@ubuntu:~/Desktop/qiling$ file -L qilinglab-x86_64 </span><br><span class="line">qilinglab-x86_64: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=76164e6b494c1af9d9f746e2dc7d3663cc23525c, not stripped</span><br></pre></td></tr></table></figure>
<p>&emsp;使用<code>ida7.7</code>查看<code>qilinglab-x86_64</code>。函数逻辑如下：</p>
<p>（1）循环初始化数组<code>v13</code>所有元素为0，如果完成对应<code>challenge1</code>就会改变<code>v13</code>对应数组的值，再用<code>checker</code>进行一次检查<code>v13</code>数组元素是否为<code>0</code>。最终，程序会输出完成的挑战数量，也就是数组<code>v13</code>中为1的个数。</p>
<h2 id="0x00-challenge1-修改内存地址"><a href="#0x00-challenge1-修改内存地址" class="headerlink" title="0x00 challenge1-修改内存地址"></a>0x00 challenge1-修改内存地址</h2><p><img src="/images/Qiling-study/image-20230706203020940.png" alt="image-20230706203020940" style="zoom:67%;" /></p>
<p>&emsp;其中<code>[rax]=v13[0]</code>，即我们想让<code>[0x1337] = 0x539 = 1337</code>。在<code>Qiling</code>中可以以多种方法编写字节序列：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 返回4字节的大端序字节序列，其中包含整数值 0x12345678 的二进制表示</span><br><span class="line"># &quot;&gt;I&quot;参数指定了这个字节序列的格式，其中&quot;&gt;&quot;表示大端序，&quot;&lt;&quot;表示小端序，&quot;I&quot;表示一个32位无符号整数</span><br><span class="line">ql.pack(&quot;&gt;I&quot;, 0x12345678)</span><br><span class="line"></span><br><span class="line"># 这个函数专门用于 16 位整数</span><br><span class="line">ql.pack16(0x1234)</span><br></pre></td></tr></table></figure>
<p>&emsp;因此，可以编写<code>challenage1-wp</code>，将<code>[0x1337]</code>指向的内存为<code>1337</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> qiling <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">challenge1</span>(<span class="params">ql</span>):</span><br><span class="line">    <span class="comment"># 以0x1000为起始，映射0x1000大小的数据，映射的大小必须是页大小的倍数，这里的页大小4096字节</span></span><br><span class="line">    <span class="comment"># info是对这部分内存做的一个标记，后续可以用这个标记来定位</span></span><br><span class="line">    ql.mem.<span class="built_in">map</span>(<span class="number">0x1000</span>, <span class="number">0x1000</span>, info = <span class="string">&#x27;[challenge1]&#x27;</span>)</span><br><span class="line">    <span class="comment"># 将整数值 1337 转换为一个16位字节写入内存地址 0x1337 所指定的内存位置，小端输入</span></span><br><span class="line">    ql.mem.write(<span class="number">0x1337</span>, ql.pack16(<span class="number">1337</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    path = [<span class="string">&quot;qilinglab-x86_64&quot;</span>]</span><br><span class="line">    rootfs = <span class="string">&quot;./qiling/examples/rootfs/x8664_linux&quot;</span></span><br><span class="line">    ql = Qiling(path, rootfs)</span><br><span class="line">    challenge1(ql)</span><br><span class="line">    ql.run()</span><br></pre></td></tr></table></figure>
<h2 id="0x01-challenge2-hook系统调用"><a href="#0x01-challenge2-hook系统调用" class="headerlink" title="0x01 challenge2-hook系统调用"></a>0x01 challenge2-hook系统调用</h2><p><img src="/images/Qiling-study/image-20230706212206713.png" alt="image-20230706212206713" style="zoom:67%;" /></p>
<p>&emsp;通过分析，此函数的逻辑为：</p>
<p>（1）运行<code>uname</code>函数，将返回结果保存到<code>name</code>结构体中，如果成功获取的话返回值为0。</p>
<p>（2）判断<code>name.sysname==&quot;QilingOS&quot;</code>，<code>name.version==&quot;ChallengeStart&quot;</code>，就可以完成此挑战。</p>
<p>&emsp;那么，我们要<code>Hook</code>函数<code>uname</code>，在返回之前改<code>sysname</code>与<code>version</code>。有<code>4</code>种<code>hook</code>方式：</p>
<p>（1）<code>QL_INTERCEPT.EXIT</code>：在系统调用执行完成之后立即执行<code>hook</code>函数。</p>
<p>（2）<code>QL_INTERCEPT.ENTER</code>：在系统调用执行之前执行<code>hook</code>函数。</p>
<p>（3）<code>QL_INTERCEPT.EXIT_TREE</code>：在系统调用执行完成并返回后，执行完其他所有系统调用的<code>hook</code>函数之后，再执行当前系统调用的<code>hook</code>函数。</p>
<p>（4）<code>QL_INTERCEPT.EXIT_ALL</code>：在系统调用执行完成并返回后，执行所有系统调用的<code>hook</code>函数，并清除这些<code>hook</code>函数。</p>
<p>&emsp;补充：系统调用返回结构体型数据时，会将结构体的地址存放在寄存器<code>rdi</code>中。<code>uname</code>返回的结构体为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct utsname &#123;</span><br><span class="line">    char sysname[65];</span><br><span class="line">    char nodename[65];</span><br><span class="line">    char release[65];  </span><br><span class="line">    char version[65];</span><br><span class="line">    char machine[65];</span><br><span class="line">    char domainname[65];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&emsp;可以写脚本如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> qiling <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># 导入Qiling中的常量</span></span><br><span class="line"><span class="keyword">from</span> qiling.const <span class="keyword">import</span> *</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_uname_on_exit_hook</span>(<span class="params">ql, *args</span>):</span><br><span class="line">    <span class="comment"># 获得rdi</span></span><br><span class="line">    rdi = ql.arch.regs.rdi</span><br><span class="line">    <span class="comment"># 输出rdi地址</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;utsname address: <span class="subst">&#123;<span class="built_in">hex</span>(rdi)&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="comment"># sysname</span></span><br><span class="line">    ql.mem.write(rdi, <span class="string">b&#x27;QilingOS\x00&#x27;</span>)</span><br><span class="line">    <span class="comment"># version</span></span><br><span class="line">    ql.mem.write(rdi + <span class="number">65</span> * <span class="number">3</span>, <span class="string">b&#x27;ChallengeStart\x00&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">challenge2</span>(<span class="params">ql</span>):</span><br><span class="line">    <span class="comment"># 使用QL_INTERCEPT.EXIT</span></span><br><span class="line">    <span class="comment"># 在系统调用执行完成之后立即执行hook函数</span></span><br><span class="line">    <span class="comment"># 用my_uname_on_exit_hook替换了uname</span></span><br><span class="line">    ql.os.set_syscall(<span class="string">&quot;uname&quot;</span>, my_uname_on_exit_hook, QL_INTERCEPT.EXIT)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">challenge1</span>(<span class="params">ql</span>):</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    path = [<span class="string">&quot;./qiling/examples/rootfs/x8664_linux/qilinglab-x86_64&quot;</span>]</span><br><span class="line">    rootfs = <span class="string">&quot;./qiling/examples/rootfs/x8664_linux&quot;</span></span><br><span class="line">    ql = Qiling(path, rootfs)</span><br><span class="line">    challenge1(ql)</span><br><span class="line">    challenge2(ql)</span><br><span class="line">    ql.run()</span><br></pre></td></tr></table></figure>
<h2 id="0x02-challenge3-自定义文件"><a href="#0x02-challenge3-自定义文件" class="headerlink" title="0x02 challenge3-自定义文件"></a>0x02 challenge3-自定义文件</h2><p><img src="/images/Qiling-study/image-20230706215408991.png" alt="image-20230706215408991" style="zoom:67%;" /></p>
<p>&emsp;分析此函数：保证<code>getrandom</code>函数拿到的数据<code>v7</code>与文件<code>/dev/urandom</code>拿到的数据<code>buf</code>相同，且<code>buf[i]!=v5</code>。其中，<code>getrandom</code>是用系统调用获得随机数，此函数用法为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ret = getrandom(ql, buf, buflen, flags)</span><br><span class="line"> </span><br><span class="line">buf：指向缓冲区的指针，用于存储读取到的随机数据。</span><br><span class="line">buflen：要从系统熵池读取的字节数。</span><br><span class="line">flags：</span><br><span class="line">    （1）0：如果系统熵池中没有足够的熵，getrandom 会阻塞直到有足够的熵可用。</span><br><span class="line">    （2）GRND_NONBLOCK（为 1）：getrandom 在系统熵池中没有足够的熵时，会立即返回错误而不是阻塞。</span><br><span class="line">    （3）GRND_RANDOM（为 2）：尝试从 /dev/random 获取随机数据，而不是从 /dev/urandom 获取。这个选项会导致 getrandom 的行为更加谨慎，可能会在熵不足时阻塞。</span><br><span class="line">ret：</span><br><span class="line">    （1）如果成功获取随机数据，getrandom 返回实际读取的字节数。</span><br><span class="line">    （2）如果出错，返回-1。</span><br></pre></td></tr></table></figure>
<p>&emsp;而<code>/dev/urandom</code> 是一个 Linux 系统中的特殊文件，它是一个伪随机数发生器设备文件，用于生成随机数。在<code>qiling</code>中使用 <code>ql.add_fs_mapper(&quot;/dev/urandom&quot;, &quot;/dev/urandom&quot;)</code> 将宿主机中的 <code>/dev/urandom (后面的)</code> 设备文件映射到<code>qiling</code>虚拟机中的 <code>/dev/urandom （前面的）</code> 文件上，以便为虚拟机中的程序提供随机数服务。</p>
<p>&emsp;<code>wp</code>如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> qiling <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># 导入Qiling模拟器中的常量</span></span><br><span class="line"><span class="keyword">from</span> qiling.const <span class="keyword">import</span> * </span><br><span class="line"><span class="comment"># 使用QlFsMappedObject自定义文件对象，以实现&quot;/dev/urandom&quot;</span></span><br><span class="line"><span class="keyword">from</span> qiling.os.mapper <span class="keyword">import</span> QlFsMappedObject</span><br><span class="line"></span><br><span class="line"><span class="comment"># 模拟/dev/urandom</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FakeUrandom</span>(<span class="title class_ inherited__">QlFsMappedObject</span>): </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">read</span>(<span class="params">self, size: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bytes</span>: </span><br><span class="line">        <span class="keyword">if</span> size == <span class="number">1</span>:</span><br><span class="line">            <span class="comment"># v5为\x42</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">b&quot;\x42&quot;</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># buf为\x41 * size</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">b&quot;\x41&quot;</span> * size</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">close</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 模拟getrandom</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hook_getrandom</span>(<span class="params">ql, buf, buflen, flags</span>):</span><br><span class="line">    <span class="keyword">if</span> buflen == <span class="number">32</span>:</span><br><span class="line">        data = <span class="string">b&#x27;\x41&#x27;</span> * buflen</span><br><span class="line">        ql.mem.write(buf, data)</span><br><span class="line">        ql.os.set_syscall_return(buflen)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        ql.os.set_syscall_return(-<span class="number">1</span>)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">challenge3</span>(<span class="params">ql</span>):</span><br><span class="line">    <span class="comment"># 将/dev/urandom文件以FakeUrandom()替换</span></span><br><span class="line">    ql.add_fs_mapper(<span class="string">r&#x27;/dev/urandom&#x27;</span>, FakeUrandom())</span><br><span class="line">    <span class="comment"># 将getrandom函数以hook_getrandom替换</span></span><br><span class="line">    ql.os.set_syscall(<span class="string">&quot;getrandom&quot;</span>, hook_getrandom)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">challenge2</span>(<span class="params">ql</span>):</span><br><span class="line">	...</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">challenge1</span>(<span class="params">ql</span>):</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    path = [<span class="string">&quot;./qiling/examples/rootfs/x8664_linux/qilinglab-x86_64&quot;</span>]</span><br><span class="line">    rootfs = <span class="string">&quot;./qiling/examples/rootfs/x8664_linux&quot;</span></span><br><span class="line">    ql = Qiling(path, rootfs)</span><br><span class="line">    challenge1(ql)</span><br><span class="line">    challenge2(ql)    </span><br><span class="line">    challenge3(ql)</span><br><span class="line">    ql.run()</span><br></pre></td></tr></table></figure>
<h2 id="0x03-challenge4-hook某地址"><a href="#0x03-challenge4-hook某地址" class="headerlink" title="0x03 challenge4-hook某地址"></a>0x03 challenge4-hook某地址</h2><p><img src="/images/Qiling-study/image-20230707120024772.png" alt="image-20230707120024772" style="zoom:67%;" /></p>
<p>&emsp;程序逻辑如下：初始时设置<code>tmp1=tmp2=0</code>，比较<code>tmp2&lt;tmp1</code>是否成立，若成立则挑战成功。那么我们就要<code>patch [rbp+tmp1]</code>为1。</p>
<p>&emsp;可以编写<code>wp</code>为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> qiling <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改eax的值</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">enter_forbidden_loop_hook</span>(<span class="params">ql</span>):</span><br><span class="line">    ql.arch.regs.eax = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">challenge4</span>(<span class="params">ql</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    .text:0000555555554E40                 mov     eax, [rbp+tmp1]</span></span><br><span class="line"><span class="string">    .text:0000555555554E43                 cmp     [rbp+tmp2], eax ; 若tmp2&lt;tmp1则成功 &lt;-- 在运行此命令前hook eax，使得eax = 1</span></span><br><span class="line"><span class="string">    .text:0000555555554E46                 jl      short loc_555555554E35 ; challenge4成功</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 根据文件路径查找已经加载的文件，获取对应文件的基地址</span></span><br><span class="line">    <span class="comment"># os.path.split(ql.path)[-1]为文件名</span></span><br><span class="line">    base = ql.mem.get_lib_base(os.path.split(ql.path)[-<span class="number">1</span>]) </span><br><span class="line">    hook_addr = base + <span class="number">0xE43</span></span><br><span class="line">    <span class="comment"># 当执行流程到达hook_addr时，该函数将被调用，此时hook_addr处的代码还未被执行。</span></span><br><span class="line">    ql.hook_address(enter_forbidden_loop_hook, hook_addr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    path = [<span class="string">&quot;./qiling/examples/rootfs/x8664_linux/qilinglab-x86_64&quot;</span>]</span><br><span class="line">    rootfs = <span class="string">&quot;./qiling/examples/rootfs/x8664_linux&quot;</span></span><br><span class="line">    ql = Qiling(path, rootfs)</span><br><span class="line">    challenge4(ql)</span><br><span class="line">    ql.run()</span><br></pre></td></tr></table></figure>
<h2 id="0x04-challenge5-hook某函数"><a href="#0x04-challenge5-hook某函数" class="headerlink" title="0x04 challenge5-hook某函数"></a>0x04 challenge5-hook某函数</h2><p><img src="/images/Qiling-study/image-20230707121805531.png" alt="image-20230707121805531" style="zoom:67%;" /></p>
<p>&emsp;函数逻辑如下：将<code>v5[i]=0,v5[i+8]=rand(),0&lt;=i&lt;=4</code>。检验时，要求<code>v5[i]=v5[i+8]</code>。思路是把<code>rand()</code>函数<code>hook</code>掉，感觉有点像<code>challenge2</code>，不同的是，<code>challenge2</code>是<code>hook</code>的系统调用，而<code>challenge5</code>是<code>hook</code>的函数调用<code>rand</code>，所以使用函数<code>ql.os.set_api</code>。<code>wp</code>如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> qiling <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_rand_on_exit_hook</span>(<span class="params">ql, *args</span>):</span><br><span class="line">    ql.arch.regs.rax = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">challenge5</span>(<span class="params">ql</span>):</span><br><span class="line">    ql.os.set_api(<span class="string">&#x27;rand&#x27;</span>, my_rand_on_exit_hook)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    path = [<span class="string">&quot;./qiling/examples/rootfs/x8664_linux/qilinglab-x86_64&quot;</span>]</span><br><span class="line">    rootfs = <span class="string">&quot;./qiling/examples/rootfs/x8664_linux&quot;</span></span><br><span class="line">    ql = Qiling(path, rootfs)</span><br><span class="line">    challenge5(ql)</span><br><span class="line">    ql.run()</span><br></pre></td></tr></table></figure>
<p>&emsp;需要注意的是，此时程序不会回显，因为要解决后面的题目。</p>
<h2 id="0x05-challenge6-修改寄存器"><a href="#0x05-challenge6-修改寄存器" class="headerlink" title="0x05 challenge6-修改寄存器"></a>0x05 challenge6-修改寄存器</h2><p><img src="/images/Qiling-study/image-20230707123259692.png" alt="image-20230707123259692" style="zoom:67%;" /></p>
<p>&emsp;程序一直循环，只有当<code>var_5==0</code>时，才会跳出，我们打算将程序执行到<code>0x0000555555554F12</code>时修改<code>eax=0</code>。其<code>wp</code>如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">hook_rax</span>(<span class="params">ql</span>):</span><br><span class="line">    ql.arch.regs.rax = <span class="number">0</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">challenge6</span>(<span class="params">ql</span>):</span><br><span class="line">    base = ql.mem.get_lib_base(os.path.split(ql.path)[-<span class="number">1</span>])</span><br><span class="line">    hook_addr = base + <span class="number">0xF16</span></span><br><span class="line">    ql.hook_address(hook_rax, hook_addr)</span><br></pre></td></tr></table></figure>
<h2 id="0x06-challenge7-hook函数调用"><a href="#0x06-challenge7-hook函数调用" class="headerlink" title="0x06 challenge7-hook函数调用"></a>0x06 challenge7-hook函数调用</h2><p><img src="/images/Qiling-study/image-20230709215819402.png" alt="image-20230709215819402" style="zoom:67%;" /></p>
<p>&emsp;程序一直<code>sleep</code>，很难返回，我们要<code>hook sleep</code>函数，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">hook_sleep</span>(<span class="params">ql</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">challenge7</span>(<span class="params">ql</span>):</span><br><span class="line">    ql.os.set_api(<span class="string">&#x27;sleep&#x27;</span>, hook_sleep)</span><br></pre></td></tr></table></figure>
<h2 id="0x07-challenge8-修改结构体的值"><a href="#0x07-challenge8-修改结构体的值" class="headerlink" title="0x07 challenge8-修改结构体的值"></a>0x07 challenge8-修改结构体的值</h2><p><img src="/images/Qiling-study/image-20230709220031016.png" alt="image-20230709220031016" style="zoom:67%;" /></p>
<p>&emsp;这是一个结构体，其整理后的内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">| 8 bytes | 30-byte memory, save &quot;Random data&quot; |</span><br><span class="line">| 4 bytes | 1337                               |</span><br><span class="line">| 4 bytes | 1039980266                         |</span><br><span class="line">| 8 bytes | a1                                 |</span><br></pre></td></tr></table></figure>
<p>&emsp;结构体定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">    char *string_ptr; // 8 字节的指针，指向字符串 &quot;Random data&quot; 所在的内存</span><br><span class="line">    uint32_t value1;  // 4 字节的整数，值为 1337</span><br><span class="line">    uint32_t value2;  // 4 字节的整数，值为 1039980266</span><br><span class="line">    int64_t a1;       // 8 字节的整数，值为传入的参数 a1</span><br><span class="line">&#125; CustomStruct;</span><br></pre></td></tr></table></figure>
<p>&emsp;我们需要修改<code>*a1=1</code>，那么<code>wp</code>可以这么写：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">challenge8_hook</span>(<span class="params">ql</span>):</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># 在内存中寻找1337和1039980266所在的内存</span></span><br><span class="line">    MAGIC = <span class="number">0x3DFCD6EA00000539</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 转换MAGIC成为字节序列</span></span><br><span class="line">    magic_addrs = ql.mem.search(ql.pack64(MAGIC))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 找到好多对应的地址</span></span><br><span class="line">    <span class="keyword">for</span> magic_addr <span class="keyword">in</span> magic_addrs:</span><br><span class="line"> </span><br><span class="line">	    <span class="comment"># MAGIC距离结构体头指针距离为 8 bytes</span></span><br><span class="line">        candidate_heap_struct_addr = magic_addr - <span class="number">8</span> </span><br><span class="line">        <span class="comment"># 获取结构体地址结构</span></span><br><span class="line">        candidate_heap_struct = ql.mem.read(candidate_heap_struct_addr, <span class="number">24</span>)</span><br><span class="line">        <span class="comment"># struct.unpack() 是一个 Python 函数，用于将字节序列解包为多个值，解包 candidate_heap_struct 地址结构。</span></span><br><span class="line">        <span class="comment"># &#x27;QQQ&#x27; 是一个格式字符串，表示要解包的数据结构包含3个64位（8 字节）无符号整数。</span></span><br><span class="line">        <span class="comment"># string_addr, _ , check_addr：只关注 string_addr 与 check_addr，最后得到相应地址</span></span><br><span class="line">        string_addr, _ , check_addr = struct.unpack(<span class="string">&#x27;QQQ&#x27;</span>, candidate_heap_struct)</span><br><span class="line">        <span class="comment"># 如果找到对应的地址</span></span><br><span class="line">        <span class="keyword">if</span> ql.mem.string(string_addr) == <span class="string">&quot;Random data&quot;</span>:</span><br><span class="line">            <span class="comment"># 修改*a1为1</span></span><br><span class="line">            ql.mem.write(check_addr, <span class="string">b&quot;\x01&quot;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">challenge8</span>(<span class="params">ql</span>):</span><br><span class="line">    base_addr = ql.mem.get_lib_base(os.path.split(ql.path)[-<span class="number">1</span>])</span><br><span class="line">    <span class="comment"># 程序运行结束时的地址</span></span><br><span class="line">    end_of_challenge8 = base_addr + <span class="number">0xFB5</span></span><br><span class="line">    ql.hook_address(challenge8_hook, end_of_challenge8)</span><br></pre></td></tr></table></figure>
<h2 id="0x08-challenge9-hook函数调用2"><a href="#0x08-challenge9-hook函数调用2" class="headerlink" title="0x08 challenge9-hook函数调用2"></a>0x08 challenge9-hook函数调用2</h2><p><img src="/images/Qiling-study/image-20230709222307435.png" alt="image-20230709222307435" style="zoom:67%;" /></p>
<p>&emsp;把<code>aBcdeFghiJKlMnopqRstuVWxYz</code>变成小写，并检查<code>src</code>与<code>dest</code>是否相等，若相等则挑战成功。目测应该是要<code>hook strcmp</code>函数。<code>wp</code>如下，其<code>hook</code>了<code>tolower</code>函数，让它什么也不做：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">hook_tolower</span>(<span class="params">ql</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">challenge9</span>(<span class="params">ql</span>):</span><br><span class="line">    ql.os.set_api(<span class="string">&#x27;tolower&#x27;</span>, hook_tolower)</span><br></pre></td></tr></table></figure>
<h2 id="0x09-challenge10-自定义文件对象"><a href="#0x09-challenge10-自定义文件对象" class="headerlink" title="0x09 challenge10-自定义文件对象"></a>0x09 challenge10-自定义文件对象</h2><p><img src="/images/Qiling-study/image-20230709222727406.png" alt="image-20230709222727406" style="zoom:67%;" /></p>
<p>&emsp;读取<code>/proc/self/cmdline</code>文件，并比较读取的字符串是否为<code>&quot;qilinglab&quot;</code>。</p>
<p>&emsp;注：<code>/proc/self/cmdline</code>是一个在<code>Linux</code>系统中的特殊文件，它提供了当前进程（即访问<code>/proc/self/cmdline</code>的进程）的命令行参数信息。假如我们使用命令<code>./my_program arg1 arg2 arg3</code>启动一个程序时，读取<code>/proc/self/cmdline</code>的过程在 <code>./my_program</code> 中，<code>/proc/self/cmdline</code>文件的内容将是：<strong><code>./my_program\0arg1\0arg2\0arg3\0</code></strong>。</p>
<p>&emsp;按照<code>challenge3</code>，可以写<code>wp</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Fake_cmdline</span>(<span class="title class_ inherited__">QlFsMappedObject</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">read</span>(<span class="params">self, expected_len</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b&#x27;qilinglab&#x27;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">close</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">challenge10</span>(<span class="params">ql</span>):</span><br><span class="line">    ql.add_fs_mapper(<span class="string">&#x27;/proc/self/cmdline&#x27;</span>, Fake_cmdline())</span><br></pre></td></tr></table></figure>
<p>&emsp;博客中此<code>wp</code>在运行后并没有解题成功，博主说是在<code>hook /proc/self/cmdline</code> 这里存在问题，所以他写了个脚本单独调试以下<code>cmdline</code>读取程序：</p>
<p>&emsp;<code>c</code> 程序：用来读取<code>cmdline</code>，文件名：<code>test_cmdline</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    FILE *file;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 打开/proc/self/cmdline文件</span></span><br><span class="line">    file = <span class="built_in">fopen</span>(<span class="string">&quot;/proc/self/cmdline&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (file == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;无法打开/proc/self/cmdline文件。\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;读取/proc/self/cmdline：\n&quot;</span>);</span><br><span class="line">    <span class="comment">// 逐个字符读取文件内容并输出到终端</span></span><br><span class="line">    <span class="keyword">while</span> ((ch = <span class="built_in">fgetc</span>(file)) != EOF) &#123;</span><br><span class="line">        <span class="comment">// 将空字符替换为换行符以提高可读性</span></span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">putchar</span>(ch);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 关闭文件</span></span><br><span class="line">    <span class="built_in">fclose</span>(file);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;结果博主发现：用<code>c</code>语言读取程序存在问题。<strong>但是我没有看出来有什么问题（：</strong>最终经过代码审计（好长的步骤），发现<code>qiling-1.4.3</code>可以正常运行<code>wp</code>。</p>
<h2 id="0x10-challenge11-绕过CPUID校验"><a href="#0x10-challenge11-绕过CPUID校验" class="headerlink" title="0x10 challenge11-绕过CPUID校验"></a>0x10 challenge11-绕过CPUID校验</h2><p><img src="/images/Qiling-study/image-20230709225245426.png" alt="image-20230709225245426" style="zoom:67%;" /></p>
<p>&emsp;要让<code>if</code>的判断顺利通过，<code>if ( __PAIR64__(_RBX, _RCX) == 0x696C6951614C676ELL &amp;&amp; (_DWORD)_RDX == 538976354 )</code> 的含义为：</p>
<p>（1）<code>rbx</code>和<code>rcx</code>两个32位寄存器组成的64位值等于<code>0x696C6951614C676ELL</code>。</p>
<p>（2）<code>RDX</code>寄存器的低32位等于<code>538976354</code>。</p>
<p>&emsp;因此我们跳过<code>cpuid</code>指令，并修改寄存器即可。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">hook_cpuid</span>(<span class="params">ql, address, size</span>):</span><br><span class="line"> 	<span class="comment"># CPUID指令的机器码是 0F A2</span></span><br><span class="line">    <span class="keyword">if</span> ql.mem.read(address, size) == <span class="string">b&#x27;\x0F\xA2&#x27;</span>:</span><br><span class="line">        regs = ql.arch.regs</span><br><span class="line">        regs.ebx = <span class="number">0x696C6951</span></span><br><span class="line">        regs.ecx = <span class="number">0x614C676E</span></span><br><span class="line">        regs.edx = <span class="number">0x20202062</span></span><br><span class="line">        <span class="comment"># 跳过cpuid指令防止被cpuid篡改</span></span><br><span class="line">        regs.rip += <span class="number">2</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">challenge11</span>(<span class="params">ql</span>):</span><br><span class="line">    begin, end = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> info <span class="keyword">in</span> ql.mem.map_info:</span><br><span class="line">        <span class="built_in">print</span>(info)</span><br><span class="line">        <span class="keyword">if</span> info[<span class="number">2</span>] == <span class="number">5</span> <span class="keyword">and</span> <span class="string">&#x27;qilinglab-x86_64&#x27;</span> <span class="keyword">in</span> info[<span class="number">3</span>]:</span><br><span class="line">            begin, end = info[:<span class="number">2</span>]</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;begin&#125;</span> -&gt; <span class="subst">&#123;end&#125;</span>&quot;</span>)</span><br><span class="line"> </span><br><span class="line">    ql.hook_code(hook_cpuid, begin=begin, end=end)</span><br></pre></td></tr></table></figure>

  
	</div>

	<div>
  	<center>
	<div class="pagination">

    
    
    <a href="/2023/07/10/IOT-security-vulnerabilities-mining/" type="button" class="btn btn-default"><i
                class="fa fa-arrow-circle-o-left"></i> 上一页</a>
    

    <a href="/" type="button" class="btn btn-default"><i class="fa fa-home"></i>Home</a>
    
    <a href="/2023/07/03/vmp-analysis/" type="button" class="btn btn-default ">下一页<i
                class="fa fa-arrow-circle-o-right"></i></a>
    

    
</div>

    </center>
	</div>


	<!-- comment -->
	
<section id="comment">
    <h2 class="title">留言</h2>

    <!-- 
    <div id="disqus_thread" class="ds-thread">
        <script type="text/javascript">
            /**
             * RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
             * LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
             */
                /*
                 var disqus_config = function () {
                 this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable
                 this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
                 };
                 */
            (function() { // DON'T EDIT BELOW THIS LINE
                var d = document, s = d.createElement('script');

                s.src = 'https://https-wd-2711-tech.disqus.com/embed.js';

                s.setAttribute('data-timestamp', +new Date());
                (d.head || d.body).appendChild(s);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="//disqus.com/?ref_noscript">comments powered by
                Disqus.</a></noscript>
    </div> -->
    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
    <div id="vcomments"></div>
    <script>
        new Valine({
            el: '#vcomments',
            appId: 'wLIJ70s3fPvW8WJPgVVAuWVR-gzGzoHsz',
            appKey: 'NVGqxhUkqtFv2CbwmXXWjCdR'
        })
    </script>

    
</section>


	</div> <!-- col-md-9/col-md-12 -->
		
	
	<div id="side_meta">
		<div class="col-md-3" id="post_meta"> 

	<!-- date -->
	
	<div class="meta-widget">
	<i class="fa fa-clock-o"></i>
	2023-07-06 
	</div>
	

	<!-- categories -->
    
	<div class="meta-widget">
	<a data-toggle="collapse" data-target="#categorys"><i class="fa fa-folder"></i></a>	
    <ul id="categorys" class="tag_box list-unstyled collapse in">
          
  <li>
    <li><a href="/categories/re/">re<span>40</span></a></li>
  </li>

    </ul>
	</div>
	

	<!-- tags -->
		

	<!-- toc -->
	<div class="meta-widget">
	
	</div>
	
    <hr>
	
</div><!-- col-md-3 -->

	</div>

	<!-- copyright -->
	<div>
    <ul class="post-copyright">
      <li class="post-copyright-author">
      <strong>作者:  </strong>wd-z711</a>
      </li>
      <li class="post-copyright-link">
      <strong>文章链接:  </strong>
      <a href="/" target="_blank" title="">https://wd-2711.tech/</a>
      </li>
      <li class="post-copyright-license">
        <strong>版权声明:   </strong>
        本博客所有文章除特别声明外，均采用 <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)">CC BY-NC-ND 4.0</a>
        许可协议。转载请注明出处!
      </li>
    </ul>
  <div>
 	

		


</div><!-- row -->




	</div>
  </div>
  <div class="container-narrow">
  <footer> <p>
  &copy; 2024 wd-z711
  
      <!-- with help from <a href="http://hexo.io/" target="_blank">Hexo</a>,<a target="_blank" rel="noopener" href="http://github.com/wzpan/hexo-theme-freemind/">Freemind</a>,<a href="http://getbootstrap.com/" target="_blank">Twitter Bootstrap</a> and <a href="http://getbootstrap.com/" target="_blank">BOOTSTRA.386</a>. 
     <br> Theme by <a target="_blank" rel="noopener" href="http://github.com/wzpan/hexo-theme-freemind/">Freemind.386</a>.     -->

     <!-- <script type="text/javascript">
      (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
      (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
      e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
      })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');
      
      _st('install','aB-vgeB8gEDrnRJuhceL','2.0.0');
    </script> -->
    </p>
 </footer>
</div> <!-- container-narrow -->
  


  
<a id="gotop" href="#">   
  <span>⬆︎TOP</span>
</a>

<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/bootstrap.min.js"></script>
<script src="/js/main.js"></script>
<script src="/js/search.js"></script> 


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>



   <script type="text/javascript">      
     var search_path = "search.xml";
	 if (search_path.length == 0) {
	 	search_path = "search.xml";
	 }
	 var path = "/" + search_path;
     searchFunc(path, 'local-search-input', 'local-search-result');
   </script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
   </html>
