<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="pragma" content="no-cache">
  <meta http-equiv="cache-control" content="no-cache">
  <meta http-equiv="expires" content="0">
  
  <title>wd-z711&#39;s B10g</title>
  <meta name="author" content="wd-z711">
  
  <meta name="description" content="Common student in China. Interested in web &amp; re.">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="wd-z711&#39;s B10g"/>

  
    <meta property="og:image" content=""/>
  

  
  
    <link href="/favicon.png" rel="icon">
  
  
  <link rel="stylesheet" href="/css/bootstrap.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/font-awesome.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/responsive.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/google-fonts.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

  <script src="/js/jquery-2.0.3.min.js"></script>

  <!-- analytics -->
  
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'G-YHJSKZDC3Y', 'auto');
  ga('send', 'pageview');
</script>




<meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="wd-z711's B10g" type="application/atom+xml">
</head>

 <body>  
  <nav id="main-nav" class="navbar navbar-inverse navbar-fixed-top" role="navigation">
    <div class="container">
      <button type="button" class="navbar-header navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
		<span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
	  <a class="navbar-brand" href="/">wd-z711&#39;s B10g</a>
      <div class="collapse navbar-collapse nav-menu">
		<ul class="nav navbar-nav">
		  
		  <li>
			<a href="/archives" title="All the articles.">
			  <i class="fa fa-archive"></i>Archives
			</a>
		  </li>
		  
		  <li>
			<a href="/categories" title="All the categories.">
			  <i class="fa fa-folder"></i>Categories
			</a>
		  </li>
		  
		  <li>
			<a href="/about" title="About me.">
			  <i class="fa fa-user"></i>About
			</a>
		  </li>
		  
		</ul>
      </div>
    </div> <!-- container -->
</nav>
<div class="clearfix"></div>

  <div class="container">
  	<div class="content">
    	 


	
		<div class="page-header">
			<h1> </h1>
		</div>
	



<div class="row post">

	<!-- cols -->
	
	<div id="top_meta"></div>
	<div class="col-md-9">
	

	<!-- content -->
	<div class="mypage">		
	  		

	  <p>title: intern-ms-prepare<br>categories: 杂记</p>
<p>password: xcl12345<br>abbrlink: 29882<br>date: 2023-09-25 16:14:56<br>typora-root-url: ..</p>
<h1 id="微软实习生准备"><a href="#微软实习生准备" class="headerlink" title="微软实习生准备"></a>微软实习生准备</h1><h2 id="DeFiHackLabs"><a href="#DeFiHackLabs" class="headerlink" title="DeFiHackLabs"></a>DeFiHackLabs</h2><p>&emsp;区块链交易调试工具：<code>Phalcon</code>、<code>Tx.viewer</code>、<code>Cruise</code>、<code>Ethtx</code>、<code>Tenderly</code>。其中，<code>Tx.viewer</code>可以对交易流程进行可视化，而<code>Tenderly</code>支持最多的链。</p>
<span id="more"></span>
<h2 id="区块链漏洞"><a href="#区块链漏洞" class="headerlink" title="区块链漏洞"></a>区块链漏洞</h2><h3 id="Insufficient-Gas-Griefing"><a href="#Insufficient-Gas-Griefing" class="headerlink" title="Insufficient Gas Griefing"></a>Insufficient Gas Griefing</h3><p>&emsp;Insufficient Gas Griefing 可以在接受数据并在另一个合约的子调用中使用。这种方法通常用于<strong>多重签名钱包和交易中继器</strong>。如果子调用失败，则要么<strong>恢复整个事务，要么继续执行</strong>。</p>
<p>&emsp;以一个简单的中继合约为例。如下所示，中继者合约允许<strong>某人签署交易，而无需执行交易</strong>。当用户无法支付与交易相关的 Gas 费用时，通常会使用此方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">contract Relayer &#123;</span><br><span class="line">    mapping (bytes =&gt; bool) executed;</span><br><span class="line"></span><br><span class="line">    function relay(bytes _data) public &#123;</span><br><span class="line">        // 重播保护；不要两次调用同一事务</span><br><span class="line">        require(executed[_data] == 0, &quot;Duplicate call&quot;);</span><br><span class="line">        executed[_data] = true;</span><br><span class="line">        innerContract.call(bytes4(keccak256(&quot;execute(bytes)&quot;)), _data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;执行交易的用户（即转发者）可以通过使用足够的 Gas 来有效地审查交易，以便交易执行，但没有足够的 Gas 来使子调用成功。有两种方法可以防止这种情况：（1）允许受信任的用户转发交易；（2）要求转发者提供足够的gas，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 由转发者调用的合约</span><br><span class="line">contract Executor &#123;</span><br><span class="line">    function execute(bytes _data, uint _gasLimit) &#123;</span><br><span class="line">        require(gasleft() &gt;= _gasLimit);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;中继智能合约可以作为不同区块链之间的桥梁，实现跨链操作和数据交换。中继智能合约可以提供更高的隐私保护，通过将敏感的交易和数据处理逻辑放在中继智能合约中进行，而不是直接在区块链上执行。</p>
<p> &emsp;Insufficient Gas Griefing 影响：攻击者可以创建恶意交易，将合约陷入无限循环或长时间执行的状态，消耗大量的计算资源和燃料（Gas），从而导致网络拥塞或其他用户无法执行交易。</p>
<h3 id="Reentrancy"><a href="#Reentrancy" class="headerlink" title="Reentrancy"></a>Reentrancy</h3><p>&emsp;当合约中的错误可能允许恶意合约在原始函数执行期间意外地重新进入合约时，可能会发生这种攻击。如果被恶意使用，这可以用来从智能合约中抽走资金。</p>
<h4 id="外部调用"><a href="#外部调用" class="headerlink" title="外部调用"></a>外部调用</h4><p>可以通过对攻击者控制的合约进行外部调用来执行重入，外部调用允许被调用者执行任意代码。外部调用的触发方式有：</p>
<p>（1）以太坊转账。当以太币转移到合约地址时，会触发合约中实现的<code>receive</code>或函数。<code>fallback</code>攻击者可以在该方法中写入任意逻辑<code>fallback</code>，这样只要合约收到转账，该逻辑就会被执行。</p>
<p>（2）safeMint。难以发现的外部调用的一个例子是 OpenZeppelin（开源的智能合约开发框架）的<code>ERC721._safeMint</code>与<code>ERC721._safeTransfer</code>函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function _safeMint(address to, uint256 tokenId, bytes memory _data) internal virtual &#123;</span><br><span class="line">    _mint(to, tokenId);</span><br><span class="line">    require(</span><br><span class="line">        _checkOnERC721Received(address(0), to, tokenId, _data),</span><br><span class="line">        &quot;ERC721: transfer to non ERC721Receiver implementer&quot;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;该函数之所以命名为<code>_safeMint</code>，是因为它首先检查合约是否已实现 ERC721Receiver，即将其标记为 NFT 的自愿接收者，从而防止代币无意中被铸造到合约中。但<code>_checkOnERC721Received</code>是对接收合约的外部调用，允许任意执行。</p>
<h4 id="单函数-Reentrancy"><a href="#单函数-Reentrancy" class="headerlink" title="单函数 Reentrancy"></a>单函数 Reentrancy</h4><p>&emsp;当攻击者尝试递归调用的函数有漏洞时，就会发生单函数Reentrancy攻击。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function withdraw() external &#123;</span><br><span class="line">    uint256 amount = balances[msg.sender];</span><br><span class="line">    (bool success,) = msg.sender.call&#123;value: balances[msg.sender]&#125;(&quot;&quot;);</span><br><span class="line">    require(success);</span><br><span class="line">    balances[msg.sender] = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;在这里我们可以看到，余额只有在<strong>资金转移后才被修改</strong>。这可以让黑客在余额设置为 0 之前多次调用该函数，从而有效地耗尽智能合约的资源。</p>
<h4 id="如何防止-Reentrancy"><a href="#如何防止-Reentrancy" class="headerlink" title="如何防止 Reentrancy"></a>如何防止 Reentrancy</h4><p>&emsp;最简单的重入预防机制是使用 ReentrancyGuard，它允许您添加修饰符，例如<code>nonReentrant</code>。 另一种方法，使用 checks-effects-interactions，即先检查后转账。</p>
<h1 id="腾讯安全平台部"><a href="#腾讯安全平台部" class="headerlink" title="腾讯安全平台部"></a>腾讯安全平台部</h1><h2 id="0x00-简历与项目"><a href="#0x00-简历与项目" class="headerlink" title="0x00 简历与项目"></a>0x00 简历与项目</h2><h3 id="0x00-1-自我介绍："><a href="#0x00-1-自我介绍：" class="headerlink" title="0x00-1 自我介绍："></a>0x00-1 自我介绍：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">谢传龙，本科西安电子科技大学，2018 届网络空间安全排名第一，连续三年一等奖学金。硕士中国科学技术大学网络空间安全专业。有两段实习经历，获得过信息安全作品赛一等奖。研究生研究方向为系统安全。平时喜欢打 CTF，逆向手。擅长的语言是 C/C++，python。自己平时也了解过Unity UE 相关的知识。学过 C++ 逆向等。熟悉 hook，反调试，fastbin/uaf/double-free/thunk-extend 等。</span><br></pre></td></tr></table></figure>
<h3 id="0x00-2-实习经历介绍："><a href="#0x00-2-实习经历介绍：" class="headerlink" title="0x00-2 实习经历介绍："></a>0x00-2 实习经历介绍：</h3><h4 id="0x00-2-1-科恩实验室"><a href="#0x00-2-1-科恩实验室" class="headerlink" title="0x00-2-1 科恩实验室"></a>0x00-2-1 科恩实验室</h4><p>腾讯科恩实验室，2021.10 -&gt; 2022.4。基于子图行为异常的分布式 Bot 识别。基于 GGNN 图神经网络，提升腾讯云防火墙在爬虫检测方面的能力，主要负责算法实现。（使用 dgl 图神经网络库）</p>
<p><strong>什么是分布式 Bot？</strong></p>
<p>分布式 Bot 是由多个不同 IP 的节点共同完成一次对网站的爬取任务，常见的模式多由一个任务调度中心将所需爬取的目标站点 URL 分发给各个节点，各节点完成各自的爬取任务。</p>
<p><strong>分布式 Bot 的特点？</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">难以检测：</span><br><span class="line">1. 单个节点对目标站点的访问频率相对较低</span><br><span class="line">2. 单个节点对目标站点的URL访问顺序相对无序、随机</span><br><span class="line">便于检测：</span><br><span class="line">1. 同源于一个分布式爬取任务的节点，爬取行为多有一致性</span><br><span class="line">2. 多存在代理池，一个分布式Bot集群中各节点IP网段相对集中（B\C段）</span><br><span class="line">3. 分布式 Bot 由于调度下发任务的随机性和零散性，常常造成单节点分配到的url具有一定的随机性和零散性，这导致单个 Bot 节点的 url 访问序列，不会符合正常业务逻辑对应的访问模式、也不符合站点页面间的层次组织关系。</span><br><span class="line">4. 相对于人类行为，Bot 任务的 URL 访问序列存在明显差异，例如对资源类 URL (js/css/ico 等) 请求的缺失</span><br></pre></td></tr></table></figure>
<p><strong>传统策略的不足</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">单个节点访问频率低：常用的频率异常规则难以感知</span><br><span class="line">难以完整打击：一个节点被拦截，其余节点仍能完成大部分爬取任务</span><br><span class="line">对抗性：UA/Referer 字段异常规则易遭对抗</span><br></pre></td></tr></table></figure>
<p><strong>动机</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">将访问序列建模成一个一个的节点，我们可以用 AI 图神经网络解决这个问题。</span><br></pre></td></tr></table></figure>
<p><strong>Step1：特征工程</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">图特征建模：</span><br><span class="line">1. trackmap：此网站所有网页所构成的节点 url 可以构成一个 trackmap。节点间存在有向带权重边，权重为站点历史流量统计到的该访问序列出现的次数。（站点流量中，人类流量与传统单机 bot 流量的量级要远高于分布式 bot，且分布式 bot 的 url 访问序列有一定随机性和零散性，故 Trackmap 的边权重可以反映某一访问序列的异常程度，即如果出现权重很小的边，那么我们就要着重关注）</span><br><span class="line">2. submap：一定时间内某 ip 的访问序列。</span><br><span class="line">3. submap 的访问权重序列，时间间隔序列。</span><br><span class="line">4. 其余特征：访问时间，UA 字段，Referer 字段，IP 地点/运营商/类型（IDC/DYN）等。</span><br></pre></td></tr></table></figure>
<p><strong>Step2：打标签</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. UA 带有 spider 字样</span><br><span class="line">2. IP 网段是某个知名 spider </span><br><span class="line">3. submap 中访问序列权重均值很低，且访问节点数 &gt; 某个阈值</span><br></pre></td></tr></table></figure>
<p><strong>Step3：网络结构</strong></p>
<p><img src="/images/intern-ms-prepare/image-20240312113621415.png" alt="image-20240312113621415" style="zoom:67%;" /></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">训练方法：</span><br><span class="line">1. trackmap 中将节点特征（主要就是 URL 文本）过 bert 形成 node characters，将边特征（边的权重）过全连接形成 edge characters。</span><br><span class="line">2. 将打好标签的 submaps 映射到 trackmap 中，可以获得 submap 的表示。</span><br><span class="line">3. submap 过 GGNN（与 GNN 不同，加入了类似于 LSTM 的门控机制，有助于长序列） 生成 graph embedding。</span><br><span class="line">4. 结合 submap 的其他特征，例如访问时间间隔序列，UA 字段，Referer 字段，IP 地点/运营商/类型（IDC/DYN）等，最后做全连接 + Relu，进行二分类。  </span><br></pre></td></tr></table></figure>
<p><strong>Step4：效果</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">测试集上针对某小说网站 70W 条数据，分布式 Bot 召回率为 97%，误报率为 6%。 </span><br></pre></td></tr></table></figure>
<h4 id="0x00-2-2-北京微软"><a href="#0x00-2-2-北京微软" class="headerlink" title="0x00-2-2 北京微软"></a>0x00-2-2 北京微软</h4><p>北京微软，2023.11 -&gt; 至今。PPL 进程针对内核攻击者的改进方案研究。</p>
<p><strong>Step1：背景</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">edge 要开发一个区块链钱包，此钱包安装好后，用户的钱包密码会保存在 TPM 中，而用户所进行的交易由用户主机中 vbs enclave 进程中的私钥进行签名。但是，会有两个安全风险：</span><br><span class="line"></span><br><span class="line">1. 在用户初始化钱包的阶段，用户将钱包密码由浏览器发送到 TPM 的过程中，会在用户主机上运行的钱包进程中进行中转，如果攻击者劫持这个钱包进程，就会获得密码。</span><br><span class="line">2. 用户在签名交易的过程中，用户将交易信息由浏览器发送到 VBS enclave，也会在用户主机上运行的钱包进程中进行中转，如果攻击者劫持这个钱包进程，就会任意修改交易信息（例如交易量，目标地址）。</span><br><span class="line"></span><br><span class="line">为了解决这个问题，我们在用户主机上运行的钱包进程中使用了 PPL 机制。PPL 简单理解，当用户想要使用 OpenProcess 等 API 来获得这个进程并进行接下来的攻击时，会在 VTL-1 中做一个 check（执行由 hypervisor 保护），只有更高级别的 PPL 进程才能够获得我们所创建的这个 PPL 进程的句柄。但是它也会产生一个问题：</span><br><span class="line"></span><br><span class="line">1. 由于做 check 实际上就是对 PPL 的等级做 check，且这个等级保存在 windows 内核中（进程的 EPROCESS），如果内核态攻击者修改这个等级，那么就可以绕过这个 check。</span><br></pre></td></tr></table></figure>
<p><strong>Step2：方案设计</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1. 调研攻击者采取攻击的多种方式，路径有：（1）现有已签名的驱动程序漏洞；（2）其他系统 PPL 的漏洞。其最终目的都是获得钱包 PPL 进程的有效句柄。</span><br><span class="line"></span><br><span class="line">2. 在避免攻击者有权限访问 PPL 进程这一点：</span><br><span class="line">（1）借助 windows defender，让其 hook 关键 windows API(openProcess，ReadProcessMemory 等)，由于 defender 的引擎是由 hypervisor 保护的，因此可以有效防止攻击者使用这些手段来获得有效句柄，并可以防止攻击者 attack defender。另外，还可以注册回调函数，可以理解为是在内核态下进行的 hook，有效防止攻击者通过直接系统调用（hell gate）来绕过 hook。同时，defender 也会定期检查自己的 hook 代码是否被 unhook 掉。</span><br><span class="line">（2）定期检查 PPL 进程的 EPROCESS，防止被攻击者修改。</span><br><span class="line"></span><br><span class="line">3. 即使攻击者有权限访问 PPL，我们也要保证密码与交易信息不被泄露或篡改。</span><br><span class="line">（1）密码使用 windows passkey team 的现有方案，直接使用他们的安全模块与 TPM 交互，从而不走 PPL 进程。</span><br><span class="line">（2）交易信息经过调研，此部分不容易防御，因此，当签名后的交易发送到 bridge service（上链之前）的时候，使用邮箱通知用户所交易的金额/收款地址等，以供用户确认。</span><br></pre></td></tr></table></figure>
<p><strong>Step3：目前工作</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. Windows 的 PatchGuard 会定时检查 windows 原生的 PPL 进程的 EPROCESS 结构体，正在调研能否代替 defender，并能够做实时保护。</span><br><span class="line">2. 正在做使用 windows passkey team 的密码保护方案的 prototype。</span><br></pre></td></tr></table></figure>
<h3 id="0x00-3-项目介绍："><a href="#0x00-3-项目介绍：" class="headerlink" title="0x00-3 项目介绍："></a>0x00-3 项目介绍：</h3><h4 id="0x00-3-1-针对-UAF-的-fuzz-工具"><a href="#0x00-3-1-针对-UAF-的-fuzz-工具" class="headerlink" title="0x00-3-1 针对 UAF 的 fuzz 工具"></a>0x00-3-1 针对 UAF 的 fuzz 工具</h4><p><a target="_blank" rel="noopener" href="https://github.com/strongcourage/uafuzz/blob/master/raid20-final286.pdf">https://github.com/strongcourage/uafuzz/blob/master/raid20-final286.pdf</a></p>
<p>&emsp;正在开发…</p>
<p>现在有很多 fuzz 框架例如，AFL 或 LibFuzzer。针对 PWN 中很容易出现的 UAF，结合 blackhat 2020 About Directed Fuzzing and Use-After-Free: How to Find Complex &amp; Silent Bugs? 的演讲，对其进行了复现。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1. 以 fuzz 的代码点与二进制文件为基础，生成 edge ID 与 distance 信息，并以此指导 seed 生成。</span><br><span class="line">2. 从最初的 seed 中生成 testcase，并从中选择 distance 最小的 case 作为输入。</span><br><span class="line">3. 根据反馈信息，生成新的 seed，并重新生成 testcase。</span><br><span class="line">4. Power Schedule，（1）确定哪些测试用例值得更多地探索，根据测试用例触达的代码路径或是接近目标区域的程度，决定为其分配更多的资源来生成更多变种。（2）分配测试用例的能量，可以以理解为对每个选中的测试用例生成变种（即通过修改测试用例来探索新路径）的次数。（3）根据测试过程中收集到的数据（如代码覆盖率变化、新发现的路径等），动态调整资源分配策略。</span><br><span class="line">4. Triage：其中一些可能会引起程序的异常行为或崩溃。Triage 阶段首先需要对这些测试用例进行初步的分类和筛选，以区分哪些是真正有价值的（可能触发了漏洞的测试用例），哪些是误报或不相关的。</span><br><span class="line"></span><br><span class="line">主要是在能量分配方面做的策略：</span><br><span class="line">1. 一个触发 UAF 漏洞的有效测试用例很可能是那些能按正确顺序（即分配、释放后使用）并覆盖多个 UAF 事件的路径。那么，通过静态分析技术预先识别程序调用图中可能导致 UAF 事件序列的 (caller, callee) 对，并在计算距离时降低这些调用对的权重，这意味着，如果测试用例的执行路径包含了这样的调用对，它们被认为是距离目标更近的路径。（到 use 函数的路径）</span><br><span class="line">2. 割边（Cut-edge）特指那些其目的地更有可能达到 bug trace 中下一个目标的边。通过静态内部程序分析识别割边，帮助 UAFuzz 理解程序内部的逻辑结构。偏好那些触发更多割边的输入。这种评分不仅考虑了覆盖到的割边数量，还考虑了这些割边被触发的次数（即命中计数）。直觉在于，通过更频繁地执行那些关键路径（即通过割边的路径），测试用例更有可能以正确的顺序触发漏洞相关的事件（如UAF中的分配、释放后使用）。</span><br><span class="line">3. 相似度计算。会优先考虑那些不仅覆盖了与漏洞痕迹相似的目标位置序列，而且在整个漏洞痕迹中覆盖了更多目标位置的测试用例。</span><br></pre></td></tr></table></figure>
<p><strong>UAF 基础</strong></p>
<p>UAF 就是 free 后再使用，它会导致信息泄露、DOS 攻击等。</p>
<p><img src="/images/intern-ms-prepare/image-20240312125118650.png" alt="image-20240312125118650" style="zoom:67%;" /></p>
<p>一个 UAF 的例子：</p>
<p><img src="/images/intern-ms-prepare/image-20240312125249331.png" alt="image-20240312125249331" style="zoom:67%;" /></p>
<p><strong>Fuzz 基础</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">黑盒 fuzz：不需要关于软件内部结构或实现的先验知识。测试人员主要关注软件的外部表现和输出，而不是其内部逻辑。测试用例通常是随机生成的，不依赖于程序的内部逻辑。</span><br><span class="line">灰盒 fuzz：结合了黑盒测试和白盒测试（了解内部结构的测试）的特点。尽管不需要完全了解软件的内部实现细节，但测试过程会利用一定程度的内部信息（如代码覆盖率）来指导测试用例的生成和执行。</span><br><span class="line">白盒 fuzz。</span><br></pre></td></tr></table></figure>
<p>&emsp;灰盒测试的步骤：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 选择好的输入。</span><br><span class="line">2. 输入突变。</span><br><span class="line">3. 根据输出来评估输入的好坏。</span><br><span class="line">4. 对配置进行更新，从而指导输入进行突变。</span><br><span class="line">5. 跳转到 2。</span><br></pre></td></tr></table></figure>
<p>&emsp;没有尽善尽美的做法，由于漏洞有的很复杂，且代码中有的数据结构很复杂，所以我们很难对所有类型的漏洞进行 fuzz，只能进行定向灰盒模糊测试 DGF（只能定向 fuzz 出某些漏洞）。它与基于覆盖率为导向的灰盒测试的区别为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. DGF 针对软件的特定部分进行测试。使用程序分析技术来识别和定位目标区域，并生成或调整测试用例以增加触及这些特定区域的概率。这可能涉及到对特定路径的追踪、对特定函数调用的监控等。</span><br><span class="line">2. 基于覆盖率为导向的模糊测试旨在最大化软件执行路径的覆盖率，发现软件中尽可能多的漏洞。通过监控软件的代码覆盖率来引导测试用例的生成和选择。新生成的测试用例如果能够执行到之前未覆盖的代码路径，则会被优先选择用于后续测试。</span><br></pre></td></tr></table></figure>
<p><strong>主流 DGF 的设计</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 以 fuzz 的代码点与二进制文件为基础，生成 edge ID 与 distance 信息，并以此指导 seed 生成。</span><br><span class="line">2. 从最初的 seed 中生成 testcase，并从中选择 distance 最小的 case 作为输入。</span><br><span class="line">3. 根据反馈信息，生成新的 seed，并重新生成 testcase。</span><br><span class="line">4. Power Schedule，（1）确定哪些测试用例值得更多地探索，根据测试用例触达的代码路径或是接近目标区域的程度，决定为其分配更多的资源来生成更多变种。（2）分配测试用例的能量，可以以理解为对每个选中的测试用例生成变种（即通过修改测试用例来探索新路径）的次数。（3）根据测试过程中收集到的数据（如代码覆盖率变化、新发现的路径等），动态调整资源分配策略。</span><br><span class="line">4. Triage：其中一些可能会引起程序的异常行为或崩溃。Triage 阶段首先需要对这些测试用例进行初步的分类和筛选，以区分哪些是真正有价值的（可能触发了漏洞的测试用例），哪些是误报或不相关的。</span><br></pre></td></tr></table></figure>
<p><img src="/images/intern-ms-prepare/image-20240312132103959.png" alt="image-20240312132103959" style="zoom:67%;" /></p>
<p><strong>检测 UAF 的难点</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fuzz 很难发现的原因：</span><br><span class="line">1. 复杂性：多个事件按顺序跨越多个函数</span><br><span class="line">2. 不会报分段错误</span><br></pre></td></tr></table></figure>
<p><strong>UAFuzz 的设计</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">种子选择：基于与 target 输入轨迹的相似度对种子优先级进行排序</span><br><span class="line">能量分配：（1）基于 UAF 的距离，优先考虑覆盖 UAF 事件的种子；（2）Cut-edge Coverage：哪些种子可以覆盖更多的到达目标的边；（3）与目标的相似度。</span><br><span class="line">Triage：仅对覆盖所有边的输入进行分类并进行预过滤。</span><br></pre></td></tr></table></figure>
<p><img src="/images/intern-ms-prepare/image-20240312132445622.png" alt="image-20240312132445622" style="zoom:67%;" /></p>
<p>&emsp;一个 UAF 的例子：</p>
<p><img src="/images/intern-ms-prepare/image-20240312134829311.png" alt="image-20240312134829311" style="zoom:67%;" /></p>
<p>&emsp;能量分配中的 distance 可以这样计算：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">（1）在计算种子距离上，需要考虑目标顺序，调用轨迹依次包含 alloc、free 和 use 函数。</span><br><span class="line">（2）直觉：一个触发 UAF 漏洞的有效测试用例很可能是那些能按正确顺序（即分配、释放后使用）并覆盖多个 UAF 事件的路径。那么，通过静态分析技术预先识别程序调用图中可能导致 UAF 事件序列的 (caller, callee) 对，并在计算距离时降低这些调用对的权重，这意味着，如果测试用例的执行路径包含了这样的调用对，它们被认为是距离目标更近的路径。例如：首选调用跟踪 &lt;main, f_2, f_use&gt;, &lt;main, f_1, f_3, f_use&gt;。</span><br></pre></td></tr></table></figure>
<p><img src="/images/intern-ms-prepare/image-20240312140224199.png" alt="image-20240312140224199" style="zoom:67%;" /></p>
<p>&emsp;在能量分配时采用 Cut-edge Coverage Metric（割边覆盖度量）技术：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">在现有的模糊测试工作中，当考虑测试用例是否能按序到达目标时，所有边（程序执行过程中可能遍历的路径）通常被等同对待。这意味着，在评估测试用例的有效性时，并没有对不同边根据它们达到后续目标的概率进行区分。</span><br><span class="line"></span><br><span class="line">割边（Cut-edge）特指那些其目的地更有可能达到 bug trace 中下一个目标的边。通过静态内部程序分析识别割边，帮助 UAFuzz 理解程序内部的逻辑结构。</span><br><span class="line"></span><br><span class="line">UAFuzz 偏好那些触发更多割边的输入。这种评分不仅考虑了覆盖到的割边数量，还考虑了这些割边被触发的次数（即命中计数）。直觉在于，通过更频繁地执行那些关键路径（即通过割边的路径），测试用例更有可能以正确的顺序触发漏洞相关的事件（如UAF中的分配、释放后使用）。</span><br></pre></td></tr></table></figure>
<p><img src="/images/intern-ms-prepare/image-20240312141542040.png" alt="image-20240312141542040" style="zoom:67%;" /></p>
<p>&emsp;在能量分配时采用的相似度计算：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">传统的方法在选择待变异的种子测试用例时，并不考虑测试用例覆盖的目标位置数量。意味着，尽管某些测试用例可能覆盖了更多与潜在漏洞相关的代码区域，但它们并没有因此而获得更高的优先级。</span><br><span class="line"></span><br><span class="line">（1）前缀（Prefix）：它考虑了测试用例覆盖目标位置的顺序。如果一个测试用例按照与漏洞痕迹（bug trace）相似的顺序覆盖了一系列目标位置，那么这个测试用例被认为是更有价值的。</span><br><span class="line">（2）包（Bag）：虽然不如前缀精确，因为它不考虑目标位置的覆盖顺序，但它考虑了整个漏洞痕迹中所有被覆盖的目标位置。这使得能够从一个更宽泛的视角评估测试用例与目标之间的相似度。</span><br><span class="line"></span><br><span class="line">基于前缀和包度量：UAFuzz 采用了一种基于前缀和包度量结合的种子选择。这意味着它在选择种子测试用例时，会优先考虑那些不仅覆盖了与漏洞痕迹相似的目标位置序列，而且在整个漏洞痕迹中覆盖了更多目标位置的测试用例。</span><br><span class="line"></span><br><span class="line">选择最大覆盖输入：具体来说，UAFuzz更频繁地选择那些到目前为止在这个度量上取得最高值的“最大覆盖输入”（max-reaching inputs），即那些与漏洞痕迹最相似的测试用例。</span><br></pre></td></tr></table></figure>
<p><img src="/images/intern-ms-prepare/image-20240312142056779.png" alt="image-20240312142056779" style="zoom:80%;" /></p>
<p>&emsp;找出可疑漏洞并作筛选（pre-filter）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">利用目标相似度度量（Target Similarity Metric）：UAFuzz 通过目标相似度度量来自动识别出哪些测试用例是潜在输入。</span><br></pre></td></tr></table></figure>
<h4 id="0x00-3-2-基于双向-GRU-attention-的聊天机器人"><a href="#0x00-3-2-基于双向-GRU-attention-的聊天机器人" class="headerlink" title="0x00-3-2 基于双向 GRU + attention 的聊天机器人"></a>0x00-3-2 基于双向 GRU + attention 的聊天机器人</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用双向GRU+attention进行训练，tkinter 进行 GUI 展示。通过注册和登录机制与聊天机器人对话。聊天机器人使用 50,000 个小黄鸭样本进行训练，使用的是第 75 轮训练的结果。我们的聊天机器人仅适用于中文。并且部署了 mysql。</span><br></pre></td></tr></table></figure>
<h4 id="0x00-3-3-VPN-状态下的内网扫描工具"><a href="#0x00-3-3-VPN-状态下的内网扫描工具" class="headerlink" title="0x00-3-3 VPN 状态下的内网扫描工具"></a>0x00-3-3 VPN 状态下的内网扫描工具</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果想扫描一个企业（一般是学校）的内部网络，但是它的vpn（easyconnect）不可用，只对外提供 webvpn 的接口，那么你可以使用这个工具来扫描内部网络。该工具针对的webvpn是wrd tech开发的，使用AES-CBC-128加密，默认的key和iv都是wrdvpnisthebest!。 因此，对于没有修改key和iv的企业，我们可以将内网url转换为公网url。</span><br></pre></td></tr></table></figure>
<p><strong>Step1：拿到账号：<code>xx</code>；密码：<code>xx</code>。</strong>进入<code>https://webvpn.bit.edu.cn/</code>并登录。需要注意的是，由于北京理工大学已经禁止<code>vpn</code>登录，因此只能使用<code>webvpn</code>。</p>
<p><strong>Step2：</strong>北京理工大学<code>webvpn</code>界面如下：</p>
<p><img src="/images/intern-ms-prepare/image-20230507134603952.png" alt="image-20230507134603952" style="zoom:67%;" /></p>
<p>&emsp;经查找，<strong>其提供的服务并没有校园网用户认证：<code>10.0.0.55/srun_portal_pc?
ac_id=8&amp;srun_wait=1&amp;theme=bit</code>。</strong></p>
<p><strong>Step3：</strong>经查阅，此<code>webvpn</code>为信瑞达公司，在<code>webvpn</code>中的内网<code>url</code>加密时，<strong>使用<code>AES-128</code>加密，默认<code>key=wrdvpnisthebest!</code>，<code>iv=wrdvpnisthebest!</code>。经过检验，北京理工大学并未修改<code>key</code>与<code>iv</code>的值，保留了默认值。</strong>借助脚本<code>webvpn.py</code>，可以将<code>10.0.0.55/srun_portal_pc?ac_id=8&amp;srun_wait=1&amp;theme=bit</code>转为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://webvpn.bit.edu.cn/http/77726476706e69737468656265737421a1a70fcc696026052b/srun_portal_pc?ac_id=8&amp;srun_wait=1&amp;theme=bit</span><br></pre></td></tr></table></figure>
<p><strong>Step4：</strong>因此，由</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://webvpn.bit.edu.cn/http/77726476706e69737468656265737421a1a70fcc696026052b/srun_portal_pc?ac_id=8&amp;srun_wait=1&amp;theme=bit</span><br></pre></td></tr></table></figure>
<p>，可以访问校园网用户认证界面，审计发现，其<code>js</code>代码存在缺陷。</p>
<p><strong>Step5：</strong>由于此网页为<code>HTTP</code>，并未使用<code>HTTPS</code>。分析网页<code>js</code>源码，发现密码直接使用<code>base64</code>表替换加密，而未使用其它保护用户口令的方法（如随机数）。<code>js</code>源码如下所示：</p>
<p><img src="./images/intern-ms-prepare/image-20230506120316264.png" alt="image-20230506120316264" style="zoom:67%;" /></p>
<p><strong>Step6：</strong>因此，开启<code>wireshark</code>混杂模式，抓取北京理工大学内网流量包，成功抓到用户认证流量包。如下所示：</p>
<p><img src="./images/intern-ms-prepare/image-20230507151531629.png" alt="image-20230507151531629" style="zoom:67%;" /></p>
<h4 id="0x00-3-4-图像中文描述"><a href="#0x00-3-4-图像中文描述" class="headerlink" title="0x00-3-4 图像中文描述"></a>0x00-3-4 图像中文描述</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Show, Attend, and Tell。本论文在RNN（LSTM）上加入了attention机制，对图像特征的像素点进行概率估计，并加权求和，其思想为：人们在观察图像中倾向于关注有用信息，它将Attention作用到输入图像的像素点之上。之后，写了一个 c++ http_server 用于接收图片，用 react 写了一个前端用于回传。</span><br></pre></td></tr></table></figure>
<p><img src="./images/intern-ms-prepare/image-20240312144602484.png" alt="image-20240312144602484" style="zoom:67%;" /></p>
<h4 id="0x00-3-5-基于-rust-的-FPS-游戏透视"><a href="#0x00-3-5-基于-rust-的-FPS-游戏透视" class="headerlink" title="0x00-3-5 基于 rust 的 FPS 游戏透视"></a>0x00-3-5 基于 rust 的 FPS 游戏透视</h4><p>正在开发 AssaultCube 的外挂。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 已知玩家头部坐标为 x1,y1,z1，敌人头部坐标为 x2,y2,z2，敌人脚部坐标为 x3,y3,z3，根据上述代码，如何进行计算，将敌人的方框展示在玩家的屏幕上？</span><br><span class="line">（1）需要将敌人的头部和脚部坐标从世界坐标系转换到屏幕坐标系，需要用到视图矩阵和投影矩阵，这可以从游戏的内存中读取（0x17DFD0）。</span><br><span class="line">（2）根据视图矩阵，对于敌人的头部 (x2, y2, z2) 和脚部 (x3, y3, z3) 坐标，将坐标转换到屏幕坐标系中，从而获得：(head_screen_x, head_screen_y) 和 (feet_screen_x, feet_screen_y)。</span><br><span class="line">（3）使用 windows_ez_overlay 绘制方框。</span><br></pre></td></tr></table></figure>
<p>&emsp;AssaultCube 是一个局域网的 FPS 游戏，分析后发现没有任何检测技术。因此，其客户端进程 ac_client.exe 可以被任意读取，且发现玩家信息固定保存在 0x18AC04，使用 rust 多线程读取后进行坐标转换计算玩家矩形位置与大小。打包成 dll 直接进行注入即可。原始的 Cube 游戏是用 C++ 和 OpenGL 开发的。</p>
<p><img src="./images/intern-ms-prepare/image-20240417153822914.png" alt="image-20240417153822914" style="zoom:67%;" /></p>
<ul>
<li>为什么要用 rust 实现？</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">rust 的安全性体现在哪里？内存安全。内存安全是指在程序运行过程中，对内存访问的控制，保证程序可以正确、安全地处理内存中的数据。不正确的内存访问可能导致各种严重问题，比如数据泄露、程序崩溃和安全漏洞等。常见的内存安全问题包括但不限于：</span><br><span class="line"></span><br><span class="line">1. 缓冲区溢出：当程序写入的数据超过了分配的内存大小时，会覆盖相邻内存区域的数据，可能导致程序行为异常或被恶意利用。</span><br><span class="line">2. 悬垂指针：当内存被释放后，仍有指针指向该内存区域，再次访问该指针会导致不可预知的行为。</span><br><span class="line">3. 重复释放内存：对同一块内存进行多次释放操作可能会引发程序崩溃或其他安全问题。</span><br><span class="line">4. 野指针：指向未知内存区域的指针，其访问可能导致程序崩溃或数据损坏。</span><br><span class="line"></span><br><span class="line">rust 是如何保证内存安全的？Rust 通过一系列语言设计和编译器检查，提供了强大的内存安全保障，主要体现在以下几点：</span><br><span class="line"></span><br><span class="line">1. 所有权系统：Rust通过所有权（Ownership）、借用（Borrowing）和生命周期（Lifetimes）的概念来管理内存。每块数据在Rust中都有一个明确的所有者；数据可以被借用，但在任何时刻，要么只能有一个可变引用（写权限），要么有多个不可变引用（读权限），这避免了数据竞争和修改冲突。</span><br><span class="line">2. 借用检查器：Rust编译器内置的借用检查器能在编译时检查引用是否遵守所有权和生命周期的规则，确保安全地访问内存。</span><br><span class="line">3. 模式匹配：Rust的模式匹配强制开发者处理所有可能的情况，减少因遗漏处理分支而导致的潜在内存安全问题。</span><br><span class="line">4. 无空指针：Rust通过Option&lt;T&gt;枚举类型处理可能为空的情况，使得开发者必须显式处理None情况，避免了空指针引用。</span><br></pre></td></tr></table></figure>
<ul>
<li>游戏坐标加密了怎么办？</li>
<li>32位的hook与64位的hook有什么区别？</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1. 对于系统API的hook，windows 系统为了达成hotpatch的目的，每个API函数的最前5个字节均为：</span><br><span class="line">move edi,edi</span><br><span class="line">push ebp</span><br><span class="line">mov ebp,esp</span><br><span class="line"></span><br><span class="line">其中move edi,edi这条指令是为了专门用于hotpatch而插入的，微软通过将这条指令跳转到一个short jmp，然后一个long jmp可以跳转到任意4G范围内的代，达到运行中替换dll的目的。假设我们要求把0x12345678这个地址的函数hook，使其跳转到0x12345690，我们可以将这5个字节替换为：0xe9 (0x12345690-0x12345678-5) ，以达到跳转到0x12345690这个地址的目的（此处，注意大小端系统的区别），这条指令是相对跳转。</span><br><span class="line"></span><br><span class="line">2. 64位系统没有了上面这样的方便之处，因此必须有一种新的策略。64位的跳转，可用两种方法，下面两个方法都是绝对跳转指令。</span><br><span class="line">（1）</span><br><span class="line">mov rax, 0x0123456789abcdef</span><br><span class="line">jmp rax</span><br><span class="line"></span><br><span class="line">（2）也可以间接跳转。将一个old_func_address的前x个字节修改为跳转到我们的new_func_address，然后再运行原来的函数地址</span><br></pre></td></tr></table></figure>
<ul>
<li>hypervisor。</li>
</ul>
<h2 id="0x01-基础知识"><a href="#0x01-基础知识" class="headerlink" title="0x01 基础知识"></a>0x01 基础知识</h2><h3 id="0x01-1-逆向相关"><a href="#0x01-1-逆向相关" class="headerlink" title="0x01-1 逆向相关"></a>0x01-1 逆向相关</h3><h4 id="0x01-1-1-反调试技术"><a href="#0x01-1-1-反调试技术" class="headerlink" title="0x01-1-1 反调试技术"></a>0x01-1-1 反调试技术</h4><p>1.有一些标志，在正常的运行状态的值跟调试状态的值不一样，或者就是一些 API （IsDebuggerPresent，查询进程环境块 PEB 中的 BeingDebugged 标志），在正常的运行下跟调试状态运行下的结果或返回值不一样。</p>
<p>2.根据运行时间（RDTSC），在正常情况下，我们的一个函数到下一个函数的运行时间也就是0.0000001秒，但是在调试状态下由于单步运行就会让这个运行时间增加，我们可以在第一个函数中获取当前时间，在第二个函数中也获取当前时间。</p>
<p>3.调试器在做软件断点的时候 会有 CC 指令写入,我们就可以对 CC 进行检测，调试器在做硬件断点的时候会对调试寄存器进行操作，我们可以检测调试寄存器中的值，调试器在做内存访问断点的时候，会修改内存属性，我可以对内存属性进行检测。</p>
<p>4.基于异常的机制，我们可以在程序里面制造一些异常，编写异常处理函数，在异常处理函数里面进行检测。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">（1）筛选器异常。（如果有SetUnhandledExceptionFilter这种函数，就说明有筛选器的存在）</span><br><span class="line">异常默认是由操作系统处理的，现在用 API 设置由用户自己定义处理异常（内存访问无效，修改到常量区等错误），当发生异常的时候，系统将调用这个回调函数，并根据回调函数的返回值决定如何进行下一步操作。在进程范围内，筛选器异常处理回调函数是唯一的，设置了一个新的回调函数后，原来的就失效了。</span><br><span class="line"></span><br><span class="line">语法：invoke SetUnhandledExceptionFilter, offset MyFilter  </span><br><span class="line"></span><br><span class="line">使用场景：代码加密（加密是因为可以防止他人改 eip 跳过你的异常，加了密之后就算跳过看到的也是加密后的代码，执行加密的代码段也是会错的）。代码段进行加密，代码开始产生异常报错，异常筛选器的回调内解密代码，重设eip信息。非调试状态能正常执行程序，调试状态不能正常执行程序（注册异常后用调试工具的话，异常会被调试工具接收，断点不了异常处理函数，也就调试不了程序，除非找到你的异常处理函数）</span><br><span class="line"></span><br><span class="line">（2）SEH 异常处理。在程序当中如果发现有 Fs[0] 这种代码 就说明有 SEH 的存在。</span><br></pre></td></tr></table></figure>
<p>5.符号检测&amp;窗口检测&amp;特征码检测。主要针对一些使用了驱动的调试器或监视器，这类调试器在启动后会创建相应的驱动链接符号，以用于应用层与其驱动的通信。但由于这些符号一般都比较固定。</p>
<p>6.TLS 线程局部存储。</p>
<p>7.PEB 结构体。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. BeingDebugged。IsDebuggerPresent API。</span><br><span class="line">2. Ldr，一个指向_PEB_LDR_DATA结构的指针，存储当前进程加载的所有模块的信息，包括模块的基地址、入口点、导入表、导出表等。调试进程时，堆内存会出现很多0xFEEEFEEE，表示未使用过的堆内存。而_PEB_LDR_DATA是在堆内存中创建的，所以查看PEB.Ldr，看里面是否有0xFEEEFEEE。若有，则代表进程正在被调试。</span><br><span class="line">3. ProcessHeap，指向HEAP结构体，Flags(+0xC)与ForceFlags(+0x10)两个成员，当被调试时，这两个成员被设置为特定的值（正常情况下Flags为0x2，ForceFlags为0x0，仅在XP中有效）。</span><br><span class="line">4. NtGlobalFlag，PEB.NtGlobalFlag会设置为0x70，正常应该是0。</span><br></pre></td></tr></table></figure>
<p>8.NtQuerylnformationProcess 获得与调试相关的信息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">（1）ProcessDebugPort，进程处于调试状态时，系统就会为它分配1个调试端口(Debug Port)，若进程处于非调试状态，则变量dwDebugPort的值设置为0；若进程处于调试状态，则变量dwDebugPort的值设置为0xFFFFFFFF。</span><br><span class="line"></span><br><span class="line">（2）ProcessDebugObjectHandle，会获得调试对象的句柄，如果进程处理与调试状态，句柄就存在，反之就不存在。</span><br><span class="line"></span><br><span class="line">（3）ProcessDebugFlags。</span><br></pre></td></tr></table></figure>
<p>9.NtQuerySysteminformation，NtQueryObject 等 API，ZwSetlnformationThread（强制分离 detach 被调试者与调试器，从而达到反调试的目的）。</p>
<h4 id="0x01-1-2-外挂检测"><a href="#0x01-1-2-外挂检测" class="headerlink" title="0x01-1-2 外挂检测"></a>0x01-1-2 外挂检测</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FPS游戏简单，刷新速度快，检测物体多，数据量大。导致它的大部分运算只能放在本地，也就是你的电脑上进行。</span><br><span class="line"></span><br><span class="line">MOBA 游戏难，每一次玩家的点击数据都需要上传给服务器进行判断，简而言之就是服务器做的运算的工作，本地只是一个执行的动画。需要去拆游戏过程中上传服务器的数据包，拆完还需绕过服务器的验证规则。最后你还需要成功修改，不能被发现。</span><br></pre></td></tr></table></figure>
<p><strong>FPS 外挂</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1. 自瞄，锁头。</span><br><span class="line">	（a）通过截图当前窗口，分析图片中的人物，再结合骨骼参数进行判断，操作鼠标事件去进行调整。</span><br><span class="line">	（b）通过hook游戏函数的方式修改朝向、或者通过坐标读取并模拟按键的方式操作玩家锁定敌人的模型头部。</span><br><span class="line"></span><br><span class="line">2. 透视。</span><br><span class="line">	（a）读取游戏客户端数据来获取敌人的准确坐标，并且通过修改系统DLL、显卡驱动、游戏的渲染参数等方式，将敌人的准确位置展示给作弊玩家。</span><br><span class="line">	（b）对抗：模拟假人数据投放入战场，以此来混淆透视外挂的效率。</span><br><span class="line">	（c）游戏利用Direct3D （D3D）渲染一个物体，而D3D提供多种渲染状态，它影响几何物体怎样被渲染。渲染类的透视外挂就是利用D3D的原理，通过修改相应的游戏文件参数实现的。</span><br><span class="line"></span><br><span class="line">3. AI 外挂。异常行为检测（鼠标输入波动），使用 AI 对抗 AI。</span><br><span class="line">3. DMA 外挂。</span><br><span class="line">	（a）DMA是Direct Memory Access（直接内存访问）是一种读写数据的计算机技术，允许硬件设备（如网卡、显卡等）直接访问系统内存，而不需要通过CPU。</span><br><span class="line">	（b）传统外挂有外挂程序运行于作弊机器上读写游戏客户端关键数据或代码；而DMA外挂则是以硬件替代了外挂软件读写游戏数据，物理隐藏了外挂程序。</span><br></pre></td></tr></table></figure>
<h4 id="0x01-1-3-SEH-amp-VEH-amp-UEH"><a href="#0x01-1-3-SEH-amp-VEH-amp-UEH" class="headerlink" title="0x01-1-3 SEH&amp;VEH&amp;UEH"></a>0x01-1-3 SEH&amp;VEH&amp;UEH</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">向量异常处理（VEH）：</span><br><span class="line">    （1）允许开发者为线程注册多个异常处理器函数。</span><br><span class="line">    （3）不是基于堆栈的，而是基于先进先出（FIFO）的队列。</span><br><span class="line">    （3）SetWindowsHookEx（spy++）。</span><br><span class="line">	（4）当异常发生时，首先调用 VEH 处理器（按照它们注册的顺序），早于 SEH。</span><br><span class="line"></span><br><span class="line">结构化异常处理（SEH）：</span><br><span class="line">	（1）Windows 提供的标准异常处理机制，支持在程序中直接处理硬件异常（如访问违规、除零错误等）和软件异常。</span><br><span class="line">	（2）SEH 使用 try 和 except 语句来定义异常处理代码块。指 C++ 中的异常处理机制，使用 try、catch 语句处理异常。</span><br><span class="line">	（3）当异常发生时，系统会查找最近的SEH异常处理器（即最近的 try/except 代码块）。如果找到，就执行相应的处理代码。如果没有找到，异常会向调用堆栈上抛。</span><br><span class="line"></span><br><span class="line">非结构化异常处理（UEH）：</span><br><span class="line">	（1）</span><br><span class="line"></span><br><span class="line">执行顺序：VEH -&gt; SEH -&gt; UEH。</span><br></pre></td></tr></table></figure>
<h4 id="0x01-1-4-hook"><a href="#0x01-1-4-hook" class="headerlink" title="0x01-1-4 hook"></a>0x01-1-4 hook</h4><p><strong>（1）PLT/GOT hook。GOT/PLT 挂钩是通过修改 GOT/PLT 段的地址来实现的。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GOT（全局偏移表）位于数据段中，它将记录外部符号的地址映射，外部符号包含变量和函数。然而，库在加载到内存时并没有固定的地址，所以GOT不能直接保存符号的地址。</span><br><span class="line"></span><br><span class="line">PLT（过程链接表）位于代码段中，库中的每个外部函数都将记录在PLT中。每个PLT的记录都是一个小的可执行代码。PLT的记录将跳转到 .GOT 中的函数调用。</span><br><span class="line"></span><br><span class="line">在编译阶段，-fPIC参数将生成与位置无关的代码。如果库不使用-fPIC参数，则当加载到进程的内存时，库文件需要重新定位并更改其代码段（意味着我们需要重复的库）。如果库使用-fPIC，则库将使用相对地址，因此我们不需要更改库代码段。当调用函数时，它将首先跳转到PLT，然后根据GOT的记录跳转到实际的函数地址。在首次调用外部函数之前，GOT表不记录其地址，这是因为linux使用了延迟绑定技术。</span><br><span class="line"></span><br><span class="line">GOT表的记录最初都保存dl_runtime_resolve函数。当首次调用外部函数时，将跳转到PLT，然后根据GOT的记录跳转到dl_runtime_resolve函数地址。此函数将把实际的外部函数地址写入GOT的记录。</span><br></pre></td></tr></table></figure>
<p><img src="/images/intern-ms-prepare/1707289802016-78cd1101-f194-4615-8aec-9a4b629dec82.png" alt="image.png" style="zoom:67%;" /></p>
<p><strong>（2）inline hook。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">反 hook：</span><br><span class="line">（1）RIP 地址。</span><br><span class="line">（2）short jump。跳转到一个地址，但是是 256 字节内。</span><br><span class="line">（3）jump back，如下图：</span><br></pre></td></tr></table></figure>
<p><img src="/images/intern-ms-prepare/1707289802495-7d7d476c-7401-49c5-9a46-9fb76107378c.png" alt="img" style="zoom:67%;" /></p>
<h5 id="（3）普通-hook，先-unhook，执行正常逻辑，然后再-hook。"><a href="#（3）普通-hook，先-unhook，执行正常逻辑，然后再-hook。" class="headerlink" title="（3）普通 hook，先 unhook，执行正常逻辑，然后再 hook。"></a>（3）普通 hook，先 unhook，执行正常逻辑，然后再 hook。</h5><h4 id="0x01-1-5-Go-逆向的点"><a href="#0x01-1-5-Go-逆向的点" class="headerlink" title="0x01-1-5 Go 逆向的点"></a>0x01-1-5 Go 逆向的点</h4><h4 id="0x01-1-6-C-虚表判定"><a href="#0x01-1-6-C-虚表判定" class="headerlink" title="0x01-1-6 C++ 虚表判定"></a>0x01-1-6 C++ 虚表判定</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">（1）构造函数中使用 lea 0xxxxx(%rip),%rdx 的方式拿到虚表。</span><br><span class="line">（2）一个单独的类(无父类)虚表指针是成员变量的第一个成员。</span><br><span class="line">（3）C++ 对象在构造函数中初始化虚表指针，虚表指针指向类的虚表。</span><br></pre></td></tr></table></figure>
<h4 id="0x01-1-7-rust-逆向的点"><a href="#0x01-1-7-rust-逆向的点" class="headerlink" title="0x01-1-7 rust 逆向的点"></a>0x01-1-7 rust 逆向的点</h4><h4 id="0x01-1-8-flutter-逆向的点"><a href="#0x01-1-8-flutter-逆向的点" class="headerlink" title="0x01-1-8 flutter 逆向的点"></a>0x01-1-8 flutter 逆向的点</h4><h4 id="0x01-1-9-安卓逆向"><a href="#0x01-1-9-安卓逆向" class="headerlink" title="0x01-1-9 安卓逆向"></a>0x01-1-9 安卓逆向</h4><h5 id="Frida-与-Xposed-原理"><a href="#Frida-与-Xposed-原理" class="headerlink" title="Frida 与 Xposed 原理"></a>Frida 与 Xposed 原理</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Frida 主要是通过将一个代理库注入到目标进程中，然后利用这个库提供的接口执行 JavaScript 脚本，实现对目标进程的控制。</span><br><span class="line">Xposed 则是在 Android 系统级别工作，通过修改 Zygote 进程（Android 中所有应用进程的父进程）来影响后续启动的所有应用。</span><br></pre></td></tr></table></figure>
<h5 id="Exception-hook-原理"><a href="#Exception-hook-原理" class="headerlink" title="Exception hook 原理"></a>Exception hook 原理</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Windows:</span><br><span class="line">	Structured Exception Handling (SEH): 是一种基于栈的异常处理机制，函数内部设置异常处理代码，当发生异常时，Windows 会从当前函数开始向上遍历调用栈</span><br><span class="line">	Vectored Exception Handling (VEH) 先于 SEH 处理程序执行。</span><br><span class="line">Linux：</span><br><span class="line">	异常处理通常通过信号（Signals）机制实现。当程序遇到错误时，操作系统会发送一个信号给进程。</span><br></pre></td></tr></table></figure>
<h5 id="Ptrace-amp-ebpf原理"><a href="#Ptrace-amp-ebpf原理" class="headerlink" title="Ptrace &amp; ebpf原理"></a>Ptrace &amp; ebpf原理</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Ptrace：GDB的基础</span><br><span class="line">ebpf 原理：允许在内核中运行沙箱化的程序，而无需修改内核代码或加载模块。eBPF 程序可以附加到各种内核事件（如系统调用、网络包、文件访问等），并收集数据。</span><br></pre></td></tr></table></figure>
<h5 id="ARM汇编：寄存器，调用约定（包括其他CPU架构），跳转指令"><a href="#ARM汇编：寄存器，调用约定（包括其他CPU架构），跳转指令" class="headerlink" title="ARM汇编：寄存器，调用约定（包括其他CPU架构），跳转指令"></a>ARM汇编：寄存器，调用约定（包括其他CPU架构），跳转指令</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">1. 寄存器：</span><br><span class="line">R0-R12：通用寄存器，用于存储数据和地址。</span><br><span class="line">R13 (SP)：堆栈指针，指向当前堆栈的顶部。</span><br><span class="line">R14 (LR)：链接寄存器，用于保存子程序返回地址。</span><br><span class="line">R15 (PC)：程序计数器，指向当前执行的指令地址。</span><br><span class="line">CPSR (Current Program Status Register)：当前程序状态寄存器，包含条件标志位和其他控制位。</span><br><span class="line">SPSR (Saved Program Status Register)：保存的程序状态寄存器，用于模式切换时保存 CPSR 的值。</span><br><span class="line"></span><br><span class="line">2. 调用约定：AAPCS (ARM Architecture Procedure Call Standard)</span><br><span class="line">2-1. 参数传递：前四个参数使用 R0-R3 寄存器传递。剩余的参数通过堆栈传递。如果参数是浮点数，可以使用 VFP/SIMD 寄存器 S0-S15 或 D0-D7 传递。</span><br><span class="line">2-2. 返回值：返回值通常通过 R0 寄存器传递。如果返回值是浮点数，可以使用 S0 或 D0 传递。</span><br><span class="line">2.3. 寄存器使用：</span><br><span class="line">	R0-R3：用于传递参数和返回值，调用者保存。</span><br><span class="line">	R4-R11：用于保存局部变量，被调用者保存。</span><br><span class="line">	R12：临时寄存器，调用者保存。</span><br><span class="line">	R13 (SP)：堆栈指针，被调用者保存。</span><br><span class="line">	R14 (LR)：链接寄存器，调用者保存。</span><br><span class="line">	R15 (PC)：程序计数器，自动管理。</span><br><span class="line">	</span><br><span class="line">3. 常见的 ARM 跳转指令：</span><br><span class="line">	B (Branch)：无条件跳转到指定地址</span><br><span class="line">	BL (Branch with Link)：跳转到指定地址，并将返回地址保存到 LR 寄存器。</span><br><span class="line">	BX (Branch and Exchange)：跳转到指定地址，并切换到目标地址的指令集（Thumb 或 ARM）。</span><br></pre></td></tr></table></figure>
<h5 id="Thumb-或-ARM指令集的区别"><a href="#Thumb-或-ARM指令集的区别" class="headerlink" title="Thumb 或 ARM指令集的区别"></a>Thumb 或 ARM指令集的区别</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ARM 指令集：指令长度固定为 32 位（4 字节）。支持更丰富的指令集和更复杂的操作。</span><br><span class="line">Thumb 指令集：指令长度固定为 16 位（2 字节）。指令集相对简单，但足以覆盖大多数常见的操作。</span><br><span class="line">ARM 指令集：占用更多的内存空间。适用于对性能要求较高的场景，如高性能计算和复杂算法。</span><br><span class="line">Thumb 指令集：用于对代码大小敏感的嵌入式系统，如微控制器和移动设备</span><br></pre></td></tr></table></figure>
<h5 id="DEX结构、ELF结构、反编译过程"><a href="#DEX结构、ELF结构、反编译过程" class="headerlink" title="DEX结构、ELF结构、反编译过程"></a>DEX结构、ELF结构、反编译过程</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">DEX（Dalvik Executable）文件是 Android 应用程序的字节码格式，用于在 Dalvik 虚拟机（现在是 ART 虚拟机）上运行。ELF（Executable and Linkable Format）是一种常见的二进制文件格式，用于可执行文件、共享库和对象文件。</span><br><span class="line"></span><br><span class="line">DEX 文件反编译</span><br><span class="line">（1）提取 DEX 文件：从 APK 文件中提取 DEX 文件。</span><br><span class="line">（2）解析 DEX 文件：使用工具（如 dexdump）解析 DEX 文件的结构。</span><br><span class="line">（3）反编译字节码：使用工具（如 dex2jar 和 JD-GUI）将 DEX 文件转换为 Java 字节码（.class 文件）。</span><br><span class="line">（4）查看源代码：使用反编译工具（如 JD-GUI）查看和分析 Java 源代码。</span><br><span class="line"></span><br><span class="line">ELF 文件反编译</span><br><span class="line">（1）提取 ELF 文件：从目标文件中提取 ELF 文件。</span><br><span class="line">（2）解析 ELF 文件：使用工具（如 readelf）解析 ELF 文件的结构。</span><br><span class="line">（3）反汇编：使用工具（如 objdump）将 ELF 文件反汇编为汇编代码。</span><br><span class="line">（4）高级反编译：使用工具（如 IDA Pro 或 Ghidra）将汇编代码转换为更高层次的伪代码或 C 代码。</span><br><span class="line">（5）分析源代码：查看和分析反编译后的代码。</span><br></pre></td></tr></table></figure>
<h5 id="Java反射、静态代理和动态代理"><a href="#Java反射、静态代理和动态代理" class="headerlink" title="Java反射、静态代理和动态代理"></a>Java反射、静态代理和动态代理</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Java 反射（Reflection）允许程序动态地调用对象的方法和访问字段。动态创建对象：可以在运行时创建任意类的对象。动态调用方法：可以在运行时调用任意类的方法。动态访问字段：可以在运行时访问任意类的字段。</span><br><span class="line"></span><br><span class="line">静态代理指的是编译时就已经确定的代理类。代理类和目标类实现了相同的接口，通过代理类来间接调用目标类的方法。动态代理是指在运行时动态生成代理类，Java 提供了 java.lang.reflect.Proxy 类和 java.lang.reflect.InvocationHandler 接口来实现动态代理。</span><br></pre></td></tr></table></figure>
<h5 id="反调试和反反调试、ollvm（反混淆）"><a href="#反调试和反反调试、ollvm（反混淆）" class="headerlink" title="反调试和反反调试、ollvm（反混淆）"></a>反调试和反反调试、ollvm（反混淆）</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">安卓反调试：</span><br><span class="line">（1）isDebuggerConnected() - hook</span><br><span class="line">（2）检查 /proc 文件系统中的 status 文件，可以判断当前进程是否被调试（tracerPid）- 手动修改 /proc/&lt;pid&gt;/status 文件中的 TracerPid 值为 0</span><br><span class="line">（3）ptrace 的返回值（是否是-1）来判断是否被调试 - hook</span><br><span class="line">（4）adb Process process = Runtime.getRuntime().exec(&quot;getprop ro.debuggable&quot;); - adb shell setprop ro.debuggable 0</span><br><span class="line">（5）系统中是否存在 frida、Xposed 相关的文件和进程，检查 zygote 进程的状态</span><br><span class="line">（6）检查设备是否是模拟器</span><br></pre></td></tr></table></figure>
<h5 id="加固与脱壳（整体加固、指令抽取、指令转换-vmp、java2c）"><a href="#加固与脱壳（整体加固、指令抽取、指令转换-vmp、java2c）" class="headerlink" title="加固与脱壳（整体加固、指令抽取、指令转换/vmp、java2c）"></a>加固与脱壳（整体加固、指令抽取、指令转换/vmp、java2c）</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">整体加固：</span><br><span class="line"></span><br><span class="line">    1.1 代码混淆</span><br><span class="line">    字符串加密：将字符串常量加密，运行时解密。</span><br><span class="line">    类名、方法名、变量名混淆：使用无意义的名称替换原有的类名、方法名和变量名。</span><br><span class="line">    控制流扁平化：将代码的控制流结构打乱，增加逆向工程的难度。</span><br><span class="line">    1.2 资源加密</span><br><span class="line">    资源文件加密：对 APK 中的资源文件（如图片、XML 文件等）进行加密，运行时解密。</span><br><span class="line">    Dex 文件加密：对 DEX 文件进行加密，运行时解密并加载。</span><br><span class="line">    1.3 反调试</span><br><span class="line">    检测调试器：使用 Debug.isDebuggerConnected() 等方法检测调试器。</span><br><span class="line">    检测模拟器：检测设备是否为模拟器。</span><br><span class="line">    检测 root 权限：检测设备是否被 root。</span><br><span class="line">    1.4 反逆向</span><br><span class="line">    完整性校验：对 APK 文件进行完整性校验，防止被篡改。</span><br><span class="line">    动态代码加载：使用动态加载技术，延迟加载关键代码。</span><br><span class="line"></span><br><span class="line">指令抽取：指令抽取是指将程序的关键指令提取出来，存储在不同的位置，然后在运行时动态加载和执行。</span><br><span class="line"></span><br><span class="line">    2.1 指令分段</span><br><span class="line">    分割指令：将指令分成多个部分，存储在不同的位置。</span><br><span class="line">    动态加载：在运行时动态加载和拼接指令。</span><br><span class="line">    2.2 指令加密</span><br><span class="line">    指令加密：对提取的指令进行加密，运行时解密。</span><br><span class="line">    动态解密：在运行时动态解密指令并执行。</span><br><span class="line"></span><br><span class="line">指令转换：Java2C 是一种将 Java 代码转换为 C 代码的技术，通常用于保护 Android 应用程序。通过将关键的 Java 代码转换为 C 代码，可以利用 C 语言的编译优化和保护机制来增加逆向工程的难度。</span><br><span class="line"></span><br><span class="line">    4.1 代码转换</span><br><span class="line">    Java 到 C 转换：将关键的 Java 代码转换为 C 代码。</span><br><span class="line">    编译成 Native 代码：将 C 代码编译成 Native 代码（.so 文件）。</span><br><span class="line">    4.2 代码混淆</span><br><span class="line">    C 代码混淆：对生成的 C 代码进行混淆，增加逆向工程的难度。</span><br><span class="line">    数据加密：对数据进行加密，运行时解密。</span><br><span class="line">    4.3 动态加载</span><br><span class="line">    动态加载 Native 代码：在运行时动态加载和执行 Native 代码。</span><br></pre></td></tr></table></figure>
<h5 id="Unicorn框架原理、VirtualApp框架原理"><a href="#Unicorn框架原理、VirtualApp框架原理" class="headerlink" title="Unicorn框架原理、VirtualApp框架原理"></a>Unicorn框架原理、VirtualApp框架原理</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Unicorn 通过模拟 CPU 的指令执行过程。</span><br><span class="line"></span><br><span class="line">VirtualApp 是一个 Android 应用虚拟化框架，允许在一个应用中运行多个独立的虚拟应用环境。VirtualApp 通过动态代理、类加载器和系统 API 拦截等技术，实现应用的隔离和虚拟化。</span><br></pre></td></tr></table></figure>
<h5 id="安卓虚拟机（Davilk和ART）、JIT和AOT"><a href="#安卓虚拟机（Davilk和ART）、JIT和AOT" class="headerlink" title="安卓虚拟机（Davilk和ART）、JIT和AOT"></a>安卓虚拟机（Davilk和ART）、JIT和AOT</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Dalvik 虚拟机是 Android 早期使用的虚拟机，它基于寄存器架构，主要运行 DEX（Dalvik Executable）格式的字节码。与 JVM 的栈架构不同，Dalvik 使用寄存器架构，Dalvik 使用 JIT 编译技术，在运行时将字节码编译为本地机器码。</span><br><span class="line"></span><br><span class="line">ART 是 Android 5.0（Lollipop）它取代了 Dalvik 虚拟机，提供了更好的性能和内存管理。ART 使用 AOT 编译技术，在安装时将 DEX 字节码编译为本地机器码，生成 OAT（Optimized ART）文件。</span><br></pre></td></tr></table></figure>
<h5 id="HTTPS证书校验（单向、双向校验）、中间人攻击"><a href="#HTTPS证书校验（单向、双向校验）、中间人攻击" class="headerlink" title="HTTPS证书校验（单向、双向校验）、中间人攻击"></a>HTTPS证书校验（单向、双向校验）、中间人攻击</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">单向：客户端验证服务器的证书，但服务器不验证客户端的证书。</span><br></pre></td></tr></table></figure>
<h5 id="安卓系统安全机制（权限控制、签名校验）、so加载流程（linker）"><a href="#安卓系统安全机制（权限控制、签名校验）、so加载流程（linker）" class="headerlink" title="安卓系统安全机制（权限控制、签名校验）、so加载流程（linker）"></a>安卓系统安全机制（权限控制、签名校验）、so加载流程（linker）</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">应用程序在 AndroidManifest.xml 文件中声明权限。</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">so加载流程</span><br><span class="line">2.1 加载请求</span><br><span class="line">    （1）dlopen：显式调用 dlopen 函数加载共享库。</span><br><span class="line">    （2）系统调用：在程序启动时，动态链接器自动加载程序依赖的共享库。</span><br><span class="line">    （3）JNI：在 Java 代码中使用 System.loadLibrary 方法加载共享库。</span><br><span class="line">2.2 动态链接器解析</span><br><span class="line">	（1）查找共享库：动态链接器根据库名查找共享库文件的位置。或者在 /system/lib、/vendor/lib、/data/app-lib、LD_LIBRARY_PATH 等中搜索。</span><br><span class="line">	（2）打开文件：open 系统调用打开共享库文件。</span><br><span class="line">	（3）读取 ELF 头：读取共享库文件的 ELF 头，获取文件的基本信息，如入口点、程序头表、节头表等。</span><br><span class="line">	（4）映射文件：mmap 系统调用将共享库文件映射到内存中。这包括代码段、数据段、BSS 段等。</span><br><span class="line">2.3 重定位</span><br><span class="line">	（1）解析符号：解析共享库中的符号表，找到需要链接的函数和变量。</span><br><span class="line">	（2）重定位：根据重定位表更新共享库中的地址引用。重定位表包含需要更新的地址和对应的符号信息。</span><br><span class="line">2.4 初始化</span><br><span class="line">	执行构造函数：动态链接器调用共享库中的构造函数（如 __attribute__((constructor)) 标记的函数）。</span><br><span class="line">	如果共享库中有 init_array 段，动态链接器会按顺序调用 init_array 段中的函数。</span><br><span class="line">	调用 JNI_OnLoad：如果共享库是 JNI 库，动态链接器会调用 JNI_OnLoad 函数。JNI_OnLoad 用于注册 Java 类中的本地方法。</span><br><span class="line">2.5 返回句柄：返回一个句柄（void* 类型），该句柄可以在后续的 dlsym 和 dlclose 调用中使用。</span><br><span class="line"></span><br><span class="line">dlsym：根据句柄和符号名获取函数地址。</span><br></pre></td></tr></table></figure>
<h5 id="安卓系统启动流程、Zygote启动流程、APP启动流程"><a href="#安卓系统启动流程、Zygote启动流程、APP启动流程" class="headerlink" title="安卓系统启动流程、Zygote启动流程、APP启动流程"></a>安卓系统启动流程、Zygote启动流程、APP启动流程</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">安卓系统启动流程：</span><br><span class="line">（1）Bootloader 初始化硬件设备。</span><br><span class="line">（2）初始化 Linux 内核。</span><br><span class="line">（3）启动 Init 进程，/init.rc。</span><br><span class="line">（4）启动 Zygote 进程。绑定到一个特定的 Socket（通常是 local:zygote），等待来自 ActivityManagerService 的启动请求，fork 系统调用创建一个新的子进程。</span><br></pre></td></tr></table></figure>
<h5 id="Activity和Service的生命周期、Binder通信机制"><a href="#Activity和Service的生命周期、Binder通信机制" class="headerlink" title="Activity和Service的生命周期、Binder通信机制"></a>Activity和Service的生命周期、Binder通信机制</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Activity 是 Android 中的一个重要组件，用于表示一个单一的屏幕：</span><br><span class="line">    onCreate(Bundle savedInstanceState)：活动创建时调用。通常在这里进行初始化操作，如设置布局、初始化变量等。</span><br><span class="line">    onStart()：活动变得可见时调用。</span><br><span class="line">    onResume()：活动开始与用户交互时调用。此时活动位于前台，可以接收用户的输入。</span><br><span class="line">    onPause()：通常在这里保存活动的临时状态，释放可能消耗大量资源的对象。</span><br><span class="line">    onStop()：活动不再可见时调用。通常在这里释放更多资源。</span><br><span class="line">    onRestart()</span><br><span class="line">    onDestroy()</span><br><span class="line">    onSaveInstanceState(Bundle outState)：系统即将开始暂停活动并可能被销毁时调用，用于保存活动的临时状态</span><br><span class="line"></span><br><span class="line">Service 用于在后台执行长时间运行的操作或执行需要在后台运行的任务：</span><br><span class="line">    onCreate()：服务第一次创建时调用。通常在这里进行初始化操作。</span><br><span class="line">    onStartCommand(Intent intent, int flags, int startId)：返回值决定服务被杀死后的行为。</span><br><span class="line">    onBind(Intent intent)：如果服务被绑定到客户端，此方法被调用。返回一个 IBinder 对象，用于客户端和服务之间的通信。</span><br><span class="line">    onUnbind(Intent intent)：当所有客户端都解除绑定时调用。</span><br><span class="line">    onDestroy()</span><br><span class="line"></span><br><span class="line">Binder 是 Android 中的一种进程间通信（IPC）机制，用于实现不同进程之间的通信。Binder 机制基于客户端-服务端模型，客户端通过 Binder 与服务端进行通信。</span><br><span class="line"></span><br><span class="line">Windows 的 IPC 机制有哪些？共享内存，命名管道</span><br></pre></td></tr></table></figure>
<h5 id="如何从海量的APP找出一个二次打包的应用"><a href="#如何从海量的APP找出一个二次打包的应用" class="headerlink" title="如何从海量的APP找出一个二次打包的应用"></a>如何从海量的APP找出一个二次打包的应用</h5><p>有几种思路（流量特征，代码相似度检测，UI节点遍历等）</p>
<h5 id="Android-的-init-array-和-JNI-OnLoad-的时机问题，如何绕过-init-array-段中的反调试"><a href="#Android-的-init-array-和-JNI-OnLoad-的时机问题，如何绕过-init-array-段中的反调试" class="headerlink" title="Android 的 init_array 和 JNI_OnLoad 的时机问题，如何绕过 init_array 段中的反调试"></a>Android 的 init_array 和 JNI_OnLoad 的时机问题，如何绕过 init_array 段中的反调试</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">init_array 段（ELF），用于存储一组函数指针。这些函数在程序启动时按顺序调用，通常用于执行全局对象的构造函数或其他初始化任务。</span><br><span class="line">1.1 执行时机</span><br><span class="line">	加载时：当动态链接器加载共享库时，会解析 init_array 段并按顺序调用其中的函数。</span><br><span class="line">	优先级：init_array 段中的函数在 JNI_OnLoad 之前调用。</span><br><span class="line">1.2 作用</span><br><span class="line">	全局对象构造：用于构造全局对象。</span><br><span class="line"></span><br><span class="line">JNI_OnLoad 用于在 Java 代码和本地代码之间建立连接，在 JVM 加载本地库时被调用。</span><br><span class="line">2.1 执行时机：当 JVM 加载本地库时，会调用 JNI_OnLoad 函数。</span><br><span class="line">2.2 作用：用于注册 Java 类中的本地方法。</span><br></pre></td></tr></table></figure>
<h5 id="so-函数定位"><a href="#so-函数定位" class="headerlink" title="so 函数定位"></a>so 函数定位</h5><p>&emsp;可以自己执行 so 文件中的函数，在自己 App 项目中建立签名类(具体的 native 方法定义通过反编译技术获取)，要注意的是包名和类名要和原 App 一致。或者可以这样运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(1) 在JDK环境下建立签名类，最后打包成 jar 包;</span><br><span class="line">(2) 将 so 文件放在系统的 lib 或 lib64 文件下；</span><br><span class="line">(3) 调用 jar 包中的类即可；</span><br></pre></td></tr></table></figure>
<p>&emsp;对于函数名加密（没有符号表）的时候，可以用 objection hook 一下，其中有 JNI 静态注册（默认）与动态注册。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">JNI_OnLoad 是在加载 so 的时候调用的。</span><br><span class="line">（1）静态注册：通过 JNIEXPORT 和 JNICALL 两个宏定义声明，在虚拟机加载 so 时发现上面两个宏定义的函数时就会链接到对应的 native 方法。JNI 层名称为：Java_包名_类名_方法名。</span><br><span class="line">（2）动态注册：通过 RegisterNatives 方法手动完成 native 方法和 so 中的方法的绑定，这样虚拟机就可以通过这个函数映射表直接找到相应的方法了。</span><br></pre></td></tr></table></figure>
<p>&emsp;如果 Native 采用的静态注册，那可以通过<code>grep</code>命令在libs文件夹下进行筛选，如果 Native 方法采用的是动态注册，有 objection 脚本，能够一步到位的定位到 Native 方法注册地址和所在的 so 文件。最终可以找到方法在 so 文件的偏移。</p>
<p>&emsp;对于动态注册：</p>
<p><img src="/images/intern-ms-prepare/image-20240313184217800.png" alt="image-20240313184217800" style="zoom:67%;" /></p>
<h5 id="Frida-与-Xposed"><a href="#Frida-与-Xposed" class="headerlink" title="Frida 与 Xposed"></a>Frida 与 Xposed</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1. frida 相关，默认以attach模式。</span><br><span class="line"></span><br><span class="line">两种操作模式：</span><br><span class="line">（1）CLI模式：通过命令行将js脚本注入到进程中。 frida -U com.android.settings -l hello.js</span><br><span class="line">（2）RPC模式：通过py脚本间接完成js脚本的注入。</span><br><span class="line"></span><br><span class="line">两种操作App的方式：</span><br><span class="line">（1）spawn（调用）模式：将启动App的权利交给Frida来控制，即使目标App已启动，在使用Frida对程序进行注入时，还是会重新启动App并注入。frida -f就会调用spawn模式。</span><br><span class="line">（2）attach（附加）模式：在目标App已启动的前提下，利用ptrace原理注入程序进而完成Hook操作，默认以attach模式注入。</span><br><span class="line"></span><br><span class="line">2. 两者比较：</span><br><span class="line">Xposed 可以在一个函数中完成针对所有进程的 hook，在 zygote 重新启动后生效，对系统影响较大，需要 root。而 frida 是单进程级别的hook，还可以 hook windows/ios，不需要 root。</span><br></pre></td></tr></table></figure>
<h5 id="objection"><a href="#objection" class="headerlink" title="objection"></a>objection</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">objection -g com.cz.babySister explore</span><br><span class="line">android hooking watch class &lt;class_name&gt; // 钩取某个类中所有非构造函数</span><br></pre></td></tr></table></figure>
<h5 id="抓包"><a href="#抓包" class="headerlink" title="抓包"></a>抓包</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 沙箱，修改安卓源码。</span><br><span class="line">2. 中间人（wifi 代理/vpn 代理）。</span><br><span class="line">	a. wifi 代理弊端：无法处理非http通信，例如websocket；容易被app检测到。</span><br><span class="line">	b. vpn 代理。相当于虚拟新网卡并修改手机路由表，工具为postern（注意要匹配所有地址）。</span><br><span class="line">	c. 反抓包：反 wifi 代理、反 VPN 代理、服务器校验客户端/客户端校验服务器（CA 证书层面），例如，（1）app 使用特定 API（Proxy.NO_PROXY`、System.getProperty(&quot;http.proxyHost&quot;)`等）检测来防止 wifi 代理；（2）使用 `getNetWorkCapbilities()` 来检测网络接口，从而检测 VPN app。（3）客户端校验服务器，即在客户端和服务器进行握手时，验证 CA 的 hash 值，来达到只与持有相同 CA 的服务器进行通信，而服务器只与持有特定 CA 的客户端进行交互。</span><br></pre></td></tr></table></figure>
<h5 id="修改设备信息"><a href="#修改设备信息" class="headerlink" title="修改设备信息"></a>修改设备信息</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">设备的相关信息（设备指纹/设备名称/设备型号）都是通过 android.os.Build 类中的成员值得到的。</span><br><span class="line">（1）IMEI 设备的唯一标识，由 15 位数字组成。</span><br><span class="line">（2）IMSI 是移动网络中区分不同用户的识别码，其存储在 SIM 卡中，由 15 位数字组成。</span><br><span class="line">（3）Android_id 是设备第一次启动时产生与存储的 64 bit 数，也叫做 SSAID（Settings.Secure.ANDROID_ID）。此值只有在设备被刷机或者恢复出厂设置时才会被修改。</span><br></pre></td></tr></table></figure>
<h5 id="如何定位关键类"><a href="#如何定位关键类" class="headerlink" title="如何定位关键类"></a>如何定位关键类</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. jeb jadx 反汇编看。</span><br><span class="line">2. hook 相关类。</span><br><span class="line">3. 抓包。</span><br></pre></td></tr></table></figure>
<h5 id="为什么有时候-classloader-找不到？"><a href="#为什么有时候-classloader-找不到？" class="headerlink" title="为什么有时候 classloader 找不到？"></a>为什么有时候 classloader 找不到？</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">时机不对，即类加载器ClassLoader在加固应用启动时切换，从而导致上述情况。具体而言，app中的类都是对应的ClassLoader加载到ART虚拟机中的，如果ClassLoader不正确，那么就无法找到对应的类。`当加固应用启动时，app的当前ClassLoader会发生切换，故而出现上述情况`。  </span><br></pre></td></tr></table></figure>
<h5 id="app加固方法"><a href="#app加固方法" class="headerlink" title="app加固方法"></a>app加固方法</h5><h4 id="0x01-1-10-python-逆向的点"><a href="#0x01-1-10-python-逆向的点" class="headerlink" title="0x01-1-10 python 逆向的点"></a>0x01-1-10 python 逆向的点</h4><h4 id="0x01-1-11-寄存器"><a href="#0x01-1-11-寄存器" class="headerlink" title="0x01-1-11 寄存器"></a>0x01-1-11 寄存器</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">EBP:(SS段中栈内数据指针)扩展基址指针寄存器</span><br><span class="line">ESI:(字符串操作源指针)源变址寄存器</span><br><span class="line">EDI:(字符串操作日标指针)目的变址寄存器</span><br><span class="line">ESP:(SS段中栈指针)栈指针寄存器</span><br><span class="line">CS:Code Segment，代码段寄存器</span><br><span class="line">SS:Stack Segment，栈段寄存器</span><br><span class="line">DS:Data Segment，数据段寄存器</span><br><span class="line">ES:Extra (Data)Segment，附加(数据)段寄存器</span><br><span class="line">FS:Data Segment，数据段寄存器，它用于计算SEH(Structured Exception Handler，结构化异常处理机制)、TEB(Thread Environment Block，线程环境块)、PEB(Process Environment Block，进程环境块)等</span><br><span class="line">GS:Data Segment，数据段寄存器</span><br></pre></td></tr></table></figure>
<h4 id="0x01-1-11-栈"><a href="#0x01-1-11-栈" class="headerlink" title="0x01-1-11 栈"></a>0x01-1-11 栈</h4><p><img src="./images/re-core-principle/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6%20(1).png" alt="未命名文件 (1)" style="zoom:80%;" /></p>
<p>&emsp;栈帧：栈帧就是利用EBP(不是ESP)寄存器访问内局部变量、参数函数返回地址等的手段。最新的编译器中都带有一个<code>优化(Optimization)</code>选项，使用该选项编译简单的函数将不会生成栈帧。</p>
<p><img src="./images/intern-ms-prepare/image-20240312150238083.png" alt="image-20240312150238083" style="zoom:67%;" /></p>
<h4 id="0x01-1-12-调用约定"><a href="#0x01-1-12-调用约定" class="headerlink" title="0x01-1-12 调用约定"></a>0x01-1-12 调用约定</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cdecl 方式，主要在 C 语言中使用，函数调用者负责处理栈，就是把函数调用时 push 进去的参数给消除。就像 printf 函数一样，可以向函数传递长度可变的参数，这种功能在其他调用方式中很难实现。</span><br><span class="line">stdcall 方式，常用于win32 API，栈的清理工作由被调用者完成，</span><br><span class="line">fastcall 方式，使用寄存器传递前两个参数，而不是使用栈。其调用速度快。</span><br></pre></td></tr></table></figure>
<h4 id="0x01-1-12-PE-文件格式与加载流程"><a href="#0x01-1-12-PE-文件格式与加载流程" class="headerlink" title="0x01-1-12 PE 文件格式与加载流程"></a>0x01-1-12 PE 文件格式与加载流程</h4><p><img src="./images/intern-ms-prepare/image-20240312150517438.png" alt="image-20240312150517438" style="zoom:67%;" /></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">（1）DOS 头：</span><br><span class="line">	e_magic //DOS签名(signature，4D5A=&gt;ASCII值&quot;MZ&quot;，MZ是一个开发人员的名字首字母，好帅)</span><br><span class="line">	elfanew //指示NT头(IMAGE_NT_HEADERS)的偏移，下图的elfanew=000000E0（小端序）</span><br><span class="line">（2）DOS 存根：由代码与数据混合而成，灵活使用该特性可以在一个可执行文件（EXE）中创建出另一个文件，它在DOS环境中运行16位DOS代码，在Windows环境中运行32位Windows代码，这种特性叫做MS-DOS兼容。</span><br><span class="line">（3）NT 头：</span><br><span class="line">    Machine                 // 每种CPU都有自己唯一的mechine码</span><br><span class="line">    NumberOfSections        // 文件中的节区数量</span><br><span class="line">    TimeDateStamp           // 记录编译器创建此文件的时间</span><br><span class="line">    SizeOfOptionalHeader    // 指明IMAGE_OPTIONAL_HEADER32(PE)或IMAGE_OPTIONAL_HEADER64(PE+)长度</span><br><span class="line">    Characteristics         // 指明文件是否可运行（0002H），是否为DLL（2000H）</span><br><span class="line">（4）EXE生成的PE文件的重定位表对应的节区名为 .reloc（一般是最后一个节区）</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PE 文件加载流程</span><br><span class="line">    1、将PE文件从磁盘中读出</span><br><span class="line">    2、根据PE结构获取镜像大小，再申请一段可读可写可执行的内存，并填充为0</span><br><span class="line">    3、将读取的数据映射到内存中</span><br><span class="line">    4、修复导出导入导出表</span><br><span class="line">    5、修复重定位</span><br><span class="line">    6、跳转到PE入口点进行执行</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PE loader 把导入函数输入到 IAT 的顺序</span><br><span class="line">    1. 读取IMAGE_IMPORT_DESCRIPTOR的Name，获得库名称字符串&quot;kernel32.dll&quot;</span><br><span class="line">    2. LoadLibrary(&quot;kernel32.dll&quot;)</span><br><span class="line">    3. 读取OriginalFirstThunk中的函数名，并在kernal32.dll找到对应地址（GetProcAddress(&quot;GetCurrentThreadld&quot;)）</span><br><span class="line">    4. 将地址填入FirstThunk对应地址</span><br><span class="line">    5. 重复3-4，直到OriginalFirstThunk结束</span><br></pre></td></tr></table></figure>
<h4 id="0x01-1-13-各种表"><a href="#0x01-1-13-各种表" class="headerlink" title="0x01-1-13 各种表"></a>0x01-1-13 各种表</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IAT 导入地址表 属于NT可选头的，记录程序正在使用哪些库中的哪些函数。</span><br><span class="line">EAT（导出地址表）。</span><br><span class="line">SDT（段描述符表）。</span><br></pre></td></tr></table></figure>
<h4 id="0x01-1-14-DLL-相关"><a href="#0x01-1-14-DLL-相关" class="headerlink" title="0x01-1-14 DLL 相关"></a>0x01-1-14 DLL 相关</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">加载DLL的方式有两种：</span><br><span class="line">	（1）显式链接（Explicit Linking）程序使用DLL时加载，使用完毕后释放内存。</span><br><span class="line">	（2）隐式链接（Implicit Linking）程序开始时加载DLL，程序终止时再释放占用的内存。即隐式链接的DLL生命周期更长。</span><br></pre></td></tr></table></figure>
<h4 id="0x01-1-15-mmap-malloc-brk"><a href="#0x01-1-15-mmap-malloc-brk" class="headerlink" title="0x01-1-15 mmap/malloc/brk"></a>0x01-1-15 mmap/malloc/brk</h4><p>&emsp;申请内存空间一般就两种方法，一种是 malloc，另一种是 mmap 映射空间。 在使用 malloc() 分配内存的时候，可能系统调用 brk()，也可能调用 mmap()。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">malloc 调用：</span><br><span class="line">1. 当分配一块小内存(小于或等于128kb)，malloc()会调用brk()调高堆顶(brk是将数据段(.data)的最高地址指针_edata往高地址推)，分配的内存在堆区域。</span><br><span class="line">	a. 通过 brk() 方式申请的内存，free 释放内存的时候，并不一定会把内存归还给操作系统，而是缓存在 malloc 的内存池中，待下次使用，这样就可以重复使用。</span><br><span class="line">	b. 优点：可以减少缺页异常，提高内存访问效率。</span><br><span class="line">	c. 缺点：由于申请的内存没有归还系统，频繁的内存分配和释放会造成内存碎片。brk()方式之所以会产生内存碎片，是由于brk通过移动堆顶的位置来分配内存，并且使用完不会立即归还系统，重复使用，如果高地址的内存不释放，低地址的内存是得不到释放的。</span><br><span class="line">2. 当分配一块大内存(大于128kb)，malloc()会调用mmap()分配一块内存（mmap是在进程的虚拟地址空间中（一般是堆和栈中间）找一块空闲的空间。</span><br><span class="line">	a. mmap()是以页为单位进行内存分配和管理的，释放后就直接归还系统了，所以不会出现小碎片的情况。</span><br></pre></td></tr></table></figure>
<p><img src="./images/intern-ms-prepare/image-20240407145105315.png" alt="image-20240407145105315" style="zoom:67%;" /></p>
<p>&emsp;brk()的实现的方式很简单，就是通过 brk() 函数将堆顶指针向高地址移动，获得新的内存空间。</p>
<p><img src="./images/intern-ms-prepare/image-20240407145146915.png" alt="image-20240407145146915" style="zoom:67%;" /></p>
<p>&emsp;mmap 是一种内存映射文件的方法，即将一个文件或者其他对象映射到进程的地址空间。实现这样的映射关系后，进程就可以采用指针的方式读写操作这一段内存，而系统会自动回写脏页面到对应的文件磁盘上，即完成了对文件的操作而不必调用 read/write 等系统调用函数。</p>
<p>&emsp;mmap 的实现原理：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">1. linux 内核使用 vm_area_struct 结构来表示一个虚拟内存区域（例如 BSS 段），同一个进程使用多个 vm_area_struct 结构来分别表示不同类型的虚拟内存区域。各个 vm_area_struct 结构使用链表链接，方便进程快速访问。</span><br><span class="line"></span><br><span class="line">Step1：进程启动映射过程，并在虚拟地址空间中为映射创建虚拟映射区域。</span><br><span class="line">	a. 进程在用户空间调用函数 mmap</span><br><span class="line">	b. 在当前进程虚拟地址空间中，寻找一段空闲的满足要求的连续的虚拟地址</span><br><span class="line">	c. 为此虚拟区分配一个 vm_area_struct 结构，接着对这个结构各个区域进行初始化</span><br><span class="line">	d. 将新建的虚拟区结构（vm_area_struct）插入进程的虚拟地址区域链表中</span><br><span class="line"></span><br><span class="line">Step2：调用内核空间的系统调用函数 mmap （不同于用户空间函数），实现文件物理地址和进程虚拟地址的一一映射。</span><br><span class="line">	a. 为映射分配新的虚拟地址区域后，通过待映射的文件指针，在文件描述符表中找到对应的文件描述符，通过文件描述符，链接到内核中相应的文件结构体，每个文件结构体维护者和这个已经打开文件相关各项信息。</span><br><span class="line">	b. 通过该文件的文件结构体，链接到 file_operations 模块，调用内核函数mmap，不同于用户空间库函数。</span><br><span class="line">	c. 内核 mmap 函数通过虚拟文件系统 inode 模块定位到文件磁盘物理地址。</span><br><span class="line">	d. 通过 remap_pfn_range 函数建立页表，即实现了文件地址和虚拟地址区域的映射关系。此时，这片虚拟地址并没有任何数据关联到主存中。</span><br><span class="line"></span><br><span class="line">Step3：进程发起对这片映射空间的访问，引发缺页异常，实现文件内容到物理内存（主存）的拷贝。</span><br><span class="line">	a. 前两个阶段仅在于创建虚拟区间并完成地址映射，但是并没有将任何文件数据拷贝至主存。真正的文件读取是当进程发起读或者写操作时。</span><br><span class="line">	b. 进程的读写操作访问虚拟地址空间这一段映射地址后，通过查询页表，先这一段地址并不在物理页面。因为目前只建立了映射，真正的硬盘数据还没有拷贝到内存中，因此引发缺页异常。</span><br><span class="line">	c. 缺页异常进行一系列判断，确定无法操作后，内核发起请求掉页过程。</span><br><span class="line">	d. 调页过程先在交换缓存空间中寻找需要访问的内存页，如果没有则调用nopage函数把所缺的页从磁盘装入到主存中。</span><br><span class="line">	e. 之后进程即可对这片主存进行读或者写的操作了，如果写操作改变了内容，一定时间后系统自动回写脏页面到对应的磁盘地址，也即完成了写入到文件的过程。注：修改过的脏页面并不会立即更新回文件，而是有一段时间延迟，可以调用msync() 来强制同步，这样所写的内容就能立即保存到文件里了。</span><br></pre></td></tr></table></figure>
<h4 id="0x01-1-16-加壳"><a href="#0x01-1-16-加壳" class="headerlink" title="0x01-1-16 加壳"></a>0x01-1-16 加壳</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">windows：</span><br><span class="line">    普通的压缩器有：UPX、ASPack、ASProtect、VMP 壳。</span><br><span class="line">    针对病毒等恶意文件的压缩器：UPack、PESpin、NSAnti，其会对源文件进行较大变形，严重破坏PE头。</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如何查找 OEP？</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="0x01-1-17-windows-消息勾取-amp-DLL-注入-amp-代码注入"><a href="#0x01-1-17-windows-消息勾取-amp-DLL-注入-amp-代码注入" class="headerlink" title="0x01-1-17 windows 消息勾取&amp; DLL 注入 &amp; 代码注入"></a>0x01-1-17 windows 消息勾取&amp; DLL 注入 &amp; 代码注入</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">（1）Windows操作系统向用户提供GUI(Graphic User Interface，图形用户界面)，它以事件驱动(Event Driven)方式工作。发生此类事件时，OS会把事先定义好的消息发送给相应的应用程序，应用程序分析收到的信息后执行相应动作。也就是说，敲击键盘时，消息会从OS移动到应用程序。</span><br><span class="line"></span><br><span class="line">（2）Windows消息处理流如下所示：</span><br><span class="line">    1. 发生键盘输入事件时，WM_KEYDOWN消息被添加到[OS message queue]</span><br><span class="line">    2. OS判断哪个应用程序中发生了事件，然后从[OS message queue]取出消息，添加到相应应用程序[applicationmessage queue]中</span><br><span class="line">    3. 应用程序监视自身的[application message queue]，发现新添加的WM_KEYDOWN消息后，调用相应的事件处理程序处理</span><br><span class="line">    </span><br><span class="line">（3）相关 API：SetWindowsHookEx() / UnhookWindowsHookEx()</span><br></pre></td></tr></table></figure>
<p>&emsp;进程注入DLL时（CreateRemoteThread）主体代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// myhack.dll</span></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadProc</span><span class="params">(LPVOID lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">URLDownloadToFile</span>(<span class="literal">NULL</span>, <span class="string">&quot;http://www.naver.com/index.html&quot;</span>, szPath, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL WINAPI <span class="title">DllMain</span><span class="params">(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_ATTACH : </span><br><span class="line">        hThread = <span class="built_in">CreateThread</span>(<span class="literal">NULL</span>, <span class="number">0</span>, ThreadProc, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">CloseHandle</span>(hThread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// InjectDll.cpp</span></span><br><span class="line"><span class="function">BOOL <span class="title">SetPrivilege</span><span class="params">(LPCTSTR lpszPrivilege, BOOL bEnablePrivilege)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( !<span class="built_in">LookupPrivilegeValue</span>(<span class="literal">NULL</span>,           <span class="comment">// lookup privilege on local system</span></span><br><span class="line">                              lpszPrivilege,  <span class="comment">// privilege to lookup </span></span><br><span class="line">                              &amp;luid) )        <span class="comment">// receives LUID of privilege</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( !<span class="built_in">AdjustTokenPrivileges</span>(hToken, </span><br><span class="line">                               FALSE, </span><br><span class="line">                               &amp;tp, </span><br><span class="line">                               <span class="built_in">sizeof</span>(TOKEN_PRIVILEGES), </span><br><span class="line">                               (PTOKEN_PRIVILEGES) <span class="literal">NULL</span>, </span><br><span class="line">                               (PDWORD) <span class="literal">NULL</span>) )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">InjectDll</span><span class="params">(DWORD dwPID, LPCTSTR szDllPath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// #1. 使用dwPID获取目标进程（notepad.exe）的句柄</span></span><br><span class="line">    <span class="keyword">if</span> ( !(hProcess = <span class="built_in">OpenProcess</span>(PROCESS_ALL_ACCESS, FALSE, dwPID)) )</span><br><span class="line"></span><br><span class="line">    <span class="comment">// #2. 在目标进程（notepad.exe）中分配 dwBufSize 大小的内存</span></span><br><span class="line">    pRemoteBuf = <span class="built_in">VirtualAllocEx</span>(hProcess, <span class="literal">NULL</span>, dwBufSize, MEM_COMMIT, PAGE_READWRITE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// #3. 将 myhack.dll 的路径写入分配的内存 pRemoteBuf</span></span><br><span class="line">    <span class="built_in">WriteProcessMemory</span>(hProcess, pRemoteBuf, (LPVOID)szDllPath, dwBufSize, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// #4. 获取 LoadLibraryA() API的地址</span></span><br><span class="line">    hMod = <span class="built_in">GetModuleHandle</span>(<span class="string">L&quot;kernel32.dll&quot;</span>);</span><br><span class="line">    pThreadProc = <span class="built_in">GetProcAddress</span>(hMod, <span class="string">&quot;LoadLibraryW&quot;</span>);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// #5. 重点，在目标进程（notepad.exe）中运行线程</span></span><br><span class="line">    hThread = <span class="built_in">CreateRemoteThread</span>(hProcess, <span class="literal">NULL</span>, <span class="number">0</span>, pThreadProc, pRemoteBuf, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">WaitForSingleObject</span>(hThread, INFINITE);	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">（2）还可以用注册表进行 dll 注入：</span><br><span class="line"></span><br><span class="line">在注册表编辑器中，将要注入的DLL的路径字符串写入AppInit_DLLs，然后重启。User32.dll被加载到进程时，会读取AppInit_DLLs注册表项。所以，相应DLL并不会被加载到所有进程，而只是加载至加载user32.dll的进程。</span><br><span class="line"></span><br><span class="line">（3）DLL 卸载：FreeLibrary。</span><br></pre></td></tr></table></figure>
<p>&emsp;DLL 加载流程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 定位。当应用程序请求加载一个 DLL 时，系统首先检查该 DLL 是否已经加载到进程的地址空间中。如果已加载，系统就会重用现有的加载实例，不会重复加载相同的 DLL。如果 DLL 尚未加载，系统将搜索DLL文件。搜索顺序可能包括应用程序的目录、系统目录（如System32）、环境变量指定的路径等。</span><br><span class="line">2. 加载。通过文件映射和内存映射的技术完成的，意味着DLL文件的内容被映射到进程的虚拟内存中。（LoadLibrary/dlopen）</span><br><span class="line">3. 解析导入表。</span><br><span class="line">4. 执行 DLLmain。</span><br></pre></td></tr></table></figure>
<h4 id="0x01-1-18-x64-逆向注意的点"><a href="#0x01-1-18-x64-逆向注意的点" class="headerlink" title="0x01-1-18 x64 逆向注意的点"></a>0x01-1-18 x64 逆向注意的点</h4><p>（1）WOW64（windows on windows 64）的机制，使得32位程序在64位程序中正常运行。64位应用程序会加载<code>kernel32.dll</code>(64位)与<code>ntdll.dll</code> (64位)。而32位应用程序则会加x64载<code>kernel32.dll</code>(32位)与<code>ntdll.dll</code>(32位)，WOW64会在中间将<code>ntdll.dll</code>(32位)的请求(API调用)重定向到<code>ntdll.dll</code>(64位)。</p>
<p><img src="/images/intern-ms-prepare/image-20240312160811329.png" alt="image-20240312160811329" style="zoom:67%;" /></p>
<p>（2）&emsp;windows下有<code>SysWOW64</code>与<code>System32</code>两个文件夹，<code>SysWOW64</code>中存放32位dll，当运行32位程序时，就用这个，映射到<code>System32</code>文件夹下的dll中。<code>System32</code>存放64位dll。</p>
<p>（3）处理器增加了 16 个 XMM 寄存器。 64位系统中不使用段寄存器。</p>
<p>（4）x64进程虚拟内存大小为16TB，32位进程虚存仅为4GB。</p>
<h4 id="0x01-1-19-OLLVM-与-LLVM"><a href="#0x01-1-19-OLLVM-与-LLVM" class="headerlink" title="0x01-1-19 OLLVM 与 LLVM"></a>0x01-1-19 OLLVM 与 LLVM</h4><p><img src="/images/intern-ms-prepare/image-20240312165943533.png" alt="image-20240312165943533" style="zoom:80%;" /></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">OLLVM 混淆方式：</span><br><span class="line">	（1）Instructions Substitution（加减法、逻辑运算）</span><br><span class="line">	（2）Bogus Control Flow（虚假控制流：BCF）</span><br><span class="line">	（3）Control Flow Flattening（控制流平坦化：CFF）</span><br></pre></td></tr></table></figure>
<p>&emsp;去 OLLVM，unicorn/angr 模拟执行，unicorn 相当于一个虚拟 cpu，所以处理的细微程度高于 angr 的代码块级，修复出来的代码精度更高。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通过代码的CFG图，分析出代码块之间的关系，然后模拟执行每个代码块。</span><br></pre></td></tr></table></figure>
<p><strong>代码优化 LLVM IR pass</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">代码优化的实质是分析+转换。</span><br><span class="line">	LLVM Pass 是 LLVM 代码优化中的一个重要组成部分。我们可以将 Pass 看作一个又一个的模块，各个 Pass 可以通过 IR 获取信息，直接对中间代码进行优化，或者为下一个 Pass 做好准备。</span><br><span class="line">	</span><br><span class="line">常见的代码优化方法有：</span><br><span class="line">1. 删除公共子表达式。例如，x+y 以前被计算过，且一段时间内 x 与 y 中的变量值没有改变，则 x+y 就可以在这段时间内替换成一个常量。</span><br><span class="line">2. 删除无用代码。即删除永远不会被使用的语句。</span><br><span class="line">3. 常量合并。类似于 1，如果一个表达式的值为常量，那么就可以用常量替换这个表达式。</span><br><span class="line">4. 代码移动。例如，对于不管循环多少次都得到相同结果的表达式，在进入循环之前对它们进行求值。</span><br><span class="line">5. 强度削弱。例如，2*x 替换为 x+x。</span><br><span class="line">6. 删除归纳变量。例如，x 每次被赋值时都会增加常数 c，则可以将 x 称为归纳变量。如果有一组归纳变量的变化步调一致，就可以将这组变量删除为只剩 1 个。</span><br><span class="line"></span><br><span class="line">LLVM 中 Pass 框架有很高的可重用性与可控制性，这使得用户可以自己开发 Pass 模块，或关闭默认开启的 Pass。Pass 分为两类：</span><br><span class="line">1. 分析，提供信息。</span><br><span class="line">2. 转换，优化 IR。</span><br></pre></td></tr></table></figure>
<h4 id="0x01-1-20-TLS"><a href="#0x01-1-20-TLS" class="headerlink" title="0x01-1-20 TLS"></a>0x01-1-20 TLS</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">（1）TLS（Thread Local Storage，线程局部存储）回调函数（Callback Function）常用于反调试。TLS回调函数的调用运行要先于EP代码的执行，该特征使它可以作为一种反调试技术使用。</span><br><span class="line">（2）TLS是各线程的独立的数据存储空间，使用TLS技术可在线程内部使用或修改进程的全局数据，就像对待自身的局部变量一样。</span><br><span class="line">（3）PE头文件就会设置TLS表。</span><br><span class="line">（4）在进程初始与结束，会运行TLS。</span><br></pre></td></tr></table></figure>
<h4 id="0x01-1-21-调试器实现原理"><a href="#0x01-1-21-调试器实现原理" class="headerlink" title="0x01-1-21 调试器实现原理"></a>0x01-1-21 调试器实现原理</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. 创建调试进程，使用的API是CreateProcess，创建标志是 DEBUG_ONLY_THIS_PROCESS。或者就是在程序运行起来，再使用调试器去附加使用的 API 是 DebugActiveProcess。</span><br><span class="line">2. 等待调试器事件。被调试程序所发生的所有异常都会通过调试会话发送到我们的调试器进程中，然后我们就可以接收到异常事件，进行处理异常事件，WaitForDebugEvent。</span><br><span class="line">3. 硬件断点，基于调试器寄存器来进行实现的,有8个调试寄存器，分别是Dr0 - Dr7。</span><br><span class="line">4. 软件断点，把代码修改为0xCC，有一些指令会触发80000003异常，也就是断点异常。</span><br><span class="line">5. 单步异常，在浮点寄存器中有一个标志叫单步标志，设置为 1 的时候，执行指令就会触发80000004异常。</span><br><span class="line">6. 内存访问，异常内存访问异常就是通过修改内存属性，让其不可访问，这时候就会触发 C05 异常。</span><br></pre></td></tr></table></figure>
<h4 id="0x01-1-22-TEB-amp-PEB"><a href="#0x01-1-22-TEB-amp-PEB" class="headerlink" title="0x01-1-22 TEB &amp; PEB"></a>0x01-1-22 TEB &amp; PEB</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TEB（Thread Environment Block）指线程环境块</span><br><span class="line">	（1）该结构体包含进程中运行线程的各种信息，进程中的每个线程都对应1个TEB结构体。</span><br><span class="line">	（2）NtTib与ProcessEnvironmentBlock（PEB）</span><br><span class="line">	（3）FS寄存器除了可以访问TLS，还指向当前线程的TEB。32位系统中进程的虚拟内存大小为4GB，因而需要32位的指针才能访问整个内存空间。但是FS寄存器的大小只有16位，那么它如何表示进程内存空间中的TEB结构体的地址呢？FS寄存器并非直接指向TEB结构体的地址，它持有SDT的索引，而该索引持有实际TEB地址。</span><br></pre></td></tr></table></figure>
<p><img src="/images/intern-ms-prepare/image-20240312161653947.png" alt="image-20240312161653947" style="zoom:67%;" /></p>
<h4 id="0x01-1-23-寄存器传参"><a href="#0x01-1-23-寄存器传参" class="headerlink" title="0x01-1-23 寄存器传参"></a>0x01-1-23 寄存器传参</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x64：RDI/RDI/RDX</span><br><span class="line">x86：fastcall 使用 ECX/EDX</span><br></pre></td></tr></table></figure>
<h3 id="0x01-2-人工智能相关"><a href="#0x01-2-人工智能相关" class="headerlink" title="0x01-2 人工智能相关"></a>0x01-2 人工智能相关</h3><h4 id="0x01-2-1-RNN-amp-LSTM-amp-GRU"><a href="#0x01-2-1-RNN-amp-LSTM-amp-GRU" class="headerlink" title="0x01-2-1 RNN &amp; LSTM &amp; GRU"></a>0x01-2-1 RNN &amp; LSTM &amp; GRU</h4><p>​    标准RNN结构输入为x，隐藏层为s，输出层为o，U是输入层到隐藏层的权重矩阵，V是隐藏层到输出层的权重矩阵，还有一个自循环矩阵W。</p>
<p><img src="/images/intern-ms-prepare/image-20230114135912148.png" alt="image-20230114135912148" style="zoom:67%;" /></p>
<p>​    隐藏层s可以细化为：</p>
<p><img src="/images/intern-ms-prepare/image-20230114140004724.png" alt="image-20230114140004724" style="zoom:70%;" /></p>
<p>​    但是RNN有一个问题，即容易造成梯度消失或梯度爆炸问题，这就说明<strong>RNN不具备长期记忆，仅仅有短期记忆功能。</strong>因此LSTM应运而生。网络结构如下：</p>
<p><img src="/images/intern-ms-prepare/image-20230114140418292.png" alt="image-20230114140418292" style="zoom:80%;" /></p>
<p>​    LSTM每一个时刻t都增加一个隐藏状态C（细胞状态），并用两个门来控制它的内容：</p>
<ol>
<li>遗忘门（Forget Gate），决定上一时刻的细胞状态C_{t-1}有多少保留到当前时刻细胞状态C_t。</li>
<li>输入门（Input Gate），决定当前时刻网络的输入x有多少保存到细胞状态C_t。然后再用输出门（Output Gate）来控制当前细胞状态C_t有多少输出到当前输出值h。</li>
</ol>
<p>​    但是，<strong>LSTM复杂度较高</strong>，由此又有了GRU，其是LSTM的v2版本。上述所说的RNN、LSTM与GRU都是处理序列数据，但是利用的一般是前文信息，但是实际上很多场景都需要结合上下文才能综合判断，因此提出了双向循环神经网络。</p>
<p><img src="/images/intern-ms-prepare/image-20230114141418228.png" alt="image-20230114141418228" style="zoom:80%;" /></p>
<p>​    基于此网络构建的典型模型是Encoder-Decoder模型。</p>
<p><img src="/images/intern-ms-prepare/image-20230114141651422.png" alt="image-20230114141651422" style="zoom:80%;" /></p>
<p>​    对于自编码模型可以理解为：<strong>从左到右，看作由一个句子（文章，段落等）生成另外一个句子（文章或段落）的通用处理模型。对于输入与输出都是序列的自编码模型，称之为Seq2Seq模型</strong>。</p>
<h4 id="0x01-2-2-注意力机制（AM）"><a href="#0x01-2-2-注意力机制（AM）" class="headerlink" title="0x01-2-2 注意力机制（AM）"></a>0x01-2-2 注意力机制（AM）</h4><p>​    Seq2Seq模型，<strong>无法应对句子很长的情况</strong>，于是注意力机制模型应运而生。注意力机制本质就是：<strong>输出句子中某个单词和输入句子中每个单词的相关性。</strong>如下图所示：</p>
<p><img src="/images/intern-ms-prepare/image-20230114142141001.png" alt="image-20230114142141001" style="zoom:67%;" /></p>
<p>​    上图中，key就是输入的每一个单词，value是这些单词对应的取值，<key, value>称之为数据对，query是输出的某一个单词。给定一个query，计算其与各个key的相似度，得到权重系数，最后得到attention value值。对上述过程进行细分，可以分为：计算相似度、归一化处理、计算注意力3个部分。</p>
<p>Step1:计算相似度：余弦相似度和核函数。</p>
<p>Step2：归一化处理，得到了相似度s_i，之后进行归一化处理（一般使用softmax函数）：</p>
<p><img src="/images/intern-ms-prepare/image-20230114143019882.png" alt="image-20230114143019882" style="zoom:70%;" /></p>
<p>Step3：计算注意力</p>
<p><img src="/images/intern-ms-prepare/image-20230114143145075.png" alt="image-20230114143145075" style="zoom:80%;" /></p>
<p>​    对比一下，不带注意力机制的Encoder-Decoder是这样的：</p>
<p><img src="/images/intern-ms-prepare/image-20230114143459261.png" alt="image-20230114143459261" style="zoom:50%;" /></p>
<p>​    其中，C代表输入X放入Encoder之后编码成的中间向量，y代表输出的值，g代表Decoder。带注意力机制的Encoder-Decoder是这样的：</p>
<p><img src="/images/intern-ms-prepare/image-20230114143725368.png" alt="image-20230114143725368" style="zoom:67%;" /></p>
<p><img src="/images/intern-ms-prepare/image-20230114143734647.png" alt="image-20230114143734647" style="zoom:50%;" /></p>
<p>​    但是每句话输入长度不一样啊，这个矩阵的T不是固定的，那么模型是如何确定权重系数矩阵的呢?<strong>它是通过对齐函数F来获得目标单词和每个输入单词对应得对齐可能性，然后经过softmax函数进行归一化得到注意力分配概率分布数值。</strong></p>
<p><img src="/images/intern-ms-prepare/image-20230114144126388.png" alt="image-20230114144126388" style="zoom:67%;" /></p>
<p><img src="/images/intern-ms-prepare/image-20230114144245439.png" alt="image-20230114144245439" style="zoom:50%;" /></p>
<h3 id="0x01-3-软件分析相关"><a href="#0x01-3-软件分析相关" class="headerlink" title="0x01-3  软件分析相关"></a>0x01-3  软件分析相关</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">May Analysis 与 Must Analysis</span><br><span class="line">	（1）May Analysis的初始fact为0，最终找出有哪些不是0的fact。例如Reaching Definitions Analysis，其意思是：假设有程序点p与q，在p点定义了变量x，且从p到q之间没有再定义x，那么说x的定值到达了p在此环境下，fact=0代表不可到达，fact=1代表可到达，我们想找不可达的，这样的话就可以把对应的语句删掉。May Analysis，程序满足一条路径即可。</span><br><span class="line">	（2）Must Analysis的初始fact为1，最终找出不是1的fact。例如Constant Propagation，其意思是：有程序点p与q，在q点定义了变量x，在q点使用了变量x，q点之前，再没有分支重新定义变量x，那么fact=1代表可常量传播，fact=0代表不可常量传播，我们想找可常量传播的，这样的话就可以传播常量。Must Analysis，程序必须满足所有路径。</span><br></pre></td></tr></table></figure>
<h4 id="0x01-3-1-指针分析"><a href="#0x01-3-1-指针分析" class="headerlink" title="0x01-3-1 指针分析"></a>0x01-3-1 指针分析</h4><h4 id="0x01-3-2-常量传播-amp-worklist"><a href="#0x01-3-2-常量传播-amp-worklist" class="headerlink" title="0x01-3-2 常量传播 &amp; worklist"></a>0x01-3-2 常量传播 &amp; worklist</h4><p>&emsp;程序的P点有一个变量x，判断在P点是否可以保证x是一个常量。要考虑所有的路径上是否定义的值都一样，如果有两条路径是x=2，有一条是x=3，那显然不行，所以是must analysis。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">为什么活跃变量分析是backward的，而常量分析是forward的呢？在某个点的变量是否活跃，是由后面的程序决定的。而在某个点的定义是否是常量，是由前面的程序决定的。</span><br></pre></td></tr></table></figure>
<p><img src="/images/intern-ms-prepare/image-20240312165153912.png" alt="image-20240312165153912" style="zoom:67%;" /></p>
<p>&emsp;此算法不好的点是：如果有任意OUT变化了，所有的block都要重新计算。而对应的Worklist Algorithm为：</p>
<p><img src="/images/intern-ms-prepare/image-20240312165224879.png" alt="image-20240312165224879" style="zoom:67%;" /></p>
<h3 id="0x01-4-算法题"><a href="#0x01-4-算法题" class="headerlink" title="0x01-4 算法题"></a>0x01-4 算法题</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 给定一棵二叉树，要求求出其最大平均值：每一个节点下可能挂有若干个子节点，需要计算以这个节点为根节点的子树的所有节点之和除以节点数的道德的平均值，然后在所有子树中找到平均值最大的一个</span><br><span class="line"></span><br><span class="line">解法为：后根序遍历，同时记录遍历到当前节点时一共遍历了几个节点，以及和是多少，遍历完左右根后再比较这个平均值和最终结果，取较大的一个</span><br></pre></td></tr></table></figure>
<h3 id="0x01-5-PWN-相关"><a href="#0x01-5-PWN-相关" class="headerlink" title="0x01-5 PWN 相关"></a>0x01-5 PWN 相关</h3><p>ROP</p>
<h4 id="代码混淆相关的汇编"><a href="#代码混淆相关的汇编" class="headerlink" title="代码混淆相关的汇编"></a>代码混淆相关的汇编</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">代码混淆引起所使用的指令都是不常见的指令，我们可以一眼就识别出来比如 rcr,bt,btc,sbb,lahf等。</span><br></pre></td></tr></table></figure>
<h4 id="shellcode-判断与混淆"><a href="#shellcode-判断与混淆" class="headerlink" title="shellcode 判断与混淆"></a>shellcode 判断与混淆</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 使用msf生成的shellcode也是具有特征的，对shellcode进行处理可以消除特征。最基本的处理方式是异或加密，实现代码很简单。</span><br><span class="line">2. 加壳</span><br></pre></td></tr></table></figure>
<h4 id="VMP-提供的保护"><a href="#VMP-提供的保护" class="headerlink" title="VMP 提供的保护"></a>VMP 提供的保护</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">文件：</span><br><span class="line">（1）内存保护 - 此选项允许从任何更改中保护文件在内存中的映像（检查所有没有WRITABLE属性的部分的数据完整性）。在将控件传递给程序的原始入口点之前执行映像完整性检查。如果违反完整性，则会显示相应的消息，程序将停止执行。</span><br><span class="line">（2）导入保护 - 此选项允许隐藏受保护程序使用的API列表。建议使用此选项以及输出文件的打包。</span><br><span class="line">（3）资源保护 - 此选项加密程序的资源（图标，清单和其他服务资源除外）。</span><br><span class="line">（4）打包输出文件 - 此选项允许打包受保护的文件以减小其大小。执行受保护文件时，将自动解压缩应用程序。整个解包没有任何磁盘写入，完全在RAM中。 </span><br><span class="line"></span><br><span class="line">重要提示：程序启动时，解压缩代码后，控件将传递给EntryPoint。如果EntryPoint的代码是虚拟化的，则此代码将在与解包器本身的代码相同的VM解释器上执行。EntryPoint的虚拟化与受保护文件的打包相结合，可防止手动解压缩受保护文件，因为在这种情况下，入侵者必须恢复EntryPoint代码才能获得工作文件映像。 </span><br><span class="line"></span><br><span class="line">额外的保护级别：</span><br><span class="line">（1）水印 - 允许为项目添加水印。</span><br><span class="line">（2）VM段 - 编译文件时，会将新段添加到存储各种系统数据的位置（虚拟化和变异代码，VM解释器，水印等）。此选项允许指定这些新段的名称。建议将段的标准“.vmp”名称更改为其他名称（例如“.UPX”）。</span><br><span class="line">（3）剥离调试信息 - 删除调试信息阻碍了破解者对代码的分析。</span><br><span class="line">（4）剥离重定位 - 某些编译器（即Delphi）为EXE文件创建重定位表，操作系统不使用该重定位表来加载EXE文件。如果启用该选项，则重定位表占用的空间将用于VM需求。  </span><br><span class="line"></span><br><span class="line">检测：</span><br><span class="line">（1）调试器 - 此选项可防止调试受保护的文件。有两种类型的调试器：用户模式调试器（OllyDBG，WinDBG等）和内核模式调试器（SoftICE，Syser等）。在将控制传递给程序的入口点之前执行调试器检测。如果检测到调试器，则会显示相应的消息，程序将停止执行。</span><br><span class="line">（2）虚拟化工具 - 此选项禁止在各种虚拟环境中执行受保护的文件：VMware，Virtual PC，VirtualBox，Sandboxie。在将控制传递到程序的入口点之前执行虚拟化的检测。如果检测到虚拟环境，则会显示相应的消息，程序将停止执行。</span><br></pre></td></tr></table></figure>
<h4 id="VMProtect虚拟机保护分析"><a href="#VMProtect虚拟机保护分析" class="headerlink" title="VMProtect虚拟机保护分析"></a>VMProtect虚拟机保护分析</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">VMP是一个基于堆栈机的intel指令模拟器，对过编译把原来的intel指令编译成精心设计的一组虚拟指令，然后用自己的一套引擎来解释执行。VMP加壳后，他会将原来的代码进行删除，导致基本完全无法进行还原。</span><br><span class="line"></span><br><span class="line">使用VMProtect保护后的程序添加了两个新节区，并且 IAT 表也需要修复（可以使用 unicorn 搞），因为VMP保护后的程序导入地址是运行时动态计算的。进入虚拟机的标志是push uint32 加上 call function 跳转到.vmp1的节区进行操作。call进去后就开始依次执行每一个handle了，在每个handle里面都存在的大量的代码混淆阻碍逆向分析。</span><br></pre></td></tr></table></figure>
<p><img src="./images/intern-ms-prepare/image-20240326172633812.png" alt="image-20240326172633812" style="zoom:67%;" /></p>
<p>&emsp;如何找 vmprotect OEP？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 通过对ZwProtectVirtualMemory下断，观察栈顶。</span><br><span class="line">2. 对代码节下硬件执行断点，得知道原始函数在大致哪个范围。</span><br><span class="line">3. 对mainCRTstartup内使用的一些API下断点（IsProcessorFeaturePresent, GetSystemTimeAsFileTime），然后回溯找到OEP。</span><br><span class="line">4. 一般对相应的遇见的第一个api下断点，一般的api也就是GetVersion，GetSystemTimeAsFileTime，如果下段后的栈回溯在text段内，那么我们继续回溯即可。可以看到相应的可以对上了，我们直接溯到call jmp的位置进行dump即可。</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">VMP采取的方案：</span><br><span class="line"></span><br><span class="line">虚拟机的寄存器：在内存开辟一段连续的区域当成虚拟机的寄存器，业界称之为VM_CONTEXT，某些版本的VMP用EDI指向这个区域</span><br><span class="line">虚拟机的堆栈: 这个和物理机是一样的，直接在内存开辟就好。VMP还是用EBP指向栈顶</span><br><span class="line">虚拟机的指令：不同版本VMP的指令是不一样的，这样可以在一定程度上防止VMP本身被破解，业界俗称VM_DATA</span><br><span class="line">虚拟机的EIP：业界俗称vEIP，某些版本的VMP用ESI替代，指向VM_DATA，用以读取虚拟CPU需要执行的指令；</span><br><span class="line"></span><br><span class="line">VMP虚拟机的执行流程</span><br><span class="line"></span><br><span class="line">（1）想想启动VT时，是不是要先开辟一段内存空间，把当前guestOS部分寄存器的值保存好？VMP也一样，先保存物理寄存器的值，后续退出VM后才能还原</span><br><span class="line">（2）让vEIP从VM_DATA读取虚拟机的指令</span><br><span class="line">（3）由于虚拟机的指令和物理CPU完全不同，那么在指令读取后，该怎么去执行了？举个栗子：比如0x1表示入栈，0x2表示出栈，0x3表示寄存器之间互相传数据（当然实际的指令可能不会这么简单，VMP每个版本的指令集都不同），这些指令该怎么执行了？在VMP中，有个概念叫handler，专门根据不同的指令执行不同的操作（当然这些操作VMP事先都定义好了）。这个和VT中VMX的handler作用类似：根据不同的异常有不同的处理方法（我个人猜测VMP的作者肯定借鉴了VT的原理和思路）；为了达到这种不同指令执行不同handler分支的效果，编码实现层面通常用switch+case实现，用于将不同的指令跳转到不同的分支执行，业界俗称dispatcher。具体到汇编代码，switch+case一般的汇编形式为：mov ecx,dword ptr ds:[eax*4+base] （注意寄存器可能会变成其他的，但这 xxx*4+基址的形式不会变）, 这是比较明显的特征，用以用来定位VMP的dispatcher。</span><br><span class="line">（4）执行完一个handler，vEIP接着指向下VM_DATA的下一个指令，然后重复（2）-（4）这几个步骤；</span><br><span class="line">（5）综上所述，要想全面了解、分析和掌控VMP，必须要找准这么几个点：</span><br><span class="line"></span><br><span class="line">VM_DATA：虚拟机的指令都集中在这了</span><br><span class="line">VM_CONTEXT：虚拟寄存器都保存在这里</span><br><span class="line">diapatcher：所有指令都从这里路由到对应的handler执行（可以简单理解为管理层派发活的，不过3.x版本的VMP貌似去掉了统一的dispatcher，由上个handler直接跳转到下个handler，有点P2P、区块链去中心化的感觉）</span><br><span class="line">handler：具体模拟执行虚拟指令的分支（可以简单理解为具体干活的工具人）。handler之间跳转通过jmp esi 或 push esi ,ret等指令实现（不同版本使用的寄存器可能不同，但跳转实现的方式就这些）；</span><br><span class="line">vEIP：当前执行的指令，需要明确是由那个物理寄存器保存的</span><br><span class="line">vStack：存放了临时数据用于各种交换</span><br></pre></td></tr></table></figure>
<h4 id="源代码到可执行文件的过程"><a href="#源代码到可执行文件的过程" class="headerlink" title="源代码到可执行文件的过程"></a>源代码到可执行文件的过程</h4><p>预处理，编译，汇编，链接。</p>
<p>blind ROP</p>
<p>SROP</p>
<h4 id="fastBin-相关漏洞"><a href="#fastBin-相关漏洞" class="headerlink" title="fastBin 相关漏洞"></a>fastBin 相关漏洞</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fastbins 是管理在 malloc_state 结构体的一串单向链表，分为0x20-0x807个链表。每个表头对应一个长度不超过4个的单向链表。</span><br><span class="line">1. 每次释放对应大小的堆块都会被连入对应大小的链表中（链表长度&lt;4）。</span><br><span class="line">2. 每次分配会优先从fastbins中分配对应大小的区块。</span><br></pre></td></tr></table></figure>
<p><img src="/images/intern-ms-prepare/image-20240326171136654.png" alt="image-20240326171136654" style="zoom:67%;" /></p>
<p>double free + fast bin</p>
<p><img src="/images/intern-ms-prepare/image-20240326171212913.png" alt="image-20240326171212913" style="zoom:67%;" /></p>
<p><img src="/images/intern-ms-prepare/image-20240326171244812.png" alt="image-20240326171244812" style="zoom:67%;" /></p>
<p><img src="/images/intern-ms-prepare/image-20240326171255057.png" alt="image-20240326171255057" style="zoom:67%;" /></p>
<h4 id="UAF-fastbin"><a href="#UAF-fastbin" class="headerlink" title="UAF + fastbin"></a>UAF + fastbin</h4><p><img src="/images/intern-ms-prepare/image-20240326171314931.png" alt="image-20240326171314931" style="zoom:67%;" /></p>
<h4 id="check-extend"><a href="#check-extend" class="headerlink" title="check extend"></a>check extend</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chuank extend 利用需要的条件是：</span><br><span class="line">1. 可以进行堆布局</span><br><span class="line">2. 可以溢出至少一个字节</span><br></pre></td></tr></table></figure>
<p><img src="/images/intern-ms-prepare/image-20240326171409403.png" alt="image-20240326171409403" style="zoom:67%;" /></p>
<p><img src="/images/intern-ms-prepare/image-20240326171419747.png" alt="image-20240326171419747" style="zoom:67%;" /></p>
<p><img src="/images/intern-ms-prepare/image-20240326171431536.png" alt="image-20240326171431536" style="zoom:67%;" /></p>
<p><img src="/images/intern-ms-prepare/image-20240326171442522.png" alt="image-20240326171442522" style="zoom:67%;" /></p>
<p><img src="/images/intern-ms-prepare/image-20240326171452849.png" alt="image-20240326171452849" style="zoom:67%;" /></p>
<h3 id="0x01-6-windows-安全相关"><a href="#0x01-6-windows-安全相关" class="headerlink" title="0x01-6 windows  安全相关"></a>0x01-6 windows  安全相关</h3><h3 id="0x01-7-编程语言基础"><a href="#0x01-7-编程语言基础" class="headerlink" title="0x01-7 编程语言基础"></a>0x01-7 编程语言基础</h3><h4 id="STL-迭代器"><a href="#STL-迭代器" class="headerlink" title="STL 迭代器"></a>STL 迭代器</h4><p>&emsp;STL（Standard Template Library，标准模板库）迭代器是一种用于遍历和访问STL容器中元素的对象。它提供了一种统一的方式来访问不同类型的容器，如向量（vector）、链表（list）、集合（set）、映射（map）等。</p>
<p>&emsp;STL迭代器可以被视为一个指针，它指向容器中的某个元素。通过对迭代器进行操作，可以遍历容器中的元素、访问元素的值、进行插入和删除操作等。迭代器相当于一个泛化的指针，通过派生统一的接口以及通过多态重写这些接口，使得迭代器可以适应不同类型的容器</p>
<h4 id="C-多态是如何实现的？"><a href="#C-多态是如何实现的？" class="headerlink" title="C++ 多态是如何实现的？"></a>C++ 多态是如何实现的？</h4><ol>
<li>静态多态包含：函数重载，C++编译器会将函数的参数类型以及其它修饰添加到函数的标签中，用于区别不同的重载函数。模板函数，由编译器根据调用替换模板参数，自动生成函数。</li>
<li>动态多态：虚函数，有虚表和虚函数指针实现，虚表由编译器实现，每一个有虚函数的类都拥有一张虚表，其中记录的是它的虚函数地址，函数重写时新的函数指针会替代掉基类对应位置的函数地址。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">虚函数。通过在运行时解析函数调用来实现的，而不是在编译时，从而允许代码在面对新的派生类型时保持开放性和灵活性。代码复用、扩展性与灵活性。</span><br></pre></td></tr></table></figure>
<p>&emsp;另外编译器在生产实例的时候还会自动生成一段内存来存储虚表的指针，使得调用虚函数的时候可以根据这张虚表+偏移定位到需要调用的虚函数地址。</p>
<h4 id="C-多态"><a href="#C-多态" class="headerlink" title="C++ 多态"></a>C++ 多态</h4><p>&emsp;（1）在基类的函数前加上 virtual 关键字，在派生类中重写该函数，运行时将会根据对象的实际类型来调用相应的函数。如果对象类型是派生类，就调用派生类的函数；如果对象类型是基类，就调用基类的函数。</p>
<p>&emsp;（2）存在虚函数的类都有一个一维的虚函数表叫做虚表，类的对象有一个指向虚表开始的虚指针。虚表是和类对应的，虚表指针是和对象对应的。 </p>
<p>&emsp;（3） 父类子类调用（不是虚函数）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">6</span> <span class="keyword">class</span> <span class="title class_">Father</span></span><br><span class="line"> <span class="number">7</span> &#123;</span><br><span class="line"><span class="number">14</span>     <span class="function"><span class="type">void</span> <span class="title">Say</span><span class="params">()</span></span></span><br><span class="line"><span class="function">15     </span>&#123;</span><br><span class="line"><span class="number">16</span>         cout &lt;&lt; <span class="string">&quot;Father say hello&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="number">17</span>     &#125;</span><br><span class="line"><span class="number">18</span> &#125;;</span><br><span class="line"><span class="number">19</span> </span><br><span class="line"><span class="number">20</span> </span><br><span class="line"><span class="number">21</span> <span class="keyword">class</span> <span class="title class_">Son</span>:<span class="keyword">public</span> Father</span><br><span class="line"><span class="number">22</span> &#123; </span><br><span class="line"><span class="number">24</span>     <span class="function"><span class="type">void</span> <span class="title">Say</span><span class="params">()</span></span></span><br><span class="line"><span class="function">25     </span>&#123;</span><br><span class="line"><span class="number">26</span>         cout &lt;&lt; <span class="string">&quot;Son say hello&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="number">27</span>     &#125;</span><br><span class="line"><span class="number">28</span> &#125;;</span><br><span class="line"><span class="number">29</span> </span><br><span class="line"><span class="number">30</span> <span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">31 </span>&#123;</span><br><span class="line"><span class="number">32</span>     Son son;</span><br><span class="line"><span class="number">33</span>     Father *pFather=&amp;son; <span class="comment">// 隐式类型转换</span></span><br><span class="line"><span class="number">34</span>     pFather-&gt;<span class="built_in">Say</span>();</span><br><span class="line"><span class="number">35</span> &#125;</span><br><span class="line"><span class="comment">// &quot;Father say hello&quot;</span></span><br></pre></td></tr></table></figure>
<p>&emsp;从编译角度，c++ 编译器在编译的时候，要确定每个对象的非虚函数的地址，这称为早期绑定，当我们将 Son 类的对象 son 的地址赋给 pFather 时，c++编译器进行了类型转换，此时 c++ 编译器认为变量 pFather 保存的就是 Father 对象的地址，调用的当然就是 Father 对象的 Say 函数。从内存角度，如下所示：</p>
<p><img src="./images/intern-ms-prepare/image-20240313180420445.png" alt="image-20240313180420445" style="zoom:67%;" /></p>
<p>（4）父类子类调用（有虚函数）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">6</span> <span class="keyword">class</span> <span class="title class_">Father</span></span><br><span class="line"> <span class="number">7</span> &#123;</span><br><span class="line"><span class="number">14</span>     <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Say</span><span class="params">()</span></span></span><br><span class="line"><span class="function">15     </span>&#123;</span><br><span class="line"><span class="number">16</span>         cout &lt;&lt; <span class="string">&quot;Father say hello&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="number">17</span>     &#125;</span><br><span class="line"><span class="number">18</span> &#125;;</span><br><span class="line"><span class="number">19</span> </span><br><span class="line"><span class="number">21</span> <span class="keyword">class</span> <span class="title class_">Son</span>:<span class="keyword">public</span> Father</span><br><span class="line"><span class="number">22</span> &#123; </span><br><span class="line"><span class="number">24</span>     <span class="function"><span class="type">void</span> <span class="title">Say</span><span class="params">()</span></span></span><br><span class="line"><span class="function">25     </span>&#123;</span><br><span class="line"><span class="number">26</span>         cout &lt;&lt; <span class="string">&quot;Son say hello&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="number">27</span>     &#125;</span><br><span class="line"><span class="number">28</span> &#125;;</span><br><span class="line"><span class="number">29</span> </span><br><span class="line"><span class="number">30</span> <span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">31 </span>&#123;</span><br><span class="line"><span class="number">32</span>     Son son;</span><br><span class="line"><span class="number">33</span>     Father *pFather=&amp;son; <span class="comment">// 隐式类型转换</span></span><br><span class="line"><span class="number">34</span>     pFather-&gt;<span class="built_in">Say</span>();</span><br><span class="line"><span class="number">35</span> &#125;</span><br><span class="line"><span class="comment">// &quot;Son say hello&quot;</span></span><br></pre></td></tr></table></figure>
<p>&emsp;编译器在编译的时候，发现 Father 类中有虚函数，此时编译器会为每个包含虚函数的类创建一个虚表（即 vtable），该表是一个一维数组，在这个数组中存放每个虚函数的地址，如下所示：</p>
<p><img src="/images/intern-ms-prepare/image-20240313180634353.png" alt="image-20240313180634353" style="zoom:67%;" /></p>
<p>&emsp;编译器另外还为每个对象提供了一个虚表指针 （vptr），用于定位虚表，在程序运行时，根据对象的类型去初始化vptr，从而让 vptr 正确的指向了所属类的虚表，从而在调用虚函数的时候，由于 pFather 实际指向的对象类型是Son，因此 vptr 指向的 Son 类的 vtable。</p>
<p>　　对象会初始化虚表指针，这是在对象的构造函数中运行的。在构造子类对象时，要先调用父类的构造函数，它初始化父类对象的虚表指针，当执行子类的构造函数时，子类对象的虚表指针被初始化，指向自身的虚表。</p>
<h4 id="C-智能指针"><a href="#C-智能指针" class="headerlink" title="C++ 智能指针"></a>C++ 智能指针</h4><p>&emsp;管理动态分配的内存的，它会帮助我们自动释放 new 出来的内存，从而避免内存泄漏。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">auto_ptr。两个指针不能指向同一个资源，复制或赋值都会改变资源的所有权。</span><br><span class="line">unique_ptr。两个指针不能指向同一个资源，禁止复制，只允许移动，是 auto_ptr 的替代。</span><br><span class="line">shared_ptr。采用引用计数的智能指针。</span><br><span class="line">weak_ptr。对一个或多个 shared_ptr 实例拥有的对象的访问，但不参与引用计数。</span><br></pre></td></tr></table></figure>
<h3 id="0x01-8-计算机网络相关"><a href="#0x01-8-计算机网络相关" class="headerlink" title="0x01-8 计算机网络相关"></a>0x01-8 计算机网络相关</h3><h4 id="linux-epoll"><a href="#linux-epoll" class="headerlink" title="linux epoll"></a>linux epoll</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">处理大量并发连接。</span><br><span class="line"></span><br><span class="line">工作模式：</span><br><span class="line">（1）LT (Level Triggered，水平触发): 默认模式，当 epoll_wait 检测到描述符就绪，将这个事件通知给应用程序，应用程序可以不立即处理该事件。下次调用 epoll_wait 时，如果这些事件仍然满足条件，则会再次通知这些事件。</span><br><span class="line">（2）ET (Edge Triggered，边缘触发): 高性能模式，仅当状态变化时才通知一次。应用程序必须立即处理事件，因为只有下一个状态变化才会触发通知。</span><br><span class="line"></span><br><span class="line">epoll_ctl - 管理 epoll 实例的感兴趣的事件列表。</span><br></pre></td></tr></table></figure>
<h4 id="如果服务器上有大量的连接处于-TIME-WAIT-状态应该如何处理？"><a href="#如果服务器上有大量的连接处于-TIME-WAIT-状态应该如何处理？" class="headerlink" title="如果服务器上有大量的连接处于 TIME_WAIT 状态应该如何处理？"></a>如果服务器上有大量的连接处于 TIME_WAIT 状态应该如何处理？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">为什么会有 TIME_WAIT 状态？</span><br><span class="line">1. 正常关闭连接：当服务器和客户端之间的连接正常关闭时，根据 TCP 协议的规定，连接的一端（通常是客户端）会进入 TIME_WAIT 状态。在此状态下，该端会等待一段时间，以确保网络中的所有数据包都被接收和处理完毕。这样可以避免后续的数据包被之前连接的残留数据所干扰。</span><br><span class="line">2. 端口资源耗尽：如果服务器的端口资源被快速消耗完，可能会导致连接的 CLOSE_WAIT 状态无法正常关闭，从而导致服务器出现大量的 TIME_WAIT 状态。</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">设置地址复用，少用短连接，调整 TIME_WAIT 时间。</span><br></pre></td></tr></table></figure>
<h4 id="短链接与长链接"><a href="#短链接与长链接" class="headerlink" title="短链接与长链接"></a>短链接与长链接</h4><p>短连接（Short Connection）是一种连接方式，它指的是在通信双方完成一次数据交换后立即断开连接的方式。</p>
<p>长连接（Long Connection），即在通信双方之间建立一次连接后，可以持续较长的时间，用于多次数据交换。</p>
<p>特点和应用场景：</p>
<ol>
<li>临时性：短连接是一种临时性的连接，即每次通信都需要重新建立连接，数据交换完毕后立即关闭连接。与长连接相比，短连接的生命周期较短暂。</li>
<li>资源消耗少：由于短连接仅在数据交换期间建立，连接时间较短，因此相对于长连接来说，短连接的资源消耗较少。这对于服务器端来说可以释放连接资源，提高系统的可扩展性。</li>
<li>频繁的连接建立和断开：由于每次通信都需要重新建立连接，因此短连接的连接建立和断开操作比较频繁。这可能会对服务器端的性能产生一定的影响，尤其在高并发的情况下。</li>
<li>适用于请求-响应模式：短连接通常用于请求-响应模式的应用场景，例如网页浏览、文件下载等。客户端发送请求，服务器端响应并返回数据，然后立即关闭连接。</li>
</ol>
<p>短连接适用于那些对实时性要求较高、连接时间较短、资源消耗较少的场景。它可以减轻服务器的负载，并且连接的建立和断开操作相对简单。然而，由于频繁的连接建立和断开操作，短连接在高并发情况下可能会导致连接的建立和断开开销较大，因此在设计和选择网络通信方式时需要综合考虑实际需求和系统性能。</p>
<p>相比之下，长连接更适用于需要保持持久连接、频繁通信、实时性要求不高的场景，如聊天应用、实时数据推送等。</p>
<h3 id="0x01-9-数据库相关"><a href="#0x01-9-数据库相关" class="headerlink" title="0x01-9 数据库相关"></a>0x01-9 数据库相关</h3><h3 id="0x01-10-Linux-相关"><a href="#0x01-10-Linux-相关" class="headerlink" title="0x01-10 Linux 相关"></a>0x01-10 Linux 相关</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dlopen（打开dll）/dlsym（获取dll中某函数的地址，对应 GetProcAddress）/dlclose</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ss -t // 查看 tcp 链接， -n 显示端口号</span><br><span class="line">lsof -i TCP // 查看正在运行系统上的文件的工具，但它也可以用来查看打开的网络连接</span><br><span class="line">tcpdump // 获取 TCP 数据包。</span><br></pre></td></tr></table></figure>
<h4 id="memcpy-和-memmove-是怎么实现的"><a href="#memcpy-和-memmove-是怎么实现的" class="headerlink" title="memcpy 和 memmove 是怎么实现的?"></a>memcpy 和 memmove 是怎么实现的?</h4><p>A.<code>memcpy</code> 函数：</p>
<ul>
<li><code>memcpy</code> 函数用于在内存区域之间进行字节级别的拷贝。</li>
<li><code>memcpy</code> 的实现通常使用比较底层的方法，如使用处理器的指令集来进行高效的内存复制操作。</li>
<li><code>memcpy</code> 的使用有一个前提：目标内存区域和源内存区域不得重叠，否则结果是不确定的。</li>
</ul>
<p>B. <code>memmove</code> 函数：</p>
<ul>
<li><code>memmove</code> 的实现考虑了源内存区域和目标内存区域可能重叠的情况。因此，它采用了更保守的策略，使用了临时缓冲区，以确保正确的结果。</li>
<li><code>memmove</code> 的使用没有重叠的限制，可以安全地处理重叠的内存区域。需要注意的是，虽然 <code>memmove</code> 在处理重叠内存区域时比 <code>memcpy</code> 更安全，但也因为这种额外的处理而可能导致性能略低于 <code>memcpy</code>。</li>
</ul>
<h4 id="close-amp-shutdown"><a href="#close-amp-shutdown" class="headerlink" title="close &amp; shutdown"></a>close &amp; shutdown</h4><ol>
<li>功能：<ul>
<li><code>close</code> 函数用于关闭套接字，关闭连接并释放相关的资源。当调用 <code>close</code> 函数时，套接字会立即关闭，不再接收或发送数据。</li>
<li><code>shutdown</code> 函数用于关闭套接字的一部分功能。通过 <code>shutdown</code> 函数可以选择关闭套接字的读取（输入）功能、写入（输出）功能或同时关闭两者。</li>
</ul>
</li>
<li>关闭连接和资源释放：<ul>
<li><code>close</code> 函数关闭套接字时，会立即关闭连接并释放与该套接字相关的资源，包括文件描述符（file descriptor）和缓冲区等。</li>
<li><code>shutdown</code> 函数不会立即关闭连接，而是根据参数来决定关闭的方式。如果选择关闭读取功能，那么套接字仍然可以发送数据，反之亦然。只有当两端都调用了 <code>shutdown</code> 函数关闭读取和写入功能后，连接才会真正关闭。</li>
</ul>
</li>
<li>影响其他套接字：<ul>
<li><code>close</code> 函数关闭套接字时，只会关闭当前套接字，对其他套接字没有影响。</li>
<li><code>shutdown</code> 函数关闭套接字的一部分功能时，可能会影响与之相关的其他套接字。例如，如果一个套接字调用了 <code>shutdown</code> 函数关闭写入功能，而另一个套接字试图向该套接字发送数据，那么发送操作可能会失败。</li>
</ul>
</li>
</ol>
<h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">如果有两个线程去1、2去访问同一个资源 C ，并且二者必须同时获取锁 A 和 B 才可以访问 C。问什么顺序获取锁会导致死锁，正确的获取和释放顺序是如何？</span><br><span class="line"></span><br><span class="line">1. 分情况讨论：第一如果两个线程同时去分别先获取不同的锁就会出现死锁，比如线程1先获得锁 A 而线程 2 先获得锁 B 然后二者都会等待。</span><br><span class="line">2. 正确的顺序应该是二者同时竞争同一个锁:</span><br><span class="line">	a. 先释放 A，由于对方正在等待A，那么对方接下来会等待B，而此时释放 B 是没有阻碍的</span><br></pre></td></tr></table></figure>
<h4 id="C-避免死锁"><a href="#C-避免死锁" class="headerlink" title="C++ 避免死锁"></a>C++ 避免死锁</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::lock()。</span><br><span class="line">1. 无死锁的加锁顺序：std::lock() 函数会按照一种事先确定的顺序对传入的互斥量进行加锁。这个顺序是为了避免出现死锁的条件，即遵循 &quot;资源申请的有序性&quot; 原则。通过约定一个全局的加锁顺序，可以避免不同线程在加锁时产生循环依赖的情况，从而避免死锁。</span><br><span class="line">2. 无死锁的原子加锁操作：std::lock() 函数使用原子操作来保证多个互斥量的加锁操作是原子的。原子操作保证了多个线程无法同时对同一个互斥量进行加锁，从而避免了竞争条件。如果无法一次性对所有互斥量进行加锁，std::lock() 函数会自动解锁之前已经加锁的互斥量，然后等待其他线程解锁剩余的互斥量，再重新尝试对所有互斥量进行加锁，直到所有互斥量都成功加锁为止。</span><br></pre></td></tr></table></figure>
<h3 id="0x01-11-区块链相关"><a href="#0x01-11-区块链相关" class="headerlink" title="0x01-11 区块链相关"></a>0x01-11 区块链相关</h3><h3 id="0x01-12-算法基础"><a href="#0x01-12-算法基础" class="headerlink" title="0x01-12 算法基础"></a>0x01-12 算法基础</h3><h4 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1. 冒泡排序。其大体思想就是通过与相邻元素的比较和交换来把小的数交换到最前面。这个过程类似于水泡向上升一样，因此而得名。对5,3,8,6,4这个无序序列进行冒泡排序。首先从后向前冒泡，4和6比较，把4交换到前面，序列变成5,3,8,4,6。同理4和8交换，变成5,3,4,8,6,3和4无需交换。5和3交换，变成3,5,4,8,6,3，这样一次冒泡就完了，把最小的数3排到最前面了。</span><br><span class="line">	a. 平均时间复杂度：O(n^2)</span><br><span class="line"></span><br><span class="line">2. 选择排序。在长度为N的无序数组中，第一次遍历n-1个数，找到最小的数值与第一个元素交换；第二次遍历n-2个数，找到最小的数值与第二个元素交换；</span><br><span class="line">	a. 平均时间复杂度：O(n^2)</span><br><span class="line"></span><br><span class="line">3. 插入排序，一个个比较，就像插扑克牌。平均时间复杂度：O(n^2)。</span><br><span class="line"></span><br><span class="line">4. 快速排序，分治思想。先从数列中取出一个数作为key值；将比这个数小的数全部放在它的左边，大于或等于它的数全部放在它的右边；对左右两个小数列重复第二步，直至各区间只有1个数。平均时间复杂度：O(N*logN)。</span><br><span class="line"></span><br><span class="line">5. 归并排序。将数组分成2组A，B，如果这2组组内的数据都是有序的，那么就可以很方便的将这2组数据进行排序。依次类推，当分出来的小组只有1个数据时，可以认为这个小组组内已经达到了有序，然后再合并相邻的2个小组就可以了。这样通过先递归的分解数列，再合并数列就完成了归并排序。平均时间复杂度：O(N*logN)。</span><br><span class="line"></span><br><span class="line">6. 堆排序。最坏，最好，平均时间复杂度均为O(nlogn)。</span><br><span class="line">	a. 堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。</span><br><span class="line">	b. 将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了。</span><br></pre></td></tr></table></figure>
<h4 id="哈希冲突解决"><a href="#哈希冲突解决" class="headerlink" title="哈希冲突解决"></a>哈希冲突解决</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 开放定址法，从发生冲突的那个单元起，按照一定的次序，从哈希表中找到一个空闲的单元。然后把发生冲突的元素存入到该单元的一种方法。开放定址法需要的表长度要大于等于所需要存放的元素。开放定址法的缺点在于删除元素的时候不能真的删除，否则会引起查找错误，只能做一个特殊标记。只到有下个元素插入才能真正删除该元素。</span><br><span class="line">2. 链地址法（拉链法）。</span><br><span class="line">3. 再哈希法，就是同时构造多个不同的哈希函数：Hi = RHi(key)   i= 1,2,3 … k; 当H1 = RH1(key)  发生冲突时，再用H2 = RH2(key) 进行计算，直到冲突不再产生。</span><br></pre></td></tr></table></figure>
<h4 id="md5-流程"><a href="#md5-流程" class="headerlink" title="md5 流程"></a>md5 流程</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：不定长度信息（要加密的信息）</span><br><span class="line">输出：固定长度128-bits。由四个32位分组组成，将这四个32位分组级联后将生成一个128位散列值。</span><br><span class="line">基本方式为：求余、取余、调整长度、与链接变量进行循环运算。得出结果。</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(1)信息填充，长度恰好是512的整数倍。</span><br><span class="line"></span><br><span class="line">(2)结构初始化，在处理过程中需要定义一个结构。该结构包含了每一次需要处理的一个明文块 (512bit)和计算出来的散列值 (128bit)。在散列的整个过程中，它的作用非常重要 ，各个明文块计算出来的散列值都是通过它来传递的。</span><br><span class="line"></span><br><span class="line">(3)分组文件，将填充好的文件进行分组，每组 512位 ,共有N组。</span><br><span class="line"></span><br><span class="line">(4)处理分组，使用算法处理每组数据。</span><br><span class="line">	a. MD5算法在计算时会用到四个32位被称作链接变量 (Chaining Variable)的整数参数 ，在使用之前要对它们赋初值。</span><br><span class="line">	b. 进入算法的四轮循环运算。循环的次数是信息中512位信息分组的数目。</span><br><span class="line">	c. 将上面四个链接变量复制到另外四个变量中。</span><br><span class="line">	d. 主循环有四轮，每轮循环都很相似。第一轮进行16次操作。每次操作对 a、b、c和 d中的其中三个作一次非线性函数运算 ，然后将所得结果加上第四个变量，一个子分组和一个常数。再将所得结果向右环移一个不定的数，并加上 a、b、c或 d中之一，最后用该结果取代 a、b、c或 d中之一。</span><br></pre></td></tr></table></figure>
<p><img src="/images/intern-ms-prepare/image-20240407150531726.png" alt="image-20240407150531726" style="zoom:67%;" /></p>
<h4 id="AES"><a href="#AES" class="headerlink" title="AES"></a>AES</h4><p><img src="/images/intern-ms-prepare/image-20240326170705343.png" alt="image-20240326170705343" style="zoom:50%;" /></p>
<h3 id="0x01-13-病毒分析"><a href="#0x01-13-病毒分析" class="headerlink" title="0x01-13 病毒分析"></a>0x01-13 病毒分析</h3><h4 id="wannaCry病毒分析（勒索病毒）"><a href="#wannaCry病毒分析（勒索病毒）" class="headerlink" title="wannaCry病毒分析（勒索病毒）"></a>wannaCry病毒分析（勒索病毒）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">WannaCry利用Windows系统的SMB漏洞获取系统的最高权限，该工具通过恶意代码扫描开放445端口的Windows系统。WannaCry利用永恒之蓝漏洞进行网络端口扫描攻击，目标机器被成功攻陷后会从攻击机下载WannaCry蠕虫进行感染，并作为攻击机再次扫描互联网和局域网的其他机器，形成蠕虫感染大范围超快速扩散。</span><br><span class="line"></span><br><span class="line">其核心流程如下图所示：</span><br><span class="line">1. 木马母体为mssecsvc.exe，运行后会扫描随机IP的互联网机器，尝试感染，也会扫描局域网相同网段的机器进行感染传播，此外会释放敲诈者程序tasksche.exe，对磁盘文件进行加密勒索。</span><br><span class="line">2. 木马加密使用AES加密文件，并使用非对称加密算法RSA 2048加密随机密钥，每个文件使用一个随机密钥，理论上不可攻破。</span><br><span class="line"></span><br><span class="line">WannaCry勒索病毒主要行为是传播和勒索。</span><br><span class="line">1. 传播：利用基于445端口的SMB漏洞MS17-010(永恒之蓝)进行传播</span><br><span class="line">2. 勒索：释放文件，包括加密器、解密器、说明文件、语言文件等；加密文件；设置桌面背景、窗体信息及付款账号等。</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">过程：</span><br><span class="line">1. 主程序运行后会先连接域名（KillSwitch），如果该域名连接成功，则直接退出且不触发任何恶意行为。否则触发传播勒索行为，执行sub_408090函数。</span><br><span class="line">2. 创建mssecsvc2.0服务，并启动该服务，参数为”-m security”，蠕虫伪装为微软安全中心。</span><br><span class="line">3. 读取并释放资源tasksche.exe至 C:\Windows 路径，创建线程运行。</span><br><span class="line">4. 蠕虫传播。WSAStartup：初始化网络。蠕虫初始化操作后，会生成两个线程，分别进行局域网和公网传播。</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">永恒之蓝：</span><br><span class="line">SMB服务端口（默认是445端口），并利用该漏洞来执行恶意代码，甚至获得系统的完全控制权。漏洞的核心是在SMBv1协议中的一个称为“Windows内核传输模式”的特性。该特性允许攻击者发送一个特殊设计的数据包，其中包含了恶意的SMB1协议请求，当Windows操作系统试图处理这个请求时，会导致系统内核缓冲区的溢出，从而使攻击者能够执行任意的代码。</span><br></pre></td></tr></table></figure>
<h3 id="0x01-14-其它"><a href="#0x01-14-其它" class="headerlink" title="0x01-14 其它"></a>0x01-14 其它</h3><h4 id="性能指标评估"><a href="#性能指标评估" class="headerlink" title="性能指标评估"></a>性能指标评估</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QPS(TPS)：每秒钟处理request/事务的数量。</span><br><span class="line">并发数：系统同时处理的request/事务的用户数量。</span><br><span class="line">响应时间（Response Time，RT）：服务器处理响应的耗时，一般取平均响应时间。</span><br><span class="line">CPU 占用，内存占用磁盘IO等，如果有网络还要考虑丢包。</span><br></pre></td></tr></table></figure>
<h3 id="0x01-15-游戏安全相关"><a href="#0x01-15-游戏安全相关" class="headerlink" title="0x01-15 游戏安全相关"></a>0x01-15 游戏安全相关</h3><h4 id="游戏安全基础导论"><a href="#游戏安全基础导论" class="headerlink" title="游戏安全基础导论"></a>游戏安全基础导论</h4><p>游戏安全问题：</p>
<ul>
<li>外挂。</li>
<li>社交类游戏有恶意内容（合规包括涉政、涉恐，业务包括广告、骂人等）。</li>
<li>打金工作室（DNF 刷钱，利用工具刷游戏资源，卖给玩家变现）（人脸认证可以识别）。</li>
<li>盗号。木马、假客户端。</li>
<li>DDOS 攻击（ping 值突增）。</li>
<li>演员与消极行为。</li>
<li>棋牌类黑产（就像赌桌一样）。</li>
<li>游戏数据盗用（xx 盒子知道 LOL 游戏数据）。</li>
<li>网吧客户端营销推广（插件），改广告。</li>
<li>游戏私服（逆向后直接模拟），给玩家更好的游戏体验。</li>
<li>单机盗版（Denuvo加固、3DM破解）。</li>
<li>云游戏。沙盒环境，有传统安全问题，也会有云端逃逸作弊。</li>
</ul>
<p>如何设计？</p>
<ul>
<li><p>尽量让服务端做敏感功能。</p>
</li>
<li><p>客户端加固：</p>
<ul>
<li>加壳、混淆、反调试、游戏进程保护（不经过 ring0）。</li>
<li>外挂在线监测。可疑样本上报-&gt;外挂识别-&gt;特征提取-&gt;白名单测试-&gt;对抗监控特征发布。</li>
</ul>
<p><img src="/images/intern-ms-prepare/image-20240417110450295.png" alt="image-20240417110450295" style="zoom:67%;" /></p>
</li>
<li><p>坐飞机、挂车怎么处理？</p>
<ul>
<li>明确加减分规则（信誉分）、单次挂车没事。</li>
<li>实时扣分反馈，对用户进行引导，做低等级副本。</li>
</ul>
</li>
<li>打金工作室怎么处理？人脸检测、弹验证码、封账号。</li>
</ul>
<h4 id="客户端安全开发基础-PC篇"><a href="#客户端安全开发基础-PC篇" class="headerlink" title="客户端安全开发基础-PC篇"></a>客户端安全开发基础-PC篇</h4><p>常见 C++ 编译器：MSVC（微软）、LLVM（clang）。</p>
<p>常见的加壳：VMProtect（混淆+虚拟化）、UPX、SafeEngine、Themida。</p>
<p>VMP 特征：push + call。</p>
<p>UE4 引擎：</p>
<p><img src="/images/intern-ms-prepare/image-20240417113029658.png" alt="image-20240417113029658" style="zoom:67%;" /></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">ULevel: UE的场景划分模式是基于子关卡来做的，UE4和其他支持大世界的引擎一样支持游戏场景中的物体动态加载与卸载，UE4中的动态加载卸载的子关卡叫做流关卡(StreamingLevel、ULevelStreaming类)，一开始就加载的子关卡叫持久关卡(PersistentLevel)</span><br><span class="line"></span><br><span class="line">UWorld:游戏主场景，游戏过程中，一般只存在一个UWorld实例</span><br><span class="line"></span><br><span class="line">GNames: 包含游戏中所有对象的命名字符串信息</span><br><span class="line"></span><br><span class="line">GObjects:包含所有游戏对象的链表</span><br><span class="line"></span><br><span class="line">Gamelnstance:顾名思义，游戏实例，保存着当前的World和其他整个游戏的信息，官方解释是一个正在运行的游戏的高级别管理对象，在游戏创建时生成，游戏关闭时销毁，一个游戏中可以有多个Gamelnstance。在游戏中切换关卡，Gamelnstance不会销毁，切换关卡时可用GameInstance携带信息</span><br><span class="line"></span><br><span class="line">GameMode: 负责指定游戏的规则，也就是应该如何玩游戏、遵守哪些规则</span><br><span class="line"></span><br><span class="line">GameState:游戏状态，记录游戏的数据，比如当前游戏的进度，世界人物的完成状态等，可同步到各个客户端</span><br><span class="line"></span><br><span class="line">UObject: 引擎对象的最小单位</span><br><span class="line"></span><br><span class="line">Actor: 在UE离不是某种具象化的3D世界对象，而是世界里面的种种元素，用更泛化抽象的概念来看，小到一个个地上的石头，大到整个世界的运行规则，更像是一个容器</span><br><span class="line"></span><br><span class="line">RootComponent:对象根组件，包含对象的位置信息(坐标、朝向)</span><br><span class="line"></span><br><span class="line">Pawn 是作为世界中的一个“代理”的Actor。Pawn可以由控制器处理，它们可以轻松地接受输入，并且可以执行各种各样的类似于玩家的动作。</span><br><span class="line"></span><br><span class="line">Character是类人的Pawn。它默认包含一个用于碰撞的CapsuleComponent(胶囊体组件)与CharacterMovementComponent(角色运动组件)它可以进行基本的拟人运动它可以平滑地在网格上复制运动，并且它具有一些动画相关的功能。</span><br><span class="line"></span><br><span class="line">Controller是负责管理Pawn的Actor，分为AIController和PlayerController。其中PlayerController(玩家控制器)是Pawn和控制它的人类玩家间的接口。PlayerController本质上代表了人类玩家的意愿。</span><br></pre></td></tr></table></figure>
<p>Unity 引擎（跨平台比较好）：Unity 脚本后处理的两种方式有 mono 与 IL2CPP。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Mono：在尽可能多的平台上使.net标准的东西能正常运行。</span><br><span class="line"></span><br><span class="line">Mono 组成组件：C#编译器，CLI虚拟机。</span><br><span class="line"></span><br><span class="line">编译器:</span><br><span class="line">	C# 编译器 mcs，将 C# 转为 IL。</span><br><span class="line">	Mono runtime 编译器：将 IL 转为原生码。</span><br><span class="line"></span><br><span class="line">三种转译方式：</span><br><span class="line">	即时编译(Just in time,JlT):程序运行过程中转译为目标平台的原生码。</span><br><span class="line">	提前编译(Ahead oftime,AOT):程序运行之前，转译为目标平台的原生码并且存储，程序运行中仍有部分CIL的byte code需要JIT编译。</span><br><span class="line">	完全静态编译(Fu ahead oftime,Ful-AOT):程序运行前，将所有源码编译成目标平台的原生码。</span><br><span class="line"></span><br><span class="line">Unity跨平台的原理：Mono运行时编译器支持将IL代码转为对应平台原生码</span><br><span class="line"></span><br><span class="line">JIT编译：将IL代码转为对应平台原生码并且将原生码映射到虚拟内存中执行。JIT编译的时候IL是在依托Mono运行时，转为对应的原生码后在依托本地运行。</span><br><span class="line"></span><br><span class="line">Mono 优缺点：</span><br><span class="line">1.构建应用非常快</span><br><span class="line">2.由于Mono的JIT(Just In Time compilation)机制,所以支持更多托管类库</span><br><span class="line">3.支持运行时代码执行</span><br><span class="line">4.Mono VM在各个平台移植异常麻烦，有几个平台就得移植几个VM(WebGL和UWP这两个平台只支持IL2CPP)</span><br></pre></td></tr></table></figure>
<p><img src="/images/intern-ms-prepare/image-20240417115927471.png" alt="image-20240417115927471" style="zoom:67%;" /></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">IL2CPP 优缺点：</span><br><span class="line">1.相比Mono，代码生成有很大的提高</span><br><span class="line">2.可以调试生成的C++代码</span><br><span class="line">3.程序的运行效率比Mono高，运行速度快</span><br><span class="line">4.多平台移植非常方便</span><br><span class="line">5.相比Mono构建应用慢</span><br><span class="line">6.只支持AOT(Ahead of Time)编译</span><br></pre></td></tr></table></figure>
<p><img src="/images/intern-ms-prepare/image-20240417120006359.png" alt="image-20240417120006359" style="zoom:67%;" /></p>
<h5 id="进程注入分类："><a href="#进程注入分类：" class="headerlink" title="进程注入分类："></a>进程注入分类：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">静态注入--进程创建前完成注入</span><br><span class="line">（1）导入表注入</span><br><span class="line">（2）DLL劫持注入</span><br><span class="line">（3）注册表注入</span><br><span class="line"></span><br><span class="line">动态注入--进程运行过程中进行注入</span><br><span class="line">（1）远程线程注入</span><br><span class="line">（2）消息钩子注入</span><br><span class="line">（3）APC注入</span><br><span class="line">（4）IAT(导入表函数)劫持注入</span><br></pre></td></tr></table></figure>
<p>导入表注入：程序运行时会导入 dll，这些信息保存在IMAGE_NT_HEADER的OptionalHeader的第二个项，指向着一个IMAGE_IMPORT_DESCRIPTOR(IID)结构体数组。进程启动时系统会遍历这个数组，加载dll到内存。因此修改导入表结构，增加一个导入表项，就可以实现让程序加载我们的dll。</p>
<p>DLL 劫持注入：程序在磁盘上搜索 DLL 文件。</p>
<p><img src="/images/intern-ms-prepare/image-20240417120638515.png" alt="image-20240417120638515" style="zoom:67%;" /></p>
<p>伪造一个系统同名的DLL，提供同样的输出表，每个输出函数转向真正的系统DLL。程序调用系统DLL时会先调用当前目录下伪造的DLL，完成相关功能后再跳到系统DLL同名函数里执行。</p>
<p>注册表注入：AppInit_DLLs与loadAppinit_dll，仅限加载 user32.dll 的程序。</p>
<p>远程线程注入：craeteRemoteThread。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">常见的利用CreateRemoteThread来实现远程线程注入的方式有两种:</span><br><span class="line">1.定义远程线程入口地址为LoadLibraryW并将需要加载的模块路径作为参数传入。</span><br><span class="line">2.编写ShellCode并将远程线程入口地址定义为ShellCode的执行地址，在ShellCode中调用Map，到目标进程中的DLL入口函数。</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FindProcess -&gt; OpenProcess -&gt; VitualAllocEx -&gt; WriteProcessMemory -&gt; CreateRemoteThread</span><br></pre></td></tr></table></figure>
<p>消息钩子注入：微软的不同进程设置消息钩子。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FindWindow -&gt; getwindowThreadProcessId -&gt; LoadLibraryEx -&gt; GetProcAddress -&gt; SetWindowsHookEx -&gt; UnhookWindowsHookEx</span><br></pre></td></tr></table></figure>
<p>APC 注入：线程调度的时候操作系统会遍历APC列表，并加载代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FindProcess -&gt; OpenProcess -&gt; VitualAllocEx -&gt; WriteProcessMemory -&gt; OpenThread -&gt; QueueUserAPC(GetProcAddress(GetModuleHandle))</span><br></pre></td></tr></table></figure>
<p>IAT劫持注入：调用系统 API 的时候，劫持系统导入表函数。</p>
<h5 id="Hook-方式："><a href="#Hook-方式：" class="headerlink" title="Hook 方式："></a>Hook 方式：</h5><p>Inline Hook：minhook 库。</p>
<p>虚表 Hook：<code>call [rax+0x48]</code>，把虚表地址进行替换，成为 hook（hook游戏内部函数）。</p>
<p>IAT(导入表) Hook：Hook 游戏所调用的外部 api 的函数。</p>
<p>内核 APIHook(SSDT SSSDT)：修改 Shadow SSDT 的表，是全局的。</p>
<h5 id="内存读写与监控："><a href="#内存读写与监控：" class="headerlink" title="内存读写与监控："></a>内存读写与监控：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">用户层内存读写方式：</span><br><span class="line">(1)OpenProcess + ReadProcessMemory（VM_READ权限）。</span><br><span class="line">(2)劫持句柄+ReadProcessMemory，有一些进程有内存读写句柄（process hacker，ark 工具）。</span><br><span class="line">(3)映射物理内存到自进程。</span><br><span class="line">	取目标进程 PID，拿到其 EPROCESS。</span><br><span class="line">	获取物理内存范围。</span><br><span class="line">	ZwOpenSection。</span><br><span class="line">	ZwMapViewOfSections。映射到自己内存中。</span><br><span class="line"></span><br><span class="line">内核层内存读写方式：</span><br><span class="line">(1)ZwReadVirtualMemory/NtReadVirtualMemory。</span><br><span class="line">(2)MmCopyVirtualMemory（非常多）。</span><br><span class="line">	PsLookUpProcessByProcessId</span><br><span class="line">	MmCopyVirtualMemory</span><br><span class="line">(3)MmCopyMemory。通过获取CR3值(页表地址)，计算虚拟地址所在的物理地址，调用MmCopyMemory即可直接拷贝转换后的物理地址内存。</span><br><span class="line">(4)RtlCopyMemory(需要先附加到目标进程中)。通过强行切换CR3值切换到目标进程后（附加的方式），直接拷贝需要读取的内存地址即可。</span><br></pre></td></tr></table></figure>
<h5 id="物理地址与虚拟地址转换"><a href="#物理地址与虚拟地址转换" class="headerlink" title="物理地址与虚拟地址转换"></a>物理地址与虚拟地址转换</h5><p>物理地址（Physical Address）和虚拟地址（Virtual Address）之间的转换通常涉及到操作系统的内存管理单元（MMU）来完成。在操作系统中，通常采用分页（Paging）或分段（Segmentation）等技术来实现虚拟地址到物理地址的转换。</p>
<ul>
<li>分页（Paging）：在分页系统中，虚拟地址被分成固定大小的页（Page），物理内存也被分成相同大小的页框（Page Frame）。虚拟地址的高位表示页号，低位表示页内偏移。通过页表（Page Table）来映射虚拟地址到物理地址。页表中的每一项包含了虚拟页号和对应的物理页框号。物理地址可以通过以下公式来计算：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">物理地址 = （物理页框号 &lt;&lt; 偏移位数） + 页内偏移</span><br></pre></td></tr></table></figure>
<ul>
<li>分段（Segmentation）：在分段系统中，程序被划分成逻辑段（Segment），每个逻辑段有自己的基地址和长度。虚拟地址由段号和段内偏移组成。通过段表（Segment Table）来映射段号到段基地址。物理地址可以通过以下公式来计算：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">物理地址 = 段基地址 + 段内偏移</span><br></pre></td></tr></table></figure>
<p>在现代操作系统中，内存管理技术更加复杂，可能会涉及到多级页表、TLB（Translation Lookaside Buffer）等结构来提高地址转换的效率和灵活性。</p>
<h5 id="各种断点："><a href="#各种断点：" class="headerlink" title="各种断点："></a>各种断点：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">用户层内存读写监控方式：</span><br><span class="line">(1)硬件断点：DR0-DR3。</span><br><span class="line">(2)INT3断点：0xcc。</span><br><span class="line">(3)页面异常断点：页面可读可执行的修改。</span><br><span class="line">(4)ProcessWorkingSet：微软提供的工作集内存，pagefault的时候拿到这个异常。</span><br><span class="line"></span><br><span class="line">内核层内存读写监控方式：</span><br><span class="line">(1)VT EPT断点监控（CE）。VT EPT 断点监控利用了硬件的扩展页表功能。简单来说，EPT 是一种在虚拟化环境中使用的页表，它负责将虚拟机内部的虚拟地址映射到物理地址。VT EPT 断点监控的原理如下：</span><br><span class="line">	1. 设置断点：当需要在虚拟机内的某个地址设置断点时，监控程序（如调试器）会修改虚拟机的 EPT 表，将目标地址所在的页面标记为只读（Read-Only），或者将其映射到一个特殊的页面，该页面用于捕获断点触发时的事件。</span><br><span class="line">	2. 执行监控：当虚拟机执行到被设置断点的地址时，由于该地址所在页面被标记为只读或者映射到特殊页面，虚拟机会触发一个 EPT 违规（EPT Violation）。这个违规会导致虚拟机陷入到虚拟机监控程序（VMM）中。</span><br><span class="line">	3. 处理违规：VMM 接管虚拟机的执行，根据触发违规的地址和其他上下文信息，确定是否是断点触发，并进行相应的处理。处理可能包括暂停虚拟机执行、触发断点事件、收集相关信息等。</span><br></pre></td></tr></table></figure>
<h4 id="客户端安全开发基础-移动端"><a href="#客户端安全开发基础-移动端" class="headerlink" title="客户端安全开发基础-移动端"></a>客户端安全开发基础-移动端</h4><h4 id="客户端逆向分析基础-PC端"><a href="#客户端逆向分析基础-PC端" class="headerlink" title="客户端逆向分析基础-PC端"></a>客户端逆向分析基础-PC端</h4><p>unity 游戏很容易使用 dnspy 看源码。而且 UE 与 unity 都有反射机制，使程序能在运行时查询对象的名称、类型、包含的方法、方法参数等等。</p>
<ul>
<li>找游戏目标代码。<ul>
<li>根据内存变化定位目标代码截获游戏日志；</li>
<li>分析日志找到目标代码；</li>
<li>拦截系统API，推测软件行为，找到目标代码；</li>
<li>基于对游戏引擎的分析找到目标代码；</li>
</ul>
</li>
</ul>
<p>reclass 看内存数据结构，分析游戏可能的结构体。</p>
<h4 id="客户端逆向分析基础-移动端"><a href="#客户端逆向分析基础-移动端" class="headerlink" title="客户端逆向分析基础-移动端"></a>客户端逆向分析基础-移动端</h4><h4 id="外挂实例细节剖析-PC端"><a href="#外挂实例细节剖析-PC端" class="headerlink" title="外挂实例细节剖析-PC端"></a>外挂实例细节剖析-PC端</h4><p>Unity有：糖豆人、元神（引擎基础加固）、永劫无间（IL2CPP 的 metadata 进行保护）、锁区（固定区域）。</p>
<p>Unity 使用 C#（反射，内存自动管理，有严重的信息泄露风险），UE4 使用 C++。</p>
<p><img src="/images/intern-ms-prepare/image-20240417141725054.png" alt="image-20240417141725054" style="zoom:67%;" /></p>
<p><img src="/images/intern-ms-prepare/image-20240417141826727.png" alt="image-20240417141826727" style="zoom:67%;" /></p>
<p><img src="/images/intern-ms-prepare/image-20240417141904267.png" alt="image-20240417141904267" style="zoom:67%;" /></p>
<p><img src="/images/intern-ms-prepare/image-20240417141933452.png" alt="image-20240417141933452" style="zoom:67%;" /></p>
<h5 id="Unity-的安全风险"><a href="#Unity-的安全风险" class="headerlink" title="Unity 的安全风险"></a>Unity 的安全风险</h5><h6 id="静态风险"><a href="#静态风险" class="headerlink" title="静态风险"></a>静态风险</h6><p><img src="/images/intern-ms-prepare/image-20240417142119546.png" alt="image-20240417142119546" style="zoom:67%;" /></p>
<p>符号泄露（IL2CPP）：IL2CPPdumper，获得符号信息，包括类名、方法名。</p>
<p>反编译攻击（Mono）：dnspy。</p>
<p>保护方法：符号加密、opcode乱序、metadata加密、方法加密、il加密。</p>
<h6 id="动态引擎风险"><a href="#动态引擎风险" class="headerlink" title="动态引擎风险"></a>动态引擎风险</h6><p><img src="/images/intern-ms-prepare/image-20240417142357569.png" alt="image-20240417142357569" style="zoom:67%;" /></p>
<p>引擎 API 调用：C#特性，可以使用 CE 可获得类名、方法名、方法地址等（assembly-sharp）。</p>
<p>程序集注入（Mono）：获取 mono 导出接口，注入程序集（针对 mono虚拟机）（sharpMonoInjector）。</p>
<p>保护方法：不让调用 mono api，即使注入了也能发现。</p>
<h6 id="其它风险"><a href="#其它风险" class="headerlink" title="其它风险"></a>其它风险</h6><p><img src="/images/intern-ms-prepare/image-20240417142954791.png" alt="image-20240417142954791" style="zoom:67%;" /></p>
<p>虚拟机逻辑攻击：c# 调用到 c++ 的代码，相互调用的机制（mono_add_internal_call）被hook的话就可以整。</p>
<h5 id="Unity-游戏基础"><a href="#Unity-游戏基础" class="headerlink" title="Unity 游戏基础"></a>Unity 游戏基础</h5><p><img src="/images/intern-ms-prepare/image-20240417143545268.png" alt="image-20240417143545268" style="zoom:67%;" /></p>
<p>GameObject 至少有 transform 这个组件（component），代表坐标。</p>
<p><img src="/images/intern-ms-prepare/image-20240417143555994.png" alt="image-20240417143555994" style="zoom:67%;" /></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">弹跳球：</span><br><span class="line">1. 球状网格碰撞（sphere mesh）的gameobject。</span><br><span class="line">2. 刚体（rigidbody component），有重力，摩擦力等。</span><br><span class="line">3. collider component有弹性的物理特性（collider component）。</span><br></pre></td></tr></table></figure>
<p>Unity 类：</p>
<p><img src="/images/intern-ms-prepare/image-20240417143929115.png" alt="image-20240417143929115" style="zoom:67%;" /></p>
<p>unity tag 标签表示属于什么类型。Layer 通常被摄像机用来渲染部分场景，它们也可以用来做射线检测时忽略一些collision使用（穿墙）。</p>
<p>工具：UnityExplorer。</p>
<p><img src="/images/intern-ms-prepare/image-20240417144528027.png" alt="image-20240417144528027" style="zoom:67%;" /></p>
<h5 id="Unity-mono-外挂实战"><a href="#Unity-mono-外挂实战" class="headerlink" title="Unity mono 外挂实战"></a>Unity mono 外挂实战</h5><p><img src="/images/intern-ms-prepare/image-20240417144658559.png" alt="image-20240417144658559" style="zoom:67%;" /></p>
<p>从程序集与 native code 两方面来写外挂。</p>
<p>native code 用 CE 就行，函数调用就是创建一个函数，例如创建快捷键。</p>
<p>程序集就是改 C# 代码，类似于程序集注入，挂一个 component。</p>
<h4 id="游戏破解分析实例-移动篇"><a href="#游戏破解分析实例-移动篇" class="headerlink" title="游戏破解分析实例-移动篇"></a>游戏破解分析实例-移动篇</h4><h4 id="外挂防御与检测基础"><a href="#外挂防御与检测基础" class="headerlink" title="外挂防御与检测基础"></a>外挂防御与检测基础</h4><h5 id="常规攻击方式"><a href="#常规攻击方式" class="headerlink" title="常规攻击方式"></a>常规攻击方式</h5><p><img src="/images/intern-ms-prepare/image-20240417145640274.png" alt="image-20240417145640274" style="zoom:67%;" /></p>
<h6 id="攻击资源文件"><a href="#攻击资源文件" class="headerlink" title="攻击资源文件"></a>攻击资源文件</h6><p>修改 CFM 的美化透视实现透视。</p>
<h6 id="攻击游戏引擎"><a href="#攻击游戏引擎" class="headerlink" title="攻击游戏引擎"></a>攻击游戏引擎</h6><p>UE的方框透视。</p>
<p><img src="/images/intern-ms-prepare/image-20240417153822914.png" alt="image-20240417153822914" style="zoom:67%;" /></p>
<p>使用 ULevel::Actors 或 Ulevel::ActorForGC 获取玩家坐标。或者是遍历 ActorChannel 的 tmap。</p>
<p><img src="/images/intern-ms-prepare/image-20240417154114637.png" alt="image-20240417154114637" style="zoom:67%;" /></p>
<p>对于自瞄而言，需要关注 APlayerController::AddPitchinput，偏航角俯仰角。</p>
<h5 id="PC：基于门槛与痕迹的检测防御"><a href="#PC：基于门槛与痕迹的检测防御" class="headerlink" title="PC：基于门槛与痕迹的检测防御"></a>PC：基于门槛与痕迹的检测防御</h5><h6 id="进入门槛"><a href="#进入门槛" class="headerlink" title="进入门槛"></a>进入门槛</h6><p>反注入、反hook、反调试。用到一些系统 API，拦截这些 API 的调用。以 OpenProcess api 为例：</p>
<p><img src="/images/intern-ms-prepare/image-20240417154656019.png" alt="image-20240417154656019" style="zoom:67%;" /></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OpenProcess -&gt; ZwOpenProcess -&gt; NtOpenProcess -&gt; PsOpenProcess</span><br></pre></td></tr></table></figure>
<p>但是 SSDT hook 容易被 ark 工具发现。</p>
<p><img src="/images/intern-ms-prepare/image-20240417154915170.png" alt="image-20240417154915170" style="zoom:67%;" /></p>
<p><img src="/images/intern-ms-prepare/image-20240417155001023.png" alt="image-20240417155001023" style="zoom:67%;" /></p>
<p><img src="/images/intern-ms-prepare/image-20240417155045786.png" alt="image-20240417155045786" style="zoom:67%;" /></p>
<p>那么我们可以 hook 调用 obOpenObjectByPointer。还有其他的 API（反调试）：</p>
<p><img src="/images/intern-ms-prepare/image-20240417155216603.png" alt="image-20240417155216603" style="zoom:67%;" /></p>
<h6 id="进入后的痕迹检测"><a href="#进入后的痕迹检测" class="headerlink" title="进入后的痕迹检测"></a>进入后的痕迹检测</h6><p><img src="/images/intern-ms-prepare/image-20240417155338287.png" alt="image-20240417155338287" style="zoom:67%;" /></p>
<h5 id="移动端：基于门槛与痕迹的检测防御"><a href="#移动端：基于门槛与痕迹的检测防御" class="headerlink" title="移动端：基于门槛与痕迹的检测防御"></a>移动端：基于门槛与痕迹的检测防御</h5><p>移动端 app 只有普通权限，没有 root。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">门槛方案:仅能局限在普通权限下进程空间本身。</span><br><span class="line">痕迹检测:仅能在普通权限下进行一些文件，进程等信息进行检测。</span><br></pre></td></tr></table></figure>
<h6 id="门槛方案"><a href="#门槛方案" class="headerlink" title="门槛方案"></a>门槛方案</h6><p><strong>加固</strong></p>
<p><img src="/images/intern-ms-prepare/image-20240417155926820.png" alt="image-20240417155926820" style="zoom:67%;" /></p>
<p>关键模块自实现不使用 syscall ，而是使用中断。反调试的方法：</p>
<p><img src="/images/intern-ms-prepare/image-20240417160128973.png" alt="image-20240417160128973" style="zoom:67%;" /></p>
<p>端口号23946是否使用？/data/local/tmp 是否有 frida 相关？</p>
<p>调试陷阱：触发异常，关键信息放到信号处理函数（IDA 会截获）（如果没有执行信号处理，则就是反调试状态）。</p>
<p><strong>代码混淆</strong></p>
<p><img src="/images/intern-ms-prepare/image-20240417160414979.png" alt="image-20240417160414979" style="zoom:67%;" /></p>
<h6 id="痕迹检测"><a href="#痕迹检测" class="headerlink" title="痕迹检测"></a>痕迹检测</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">文件读写：</span><br><span class="line">	（1）针对进程自身pid下的各文件，写入文件/so等</span><br><span class="line">	（2）inotify可感知外部进程对指定文件的操作，示例:/proc/pid/mem</span><br><span class="line"></span><br><span class="line">内存遍历：</span><br><span class="line">	（1）内存页属性（可读可写可执行的页）+页名称，/proc/pid/maps</span><br><span class="line">	（2）内存页属性+匿名</span><br><span class="line"></span><br><span class="line">破解版：</span><br><span class="line">	（1）针对透视破解版需创建界面用于绘制透视方框的特点进行检测，截不到界面，悬浮，不响应触摸，是否有叠加层权限？</span><br><span class="line">	（2）alert_window权限</span><br><span class="line">	（3）windowsmanager，遍历所有的 view，是否响应触摸？</span><br></pre></td></tr></table></figure>
<h5 id="基于行为与表现的检测方法"><a href="#基于行为与表现的检测方法" class="headerlink" title="基于行为与表现的检测方法"></a>基于行为与表现的检测方法</h5><h6 id="基于过程"><a href="#基于过程" class="headerlink" title="基于过程"></a>基于过程</h6><p>以透视为例：渲染，人物在前，建筑物在后。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">渲染类透视拆解:</span><br><span class="line">输入:介入游戏的DrawIndexedPrimitive</span><br><span class="line">中间过程:iStread 比较，SetRenderState</span><br><span class="line">输出:人被显示了</span><br><span class="line"></span><br><span class="line">检测方法：</span><br><span class="line">输入:完整性校验(IAT，虚表)，第三方组件(多版本，调用链)</span><br><span class="line">中间过程：(隐蔽性，稳定性）。Callstack检测</span><br><span class="line">输出:截图</span><br><span class="line"></span><br><span class="line">D3D 实现图形渲染，WDDM 是显示驱动程序模型。</span><br></pre></td></tr></table></figure>
<p><img src="/images/intern-ms-prepare/image-20240417161327229.png" alt="image-20240417161327229" style="zoom:67%;" /></p>
<p>以自瞄为例：跨进程读数据，计算下一步秒哪儿（朝向数据变化），然后改游戏属性。</p>
<p><img src="/images/intern-ms-prepare/image-20240417161512553.png" alt="image-20240417161512553" style="zoom:67%;" /></p>
<p>主要 API 就是 controlRotation 与 cameraRotation，在两帧之内是否有异常访问。</p>
<h6 id="基于结果"><a href="#基于结果" class="headerlink" title="基于结果"></a>基于结果</h6><p>服务端录制的，可以验证基于行为的策略的有效性。</p>
<p><img src="/images/intern-ms-prepare/image-20240417161829418.png" alt="image-20240417161829418" style="zoom:67%;" /></p>
<p><img src="/images/intern-ms-prepare/image-20240417162208871.png" alt="image-20240417162208871" style="zoom:80%;" /></p>
<p><img src="/images/intern-ms-prepare/image-20240417162238981.png" alt="image-20240417162238981" style="zoom:67%;" /></p>
<p>难点：</p>
<p>（1）从视频中数据解析与提取。</p>
<p>（2）可见性判定，如何判断用户能否看到对手。</p>
<p><img src="/images/intern-ms-prepare/image-20240417162510582.png" alt="image-20240417162510582" style="zoom:80%;" /></p>
<h3 id="0x01-16-游戏安全大赛题解（2024与2020）"><a href="#0x01-16-游戏安全大赛题解（2024与2020）" class="headerlink" title="0x01-16 游戏安全大赛题解（2024与2020）"></a>0x01-16 游戏安全大赛题解（2024与2020）</h3><p><a target="_blank" rel="noopener" href="https://bbs.kanxue.com/thread-281334.htm">https://bbs.kanxue.com/thread-281334.htm</a></p>
<p><a target="_blank" rel="noopener" href="https://xia0ji233.pro/2024/03/30/tencent-race-2020-pre/">https://xia0ji233.pro/2024/03/30/tencent-race-2020-pre/</a>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             </p>

  
	</div>

	<div>
  	<center>
	<div class="pagination">

    
    
    <a href="/2023/11/03/blog-migrate-test/" type="button" class="btn btn-default"><i
                class="fa fa-arrow-circle-o-left"></i> 上一页</a>
    

    <a href="/" type="button" class="btn btn-default"><i class="fa fa-home"></i>Home</a>
    
    <a href="/2023/10/29/ACTF-2023/" type="button" class="btn btn-default ">下一页<i
                class="fa fa-arrow-circle-o-right"></i></a>
    

    
</div>

    </center>
	</div>


	<!-- comment -->
	
<section id="comment">
    <h2 class="title">留言</h2>

    <!-- 
    <div id="disqus_thread" class="ds-thread">
        <script type="text/javascript">
            /**
             * RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
             * LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
             */
                /*
                 var disqus_config = function () {
                 this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable
                 this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
                 };
                 */
            (function() { // DON'T EDIT BELOW THIS LINE
                var d = document, s = d.createElement('script');

                s.src = 'https://https-wd-2711-tech.disqus.com/embed.js';

                s.setAttribute('data-timestamp', +new Date());
                (d.head || d.body).appendChild(s);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="//disqus.com/?ref_noscript">comments powered by
                Disqus.</a></noscript>
    </div> -->
    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
    <div id="vcomments"></div>
    <script>
        new Valine({
            el: '#vcomments',
            appId: 'wLIJ70s3fPvW8WJPgVVAuWVR-gzGzoHsz',
            appKey: 'NVGqxhUkqtFv2CbwmXXWjCdR'
        })
    </script>

    
</section>


	</div> <!-- col-md-9/col-md-12 -->
		
	
	<div id="side_meta">
		<div class="col-md-3" id="post_meta"> 

	<!-- date -->
	
	<div class="meta-widget">
	<i class="fa fa-clock-o"></i>
	2023-11-03 
	</div>
	

	<!-- categories -->
    

	<!-- tags -->
		

	<!-- toc -->
	<div class="meta-widget">
	
	</div>
	
    <hr>
	
</div><!-- col-md-3 -->

	</div>

	<!-- copyright -->
	<div>
    <ul class="post-copyright">
      <li class="post-copyright-author">
      <strong>作者:  </strong>wd-z711</a>
      </li>
      <li class="post-copyright-link">
      <strong>文章链接:  </strong>
      <a href="/" target="_blank" title="">https://wd-2711.tech/</a>
      </li>
      <li class="post-copyright-license">
        <strong>版权声明:   </strong>
        本博客所有文章除特别声明外，均采用 <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)">CC BY-NC-ND 4.0</a>
        许可协议。转载请注明出处!
      </li>
    </ul>
  <div>
 	

		


</div><!-- row -->




	</div>
  </div>
  <div class="container-narrow">
  <footer> <p>
  &copy; 2025 wd-z711
  
      <!-- with help from <a href="http://hexo.io/" target="_blank">Hexo</a>,<a target="_blank" rel="noopener" href="http://github.com/wzpan/hexo-theme-freemind/">Freemind</a>,<a href="http://getbootstrap.com/" target="_blank">Twitter Bootstrap</a> and <a href="http://getbootstrap.com/" target="_blank">BOOTSTRA.386</a>. 
     <br> Theme by <a target="_blank" rel="noopener" href="http://github.com/wzpan/hexo-theme-freemind/">Freemind.386</a>.     -->

     <!-- <script type="text/javascript">
      (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
      (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
      e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
      })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');
      
      _st('install','aB-vgeB8gEDrnRJuhceL','2.0.0');
    </script> -->
    </p>
 </footer>
</div> <!-- container-narrow -->
  


  
<a id="gotop" href="#">   
  <span>⬆︎TOP</span>
</a>

<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/bootstrap.min.js"></script>
<script src="/js/main.js"></script>
<script src="/js/search.js"></script> 


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>



   <script type="text/javascript">      
     var search_path = "search.xml";
	 if (search_path.length == 0) {
	 	search_path = "search.xml";
	 }
	 var path = "/" + search_path;
     searchFunc(path, 'local-search-input', 'local-search-result');
   </script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
   </html>
