<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="pragma" content="no-cache">
  <meta http-equiv="cache-control" content="no-cache">
  <meta http-equiv="expires" content="0">
  
  <title>smart_contract | wd-z711&#39;s B10g</title>
  <meta name="author" content="wd-z711">
  
  <meta name="description" content="Smart contract study notes of bilibili blogger &#34;Dongfeng Grass Green&#34;.">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="smart_contract"/>
  <meta property="og:site_name" content="wd-z711&#39;s B10g"/>

  
    <meta property="og:image" content=""/>
  

  
  
    <link href="/favicon.png" rel="icon">
  
  
  <link rel="stylesheet" href="/css/bootstrap.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/font-awesome.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/responsive.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/google-fonts.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

  <script src="/js/jquery-2.0.3.min.js"></script>

  <!-- analytics -->
  
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'G-YHJSKZDC3Y', 'auto');
  ga('send', 'pageview');
</script>




<meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="wd-z711's B10g" type="application/atom+xml">
</head>

 <body>  
  <nav id="main-nav" class="navbar navbar-inverse navbar-fixed-top" role="navigation">
    <div class="container">
      <button type="button" class="navbar-header navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
		<span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
	  <a class="navbar-brand" href="/">wd-z711&#39;s B10g</a>
      <div class="collapse navbar-collapse nav-menu">
		<ul class="nav navbar-nav">
		  
		  <li>
			<a href="/archives" title="All the articles.">
			  <i class="fa fa-archive"></i>Archives
			</a>
		  </li>
		  
		  <li>
			<a href="/categories" title="All the categories.">
			  <i class="fa fa-folder"></i>Categories
			</a>
		  </li>
		  
		  <li>
			<a href="/about" title="About me.">
			  <i class="fa fa-user"></i>About
			</a>
		  </li>
		  
		</ul>
      </div>
    </div> <!-- container -->
</nav>
<div class="clearfix"></div>

  <div class="container">
  	<div class="content">
    	 


	
		<div class="page-header">
			<h1> smart_contract</h1>
		</div>
	



<div class="row post">

	<!-- cols -->
	
	<div id="top_meta"></div>
	<div class="col-md-9">
	

	<!-- content -->
	<div class="mypage">		
	  
		 <div class="alert alert-success description">
			<i class="fa fa-info-circle"></i> Smart contract study notes of bilibili blogger "Dongfeng Grass Green".
		 </div> <!-- alert -->
	  		

	  <h1 id="solidity智能合约"><a href="#solidity智能合约" class="headerlink" title="solidity智能合约"></a>solidity智能合约</h1><h2 id="0x00-智能合约入门"><a href="#0x00-智能合约入门" class="headerlink" title="0x00 智能合约入门"></a>0x00 智能合约入门</h2><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><p>​    智能合约的机制：<strong>节点一侧是transaction，一侧是EVM；transaction被确认之后，会触发EVM的执行。</strong></p>
<p><img src="/images/smart-contract/11.png" alt="11"></p>
<p>​    简单的智能合约代码：</p>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity 0.8.12;</span><br><span class="line">contract NumberStore&#123;</span><br><span class="line">	uint public x;</span><br><span class="line">	function setX(uint px) public &#123;</span><br><span class="line">		x = px;</span><br><span class="line">	&#125;</span><br><span class="line">	function getX public view returns(uint) &#123;</span><br><span class="line">		return x;</span><br><span class="line">	&#125;</span><br><span class="line">	function add(uint a, uint b) private pure returns(uint) &#123;</span><br><span class="line">		return a + b;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    <strong>开发环境：</strong>hardhat（合约打包、模拟器、测试框架，可以开发部署完整项目），remix（solidity语言的开发、测试）。</p>
<p>​    <strong>变量可见性：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public # 完全可见</span><br><span class="line">external # 完全可见。与public不同的地方：（1）同一合约的函数调用一个本合约的external函数时，要this关键字来调，这意味着要用call方式执行，要产生新的上下文，耗费资源。</span><br><span class="line">private # 对本合约可见，其他不可见</span><br><span class="line">internal # 对本合约与继承子合约可见，变量默认情况是internal，而函数默认为public</span><br></pre></td></tr></table></figure>
<p>​    以太坊地址为20字节（160位）。地址分为合约地址（指向一个合约）与钱包地址（代表一个account）。</p>
<p>​    <strong>函数的交易属性：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">view # 合约状态读操作，这样的话就没有必要产生一个交易</span><br><span class="line">pure # 既不是读操作也不是写操作，与合约关系不大，只跟输入的参数有关（纯函数）。为什么有pure，是因为有一个信任的关系，比如我们想要计算某个资产，我们更希望交给区块链上的某一个节点来算，而不是自己偷着算。(然而，如果一个pure函数被另一个产生交易的函数内部调用，那么它将花费gas，因为一个交易的gas成本取决于完成它时执行的EVM操作码的数量)</span><br><span class="line">transactional # 默认是这样的，但是没有具体的关键字，代表这个函数背后隐含着一个交易的产生（写操作）</span><br></pre></td></tr></table></figure>
<p>​    <strong>构造函数：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity 0.8.12;</span><br><span class="line">contract NumberStore&#123;</span><br><span class="line">	uint public x;</span><br><span class="line">	// 构造函数</span><br><span class="line">	constructor(uint _x)&#123;</span><br><span class="line">		x = _x;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    <strong>函数修饰器：</strong>定义什么样的实体能够调用什么样的函数（访问控制）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity 0.8.12;</span><br><span class="line">contract NumberStore&#123;</span><br><span class="line">	uint public x;</span><br><span class="line">	constructor(uint _x)&#123;</span><br><span class="line">		x = _x;</span><br><span class="line">	&#125;</span><br><span class="line">	// 修饰器</span><br><span class="line">	modifier notTooLarge(uint _x)&#123;</span><br><span class="line">		require(_x &lt; 10000, &quot;too large&quot;); // 如果_x &gt;= 10000，就会抛出too large异常。</span><br><span class="line">		// 或者这么写</span><br><span class="line">		/*</span><br><span class="line">		if(_x &gt;= 10000)</span><br><span class="line">			revert(&quot;too large&quot;);</span><br><span class="line">		*/</span><br><span class="line">		_; //执行所修饰的函数体</span><br><span class="line">	&#125;</span><br><span class="line">	function setX(uint _x) public notTooLarge(_x)&#123;</span><br><span class="line">		x = _x;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    <strong>log日志：</strong>一旦对区块链进行写操作，就需要将所有的节点状态改变，有必要记录一下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity 0.8.12;</span><br><span class="line">contract NumberStore&#123;</span><br><span class="line">	// log日志定义</span><br><span class="line">	event Xchanged(uint oldv, uint newv);</span><br><span class="line">	uint public x;</span><br><span class="line">	function setX(uint px) public &#123;</span><br><span class="line">		x = px;</span><br><span class="line">		//log日志使用</span><br><span class="line">		emit Xchanged(x, px);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    <strong>数据类型：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type(uint8).min //取数据类型的最小值</span><br></pre></td></tr></table></figure>
<ol>
<li><p>以太坊虚拟机是256位的机器。</p>
</li>
<li><p>低版本以太坊取模，高版本直接抛出异常。举例<code>uint8 x = 255; x++; x --&gt; 0</code>，而高版本直接抛出异常。</p>
</li>
<li>uint是uint256的别名。</li>
<li>可以定义<code>bytes1</code>到<code>bytes32</code>。<code>bytes32 arr; byte b = arr[1];</code>，<code>.length</code>可以定义数组长度。</li>
</ol>
<p>​    <strong>Address（重点）：</strong></p>
<p>​    Address分为合约账号地址与外部账号地址（某个钱包 EOA：external owned account），160位。地址中包括可支付的地址（payable address：可以给这个地址转钱），EOA都是可以payable address，而有的合约账号地址不能收钱。其中可以转账（send），查询余额（balance）。</p>
<p>​    <strong>合约类型：</strong></p>
<p>​    每一个contract都有自己的类型，可以转化为address，例如：<code>MyContract c; address addr = address(c);</code>。可以类比为C++中的类。在区块链上部署的合约可以使用new来创建一个新的合约。</p>
<p>​    <strong>枚举</strong>：可以看作是一个8位整型数，0-255，可以遍历。举例说明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity 0.8.12;</span><br><span class="line"></span><br><span class="line">contract test&#123;</span><br><span class="line">	enum Action&#123;left, right, straight, back&#125;</span><br><span class="line">	Action choice;</span><br><span class="line">	function setChoice(uint x) public&#123;</span><br><span class="line">		choice = Action(x);</span><br><span class="line">	&#125;</span><br><span class="line">	function getChoice() public view returns(uint)&#123;</span><br><span class="line">		return uint(choice);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    <strong>映射mapping（重点）：</strong>键值对<code>(key,value)</code>。<code>key</code>不能是合约、映射，<code>value</code>可以，mapping无法遍历，mapping无法当参数与返回值，也不能在函数体内定义，只能在contract的成员变量存在。声明为public的映射会自动创建一个getter函数，这样的话就像字典一样访问了。举例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity 0.8.12;</span><br><span class="line"></span><br><span class="line">contract test&#123;</span><br><span class="line">	mapping(address =&gt; uint) public balances;</span><br><span class="line">	function update(uint newb) public&#123;</span><br><span class="line">		balances[msg.sender] = newb;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    <strong>函数的上下文变量：</strong>外部账户（个人用户，钱包）调用函数时，函数的背后都对应着交易transaction。内部账户（合约）调用另一个合约函数时，也是用一个类似于transaction的数据结构去调用的，这个结构叫做message。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">msg.sender //函数的调用者，address</span><br><span class="line">msg.data</span><br><span class="line">msg.value // eth，以太币</span><br></pre></td></tr></table></figure>
<p>​    <strong>下面我们写一个合约，管理所有的账户，且不同的账户之间可以互相转钱。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity 0.8.12;</span><br><span class="line"></span><br><span class="line">contract sol&#123;</span><br><span class="line">	mapping(address=&gt;uint) public balance;</span><br><span class="line">	</span><br><span class="line">	constructor(uint x)&#123;</span><br><span class="line">		balance[msg.sender] = x;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	function transfer(address to, uint amount) &#123;</span><br><span class="line">		address from = msg.sender;</span><br><span class="line">		if(balance[from] &lt; amount)&#123;</span><br><span class="line">			revert(&quot;not enough!&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		balance[to] += amount;</span><br><span class="line">		balance[from] -= amount;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    <strong>智能合约如何与前端交互：</strong>web3j。web3j是一个开源Java库，旨在为以太坊开发人员提供一个简单的、类型安全的接口。它抽象出了与以太坊区块链交互的底层细节，并且使用简单的Java对象，提供了对智能合约的编程接口。</p>
<p>​    <strong>Metamask是一个浏览器以太坊钱包，它的运行机制如下：</strong></p>
<ol>
<li>安装：MetaMask 作为浏览器扩展安装在 Chrome上。用户创建一个新钱包并设置密码来加密和保护他们的私钥。</li>
<li>私钥管理：MetaMask 生成一个私钥，存储在用户浏览器本地。私钥用于签署交易，用户对其拥有完全控制权，允许他们访问自己的资金并与 dApp 进行交互。</li>
<li>与 dApp 交互：安装 MetaMask 后，用户可以访问任何构建在以太坊区块链上的 dApp 并与之交互。dApp 将向 MetaMask 发送请求以访问用户的以太坊帐户并代表他们签署交易。</li>
<li>交易签名：当 dApp 想要执行交易时，它会将详细信息发送给 MetaMask，然后 MetaMask 会提示用户审核并批准交易。用户可以选择签署或拒绝交易，如果批准，MetaMask 使用私钥签署交易。</li>
<li>广播交易：交易签署后，MetaMask 将其发送到以太坊网络进行处理。然后网络将交易添加到一个区块中，它成为永久以太坊区块链分类账的一部分。</li>
</ol>
<p>​    总之，MetaMask 充当用户和以太坊区块链之间的桥梁，允许用户与 dApp 交互并安全地管理他们的私钥和资金。</p>
<p>​    <strong>dApp是什么？</strong></p>
<p>​    去中心化应用程序 (dApp) 是在去中心化网络（例如区块链）上运行的软件应用程序，而不是单个集中式服务器。dApps 被设计成自治的，这意味着它们可以在没有任何中央权威或中介的情况下运行。</p>
<p>​    dApp 通常由前端用户界面和后端区块链网络组成，并根据智能合约中编码的规则运行。dApp 的关键特征是其底层代码和数据存储在去中心化网络中，每个人都可以访问，从而提供透明度和不变性。</p>
<p>​    dApp 可用于多种用途，例如数字钱包、交易所、市场、预测市场等。dApp 的去中心化特性确保它们是安全的、无需信任的和防篡改的，使其成为需要高度安全性和透明度的用例的理想选择。</p>
<p>​    <strong>一些基于以太坊区块链构建的流行 dApp 包括 CryptoKitties、Uniswap 和 MakerDAO</strong>。</p>
<p>Time：2023-02-10</p>
<hr>
<h3 id="通过web3j如何访问智能合约？"><a href="#通过web3j如何访问智能合约？" class="headerlink" title="通过web3j如何访问智能合约？"></a>通过web3j如何访问智能合约？</h3><p>​    <strong>补充：</strong></p>
<ol>
<li>hfs.exe是将html文件以http的方式展现给我们的一个文件服务器。</li>
<li>external关键字：<code>external</code> 关键字在 Solidity 中用于声明一个外部函数，这意味着该<strong>函数可以从外部调用，但不能在合约内部调用</strong>。外部函数在以太坊网络上充当接口，允许其他合约或外部实体与该合约进行通信。外部函数的签名与参数类型必须完全匹配，否则将无法调用该函数。该关键字的一个常见用法是定义与其他合约的接口，以允许在合约之间进行通信。<strong>例如，一个合约可以声明一个外部函数，然后其他合约可以调用该函数，以执行某些功能。</strong></li>
<li><code>web3.eth.getCoinbase()</code>是一个Web3.js函数，它返回当前Ethereum节点的默认挖矿地址，也称为“Coinbase”地址。这个<strong>地址是用来接收新挖出的以太坊块中的以太币奖励的。</strong>如果你在运行自己的节点，并且已经开始了挖矿，那么你可以使用这个函数来确定你的Coinbase地址。</li>
</ol>
<p>​    一个智能合约<code>owner.sol</code>如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: GPL-3.0</span><br><span class="line"></span><br><span class="line">pragma solidity &gt;=0.7.0 &lt;0.9.0;</span><br><span class="line"></span><br><span class="line">import &quot;hardhat/console.sol&quot;; // 先不管</span><br><span class="line"></span><br><span class="line">contract Owner &#123;</span><br><span class="line"></span><br><span class="line">    address private owner;</span><br><span class="line"></span><br><span class="line">    // owner发生变化的时候的event</span><br><span class="line">    event OwnerSet(address indexed oldOwner, address indexed newOwner);</span><br><span class="line"></span><br><span class="line">    // 修饰器，查看调用者是否是owner</span><br><span class="line">    modifier isOwner() &#123;</span><br><span class="line">        require(msg.sender == owner, &quot;Caller is not owner&quot;);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	// 构造函数，第一次部署这个合约的时候，owner=msg.sender</span><br><span class="line">    constructor() &#123;</span><br><span class="line">        console.log(&quot;Owner contract deployed by:&quot;, msg.sender);</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">        emit OwnerSet(address(0), owner); // event 日志</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	// 只有合约的所有者才能changeOwner</span><br><span class="line">    function changeOwner(address newOwner) public isOwner &#123;</span><br><span class="line">        emit OwnerSet(owner, newOwner);</span><br><span class="line">        owner = newOwner;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	// external先不用管，view代表读操作</span><br><span class="line">    function getOwner() external view returns (address) &#123;</span><br><span class="line">        return owner;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>​    编译完成后，在Owner_metadata.json中，会找到abi（application binary interface：应用二进制接口）的相关信息，<strong>这是web3j调用合约的接口描述</strong>，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">&quot;abi&quot;: [</span><br><span class="line">		&#123;</span><br><span class="line">            &quot;inputs&quot;: [],</span><br><span class="line">            &quot;stateMutability&quot;: &quot;nonpayable&quot;,</span><br><span class="line">            &quot;type&quot;: &quot;constructor&quot;</span><br><span class="line">		&#125;,</span><br><span class="line">         &#123;</span><br><span class="line">            &quot;anonymous&quot;: false,</span><br><span class="line">            &quot;inputs&quot;: [</span><br><span class="line">            	&#123;</span><br><span class="line">                    &quot;indexed&quot;: true,</span><br><span class="line">                    &quot;internalType&quot;: &quot;address&quot;,</span><br><span class="line">                    &quot;name&quot;: &quot;oldOwner&quot;,</span><br><span class="line">                    &quot;type&quot;: &quot;address&quot;</span><br><span class="line">                 &#125;,</span><br><span class="line">                 &#123;</span><br><span class="line">                    &quot;indexed&quot;: true,</span><br><span class="line">                    &quot;internalType&quot;: &quot;address&quot;,</span><br><span class="line">                    &quot;name&quot;: &quot;newOwner&quot;,</span><br><span class="line">                    &quot;type&quot;: &quot;address&quot;</span><br><span class="line">                  &#125;</span><br><span class="line">            ],</span><br><span class="line">            &quot;name&quot;: &quot;OwnerSet&quot;,</span><br><span class="line">            &quot;type&quot;: &quot;event&quot;</span><br><span class="line">         &#125;,</span><br><span class="line">         &#123;</span><br><span class="line">             &quot;inputs&quot;: [</span><br><span class="line">                 &#123;</span><br><span class="line">                     &quot;internalType&quot;: &quot;address&quot;,</span><br><span class="line">                     &quot;name&quot;: &quot;newOwner&quot;,</span><br><span class="line">                     &quot;type&quot;: &quot;address&quot;</span><br><span class="line">                 &#125;</span><br><span class="line">             ],</span><br><span class="line">             &quot;name&quot;: &quot;changeOwner&quot;,</span><br><span class="line">             &quot;outputs&quot;: [],</span><br><span class="line">             &quot;stateMutability&quot;: &quot;nonpayable&quot;,</span><br><span class="line">             &quot;type&quot;: &quot;function&quot;</span><br><span class="line">         &#125;,</span><br><span class="line">         &#123;</span><br><span class="line">             &quot;inputs&quot;: [],</span><br><span class="line">             &quot;name&quot;: &quot;getOwner&quot;,</span><br><span class="line">             &quot;outputs&quot;: [</span><br><span class="line">                 &#123;</span><br><span class="line">                     &quot;internalType&quot;: &quot;address&quot;,</span><br><span class="line">                     &quot;name&quot;: &quot;&quot;,</span><br><span class="line">                     &quot;type&quot;: &quot;address&quot;</span><br><span class="line">                 &#125;</span><br><span class="line">         	],</span><br><span class="line">             &quot;stateMutability&quot;: &quot;view&quot;,</span><br><span class="line">             &quot;type&quot;: &quot;function&quot;</span><br><span class="line">         &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>​    将其放到owner.js中，最后进行试验，详见：</p>
<p>​    <a target="_blank" rel="noopener" href="https://github.com/WD-2711/smart_contract_files/tree/main/web3j%E8%AE%BF%E9%97%AE">https://github.com/WD-2711/smart_contract_files/tree/main/web3j%E8%AE%BF%E9%97%AE</a></p>
<h2 id="0x01-智能合约基础"><a href="#0x01-智能合约基础" class="headerlink" title="0x01 智能合约基础"></a>0x01 智能合约基础</h2><p>​    <strong>补充：</strong></p>
<ol>
<li>ERC20：最基础的智能合约规范。</li>
<li>ICO（Initial Coin Offering）是一种融资方式，用于吸引投资者投资区块链项目，或将传统证券转换为加密货币。在ICO中，项目团队发行新的加密货币，并将其作为对项目的投资回报。投资者通过投资以太坊或比特币等已有加密货币，来获得新发行的加密货币。</li>
<li>智能合约管理利益<strong>各方</strong>的利益关系。</li>
</ol>
<h3 id="合约是如何部署到区块链上的？"><a href="#合约是如何部署到区块链上的？" class="headerlink" title="合约是如何部署到区块链上的？"></a>合约是如何部署到区块链上的？</h3><p>​    区块链上的合约通常使用智能合约语言编写，如 Solidity（用于以太坊）、Chaincode（用于Hyperledger Fabric）等。为了部署合约到区块链上，你需要执行以下步骤：</p>
<ol>
<li>编写智能合约代码：使用智能合约语言编写代码，确保它符合区块链平台的规则。</li>
<li>编译代码：使用合适的编译器将智能合约代码编译成能在区块链上运行的代码。</li>
<li>部署合约：使用适当的工具（如 Remix）或命令行界面将合约部署到区块链。</li>
<li>等待确认：等待合约部署交易在区块链上得到确认。</li>
<li>调用合约：通过客户端或DApp（去中心化应用程序）调用合约并执行相应的操作。</li>
</ol>
<p>​    注意：部署合约需要支付费用，因为区块链网络上的节点需要执行合约代码。费用通常以加密货币（如以太币）的形式支付。</p>
<h3 id="智能合约部署到区块链上的底层原理是什么？"><a href="#智能合约部署到区块链上的底层原理是什么？" class="headerlink" title="智能合约部署到区块链上的底层原理是什么？"></a>智能合约部署到区块链上的底层原理是什么？</h3><p>​    智能合约部署到区块链上的底层原理包括以下步骤：</p>
<ol>
<li>创建交易：将智能合约代码打包创建一笔交易，该交易将在区块链上的节点中被执行。</li>
<li>签名交易：使用密钥对交易进行签名，以验证交易的发送者身份。</li>
<li>广播交易：将签名后的交易广播到区块链网络的其他节点上。</li>
<li>执行交易：所有节点对该交易进行验证，如果验证通过，则该交易将在区块链上的虚拟机（如Ethereum虚拟机）上执行。</li>
<li>存储合约：在交易被执行后，智能合约代码将被存储在区块链上。</li>
<li>调用合约：任何人都可以通过发送交易来调用该合约，以执行合约中定义的操作。</li>
</ol>
<p>​    总体来说，智能合约部署到区块链上的原理是通过创建一笔交易，将智能合约代码打包到该交易中，并通过区块链上的节点对该交易进行验证和执行，从而将智能合约代码存储到区块链上并可供任何人调用。</p>
<h3 id="如何将智能合约代码打包成一笔交易？"><a href="#如何将智能合约代码打包成一笔交易？" class="headerlink" title="如何将智能合约代码打包成一笔交易？"></a>如何将智能合约代码打包成一笔交易？</h3><p>​    将智能合约代码打包成一笔交易需要使用一个特定的数据结构，这通常被称为交易的输入数据。这个数据结构通常包含以下几个部分：</p>
<ol>
<li>合约代码：该代码将被执行，并存储在区块链上。</li>
<li>调用数据：指定该交易如何调用智能合约。</li>
<li>费用：指定用于执行该交易的代币数量。</li>
<li>签名：证明交易发送者是否拥有指定的代币数量，并同意用这些代币支付交易的费用。</li>
</ol>
<p>​    在部署智能合约时，通常会指定一些特定的调用数据，如调用合约的初始化方法，以创建智能合约。</p>
<p>​    最后，打包成的交易可以在区块链网络上广播，以便在整个网络中的节点都可以对其进行验证并执行。</p>
<h3 id="交易是如何在区块链上的虚拟机上执行的？"><a href="#交易是如何在区块链上的虚拟机上执行的？" class="headerlink" title="交易是如何在区块链上的虚拟机上执行的？"></a>交易是如何在区块链上的虚拟机上执行的？</h3><p>​    在区块链上，每个节点都运行着一个虚拟机，该虚拟机用于执行智能合约代码和交易。当一笔交易被广播到区块链网络上时，每个节点都会对其进行验证，以确保交易的费用足够支付执行代码的成本，并且交易签名是有效的。</p>
<p>​    如果交易被验证，虚拟机将按照交易的调用数据执行合约代码。在执行过程中，虚拟机可能会对区块链的状态进行更改，例如，更新智能合约的内部状态，在资产账户之间转移代币，或创建新的智能合约。</p>
<p>​    在执行完成后，虚拟机将生成一个执行报告，该报告描述了交易的执行结果。如果交易执行成功，执行报告将被添加到区块链的下一个区块中，并且将在整个网络中永久存储。如果交易执行失败，执行报告将不会被添加到区块链中，并且交易将被视为无效。</p>
<h3 id="tether-USD是什么？"><a href="#tether-USD是什么？" class="headerlink" title="tether USD是什么？"></a>tether USD是什么？</h3><p>​    Tether USD (USDT)是一种以美元为基础资产的代币，是一种加密数字资产。它是由Tether公司开发和管理的，旨在模拟美元，并且其价值与美元兑换率相同。Tether USD的目的是提供一种可靠的数字资产，其价值相对稳定，并且可以与美元相互转换。</p>
<p>​    给定一个合约NumberStorage.sol：</p>
<blockquote id="fn_1">
<sup>1</sup>. NumberStorage.sol代码<a href="#reffn_1" title="Jump back to footnote [1] in the text."> &#8617;</a>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// SPDX-License-Identifier: NONE</span><br><span class="line"></span><br><span class="line">pragma solidity 0.8.12;</span><br><span class="line"></span><br><span class="line">contract NumberStorage&#123;</span><br><span class="line">	// 下列是ERC20规范所要求的属性（name, symbol, decimal, balanceOf）</span><br><span class="line">	string public name = &quot;xcl&quot;;</span><br><span class="line">	string public symbol = &quot;$&quot;;</span><br><span class="line">	uint public decimal =  4; // 基本货币单位，例如balance=20000，那么在metamask中就显示2$</span><br><span class="line">	mapping(address=&gt;uint) public balanceOf; // 定义余额</span><br><span class="line">	</span><br><span class="line">	// 构造函数，在其中铸币（mint），这些部分可以根据需求来自己写，分发给哪些人？</span><br><span class="line">	constructor(uint x)&#123;</span><br><span class="line">		balanceOf[msg.sender] = x;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	// 转账事件</span><br><span class="line">    event TransferEvent(uint oldv, uint newv);</span><br><span class="line">	</span><br><span class="line">	// 修饰器</span><br><span class="line">	modifier notTooLarge(uint _x)&#123;</span><br><span class="line">		require(_x &lt; 10000, &quot;too large&quot;);</span><br><span class="line">		_;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	// 转账函数，一般是固定的</span><br><span class="line">	function transfer(address to, uint amount) public &#123;</span><br><span class="line">		address from = msg.sender;</span><br><span class="line">		if(balanceOf[from] &lt; amount)&#123;</span><br><span class="line">			revert(&quot;not enough!&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		balanceOf[to] += amount;</span><br><span class="line">		balanceOf[from] -= amount;</span><br><span class="line">	&#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    在remix上部署，并在metamask上添加资产，最终得到：</p>
<p><img src="/images/smart-contract/image-20230211123159722.png" alt="image-20230211123159722" style="zoom:80%;" /></p>
<p>​    非常简陋，相当于2017年的时候的ICO。</p>
<h3 id="一般合约间的函数调用"><a href="#一般合约间的函数调用" class="headerlink" title="一般合约间的函数调用"></a>一般合约间的函数调用</h3><ol>
<li>如果被调用合约在另外一个源文件中，可以通过 import 引入其他合约的函数。</li>
<li>调用者必须持有被调用合约的地址。</li>
<li>利用地址重载被调用的合约，并调用此合约的函数。</li>
</ol>
<p>​    举例说明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// Callee.sol</span><br><span class="line">// SPDX-License-Identifier: NONE</span><br><span class="line"></span><br><span class="line">pragma solidity 0.8.12;</span><br><span class="line"></span><br><span class="line">contract Callee&#123;</span><br><span class="line">	uint public x;</span><br><span class="line">	function setX(uint _x) external &#123;</span><br><span class="line">		x = _x;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// Caller.sol</span><br><span class="line">// SPDX-License-Identifier: NONE</span><br><span class="line"></span><br><span class="line">pragma solidity 0.8.12;</span><br><span class="line"></span><br><span class="line">import &quot;./Callee.sol&quot;;</span><br><span class="line">contract Caller&#123;</span><br><span class="line">	address public calleeAddr;</span><br><span class="line">	constructor(address ca)&#123;</span><br><span class="line">		calleeAddr = ca;</span><br><span class="line">	&#125;</span><br><span class="line">	function setCalleeX(uint _x) external&#123;</span><br><span class="line">		Callee callee = Callee(calleeAddr); // 调用了callee.sol中的setX函数</span><br><span class="line">		callee.setX(_x);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="利用接口的函数调用（重点）"><a href="#利用接口的函数调用（重点）" class="headerlink" title="利用接口的函数调用（重点）"></a>利用接口的函数调用（重点）</h3><ol>
<li>调用者有被调用合约的地址。</li>
<li>调用者自己定义一个接口，其中函数的signature（函数的定义部分）与被调用合约的相应函数一致（不用import）。</li>
<li>将合约地址重载为自己定义的接口，并调用其函数。</li>
</ol>
<p>​    举例说明，callee.sol与之前一致，不再重复。重点是Caller.sol，<strong>其实感觉挺离谱的，重点应该是external，还有就是传递的合约地址</strong>，这样就可以解耦。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// Caller.sol</span><br><span class="line">// SPDX-License-Identifier: NONE</span><br><span class="line"></span><br><span class="line">pragma solidity 0.8.12;</span><br><span class="line"></span><br><span class="line">interface MyCallee&#123;</span><br><span class="line">	function setX(uint _x) external; // 只需要setX函数的定义即可，不需要callee其他的函数。</span><br><span class="line">	// 需要注意的是，首先先部署callee.sol，之后我们就可以直接将callee.sol的代码删除，之后再部署caller.sol。</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Caller&#123;</span><br><span class="line">	address public calleeAddr;</span><br><span class="line">	constructor(address ca)&#123;</span><br><span class="line">		calleeAddr = ca;</span><br><span class="line">	&#125;</span><br><span class="line">	function setCalleeX(uint _x) external&#123;</span><br><span class="line">		MyCallee callee = MyCallee(calleeAddr);</span><br><span class="line">		callee.setX(_x);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="如何调用tether-goerli的源码来写我们的合约"><a href="#如何调用tether-goerli的源码来写我们的合约" class="headerlink" title="如何调用tether goerli的源码来写我们的合约"></a>如何调用tether goerli的源码来写我们的合约</h3><p>​    首先复制合约地址（<a target="_blank" rel="noopener" href="https://goerli.etherscan.io/token/0x509ee0d083ddf8ac028f2a56731412edd63223b9）。">https://goerli.etherscan.io/token/0x509ee0d083ddf8ac028f2a56731412edd63223b9）。</a></p>
<p>​    之后写如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// call_tether.sol</span><br><span class="line">// SPDX-License-Identifier: NONE</span><br><span class="line">// 复制的合约地址：0x509Ee0d083DdF8AC028f2a56731412edD63223B9</span><br><span class="line">pragma solidity 0.8.12;</span><br><span class="line">interface MyTether&#123;</span><br><span class="line">	function name() external view returns(string memory);</span><br><span class="line">	function symbol() external view returns(string memory);</span><br><span class="line">	function decimals() external view returns(uint);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/smart-contract/image-20230211174620111.png" alt="image-20230211174620111" style="zoom:67%;" /></p>
<p>​    重载之后，可以发现：</p>
<p><img src="/images/smart-contract/image-20230211175212792.png" alt="image-20230211175212792" style="zoom:67%;" /></p>
<p>​    再来写一段代码，这是自己部署了一个合约来查询tether goerli的名字。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// call_tether.sol</span><br><span class="line">// SPDX-License-Identifier: NONE</span><br><span class="line">// 复制的合约地址：0x509Ee0d083DdF8AC028f2a56731412edD63223B9</span><br><span class="line">pragma solidity 0.8.12;</span><br><span class="line">interface MyTether&#123;</span><br><span class="line">	function name() external view returns(string memory);</span><br><span class="line">	function symbol() external view returns(string memory);</span><br><span class="line">	function decimals() external view returns(uint);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract MyContract&#123;</span><br><span class="line">	address public addr;</span><br><span class="line">	constructor(address a)&#123;</span><br><span class="line">		addr = a;</span><br><span class="line">	&#125;</span><br><span class="line">	function getTetherName() external view returns(string memory)&#123;</span><br><span class="line">		MyTether th = MyTether(addr);</span><br><span class="line">		return th.name();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="函数调用时的上下文变量（智能合约基本原理）"><a href="#函数调用时的上下文变量（智能合约基本原理）" class="headerlink" title="函数调用时的上下文变量（智能合约基本原理）"></a>函数调用时的上下文变量（智能合约基本原理）</h3><p><img src="/images/smart-contract/3.png" alt="3"></p>
<p>​    上述图不做多说，心里要理解。<strong>可能总结的不太对，不对的话后面再说。</strong>代码举例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// call_chain.sol</span><br><span class="line">// SPDX-License-Identifier: NONE</span><br><span class="line">pragma solidity 0.8.12;</span><br><span class="line"></span><br><span class="line">contract A&#123;</span><br><span class="line">	function a1() public view returns(address)&#123;</span><br><span class="line">		return a2();</span><br><span class="line">	&#125;</span><br><span class="line">	function a2() public view returns(address)&#123;</span><br><span class="line">		return msg.sender;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/smart-contract/image-20230211184746514.png" alt="image-20230211184746514" style="zoom:67%;" /></p>
<p>​    这对应<code>EOA---a1()---a2()</code>部分，由结果可以看出，a1()与a2()对应的是一种message。</p>
<p>​    再来看如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// call_chain_A.sol</span><br><span class="line">// SPDX-License-Identifier: NONE</span><br><span class="line">pragma solidity 0.8.12;</span><br><span class="line"></span><br><span class="line">interface B_reload&#123;</span><br><span class="line">	function b1() external view returns(address);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract A&#123;</span><br><span class="line">	address public addr;</span><br><span class="line">	constructor(address a)&#123;</span><br><span class="line">		addr = a;</span><br><span class="line">	&#125;</span><br><span class="line">	function a1() public view returns(address)&#123;</span><br><span class="line">		B_reload re = B_reload(addr);</span><br><span class="line">		return re.b1();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// call_chain_B.sol</span><br><span class="line">// SPDX-License-Identifier: NONE</span><br><span class="line">pragma solidity 0.8.12;</span><br><span class="line"></span><br><span class="line">contract B&#123;</span><br><span class="line">	function b1() external view returns(address)&#123;</span><br><span class="line">		return msg.sender;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    先部署call_chain_B.sol，再部署call_chain_A.sol。结果如下：</p>
<p><img src="/images/smart-contract/image-20230211195317325.png" alt="image-20230211195317325" style="zoom:67%;" /></p>
<p>​    这对应着<code>EOA---a1---b1</code>的环节。</p>
<h3 id="合约函数的动态调用方法（Call）"><a href="#合约函数的动态调用方法（Call）" class="headerlink" title="合约函数的动态调用方法（Call）"></a>合约函数的动态调用方法（Call）</h3><p>​    之前无论是 import 还是接口重载调用，都是静态调用。</p>
<p>​    静态调用是<strong>在编译时预先确定的调用，不会改变合约状态</strong>。因为它们不修改合约状态，所以<strong>静态调用可以在不需要任何费用的情况下执行</strong>。动态调用是<strong>在运行时确定的调用，可以改变合约状态</strong>。<strong>动态调用需要消耗gas，</strong>因为它们需要在区块链上进行状态更改。在 Solidity 中，使用关键字 “view” 来声明静态调用，而动态调用则不需要声明。</p>
<p>​    下面是一个静态调用示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">contract A &#123;</span><br><span class="line">  function multiply(uint x, uint y) public view returns (uint) &#123;</span><br><span class="line">    return x * y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract B &#123;</span><br><span class="line">  function callMultiply(address _addressA) public returns (uint) &#123;</span><br><span class="line">    A a = A(_addressA);</span><br><span class="line">    uint result = a.multiply(2, 3);</span><br><span class="line">    return result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    在合约 B 中，我们通过调用合约 A 的 multiply 函数进行静态调用。因为 multiply 函数是用 view 关键字声明的，所以它是一个静态调用。</p>
<p>​    再给一个动态调用的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">contract A &#123;</span><br><span class="line">  uint public value;</span><br><span class="line">  function setValue(uint _value) public &#123;</span><br><span class="line">    value = _value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract B &#123;</span><br><span class="line">  function callSetValue(address _addressA, uint _value) public &#123;</span><br><span class="line">    A a = A(_addressA);</span><br><span class="line">    a.setValue(_value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    在合约 B 中，我们通过调用合约 A 的 setValue 函数进行动态调用。由于该函数改变了合约 A 的状态，因此它是一个动态调用。在执行此调用时，需要消耗 gas，因为区块链上的状态需要更改。</p>
<p>Time：2023-02-11</p>
<hr>
<p>​    <strong>call的调用格式：</strong><code>&lt;address&gt;.call(calldata)</code>，<strong>call是address的方法，返回值为<code>(bool success, bytes data)</code>。</strong></p>
<p>​    <strong>calldata的结构：</strong>calldata的前四个字节指向合约的哪个函数，也叫做selector，剩下的数据就是参数编码后的数据。其中<code>seletor=bytes4(keccak256(&lt;sig&gt;))</code>，其中<code>&lt;sig&gt;</code>为函数字符串，<code>keccak256</code>可以看作哈希。总的来说，代码是这样写的：<code>calldata=abi.encodeWithSignature(sig, ps)</code>，sig为函数字符串。</p>
<p>​    上述静态动态调用是chatGPT给出的结果，然而老师讲的却不是这样。下面给出一个老师讲的<strong>静态调用的例子</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//callee.sol</span><br><span class="line">contract Callee&#123;</span><br><span class="line">	uint x;</span><br><span class="line">	function setX(uint px) public &#123;</span><br><span class="line">		x = px;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import &quot;callee.sol&quot;</span><br><span class="line">contract Caller&#123;</span><br><span class="line">	Callee callee;</span><br><span class="line">	function SetCalleeX()&#123;</span><br><span class="line">		callee.setX(12); // 编译的时候检查</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    再给出一个<strong>动态调用的例子</strong>：（可以绕过solidity的类型检查 ）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">contract Callee&#123;</span><br><span class="line">	uint x;</span><br><span class="line">	function setX(uint px) public &#123;</span><br><span class="line">		x = px;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">contract Caller&#123;</span><br><span class="line">	address callee;</span><br><span class="line">	constructor(address ca)&#123;</span><br><span class="line">		callee = ca;</span><br><span class="line">	&#125;</span><br><span class="line">	function SetCalleeX()&#123;</span><br><span class="line">		bytes memory calldata = abi.encodeWithSignature(&quot;setX(uint256)&quot;, 12); // 不能使用别名</span><br><span class="line">		(bool suc, bytes memory data) = callee.call(calldata);</span><br><span class="line">		if (!suc)&#123;</span><br><span class="line">			revert(&quot;error&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="注1：memory使用场景"><a href="#注1：memory使用场景" class="headerlink" title="注1：memory使用场景"></a>注1：memory使用场景</h4><p>​    <code>memory</code>是一种数据存储位置。它表示在执行函数时将变量存储在内存中而不是存储在合约的存储器中。以下是<code>memory</code>关键字的使用示例：</p>
<ul>
<li>字符串操作。字符串是一个动态的数据类型，它的长度不固定。因此，将它们存储在内存中。</li>
<li>数组操作。与字符串操作类似。</li>
</ul>
<h4 id="注2：external与public的区别"><a href="#注2：external与public的区别" class="headerlink" title="注2：external与public的区别"></a>注2：external与public的区别</h4><p>​    <code>public</code> 修饰的函数或状态变量可以被合约内部和外部的任何部分访问，而 <code>external</code> 修饰的函数或状态变量只能被其他合约访问，而不能被合约内部访问。</p>
<h4 id="注3：remix中的call函数调用"><a href="#注3：remix中的call函数调用" class="headerlink" title="注3：remix中的call函数调用"></a>注3：remix中的call函数调用</h4><p>​    如下图所示，我们可以在setX中来变化X的值，也可以复制calldata，放到下面的大红框中，来进行X的设置。</p>
<p><img src="/images/smart-contract/image-20230218105130790.png" alt="image-20230218105130790" style="zoom:67%;" /></p>
<h3 id="fallback函数（备胎函数）"><a href="#fallback函数（备胎函数）" class="headerlink" title="fallback函数（备胎函数）"></a>fallback函数（备胎函数）</h3><p>​    和constructor()一样，都是特殊函数。<strong>当我们调用其他合约的某个函数，且这个函数不存在的时候，就会调用fallback函数。其在转账功能和proxy模式中有重要作用，后面再详细说。</strong></p>
<p>​    举例说明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// Callee.sol</span><br><span class="line">// SPDX-License-Identifier: NONE</span><br><span class="line"></span><br><span class="line">pragma solidity 0.8.12;</span><br><span class="line"></span><br><span class="line">contract Callee&#123;</span><br><span class="line">	uint public x;</span><br><span class="line">	uint public y;</span><br><span class="line">	function setX(uint _x) public &#123;</span><br><span class="line">		x = _x;</span><br><span class="line">	&#125;</span><br><span class="line">	// fallback在被调用者中定义</span><br><span class="line">	fallback() external&#123;</span><br><span class="line">		y = 900;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// Caller.sol</span><br><span class="line">// SPDX-License-Identifier: NONE</span><br><span class="line"></span><br><span class="line">pragma solidity 0.8.12;</span><br><span class="line"></span><br><span class="line">contract Caller&#123;</span><br><span class="line">	address public calleeAddr;</span><br><span class="line">	constructor(address ca)&#123;</span><br><span class="line">		calleeAddr = ca;</span><br><span class="line">	&#125;</span><br><span class="line">	function setCalleeX() public&#123;</span><br><span class="line">		// 调用了一个不存在的函数setY，触发fallback函数</span><br><span class="line">		bytes memory cd = abi.encodeWithSignature(&quot;setY(uint256)&quot;, 100);</span><br><span class="line">		(bool suc, bytes memory data) = calleeAddr.call(cd);</span><br><span class="line">		if(!suc)&#123;</span><br><span class="line">			revert(&quot;error&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="gas与转账"><a href="#gas与转账" class="headerlink" title="gas与转账"></a>gas与转账</h3><ul>
<li>合约之中可以存钱，例如<code>Multisig</code>钱包。</li>
<li>以太币货币单位ETH。</li>
</ul>
<p><img src="/images/smart-contract/image-20230222223833629.png" alt="image-20230222223833629" style="zoom:67%;" /></p>
<ul>
<li><p>gas与gas price。gas是油，gas price是油费，固定的合约函数执行时，gas没有变化，变化的是gas的价格。交易的发起者可以设置gaslimit，表示发起者最多想  要消耗多少gas。<strong>当交易失败时（使用revert或者require），已经用了的gas不退。</strong></p>
</li>
<li><p><strong>转账是与函数调用一块发生的，转账就是函数调用。</strong></p>
</li>
<li><p>合约是可以有余额（有钱）的。当调用者调用合约的函数时，例如<code>contractA.foo&#123;options&#125;()</code>，可以添加一些选项<code>options</code>，例如<code>&#123;gaslimit, value（转给合约多少钱）&#125;</code>，如果不加<code>value</code>，相当于调用者不会给合约转钱。而被调用者（某个合约）可以添加<code>payable</code>标识符，以标识被调用者是否有能力收钱。</p>
</li>
</ul>
<p>&emsp;我们给出一个图，回顾一下之前的东西：</p>
<p><img src="/images/smart-contract/image-20230307224400880.png" alt="image-20230307224400880" style="zoom:67%;" /></p>
<p>&emsp;解释一下上图，其中<code>msg.data</code>是一个完整的调用数据（calldata）。<strong>它包含了调用者发送给合约的函数签名和参数。</strong>它可以用来实现低级的合约调用，例如使用delegatecall或call。如果calldata是空的，那么直接执行fallback函数（<strong>但是执行哪个合约的fallback呢？执行被调用合约的fallback</strong>），如果不是空，就解析一下，得到函数名<code>fname</code>，如果函数名不存在，那么就执行被调用合约的<code>fallback</code>。</p>
<p>&emsp;在上述逻辑的基础上，如果没有加入选项<code>value</code>，即调用者没带钱，那么上述逻辑正常执行。如果加入了选项<code>value</code>，调用者带了钱，那么就要看被调用的合约是否是<code>payable</code>，即是否支持收钱。（带钱反而还麻烦，离谱）</p>
<p>&emsp;如果我们就想转钱，不想让被调用合约执行某些函数，且被调用的合约中的fallback函数是payable的，那么我们直接<code>contractA.foo&#123;value:&lt;value&gt;&#125;(&quot;&quot;)</code>，即calldata直接是一个空串，这样就行了。</p>
<p>&emsp;<strong>下面给出一个转账示例，是EOA转给SendEther合约，然后转给ReceiveEther合约：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: NONE</span><br><span class="line"></span><br><span class="line">pragma solidity ^0.8.13;</span><br><span class="line"></span><br><span class="line">// 收款方</span><br><span class="line">contract ReceiveEther &#123;</span><br><span class="line"></span><br><span class="line">    event Fallback(bytes cdata, uint value, uint gas);</span><br><span class="line">    event Foo(bytes cdata, uint value, uint gas);</span><br><span class="line"></span><br><span class="line">    fallback() external payable &#123;</span><br><span class="line">        emit Fallback(msg.data, msg.value, gasleft());     // msg.data为空，或者解析不出一个正常的函数时使用fallback</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getBalance() public view returns (uint) &#123;     // 此合约有一个balance的属性，存放着当前的余额（收的款value的总和）</span><br><span class="line">        return address(this).balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function foo() public payable &#123;</span><br><span class="line">        emit Foo(msg.data, msg.value, gasleft());          // 记录 event</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 转账方</span><br><span class="line">contract SendEther &#123;</span><br><span class="line"></span><br><span class="line">    function getBalance() public view returns (uint) &#123;</span><br><span class="line">        return address(this).balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 收钱，里面不用写代码，是外部EOA给SendEther转的钱</span><br><span class="line">    function recv() public payable &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 转钱，amount从SendEther合约的balance中来</span><br><span class="line">    function sendViaCall(address payable _to, uint amount) public &#123;</span><br><span class="line">        // 调用了ReceiveEther的fallback函数</span><br><span class="line">        (bool sent, bytes memory data) = _to.call&#123;value:amount&#125;(&quot;&quot;);</span><br><span class="line">        require(sent, &quot;Fail to send&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function sendViaFoo(address payable _to, uint amount) public &#123;</span><br><span class="line">        ReceiveEther re = ReceiveEther(_to);</span><br><span class="line">        re.foo&#123;value:amount&#125;();                      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;回顾一下之前的<code>NumberStorage.sol</code>的代码，其功能为：<strong>线下募资，别人给他美金。然后开发者创建一种代币，叫<code>xcl</code>，并在constructor构造函数中将这些代币分发给投资者。下面我们要将线下募资环节转移到线上，即线上募资Eth以太币。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: NONE</span><br><span class="line"></span><br><span class="line">pragma solidity 0.8.12;</span><br><span class="line"></span><br><span class="line">contract NumberStorage&#123;</span><br><span class="line"></span><br><span class="line">	string public name = &quot;xcl&quot;;</span><br><span class="line">	string public symbol = &quot;$&quot;;</span><br><span class="line">	uint public decimal =  4; </span><br><span class="line">	mapping(address=&gt;uint) public balanceOf; </span><br><span class="line">	</span><br><span class="line">	// 合约部署者初始有多少代币</span><br><span class="line">	constructor(uint x)&#123;</span><br><span class="line">		balanceOf[msg.sender] = x;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">    event TransferEvent(uint oldv, uint newv);</span><br><span class="line">	</span><br><span class="line">	modifier notTooLarge(uint _x)&#123;</span><br><span class="line">		require(_x &lt; 10000, &quot;too large&quot;);</span><br><span class="line">		_;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	function transfer(address to, uint amount) public &#123;</span><br><span class="line">		address from = msg.sender;</span><br><span class="line">		if(balanceOf[from] &lt; amount)&#123;</span><br><span class="line">			revert(&quot;not enough!&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		balanceOf[to] += amount;</span><br><span class="line">		balanceOf[from] -= amount;</span><br><span class="line">	&#125;    </span><br><span class="line">	</span><br><span class="line">	// 线上募资以太币eth</span><br><span class="line">	// 给我多少eth，我发给他多少xcl代币</span><br><span class="line">	function mint() public payable	&#123;</span><br><span class="line">		balanceOf[msg.sender] = balanceOf[msg.sender] + msg.value;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	// 查看当前合约中有多少eth，而不是xcl代币</span><br><span class="line">    function getBalance() public view returns (uint) &#123;</span><br><span class="line">        return address(this).balance;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	// 合约部署者（募资人）将eth取走，即合约向外部钱包（募资人的钱包）转账</span><br><span class="line">	// 但是任何人都可以提钱，这个函数很有问题，缺少访问控制</span><br><span class="line">	function withdraw() public &#123;</span><br><span class="line">		uint bal = address(this).balance;</span><br><span class="line">		msg.sender.call&#123;value:bal&#125;(&quot;&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;如何解决上述问题（任何人都可以提钱），即在上述代码中加入：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: NONE</span><br><span class="line"></span><br><span class="line">pragma solidity 0.8.12;</span><br><span class="line"></span><br><span class="line">contract NumberStorage&#123;</span><br><span class="line">	address private owner;</span><br><span class="line">	modifier isOwner() &#123;</span><br><span class="line">		require(msg.sender == owner, &quot;Caller is not owner&quot;);</span><br><span class="line">		_;</span><br><span class="line">	&#125;</span><br><span class="line">	constructor() &#123;</span><br><span class="line">		owner = msg.sender;</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">	function withdraw() public isOwner &#123;</span><br><span class="line">		uint bal = address(this).balance;</span><br><span class="line">		msg.sender.call&#123;value:bal&#125;(&quot;&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="知识点补充"><a href="#知识点补充" class="headerlink" title="知识点补充"></a>知识点补充</h3><p>&emsp;<strong>Solidity合约举例网址：</strong><code>solidity-by-example.org</code></p>
<p>&emsp;<strong>数组：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Array &#123;</span><br><span class="line">    // 不定长数组</span><br><span class="line">    uint[] public arr;</span><br><span class="line">    uint[] public arr2 = [1, 2, 3];</span><br><span class="line">    // 定长数组</span><br><span class="line">    uint[10] public myFixedSizeArr;</span><br><span class="line"></span><br><span class="line">    function get(uint i) public view returns (uint) &#123;</span><br><span class="line">        return arr[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getArr() public view returns (uint[] memory) &#123;</span><br><span class="line">        return arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 不定长数组（动态数组）可以使用push与pop来增加数组元素，定长数组不可以</span><br><span class="line">    function push(uint i) public &#123;</span><br><span class="line">        arr.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    function pop() public &#123;</span><br><span class="line">        arr.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    function getLength() public view returns (uint) &#123;</span><br><span class="line">        return arr.length;</span><br><span class="line">    &#125;</span><br><span class="line">    function remove(uint index) public &#123;</span><br><span class="line">        delete arr[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function examples() external &#123;</span><br><span class="line">        // 创建一个不定长数组，其中有元素5</span><br><span class="line">        uint[] memory a = new uint[](5);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;<strong>结构体struct：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Todos &#123;</span><br><span class="line">    struct Todo &#123;</span><br><span class="line">        string text;</span><br><span class="line">        bool completed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Todo结构体数组</span><br><span class="line">    Todo[] public todos;</span><br><span class="line"></span><br><span class="line">    function create(string calldata _text) public &#123;</span><br><span class="line">        // todos结构体数组添加新的Todo元素的第1种方式</span><br><span class="line">        todos.push(Todo(_text, false));</span><br><span class="line"></span><br><span class="line">        // todos结构体数组添加新的Todo元素的第2种方式</span><br><span class="line">        todos.push(Todo(&#123;text: _text, completed: false&#125;));</span><br><span class="line"></span><br><span class="line">        // 初始化Todo元素，并添加到todos数组中</span><br><span class="line">        Todo memory todo;</span><br><span class="line">        todo.text = _text;</span><br><span class="line">        todos.push(todo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 取todos数组中的一个Todo元素</span><br><span class="line">    function get(uint _index) public view returns (string memory text, bool completed) &#123;</span><br><span class="line">        Todo storage todo = todos[_index];</span><br><span class="line">        return (todo.text, todo.completed);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 更新todos数组中其中一个Todo元素的text</span><br><span class="line">    function updateText(uint _index, string calldata _text) public &#123;</span><br><span class="line">        Todo storage todo = todos[_index];</span><br><span class="line">        todo.text = _text;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 更新todos数组中其中一个Todo元素的completed</span><br><span class="line">    function toggleCompleted(uint _index) public &#123;</span><br><span class="line">        Todo storage todo = todos[_index];</span><br><span class="line">        todo.completed = !todo.completed;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;<strong>注：</strong>solidity中的storage和memory是两种不同的数据存储位置，不加说明的话，默认放到storage中。它们类似于计算机的硬盘和内存。storage是合约的永久性数据存储位置，它会在函数调用之间保持不变。memory是合约的临时性数据存储位置，它只在函数调用期间有效，函数调用结束后就会被删除。memory中的数据可以通过指针或引用来访问和修改。calldata是外部函数的动态参数存储位置，它类似于memory，但是只能读取不能修改。</p>
<p>&emsp;<strong>常量：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Constants &#123;</span><br><span class="line">    address public constant MY_ADDRESS = 0x777788889999AaAAbBbbCcccddDdeeeEfFFfCcCc;</span><br><span class="line">    uint public constant MY_UINT = 123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;<strong>Immutable（不可变性）：</strong></p>
<p>&emsp;表示只能改变一次。immutable修饰的变量可以和常量、字面量（就直接是数字、字符）或其他immutable变量进行比较，但是不能和普通的状态变量或内存变量进行比较。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Immutable &#123;</span><br><span class="line">    address public immutable MY_ADDRESS;</span><br><span class="line">    uint public immutable MY_UINT;</span><br><span class="line"></span><br><span class="line">    constructor(uint _myUint) &#123;</span><br><span class="line">        MY_ADDRESS = msg.sender;</span><br><span class="line">        MY_UINT = _myUint;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;<strong>Gas：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">contract Gas &#123;</span><br><span class="line">    uint public i = 0;</span><br><span class="line">	// 运行这个函数，直到gas被消耗光</span><br><span class="line">    function forever() public &#123;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            i += 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;<strong>Inheritance（继承性）：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">/* 继承图</span><br><span class="line">    A</span><br><span class="line">   / \</span><br><span class="line">  B   C</span><br><span class="line"> / \ /</span><br><span class="line">F  D,E</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">contract A &#123;</span><br><span class="line">    function foo() public pure virtual returns (string memory) &#123;</span><br><span class="line">        return &quot;A&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 继承关键字为is，相当于java的extends，C++的“:”</span><br><span class="line">contract B is A &#123;</span><br><span class="line">    // 重写 A.foo()</span><br><span class="line">    function foo() public pure virtual override returns (string memory) &#123;</span><br><span class="line">        return &quot;B&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract C is A &#123;</span><br><span class="line">    // 重写 A.foo()</span><br><span class="line">    function foo() public pure virtual override returns (string memory) &#123;</span><br><span class="line">        return &quot;C&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract D is B, C &#123;</span><br><span class="line">    // D.foo() 返回 &quot;C&quot;</span><br><span class="line">    // 因为C是最右边（`contract D is B,C`决定了C在右边）的父合同，且有函数foo()</span><br><span class="line">    function foo() public pure override(B, C) returns (string memory) &#123;</span><br><span class="line">        return super.foo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 继承必须从 &quot;最基本(根)&quot;到 &quot;最派生&quot; 排序，`contract F is A, B`一交换，就错了</span><br><span class="line">contract F is A, B &#123;</span><br><span class="line">    function foo() public pure override(A, B) returns (string memory) &#123;</span><br><span class="line">        return super.foo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>&emsp;<strong>注：</strong>多重继承指的是一个派生类可以有两个或多个基类。这意味着一个子类可以拥有多个父类，并且继承它们所有的成员变量和成员函数。然而，多重继承容易让代码逻辑复杂、思路混乱，一直备受争议。</p>
<p>&emsp;<strong>除了动态调用（call）与静态调用（导入代码调用）之外，还用过哪些不被推荐的转账方式呢？</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/* 将钱转出的一方要调用的函数 */</span><br><span class="line">address.transfer    // 类似于address.call</span><br><span class="line">address.send</span><br><span class="line">receive             // 类似于fallback, constructor</span><br></pre></td></tr></table></figure>
<p>&emsp;其中<code>address.transfer</code>、<code>address.send</code>与call转账方式相比，在<code>gas_limit</code>上有区别，<code>address.transfer</code>、<code>address.send</code>不能指定<code>gas_limit</code>（只能是2300个，为了防止重入攻击），而call方式可以指定<code>gas_limit</code>的大小（默认的是剩下多少给多少）。如果发送方中定义了address.transfer（或者address.send），那么合约的接收方也一定要定义receive函数。</p>
<p>&emsp;<strong>补充：</strong>什么是重入攻击（Re-Entrancy）？看下面的样例合约：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.23;</span><br><span class="line"></span><br><span class="line">contract babybank &#123;</span><br><span class="line">    mapping(address =&gt; uint) public balance;</span><br><span class="line">    address owner;</span><br><span class="line"></span><br><span class="line">    function withdraw(uint amount) public&#123;</span><br><span class="line">        msg.sender.call.value(amount*100000000000000)();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;如果msg.sender本身就是一个合约的话，call调用在转账的时候会调用该合约的fallback函数。这时候如果构造一个恶意的合约，在它的fallback函数里面再次调用一次样例合约中的withdraw函数，这样就相当于调用了2次withdraw，经过了2次<code>balance[msg.sender] -= amount;</code>。当然，在其fallback函数里，可以继续调用该withdraw函数，无限循环，也可以在某种情形下（比如账户中的奖励点数已经足够多了）中止调用。<br>&emsp;<strong>补充：</strong>什么是DeFi？</p>
<p>&emsp;DeFi（ 去中心化金融：Decentralized Finance）指的是建立在<strong>区块链技术上的金融应用系统</strong>，其设计是开放和无许可的。Solidity是一种编程语言，用于在Ethereum和其他支持它的区块链平台上编写智能合约。它被用来在这些平台上构建DeFi应用程序，最著名的就是Uniswap。</p>
<h3 id="Delegatecall"><a href="#Delegatecall" class="headerlink" title="Delegatecall"></a>Delegatecall</h3><p>&emsp;<strong>call是什么？call是调用其他合约函数的一种方式，且使用call可以进行转账。</strong></p>
<p>&emsp;<strong>在合约不可变的情况下进行合约的升级，要用到delegatecall。</strong></p>
<h4 id="成员变量与状态变量在合约存储空间中的分布"><a href="#成员变量与状态变量在合约存储空间中的分布" class="headerlink" title="成员变量与状态变量在合约存储空间中的分布"></a>成员变量与状态变量在合约存储空间中的分布</h4><p>&emsp;<strong>值变量</strong>（也就是uint，bool等定长的变量），他们所占的内存空间大小是固定的。值变量的存储顺序是按照定义的顺序来存储的，uint是32字节，byte1占用1个字节。如果一个数据类型没有占满一个存储槽（32字节），那么如果又来了一个byte1，可以放到这个槽里，那他俩就一个槽，如果放不下，那么就放到下一个槽里，但也有例外，例如，struct与array总是新开辟一个存储槽（32字节），且它们总是占用整数个存储槽，这些存储槽不与其他变量共享。</p>
<p>&emsp;<strong>动态类型变量</strong>（例如Mapping，uint[]）的存放，例如顺序定义了<code>uint s1; mapping m; uint s2</code>，其中<code>mapping m</code>前后是两个<code>uint</code>，<code>mapping</code>占用的大小总是32字节（一个存储槽），其相当于一个指针，指向远处的一段内存。</p>
<p>&emsp;其计算公式为<code>index=keccak256(keccak256(k),p)</code>，keccak256为哈希函数，k为mapping的某个键，p为mapping所在的插槽的下标，index为那段内存的位置。这个意思是mapping中键为k对应的值，存储在index指向的内存中。</p>
<h4 id="delegatecall介绍"><a href="#delegatecall介绍" class="headerlink" title="delegatecall介绍"></a>delegatecall介绍</h4><p>&emsp; 原来的call调用图：</p>
<p><img src="/images/smart-contract/image-20230308145337761.png" alt="image-20230308145337761" style="zoom:67%;" /></p>
<p>&emsp;现在的delegatecall调用图：</p>
<p><img src="/images/smart-contract/image-20230308145359555.png" alt="image-20230308145359555" style="zoom:67%;" /></p>
<p>&emsp; 之前b1与b2只能访问contractB中的变量，现在将b1与b2拉到contractA中，那么b1与b2相当于contractA的函数，所以能访问contractA中的变量，所见到的msg也不是<code>message2</code>了，而是<code>message1&#39;</code>（不是<code>message1</code>）。<strong>即delegatecall是将另一个合约中的函数拿来当作自己合约的内部函数来用。</strong><code>message1</code>与<code>message1&#39;</code>的<code>msg.sender</code>、<code>msg.value</code>相同，而<code>msg.data</code>与<code>msg.gaslimit</code>可以不同。</p>
<p>&emsp; 那么，如果contractB与contractA中都有叫x的变量，而b1函数中进行了对变量x的操作，那么当调用delegatecall后，b1被放到了contractA里，其操作的变量x也是contractA中的x。（这要求contractB与contractA有可兼容的存储布局）</p>
<p>&emsp; 有如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.13;</span><br><span class="line"></span><br><span class="line">contract B &#123;</span><br><span class="line">	uint public num;</span><br><span class="line">	address public sender;</span><br><span class="line">	uint public value;</span><br><span class="line">	bytes public cdata;</span><br><span class="line">	</span><br><span class="line">	function setVars(uint _num) public payable &#123;</span><br><span class="line">		num = _num;</span><br><span class="line">		sender = msg.sender;</span><br><span class="line">		value = msg.value;</span><br><span class="line">		cdata = msg.data;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// A调用了B中的函数</span><br><span class="line">contract A &#123;</span><br><span class="line">	// A的存储布局与B一模一样</span><br><span class="line">	uint public num;</span><br><span class="line">	address public sender;</span><br><span class="line">	uint public value;</span><br><span class="line">	bytes public cdata;</span><br><span class="line">	</span><br><span class="line">	function setVars(address _contract, uint _num) public payable &#123;</span><br><span class="line">		(bool suc, bytes memory data) = _contract.delegatecall(</span><br><span class="line">			abi.encodeWithSignature(&quot;setVars(uint256)&quot;, _num)</span><br><span class="line">		);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 最终，contractB不会有任何改变，而contractA中的变量发生了改变。</span><br></pre></td></tr></table></figure>
<p>&emsp;<strong>Delegatecall与call的级联调用结论：</strong></p>
<p><img src="/images/smart-contract/image-20230406141940186.png" alt="image-20230406141940186" style="zoom:80%;" /></p>
<h3 id="函数调用机制总结"><a href="#函数调用机制总结" class="headerlink" title="函数调用机制总结"></a>函数调用机制总结</h3><p>&emsp; 由于mapping是这样存储的：<code>index=keccak256(keccak256(k),p)</code>，因此<strong>solidity中的mapping无法遍历（当然自己可以把key存起来就好）</strong> ，其中p是mapping在存储槽中的位置，k是键，存储槽p中不存储任何关于mapping的数据。<strong>而动态数组不一样，动态数组的存储槽p中放的是此数组的长度。</strong>举例说明一下遍历方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// SPDX-License-Identifier: NONE</span><br><span class="line"></span><br><span class="line">pragma solidity 0.8.12;</span><br><span class="line"></span><br><span class="line">contract NumberStorage&#123;</span><br><span class="line">	string public name = &quot;xcl&quot;;</span><br><span class="line">	string public symbol = &quot;$&quot;;</span><br><span class="line">	uint public decimal =  4; </span><br><span class="line">	</span><br><span class="line">	// 我们要遍历balanceOf这个Mapping</span><br><span class="line">	mapping(address=&gt;uint) public balanceOf; // 定义余额</span><br><span class="line">	address[] holders;</span><br><span class="line">	</span><br><span class="line">	// 添加与删除用户</span><br><span class="line">	function add(address holder) internal &#123;</span><br><span class="line">		holders.push(holder);</span><br><span class="line">	&#125;</span><br><span class="line">	function remove(address holder) internal &#123;</span><br><span class="line">		uint index = 0;</span><br><span class="line">		for(uint i = 0; i &lt; holders.length; i++)&#123;</span><br><span class="line">			if(holder == holders[i])&#123;</span><br><span class="line">				index = i;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		address l = holders[holders.length];</span><br><span class="line">		holders[index] = l;</span><br><span class="line">		holders.pop();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	function mint() public payable	&#123;</span><br><span class="line">		balanceOf[msg.sender] = balanceOf[msg.sender] + msg.value;</span><br><span class="line">		add(msg.sender);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	// 进行分红，就要遍历Holders</span><br><span class="line">	function divident() public &#123;</span><br><span class="line">		for(uint i = 0; i &lt; holders.length; i++)&#123;</span><br><span class="line">			uint bal = balanceOf[holders[i]];</span><br><span class="line">			...</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;补充： <strong>当使用calldata来调用合约的函数时（用call函数），不管有没有改变合约的状态，即使是读，也会产生一个交易，广播到区块链网络。（猜测应该是abi.encodeWithSignature的问题）</strong>。<strong>因此，如果是view（读操作）或者pure（不是读也不是写）函数，那么我们最好不要使用call函数来调用，而是使用interface重载的方式来调用。</strong></p>
<h4 id="变量存储位置"><a href="#变量存储位置" class="headerlink" title="变量存储位置"></a>变量存储位置</h4><p>&emsp;数组，字符串，结构体，Mapping<strong>（Mapping只在storage中，不在memory中）</strong>。</p>
<p>&emsp;相同存储位置的变量赋值没有拷贝，只是引用，但是不同存储位置的变量赋值意味着拷贝（相应的消耗gas，执行的EVM机器码多了）。</p>
<p>&emsp;calldata（msg.data）是Immutable的，一旦赋值，不可更改。</p>
<p>&emsp;下面给出一个示例，讲一下calldata、memory与storage：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.13;</span><br><span class="line"></span><br><span class="line">contract DataLocations &#123;</span><br><span class="line">	// arr, map, myStructs[1]一开始存在storage中</span><br><span class="line">	uint[] public arr;</span><br><span class="line">	mapping(uint=&gt;address) map;</span><br><span class="line">	struct MyStruct&#123;</span><br><span class="line">		uint foo;</span><br><span class="line">	&#125;</span><br><span class="line">	mapping(uint=&gt;MyStruct) myStructs;</span><br><span class="line">	</span><br><span class="line">	function f() public &#123;</span><br><span class="line">		_f(arr, map, myStructs[1]);</span><br><span class="line">		</span><br><span class="line">		// myStructs是Mapping，存储在storage里，相同存储位置之间的赋值不消耗Gas，只是引用。</span><br><span class="line">		MyStruct storage myStruct = myStructs[1];</span><br><span class="line">		</span><br><span class="line">		// 在memory中创建一个结构体myMemStruct，foo=0</span><br><span class="line">		MyStruct memory myMemStruct = MyStruct(0);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	function _f(</span><br><span class="line">		// 这三个变量原来就在storage中，所以只是会产生引用，不会拷贝（不消耗gas），但是_f对三个变量的修改直接能返回（合约中能看到），即相当于传了指针</span><br><span class="line">		uint[] storage _arr,                 </span><br><span class="line">		mapping(uint=&gt;address) storage _map,</span><br><span class="line">		MyStruct storage _myStruct             </span><br><span class="line">	) internal &#123;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	function _f(</span><br><span class="line">		// _arr与_myStruct进行了拷贝（消耗gas），相当于传了值</span><br><span class="line">		uint[] memory _arr,                 </span><br><span class="line">		mapping(uint=&gt;address) storage _map,</span><br><span class="line">		MyStruct memory _myStruct             </span><br><span class="line">	) internal &#123;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	// 外部合约能调用g函数，这样的话_arr就是calldata类型的，这里转成了memory类型的，发生了拷贝</span><br><span class="line">	function g(uint[] memory _arr) public returns(uint[] memory) &#123;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Time：2023-03-08</p>
<hr>
<p>&emsp;关于转账的补充：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity 0.8.13;</span><br><span class="line"></span><br><span class="line">contract MyErc20Token&#123;</span><br><span class="line">    string public name = &quot;XCL&quot;;</span><br><span class="line">    string public symbol = &quot;$&quot;;</span><br><span class="line">    uint public decimals = 4;</span><br><span class="line">    address public owner;</span><br><span class="line">    mapping(address=&gt;uint) public balanceOf;</span><br><span class="line"></span><br><span class="line">    constructor()&#123;</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line">    function mint() public payable &#123;</span><br><span class="line">        balanceOf[msg.sender] += msg.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    event TransferEvent(uint oldv, uint newv);</span><br><span class="line"></span><br><span class="line">    modifier isOwner()&#123;</span><br><span class="line">        require(msg.sender == owner, &quot;not owner!&quot;);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function transfer(address to, uint amount) public &#123;</span><br><span class="line">        address from = msg.sender;</span><br><span class="line">        uint current = balanceOf[from];</span><br><span class="line">        if(current &lt;= amount)</span><br><span class="line">            revert(&quot;not enough balance&quot;);</span><br><span class="line">        uint toc = balanceOf[to];</span><br><span class="line"></span><br><span class="line">        current -= amount;</span><br><span class="line">        toc += amount;</span><br><span class="line">        balanceOf[from] -= amount;</span><br><span class="line">        balanceOf[to] = toc;</span><br><span class="line">    &#125;</span><br><span class="line">    function withdraw() external isOwner()&#123;</span><br><span class="line">        // call函数的执行逻辑，如果owner有receive，那么先使用receive，否则就使用fallback</span><br><span class="line">        (bool suc, bytes memory data) = owner.call&#123;value:address(this).balance&#125;(&quot;&quot;);</span><br><span class="line">        require(suc, &quot;failed&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 当某个人直接使用transfer转账给此合约以太币时，而没有使用mint，此时这个人就是吃亏的，因为这个人账户上的钱并没有变多，反而以太币的账户钱变多了。</span><br><span class="line">    // fallback用于使用call直接转账的情况</span><br><span class="line">    fallback() external payable&#123;</span><br><span class="line">        mint();</span><br><span class="line">    &#125;</span><br><span class="line">    // 只有实现了receive函数，send与transfer函数才能被调用，重点！！</span><br><span class="line">    receive() external payable&#123;</span><br><span class="line">        // 其gas有限制：2300，仅够做一个日志emit，mint函数调用不了 </span><br><span class="line">        // 所以就不写receive函数了，别人无法用send与transfer函数（调用的话会失败），只能用call函数</span><br><span class="line">        // 如果写了receive函数，那么别人转账之后，mint实现不了，别人账户上的钱也不会增加</span><br><span class="line">        // 所以宁可不写receive，让调用失败</span><br><span class="line">        mint();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="代理模式与合约升级"><a href="#代理模式与合约升级" class="headerlink" title="代理模式与合约升级"></a>代理模式与合约升级</h3><p>&emsp;为什么要升级？（1）合约要稳定，技术上区块链的imutability不可变性，但是合约可能修订，由于漏洞，被攻击时需要紧急处理。（2）由于合约技术上的不可变性，升级需要特殊技术支持。（3）升级应不伤害去中心化与民主，即升级是由个人决定的，还是所有的人共同决定的。</p>
<p>&emsp;代理模式是用来支持智能合约升级的。如下图所示：</p>
<p><img src="/images/smart-contract/image-20230406122633754.png" alt="image-20230406122633754" style="zoom:67%;" /></p>
<p>&emsp;Proxy是一个合约，但是只存放了合约的数据（例如ERC20中的Balance、Name等），其相关的处理逻辑（函数）存放在不同的implementation中。这可以proxy使用delegatecall调用implemention中的函数完成。</p>
<p>&emsp;代理模式需要注意的点：（1）proxy和implementation内存布局要兼容；（2）proxy有成员变量指implementation，并且有函数可以切换implementation；（3）proxy实现fallback函数，不实现功能函数，fallback调用implementation.call并传递msg.data；（4）implementation实现功能函数并被proxy转发的calldata解析调用；（5）proxy的调用者用自己定义的功能接口调用proxy。</p>
<p>&emsp;上述看着有点晦涩难懂，直接上代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.8.13;</span><br><span class="line"></span><br><span class="line">// 目的是产生一个abi(应用二进制接口)</span><br><span class="line">// 把proxy与v1联系起来后，把proxy重载成ProxyInterface的接口</span><br><span class="line">interface ProxyInterface &#123;</span><br><span class="line">    function inc() external;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Proxy &#123;</span><br><span class="line">    address public implementation;</span><br><span class="line">    uint public x;</span><br><span class="line"></span><br><span class="line">    function setImplementation(address _imp) external &#123;</span><br><span class="line">        implementation = _imp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // fallback调用</span><br><span class="line">    function _delegate(address _imp) internal virtual &#123;</span><br><span class="line">        (bool suc, bytes memory data) = _imp.delegatecall(msg.data);</span><br><span class="line">        if(!suc)</span><br><span class="line">            revert(&quot;failed&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    // 当客户端把proxy当作有某种丰富功能的合约时，proxy都会调用fallback函数，proxy把消息传给implementation合约</span><br><span class="line">    fallback() external payable &#123;</span><br><span class="line">        _delegate(implementation);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract V1 &#123;</span><br><span class="line">    // 内存布局与Proxy兼容</span><br><span class="line">    address public implementation;</span><br><span class="line">    uint public x;</span><br><span class="line"></span><br><span class="line">    function inc() external &#123;</span><br><span class="line">        x += 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract V2 &#123;</span><br><span class="line">    address public implementation;</span><br><span class="line">    uint public x;</span><br><span class="line"></span><br><span class="line">    function inc() external &#123;</span><br><span class="line">        x += 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function dec() external &#123;</span><br><span class="line">        x -= 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;代码的功能是：将Proxy重载为ProxyInterface的接口，并调用Inc函数。重载流程如下：</p>
<p><img src="/images/smart-contract/image-20230406125631894.png" alt="image-20230406125631894" style="zoom:50%;" /></p>
<p>&emsp;升级流程：（1）重新写ProxyInterface接口（也可以不更新）；（2）写V2版本的处理逻辑；（3）调用Proxy的setImplementation以部署新的逻辑。</p>
<h4 id="知识补充："><a href="#知识补充：" class="headerlink" title="知识补充："></a>知识补充：</h4><p>&emsp;由于Proxy与V1的内存布局相同，在翻译成机器码后，机器码中是没有x变量名的，它只认是什么类型的第几个slot。因此，即使Proxy中不声明x，程序也能运行。因为Proxy中默认有这个slot的位置，所以将proxy中的变量x改为y，V1中的变量还是叫x，这样inc之后proxy中的y就会加1。</p>
<p>&emsp;Proxy的数据定义可以完全是白纸，但是最后改变的还是白纸（Proxy）中的slot。</p>
<p>&emsp;Remix中的At Address是将一个合约重载成一个接口，前提是给定相应的合约地址。可以改成：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.8.13;</span><br><span class="line"></span><br><span class="line">interface ProxyInterface &#123;</span><br><span class="line">    function inc() external;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Client &#123;</span><br><span class="line">	address proxy;</span><br><span class="line">	constructor(address _proxy) public &#123;</span><br><span class="line">		proxy = _proxy;</span><br><span class="line">	&#125;</span><br><span class="line">	function inc_client() public &#123;</span><br><span class="line">		ProxyInterface pi = ProxyInterface(proxy);</span><br><span class="line">		pi.inc();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>用汇编绕过fallback不能有返回值的限制</strong></p>
<p>&emsp;上上个代码中，有一些问题，具体在：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">function _delegate(address _imp) internal virtual &#123;</span><br><span class="line">    (bool suc, bytes memory data) = _imp.delegatecall(msg.data);</span><br><span class="line">    if(!suc)</span><br><span class="line">        revert(&quot;failed&quot;);</span><br><span class="line">&#125;</span><br><span class="line">fallback() external payable &#123;</span><br><span class="line">	_delegate(implementation);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>&emsp;存在的问题是，_imp.delegatecall(msg.data)的返回值为data，而程序逻辑并没有对data进行处理，<strong>而fallback函数又不能定义返回值</strong>。如何解决呢？<strong>用汇编来写，来绕过fallback不能有返回值的限制。</strong>如下所示：（<strong>代码没看懂，老师也没讲</strong>）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">function _delegate(address _imp) internal virtual &#123;</span><br><span class="line">    assembly &#123;</span><br><span class="line">    	calldatacopy(0, 0, calldatasize())</span><br><span class="line">    	let result := delegatecall(gas(), _imp, 0, calldatasize(), 0, 0)</span><br><span class="line">    	returndatacopy(0, 0, returndatasize())</span><br><span class="line">    	</span><br><span class="line">    	switch result</span><br><span class="line">    	case 0 &#123;</span><br><span class="line">    		revert(0, returndatasize())</span><br><span class="line">    	&#125;</span><br><span class="line">    	default &#123;</span><br><span class="line">    		return(0, returndatasize())</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">fallback() external payable &#123;</span><br><span class="line">	_delegate(implementation());</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p><strong>非结构化存储</strong></p>
<p>&emsp;上上上上代码中，Proxy只用到了implementation，没用x，而V1只用到了x，没用implementation。这样做是为了保证Proxy与implementation的存储布局相同。下面我们使用非结构化存储，对其进行升级。</p>
<p>&emsp;非结构化存储思想：proxy低位存储中留下一张白纸，由V1操作的业务数据（这里指变量x）一律不作定义，留给V1管理，读和写都由V1来进行。proxy自己需要的控制性变量（例如implementation）通过指定slot，从而避开低位slot。这也需要汇编来完成，proxy使用sload与sstore，将控制性变量放在某个指定的位置。</p>
<p><strong>支持返回值与非结构化存储的总体代码（非常值得好好看）</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.8.13;</span><br><span class="line"></span><br><span class="line">interface ProxyInterface &#123;</span><br><span class="line">    function inc() external;</span><br><span class="line">    // 看view时候需要返回值</span><br><span class="line">    function x() external view returns(uint);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Proxy &#123;</span><br><span class="line">	// 非结构化存储，把implementation放到了某个位置</span><br><span class="line">	bytes32 private constant implementationPosition = keccak256(&quot;org.zeppelinos.proxy.implementation&quot;);</span><br><span class="line">	function upgradeTo(address newImplementation) public &#123;</span><br><span class="line">		address currentImplementation = implementation();</span><br><span class="line">		setImplementation(newImplementation);</span><br><span class="line">	&#125;</span><br><span class="line">	function implementation() public view returns(address impl) &#123;</span><br><span class="line">		bytes32 position = implementationPosition;</span><br><span class="line">		assembly &#123;</span><br><span class="line">			impl := sload(position)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    function setImplementation(address newImplementation) internal &#123;</span><br><span class="line">        bytes32 position = implementationPosition;</span><br><span class="line">		assembly &#123;</span><br><span class="line">			sstore(position, newImplementation)</span><br><span class="line">		&#125;        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function _delegate(address _imp) internal virtual &#123;</span><br><span class="line">    	// 用汇编处理fallback没有返回值的问题，用来返回x的值，以后可以直接将Proxy重载成ProxyInterface，从而能看到x</span><br><span class="line">        assembly &#123;</span><br><span class="line">            calldatacopy(0, 0, calldatasize())</span><br><span class="line">            let result := delegatecall(gas(), _imp, 0, calldatasize(), 0, 0)</span><br><span class="line">            returndatacopy(0, 0, returndatasize())</span><br><span class="line"></span><br><span class="line">            switch result</span><br><span class="line">            case 0 &#123;</span><br><span class="line">                revert(0, returndatasize())</span><br><span class="line">            &#125;</span><br><span class="line">            default &#123;</span><br><span class="line">                return(0, returndatasize())</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fallback() external payable &#123;</span><br><span class="line">        _delegate(implementation());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract V1 &#123;</span><br><span class="line">    uint public x;</span><br><span class="line"></span><br><span class="line">    function inc() external &#123;</span><br><span class="line">        x += 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract V2 &#123;</span><br><span class="line">    uint public x;</span><br><span class="line"></span><br><span class="line">    function inc() external &#123;</span><br><span class="line">        x += 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function dec() external &#123;</span><br><span class="line">        x -= 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="openzepellin：智能合约的基础库，包含合约升级"><a href="#openzepellin：智能合约的基础库，包含合约升级" class="headerlink" title="openzepellin：智能合约的基础库，包含合约升级"></a>openzepellin：智能合约的基础库，包含合约升级</h4><h3 id="库（library）"><a href="#库（library）" class="headerlink" title="库（library）"></a>库（library）</h3><p>&emsp;库：代码复用，solidity的库也是合约。</p>
<p>&emsp;solidity的库的特征：（1）只有逻辑，没有数据（没有成员变量）。（2）不能payable。（3）不能继承，简化代码。（4）modifier对外不可见，外部合约不能调用modifier。</p>
<p>&emsp;代码结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.8.13;</span><br><span class="line">library libraryName &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;调用方式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import LibraryName from &quot;./library-file.sol&quot;</span><br></pre></td></tr></table></figure>
<h4 id="Using关键字：语法糖"><a href="#Using关键字：语法糖" class="headerlink" title="Using关键字：语法糖"></a>Using关键字：语法糖</h4><p>&emsp;相关示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.8.13;</span><br><span class="line"></span><br><span class="line">library SafeMath &#123;</span><br><span class="line">    function add(uint x, uint y) internal pure returns(uint) &#123;</span><br><span class="line">        uint z = x + y;</span><br><span class="line">        require(z &gt;= x, &quot;uint overflow&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">library Math &#123;</span><br><span class="line">    function sqrt(uint y) internal pure returns(uint z) &#123;</span><br><span class="line">        if(y &gt; 3)&#123;</span><br><span class="line">            z = y;</span><br><span class="line">            uint x = y / 2 + 1;</span><br><span class="line">            while(x &lt; z) &#123;</span><br><span class="line">                z = x;</span><br><span class="line">                x = (y / x + x) / 2;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125; else if (y != 0) &#123;</span><br><span class="line">            z = 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract TestSafeMath &#123;</span><br><span class="line">    // 把uint类型的变量都加上Math库中所定义的函数，后面就可以直接用x.sqrt而不是Math.sqrt(x)</span><br><span class="line">    using Math for uint; </span><br><span class="line">    uint public MAX_UINT = 2**256 - 1;</span><br><span class="line"></span><br><span class="line">    function testAdd(uint x, uint y) public pure returns(uint) &#123;</span><br><span class="line">        return SafeMath.add(x, y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function testSquareRoot(uint x) public pure returns(uint) &#123;</span><br><span class="line">        return x.sqrt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;下面要解释上述代码的一些问题。</p>
<ul>
<li>Library中的函数为什么定义成Internal？</li>
</ul>
<p>&emsp;定义成Internal之后，在TestSafeMath编译时，SafeMath.add就会自动插入到TestSafeMath编译后的代码中（Inline），此时库并未被单独部署。但是，如果库中有public的函数（只要有一个public），库就会被单独部署为合约，假如调用者调用了这个Public函数，那么将会是delegatecall类型的调用。</p>
<p>&emsp;如果库中的函数被多次调用，那么用Internal修饰时，就会拷贝多份。如果使用Public修饰，那么就只有一份，也就是被部署过的库。</p>
<ul>
<li>Library与代理模式的区别？</li>
</ul>
<p>&emsp;代理模式（V1）中有成员变量，其成员变量内存布局要与调用者（Proxy）相同，而Library中不允许有成员变量。那怎么办呢？一般来说，函数的参数并不是storage的，但是Library允许函数参数是storage的，这样就能改变调用者的一些值。</p>
<ul>
<li>代理模式能进行合约升级，为什么不能用Library来进行合约升级呢？</li>
</ul>
<p>&emsp;调用者对单独部署的library的引用是<strong>在编译时完成，不是运行时，无法实现动态升级</strong>。而代理模式则可以在运行时升级。</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在群中，还未加群，等到加上群了再看。</span><br></pre></td></tr></table></figure>

  
	</div>

	<div>
  	<center>
	<div class="pagination">

    
    
    <a href="/2023/02/10/go-study/" type="button" class="btn btn-default"><i
                class="fa fa-arrow-circle-o-left"></i> 上一页</a>
    

    <a href="/" type="button" class="btn btn-default"><i class="fa fa-home"></i>Home</a>
    
    <a href="/2023/01/14/chatbot/" type="button" class="btn btn-default ">下一页<i
                class="fa fa-arrow-circle-o-right"></i></a>
    

    
</div>

    </center>
	</div>


	<!-- comment -->
	
<section id="comment">
    <h2 class="title">留言</h2>

    <!-- 
    <div id="disqus_thread" class="ds-thread">
        <script type="text/javascript">
            /**
             * RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
             * LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
             */
                /*
                 var disqus_config = function () {
                 this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable
                 this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
                 };
                 */
            (function() { // DON'T EDIT BELOW THIS LINE
                var d = document, s = d.createElement('script');

                s.src = 'https://https-wd-2711-tech.disqus.com/embed.js';

                s.setAttribute('data-timestamp', +new Date());
                (d.head || d.body).appendChild(s);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="//disqus.com/?ref_noscript">comments powered by
                Disqus.</a></noscript>
    </div> -->
    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
    <div id="vcomments"></div>
    <script>
        new Valine({
            el: '#vcomments',
            appId: 'wLIJ70s3fPvW8WJPgVVAuWVR-gzGzoHsz',
            appKey: 'NVGqxhUkqtFv2CbwmXXWjCdR'
        })
    </script>

    
</section>


	</div> <!-- col-md-9/col-md-12 -->
		
	
	<div id="side_meta">
		<div class="col-md-3" id="post_meta"> 

	<!-- date -->
	
	<div class="meta-widget">
	<i class="fa fa-clock-o"></i>
	2023-02-09 
	</div>
	

	<!-- categories -->
    
	<div class="meta-widget">
	<a data-toggle="collapse" data-target="#categorys"><i class="fa fa-folder"></i></a>	
    <ul id="categorys" class="tag_box list-unstyled collapse in">
          
  <li>
    <li><a href="/categories/blockchain/">blockchain<span>5</span></a></li>
  </li>

    </ul>
	</div>
	

	<!-- tags -->
		

	<!-- toc -->
	<div class="meta-widget">
	
	</div>
	
    <hr>
	
</div><!-- col-md-3 -->

	</div>

	<!-- copyright -->
	<div>
    <ul class="post-copyright">
      <li class="post-copyright-author">
      <strong>作者:  </strong>wd-z711</a>
      </li>
      <li class="post-copyright-link">
      <strong>文章链接:  </strong>
      <a href="/" target="_blank" title="">https://wd-2711.tech/</a>
      </li>
      <li class="post-copyright-license">
        <strong>版权声明:   </strong>
        本博客所有文章除特别声明外，均采用 <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)">CC BY-NC-ND 4.0</a>
        许可协议。转载请注明出处!
      </li>
    </ul>
  <div>
 	

		


</div><!-- row -->




	</div>
  </div>
  <div class="container-narrow">
  <footer> <p>
  &copy; 2023 wd-z711
  
      <!-- with help from <a href="http://hexo.io/" target="_blank">Hexo</a>,<a target="_blank" rel="noopener" href="http://github.com/wzpan/hexo-theme-freemind/">Freemind</a>,<a href="http://getbootstrap.com/" target="_blank">Twitter Bootstrap</a> and <a href="http://getbootstrap.com/" target="_blank">BOOTSTRA.386</a>. 
     <br> Theme by <a target="_blank" rel="noopener" href="http://github.com/wzpan/hexo-theme-freemind/">Freemind.386</a>.     -->

     <!-- <script type="text/javascript">
      (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
      (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
      e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
      })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');
      
      _st('install','aB-vgeB8gEDrnRJuhceL','2.0.0');
    </script> -->
    </p>
 </footer>
</div> <!-- container-narrow -->
  


  
<a id="gotop" href="#">   
  <span>⬆︎TOP</span>
</a>

<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/bootstrap.min.js"></script>
<script src="/js/main.js"></script>
<script src="/js/search.js"></script> 


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>



   <script type="text/javascript">      
     var search_path = "search.xml";
	 if (search_path.length == 0) {
	 	search_path = "search.xml";
	 }
	 var path = "/" + search_path;
     searchFunc(path, 'local-search-input', 'local-search-result');
   </script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
   </html>
